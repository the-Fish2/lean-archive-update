[
    {
        "content": "<p>I'd be happy to see further examples.</p>\n<p>The main example from the <a href=\"https://arxiv.org/abs/2403.12733\">paper</a> seems to be at the top of page 16 (oof, not copy-and-pasteable). It is indeed shorter, but I don't really see any abbreviation beyond ascii art. Are there more convincing examples where something non-syntactical is happening?</p>",
        "id": 428306623,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711105441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428306623\">said</a>:</p>\n<blockquote>\n<p>I'd be happy to see further examples.</p>\n<p>The main example from the <a href=\"https://arxiv.org/abs/2403.12733\">paper</a> seems to be at the top of page 16 (oof, not copy-and-pasteable). It is indeed shorter, but I don't really see any abbreviation beyond ascii art. Are there more convincing examples where something non-syntactical is happening?</p>\n</blockquote>\n<p>I think the main advantage of LeanSSR proofs is not the size, but that they are interactive and still as compact as handcrafted terms. Please check the explanation at section 4.2 for  detailed comparison with mathlib proofs. </p>\n<p>Other than that, LeanSSR provides a convenient machinery for forwards style reasoning (sec 2.5) and reduces the amount of required bookkeeping (sec 2.1).</p>\n<p>You can find examples at the LeanSSR repo at <code>Examples/</code> folder. Moreover, if you switch to <code>itp24</code> branch, you would find some proofs ported from Mathlib <code>Examples/Mathlib</code>.</p>\n<p>Another exciting (at least for me) part of LeanSSR is enhanced Computational Reflection.</p>",
        "id": 428309931,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711106815
    },
    {
        "content": "<p>I don’t understand the sentence “Unlike Coq, Lean assumes axioms of classical logic, such as the law of excluded middle”. I don’t think there is any difference here. Neither Coq not Lean has builtin classical logic and you can add the corresponding axioms to both.</p>",
        "id": 428352073,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711120379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428309931\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428306623\">said</a>:</p>\n<blockquote>\n<p>I'd be happy to see further examples.</p>\n<p>The main example from the <a href=\"https://arxiv.org/abs/2403.12733\">paper</a> seems to be at the top of page 16 (oof, not copy-and-pasteable). It is indeed shorter, but I don't really see any abbreviation beyond ascii art. Are there more convincing examples where something non-syntactical is happening?</p>\n</blockquote>\n<p>I think the main advantage of LeanSSR proofs is not the size, but that they are interactive and still as compact as handcrafted terms. Please check the explanation at section 4.2 for  detailed comparison with mathlib proofs. </p>\n</blockquote>\n<p>I still don't get it, and I have now read it thoroughly, including section 4.2. (By the way, the declaration from which you are taking that subgoal is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.card_eq_of_bijective#doc\">docs#Finset.card_eq_of_bijective</a>, not <code>card_eq_of_bijective</code>, which doesn't exist.) That is, you say \"not the size\", but \"still as compact\". Do you mean you don't care about the size of the proof script, but you do care about the size of the generated term?</p>\n<p>Even if the answer the previous question is yes, I still don't understand. For example, the existing proof in Mathlib is interactive if you follow the \"Expected Type\" in the VS Code infoview. But if you really want something from the tactic state, then compare with this proof of the subgoal, which is also \"interactive\", but where the generated term is still small:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"c\">/-</span>\n<span class=\"cm\">      running `show_term` on this shows the term is still pretty compact.</span>\n<span class=\"cm\">      Try this: exact fun a ↦</span>\n<span class=\"cm\">        {</span>\n<span class=\"cm\">          mp := fun ha ↦</span>\n<span class=\"cm\">            Exists.casesOn (hf a ha) fun i h ↦</span>\n<span class=\"cm\">              Exists.casesOn h fun hi eq ↦ Exists.intro i (Exists.intro (mem_range.mpr hi) eq),</span>\n<span class=\"cm\">          mpr := fun a_1 ↦</span>\n<span class=\"cm\">            Exists.casesOn a_1 fun i h ↦</span>\n<span class=\"cm\">              Exists.casesOn h fun hi eq ↦ Eq.mpr (id (congrArg (fun _a ↦ _a ∈ s) eq.symm)) (hf' i (mem_range.mp hi)) }</span>\n<span class=\"cm\">      -/</span>\n      <span class=\"n\">refine</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"bp\">·</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n        <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mem_range.2</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span>\n      <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">eq</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hf'</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note, this is an honest question, I'm not trying to be argumentative.</p>",
        "id": 428365017,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711124130
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> has marked this topic as resolved.</p>",
        "id": 428370357,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711125696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> has marked this topic as unresolved.</p>",
        "id": 428370367,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711125700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428352073\">said</a>:</p>\n<blockquote>\n<p>Neither Coq not Lean has builtin classical logic and you can add the corresponding axioms to both.</p>\n</blockquote>\n<p>I guess you could argue that Lean has classical logic built <em>into its standard tactics</em> (like <code>split</code>), bur this is certainly a much weaker claim than one about the type theory.</p>",
        "id": 428377497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711128076
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> To answer your first question, no, we don't really care about the size of the generated proof term.</p>\n<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  To correct the course of this discussion, let me restate our main theses:</p>\n<ol>\n<li>SSReflect is a very powerful tactic language in the style of Forth, so proofs in it tend to be very concise. Indeed, this style might not resonate with your mental reasoning model, and this is fine. That said, the utility of Coq/SSreflect for formalising mathematics has been empirically shown by a <a href=\"https://math-comp.github.io/papers.html\">substantial number of documented efforts</a>. Our team felt quite handicapped not having it in Lean, so we decided to implement it ourselves.</li>\n<li>Once we tried to do so, we had to dive deep into Lean metaprogramming, and we consider our experience of using it worthy of sharing in a paper.</li>\n<li>We also noticed that one can make SSReflect even better with Lean's mechanisms (in terms of usability and expressivity), and so we did, which is our main pragmatic contribution. We do genuinely find LeanSSR a significant improvement over Coq/SSReflect.</li>\n<li>Finally, we have shown that idiomatic proofs from mathlib, when rephrased in LeanSSR, become shorter. Whether this is an advantage one would care about, is a different question, but we believe it was important to highlight.</li>\n</ol>",
        "id": 428380246,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711129084
    },
    {
        "content": "<p>Can you give an example of what you felt limited about to the degree that you decided to go through the effort of developing this entire framework, instead of a more ad-hoc solution?</p>",
        "id": 428384775,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711130740
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"702586\">@Ilya Sergey</span> : I think part of the issue might be, for many lean users including me, lean is their main ITP (perhaps even the only one we use). Many of us come from non PL backgrounds. For me, the difficulty in this paper was, at least in the first half, trying to understand how LeanSSR differs from standard tactics with a sprinkling of macros to do the intros and reverts. What I think would help someone like me is to see a proof that is really hard to do with normal tactics, but super easy with LeanSSR.</p>\n<p>That being said, teaching SSR is not the main goal of this paper, so I guess it is unfair to ask that here. SSReflect is a fairly well established tactic language in Coq.</p>",
        "id": 428385049,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711130839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I don't think it was about a particular example, but rather about a proof style, which we were quite used to, and which is different from the idiomatic proofs in Lean, both tactic-based and explicit term constructions. A great example of SSR-style proofs is a MathComp <a href=\"https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/seq.v\">formalisation of sequences</a>.</p>\n<p>At the end, it turned out to be a very fun metaprogramming exercise to add our favourite scripting front-end to Lean, and we were excited to share it with others.</p>",
        "id": 428385689,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711131122
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> Thank you for the feedback, this is actually quite insightful. </p>\n<blockquote>\n<p>to see a proof that is really hard to do with normal tactics, but super easy with LeanSSR.</p>\n</blockquote>\n<p>I feel no matter what example we pick, it might be an uphill battle, as there will always be an ad-hoc solution that adds an example-specific macro or a piece of automation in a post-hoc fashion, which trivialises its proof in \"vanilla\" Lean.</p>\n<p>Perhaps, you could suggest a self-contained example from your experience with a particularly nasty Lean proof, and let us take a stab at it with unmodified LeanSSR. :)</p>",
        "id": 428386413,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711131377
    },
    {
        "content": "<p>I'm a fan of Forth and languages like APL and J, so I'm looking forward to trying this out sometime to see what SSR is about. I've been curious, and having a Lean version will really lower the activation energy!</p>",
        "id": 428388593,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711132264
    },
    {
        "content": "<p>Adding some extra context to help navigate (they haven't appeared yet in this thread):</p>\n<ul>\n<li><a href=\"#narrow/stream/113486-announce/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428305241\">Zulip announcement for LeanSSR</a></li>\n<li><a href=\"https://github.com/verse-lab/lean-ssr\">Github repo</a></li>\n</ul>",
        "id": 428389160,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711132502
    },
    {
        "content": "<p>I think it would be helpful having a \"proof off\" to evaluate Mathlib tactics against SSR. Have experienced users of each work together to refine the proofs as much as possible in the respective style.</p>\n<p>In the paper, I don't feel like Fig 15(a) is a good representative example of a mathlib proof. It's a common sight, sure, but one part of mathlib style is to write a proof term directly to say \"there is nothing to see here, it's obvious and you shouldn't bother reading it.\" These often come initially come from a tactic proof, but it gets eliminated.</p>",
        "id": 428390117,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711132894
    },
    {
        "content": "<p>Here's a tactic proof version, set up like an <code>example</code> in the paper, which works in the context set up right before <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.card_eq_of_bijective#doc\">docs#Finset.card_eq_of_bijective</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">ha</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n    <span class=\"n\">use</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mem_range.2</span> <span class=\"n\">hi</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hf'</span>\n</code></pre></div>\n<p>The proof can be written in three lines using semicolons</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">ha</span><span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"bp\">;</span> <span class=\"n\">use</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mem_range.2</span> <span class=\"n\">hi</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">hf'</span>\n</code></pre></div>\n<p>and the SSR for comparison (copy/pasted from the paper; any typos are my fault):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">move</span><span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n    <span class=\"o\">⟨</span><span class=\"bp\">/</span><span class=\"n\">hf</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"bp\">/</span><span class=\"n\">mem_range</span> <span class=\"bp\">?</span> <span class=\"bp\">&lt;-</span><span class=\"o\">]</span> <span class=\"bp\">//</span> <span class=\"bp\">|</span>\n    <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"bp\">/</span><span class=\"n\">mem_range</span> <span class=\"bp\">/</span><span class=\"n\">hf</span><span class=\"bp\">’</span> <span class=\"bp\">/</span><span class=\"o\">[</span><span class=\"n\">swap</span><span class=\"o\">]</span><span class=\"bp\">-&gt;</span><span class=\"o\">]</span> <span class=\"bp\">//</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 428390878,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711133224
    },
    {
        "content": "<p>Another proof could be <code>by aesop</code>. Whether that is cheating or <span aria-label=\"golf\" class=\"emoji emoji-1f3cc\" role=\"img\" title=\"golf\">:golf:</span> is left as exercise to the reader.</p>",
        "id": 428394228,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711134611
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks for digging in and for the enthusiasm!</p>\n<p>Here's the LeanSSR proof, a bit shortened compared to the version from the paper:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">move</span><span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"bp\">/</span><span class=\"n\">hf</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"bp\">/</span><span class=\"n\">mem_range</span><span class=\"o\">]</span> <span class=\"bp\">|</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"bp\">&lt;-</span><span class=\"o\">]⟩</span> <span class=\"bp\">//</span>\n</code></pre></div>\n<p>You can check it by inserting after line 140 of <a href=\"https://github.com/verse-lab/lean-ssr/blob/itp24/Examples/Mathlib.lean#L140\">this file</a> in the branch <code>itp24</code> of the <a href=\"https://github.com/verse-lab/lean-ssr\">project repository</a>.</p>\n<p>The proof is interactive, so you can see what happens to the proof state after each symbol.</p>",
        "id": 428394555,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711134769
    },
    {
        "content": "<p>In the paper, you write</p>\n<blockquote>\n<p>Finally, unlike the proof terms constructed holistically,<br>\nLeanSSR proofs are interactive: one can check the intermediate subgoals by simply pointing<br>\nto the specific location in the text buffer, resulting in a better overall proof experience</p>\n</blockquote>\n<p>But you can also put your cursor in the middle of a term-mode proof and see the goal state at that point. So term-mode proofs are also interactive.</p>",
        "id": 428395299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711135116
    },
    {
        "content": "<p>Ilya, I am afraid that some messages here failed to convey their intended tone. I’m sure nobody here thinks that your work is useless or bad. At least people coming from maths departments know that Feit-Thompson was formalized using SSReflect. So there is no need to prove that this style can be put to very good use. But it certainly looks impenetrable so people would like to understand what are the benefits. And, as Kyle wrote, having a Lean version makes it a lot more plausible that we can finally understand that by playing with it.</p>",
        "id": 428395397,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711135173
    },
    {
        "content": "<p>Yes, I should have been a bit more careful with how I phrased my messages above! Thanks Patrick, for your remark.</p>",
        "id": 428395618,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711135279
    },
    {
        "content": "<p>This paper is a great example of the flexibility of Lean's metaprogramming, and it looks like it might be effective at attracting Coq users to Lean; so even if as a Lean user I struggle to initially appreciate the unfamiliar syntax, the effort to bridge between communities is certainly appreciated!</p>",
        "id": 428396063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711135471
    },
    {
        "content": "<p>I think that, beyond the cosmetic question of ascii-art abbreviations, the thing that is really unusual for us is the intro/revert dance. The standard Lean tactic try to <em>hide</em> this as much as possible. For instance <code>rw</code> tactic does need this when rewriting the local context, but it tries really really hard to pretend it does not. I can see some value in not pretending: when something goes wrong it can be pretty confusing to suddenly have two copies of your local assumptions. But this is really rare so I guess there is more motivation for explicit intro/revert.</p>",
        "id": 428396222,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711135549
    },
    {
        "content": "<p>Even <code>revert</code> is pretty rare to use in Lean;  <code>induction x generalizing y</code> does a great job of hiding it</p>",
        "id": 428396530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711135653
    },
    {
        "content": "<p>And I also wanted to say that I personally think that reports on Lean 4 meta-programming experiments are very nice. This is so true that I also wrote one for the same conference. Lean 4 is brand new and simply giving examples of things that are possible is valuable.</p>",
        "id": 428396544,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711135661
    },
    {
        "content": "<p>Yes, <code>induction … generalizing …</code> is another example of revert-hiding.</p>",
        "id": 428396660,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1711135695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Yes, this phrasing is not great. Let me clarify.</p>\n<p>While your statement is true for a <em>fully constructed</em> proof term, it is not the case for a proof in progress (at least in my limited experience with the Lean term mode). </p>\n<p>What we meant is that a partially constructed proof term does not provide the same interactive experience as the tactic mode. For example, pointing at <code>X</code> in the middle of the following incomplete proof in the \"Expected type\" mode shows the entire goal rather than the subgoal \"in the focus\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n        <span class=\"n\">X</span><span class=\"o\">,</span>\n        <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eq</span> <span class=\"bp\">▸</span> <span class=\"n\">hf'</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 428396800,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711135756
    },
    {
        "content": "<p>You're supposed to use an <code>_</code> instead of an <code>X</code>. If you do, you can see the current goal at that point if you move your cursor before <code>_</code>.</p>",
        "id": 428397010,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711135842
    },
    {
        "content": "<p>The deal is that <code>X</code> is an elaboration error, but <code>_</code> elaborates to a metavariable that can capture that context.</p>",
        "id": 428397050,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711135862
    },
    {
        "content": "<p>You can even write <code>sorry</code> there. Anything that doesn't give an elaboration error.</p>",
        "id": 428397126,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711135901
    },
    {
        "content": "<p>Why isn't the expected type shown anyway? It's shown if I add an <code>id</code> before the <code>X</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">a</span> <span class=\"n\">ha</span>\n        <span class=\"n\">id</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"c1\">-- put cursor before `id`, everything is fine</span>\n        <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">eq</span> <span class=\"bp\">▸</span> <span class=\"n\">hf'</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 428397657,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711136040
    },
    {
        "content": "<p>(my expectation would be that the <code>X</code> is elaborated as a <code>sorry</code> with an error message, and so I can get the expected type where the sorry goes)</p>",
        "id": 428397774,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711136086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thank you for the kind words.</p>\n<blockquote>\n<p>But it certainly looks impenetrable so people would like to understand what are the benefits. </p>\n</blockquote>\n<p>I can very much relate to that. So let me note that one of the key advantages of LeanSSR compared to Coq/SSReflect is that the former truly allows for the \"small-step\" proof debugging (this is what we consider one of the main features). </p>\n<p>That is, if you open any of our proofs in a project that has been compiled and step between the symbols, you'll see the changes in the tactic state. This, hopefully,  will provide additional intuition on what is the meaning of each operation.</p>",
        "id": 428397875,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711136146
    },
    {
        "content": "<p>I think the problem you are facing is that many of your readers here are not comparing to Coq/SSReflect, but to \"regular\" Lean tactics. As you say, there is a big advantage in your version over the Coq version; it's just not the initial comparison a Lean user will make. (I don't think this is a problem with your paper)</p>",
        "id": 428398166,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711136272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> It's possible this is a bug, and we always write 100% perfect code so we've never noticed <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> (Rather, if there's an error we're probably focused more on that and fix it first)</p>",
        "id": 428398188,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711136281
    },
    {
        "content": "<blockquote>\n<p>the thing that is really unusual for us is the intro/revert dance. The standard Lean tactic try to hide this as much as possible.</p>\n</blockquote>\n<p>Ah, I see. This is very useful for us to realise. SSR style is certainly much more \"stack-based\" in spirit. So the pervasive intro/revert patterns are merely there to massage the goal (i.e., the \"stack\") to hit it with the hypotheses.</p>",
        "id": 428398308,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711136319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"702586\">Ilya Sergey</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428397875\">said</a>:</p>\n<blockquote>\n<p>That is, if you open any of our proofs in a project that has been compiled and step between the symbols, you'll see the changes in the tactic state. This, hopefully, will provide additional intuition on what is the meaning of each operation.</p>\n</blockquote>\n<p>I do appreciate that, but I guess as a lean user I'm used to expecting it. Unfortunately I find it's not really enough to truly grok a new proof language; I don't really know Coq but I can step though proofs in the library and observe that things change in the direction of getting solved and then poof the goal is done, and I make random modifications and then random surprising things stop working and so I just leave it as is... It's not easy to break in to the language from that angle</p>",
        "id": 428398476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711136401
    },
    {
        "content": "<p>I would really love a \"Coq for the lean user\" tutorial for either traditional coq or ssreflect</p>",
        "id": 428398705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711136489
    },
    {
        "content": "<p>Does the Coq/SSReflect library (with an editor of your choice) provide semantic highlighting in the editor that hints at the structure of the proof? I suspect that your LeanSSR gets that for free, in the form of pale highlights over the AST nodes when you hover over them.</p>",
        "id": 428399022,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711136604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"702586\">@Ilya Sergey</span> : I think another related point is that it took me until page 3 to figure out what \"symbolic\" meant. So one of the claims of the paper in section 2 is that lean SSR makes it more convenient to switch between the function style definition and predicate style definition with #reflect command. In lean the typical proof style is to write a definition, followed by a number of simple \"API\" lemmas, so that downstream theorems  don't need to deal with the definition's innards. Can LeanSSR help reduce this need for API lemmas?</p>",
        "id": 428399487,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711136774
    },
    {
        "content": "<p>One thing I am especially interested in is if there is a way to translate SSR to 'traditional' lean proof scripts. Given that you were able to write LeanSSR in lean I guess that all the tools are already present, but is it possible to take a SSR proof and write it entirely using regular lean tactics (even if it's much more verbose)?</p>",
        "id": 428399531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711136793
    },
    {
        "content": "<p>I think doing such a translation on some representative examples would be very helpful for the people here, including me</p>",
        "id": 428399631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711136845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Great questions, but please allow me or <span class=\"user-mention\" data-user-id=\"690517\">@Vladimir Gladstein</span> handle them in a few hours: it's rather late in Singapore now.</p>",
        "id": 428399831,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711136932
    },
    {
        "content": "<p>(One tool tactics can use to do the revert/intro pattern is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.MVarId.withReverted#doc\">docs#Lean.MVarId.withReverted</a>, though many tactics end up handling this themselves. That function is for fairly simple cases.)</p>",
        "id": 428400486,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711137233
    },
    {
        "content": "<p>(I'm curious what the effect of <code>Elab.pushInfoLeaf</code> is in that function, and how it manifests in the goal view)</p>",
        "id": 428401322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711137608
    },
    {
        "content": "<p>(It does not affect the info view, only find-references, unused-variables, and so on)</p>",
        "id": 428401714,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1711137787
    },
    {
        "content": "<p><code>fvarAliasInfo</code> nodes are for tracking when a variable is \"semantically renamed\" to a different FVarId which is still morally represented by the original. This is used for example in the unused variable linter: if you have a variable <code>h : x + 1 = 2</code> in context and <code>rw</code> or <code>induction</code> rewrites it to <code>h : x = 1</code>, then uses of the new <code>h</code> count as uses of the old <code>h</code>, and conversely if the new <code>h</code> is not used then we may flag the old one as unused</p>",
        "id": 428401766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711137816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"702586\">@Ilya Sergey</span> thanks for <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428380246\">this explanation</a>, it makes sense to me now.</p>",
        "id": 428407528,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711140595
    },
    {
        "content": "<p>Another point that I find a bit confusing is that there seems to be two completely disjoint things going on here: on the one hand, the stack-based intro/revert proof style and associated shortcuts, and on the other hand the actual small-scale reflection, <code>#reflect</code> and so on. Is there a particular reason why these two things are packaged together?</p>",
        "id": 428409098,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1711141355
    },
    {
        "content": "<p>This has always been the thing that impeded me from learning what \"reflection\" meant in Coq, because it seemed to not be well-distinguished from the tactic framework in general</p>",
        "id": 428410864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711142356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428409098\">said</a>:</p>\n<blockquote>\n<p>Another point that I find a bit confusing is that there seems to be two completely disjoint things going on here: on the one hand, the stack-based intro/revert proof style and associated shortcuts, and on the other hand the actual small-scale reflection, <code>#reflect</code> and so on. Is there a particular reason why these two things are packaged together?</p>\n</blockquote>\n<p>Indeed, this is correct: to the large extent, the SSR language for proof context manipulation is independent from the reflection support, and, in my observation, many Coq user use just the tactic language for its concise way to express proofs without bothering to implement their own <code>Reflect</code>-lemmas. This is confirmed by the first 1.5 pages of the Introduction of the <a href=\"https://inria.hal.science/inria-00258384v16/document\">SSReflect tutorial</a>.</p>\n<p>That said, in the original SSReflect for Coq this style of proof management is chosen partially because it helps to \"massage\" the goal for subsequent \"switching\" between the logical and the symbolic representation, as we show in Fig. 14 of <a href=\"https://arxiv.org/pdf/2403.12733.pdf\">our paper</a>. Somewhat curiously, this point no longer applies to LeanSSR, as the switching is done transparently (we explain it more in the paper).</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> The idea of proofs by reflection in Coq is much older than SSReflect, and I wouldn't even dare to say that it was Coq-specific to begin with. However, proof by symbolic computation in traditional Coq is usually hidden as a part of specialised tactics that invoke certified solvers and is not something regular users implement often. The <em>small-scale</em> aspect of SSR is, informally, about democratising proofs by computations with user-provided definitions, so they could be used pervasively in the proofs. LeanSSR provides precisely this experience, enhanced with Lean's capability to derive equalities about symbolic definitions (see Section 3.4 of our paper).</p>",
        "id": 428430384,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711156015
    },
    {
        "content": "<p>I've been trying to understand what reflection gives you, and it seems to me the main feature in the example is that if you make a boolean function that computes an inductively defined Prop, then you can automatically derive <code>@[simp]</code> lemmas, but I'm not sure I'm really grasping what the purpose is.</p>\n<p>I'm sure this is more interesting for something that's not a toy example, but for what it's worth, in mathlib (lacking any automation for it) we would probably just write those simp lemmas:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">even.zero</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_add_two</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">generalize</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hm</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">hm</span>\n      <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">even.add2</span>\n\n<span class=\"c1\">-- Written in a Lean version of SSReflect style</span>\n<span class=\"kd\">example</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"n\">generalizing</span> <span class=\"n\">m</span>\n  <span class=\"n\">case'</span> <span class=\"n\">add2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Written in a more idiomatic style</span>\n<span class=\"kd\">example</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"n\">generalizing</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 428432025,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711157780
    },
    {
        "content": "<p>For those who are interested, here's an annotated version of the LeanSSR proof of the earlier example, using the more-or-less the corresponding Lean tactics.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- The full LeanSSR proof: move=&gt; ⟨/hf ![i /mem_range] | ![i hi &lt;-]⟩ //</span>\n  <span class=\"c1\">-- move</span>\n  <span class=\"n\">whnf</span> <span class=\"c1\">-- this is a no-op in this case</span>\n  <span class=\"c1\">-- ⟨.. | ..⟩</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">case'</span> <span class=\"n\">mp</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- /hf ![i /mem_range]</span>\n    <span class=\"c1\">-- /hf</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">hf</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">revert</span> <span class=\"n\">h</span>\n    <span class=\"c1\">-- ![i ..]</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">H1</span><span class=\"o\">,</span> <span class=\"n\">H2</span><span class=\"o\">⟩</span>\n    <span class=\"n\">revert</span> <span class=\"n\">H1</span> <span class=\"n\">H2</span>\n    <span class=\"c1\">-- /mem_range</span>\n    <span class=\"n\">intro</span> <span class=\"n\">H1</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finset.mem_range</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H1</span>\n    <span class=\"n\">revert</span> <span class=\"n\">H1</span>\n  <span class=\"n\">case'</span> <span class=\"n\">mpr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"c1\">-- ![i hi &lt;-]</span>\n    <span class=\"c1\">-- ![i hi ..]</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩</span>\n    <span class=\"c1\">-- &lt;-</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n    <span class=\"n\">clear</span> <span class=\"n\">H</span>\n  <span class=\"c1\">-- //</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">aesop</span> <span class=\"c1\">-- not a direct translation, but same intent</span>\n</code></pre></div>",
        "id": 428432939,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711158692
    },
    {
        "content": "<p>And here's that proof but optimized a bit using Lean idioms</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_range.1</span> <span class=\"n\">hi</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">case'</span> <span class=\"n\">mp</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hf</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">H1</span><span class=\"o\">,</span> <span class=\"n\">H2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Finset.mem_range</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H1</span>\n  <span class=\"n\">case'</span> <span class=\"n\">mpr</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">aesop</span>\n</code></pre></div>\n<p>(That could be compared to the one <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428390878\">in this message</a> that's a tactic version of the original term proof.)</p>",
        "id": 428433044,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711158813
    },
    {
        "content": "<p>Regarding §3.3 of the paper and the use of <code>EnvExtension</code>s to store tactic-local state; I suspect this is unsafe with regards to parallelism. I expect the recommended approach to be to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StateT#doc\">docs#StateT</a> to add extra state to a <code>TacticM</code>, though I'm not sure how to interface that with <code>elabTactic</code> without duplicating all its code.</p>",
        "id": 428433531,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711159269
    },
    {
        "content": "<p>It seems that the \"zen\" of this SSR tactic language is to try to keep hypotheses in the goal as much as possible, and so there are sort of two stacks at work. First, the goal stack, which is exactly the same thing as Lean's tactic list (which already has its own stack-manipulation tactics) and second the \"hypothesis stack\" (my naming), of hypotheses that are still in the pi type of the goal's target. By avoiding intro-ing, you can avoid needing to name them.</p>\n<p>It seems to me that the terseness of SSR is mostly a matter of choosing symbols for each tactic, rather than naming them, and Lean could enjoy the benefits of the SSR philosophy by having additional \"normal\" tactics that have their features.</p>\n<p>That loses the APL philosophy where you want to cram as much as possible into a short amount of space, but SSR doesn't seem like it's intended to be a \"tool of thought\" like APL is — you don't really <em>reason</em> about tactic proofs like you do an expression.</p>",
        "id": 428433643,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711159395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428399022\">said</a>:</p>\n<blockquote>\n<p>I suspect that your LeanSSR gets that for free, in the form of pale highlights over the AST nodes when you hover over them.</p>\n</blockquote>\n<p>I had a closer look: to make this work, you need to add docstrings to each of your <code>syntax</code>es:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- simplification by evaluation -/</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"/=\"</span> <span class=\"o\">:</span> <span class=\"n\">ssrTriv</span>\n</code></pre></div>\n<p>etc</p>",
        "id": 428434121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711159822
    },
    {
        "content": "<p>Some examples of SSR-like tactics that we could have in mathlib:</p>\n<ul>\n<li>Versions of <code>apply</code> that effectively does <code>intro</code> enough times, applies those to the lemma, then revert.</li>\n<li>Version of <code>cases</code> that effectively does <code>intro</code>, does <code>cases</code> on that, and then reverts everything. (Note: you don't actually need to implement it this way.)</li>\n<li>An extension to <code>rintro</code> that in addition to being able to use a <code>rfl</code> pattern for substitution, lets you do <code>&lt;-</code> and <code>-&gt;</code> patterns to rewrite.</li>\n<li>A recursive version of <code>cases</code> that keeps doing <code>cases</code> on the last constructor argument, as an inverse to anonymous constructor notation.</li>\n<li>Versions of <code>constructor</code> that let you do <code>case =&gt;</code> or <code>case' =&gt;</code> on each goal in a structured way. (Maybe we just need a version of <code>next =&gt;</code> that is like <code>case' =&gt;</code> but pushes the goal to the end of the goal list at the end?)</li>\n</ul>",
        "id": 428434152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711159847
    },
    {
        "content": "<blockquote>\n<p>Version of cases that effectively does intro, does cases on that, and then reverts everything. (Note: you don't actually need to implement it this way.)</p>\n</blockquote>\n<p>I think this is currently captured in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.forall#doc\">docs#Prod.forall</a> etc, though perhaps our current approach is worse than the one you suggest</p>",
        "id": 428434226,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711159921
    },
    {
        "content": "<p>Yeah, that's how we usually handle this. It's fine, but the cost is we have to write a <code>forall</code> lemma for every single type we want to do this for.</p>",
        "id": 428434351,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711160012
    },
    {
        "content": "<p>Kyle, I'm not necessarily saying we shouldn't have those, but I do worry it could lead to over-golfing.</p>",
        "id": 428434389,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711160044
    },
    {
        "content": "<p>I think it would be reasonable for them to be autogenerated with every structure; but the nice thing about your suggestion is that it makes it easier to choose <em>which</em> binders to apply the unpacking to</p>",
        "id": 428434420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711160054
    },
    {
        "content": "<p>That (over-golfed) was my impression of the SS reflect tactic language (the utility of reflection aside), but I was holding my tongue because I know that it could just be my lack of familiarity with the syntax.</p>",
        "id": 428434581,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1711160196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428434389\">said</a>:</p>\n<blockquote>\n<p>Kyle, I'm not necessarily saying we shouldn't have those, but I do worry it could lead to over-golfing.</p>\n</blockquote>\n<p>There are lots of little manipulations where it's just logic, and you just want to restructure some exists/foralls/sigmas/what-have-you and it's obvious from there.</p>\n<p>But in any case, I think the broader point is that the really terse symbolic language that SS reflect presents you is obscuring the fact that there are some useful tactics in here that I think we're missing, that would look perfectly fine as Lean tactics. As far as I understand it, there's nothing about SS reflect that requires each tactic to be a couple symbols long.</p>",
        "id": 428434840,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711160449
    },
    {
        "content": "<p>Consider going from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">⋯</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">⋯</span> <span class=\"bp\">=</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>by \"applying\" <code>hf</code> to the front of the goal's target. Then you could do an <code>rintro</code> to deconstruct that existential, or <code>simp</code> using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=forall_exists_index#doc\">docs#forall_exists_index</a> (This tactic state appears in the examples above.)</p>\n<p>The only way I know how to do that is <code>intro h; apply hf at h; revert h</code>, and that's using  <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s relatively new <code>apply ... at ...</code> tactic. This one acting on the goal could potentially be <code>apply hf at ⊢</code> (Not to be confused with <code>apply hf</code>, which also acts on the goal!)</p>",
        "id": 428435300,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711160945
    },
    {
        "content": "<p>Of course, every new tactic is a new tactic to learn, and this is just combining a few basic tactics.</p>",
        "id": 428435415,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711161027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"https://leanprover.zulipchat.com#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428432025\">said</a>:</p>\n<blockquote>\n<p>I've been trying to understand what reflection gives you, and it seems to me the main feature in the example is that if you make a boolean function that computes an inductively defined Prop, then you can automatically derive <code>@[simp]</code> lemmas, but I'm not sure I'm really grasping what the purpose is.</p>\n</blockquote>\n<p>Whence my question about reducing the manual work of writing these lemmas as API lemmas. </p>\n<p>Another question that might be of interest: what is the anticipated effect of using this proof style on the compilation time of mathlib.</p>",
        "id": 428436504,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711162135
    },
    {
        "content": "<p>Good morning (Singapore time) every one, finally I am woke up and can handle your questions. <br>\nFirst of all, let me thank all of you for a really detailed and thoughtful discussion on LeanSSR. Reading all your comments, I have learnt a lot, and would be happy to integrate your comments to make LeanSSR even better.</p>\n<p>Let me first address concerns raised by <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> and <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> about computational reflection. <br>\nAs <span class=\"user-mention\" data-user-id=\"702586\">@Ilya Sergey</span> has already mentioned, the main feature of Coq/SSReflect is that it allows you to bind the boolean and propositional representations of the same predicate.<br>\nThe main idea here is that you only have to prove <code>Reflect</code> instance for two predicates, and you will get three things for free:</p>\n<ol>\n<li>First, you get partial evaluations principles. In Coq/SSreflect, whenever you want to use them, you have to “switch” from propositional representation to a boolean one. Please refer to the Coq proof in Section 4.1. Correspondent switches are done via <code>/subseqP</code>. </li>\n<li>Second, you can still enjoy the inductive nature of your predicate. Like induction on <code>even n</code> in section 2.6, and case analysis on line 7 of Fig 8.b</li>\n<li>Finally, you actually prove that your predicate is decidable for free as well! You can case analysis on true/false values of your predicate, use it inside <code>if-the-else</code> and so on…</li>\n</ol>\n<p>The beauty of this approach is that all 3 advantages come from one principle: reflection. <br>\nFor sure, using “API” lemmas + proving the <code>Deciable</code> instance manually would give same benefits. But the advantage of reflection is that it allows to unify “API” lemmas and <code>Deciable</code>in one concept, and minimise the manual effort to achieve the same thing. <br>\nFor example, we invite you to prove “API” lemmas for <code>subseq</code> predicate (seq. 2.7) and also prove that it is <code>Decidable</code>.  During the proof of <code>Decidability</code> via reflection with <code>subseqb</code>you will essentially have to prove that <code>subseq</code> behaves in the same way as <code>subseqb</code> does. And this is pretty much the same as proving “API” lemmas (where we once again establish that <code>subseq</code> can be reduced in the same way as <code>subseqb</code>)</p>\n<p>If you have a look at the MathComp libraries about lists <a href=\"https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/seq.v\">seq.v</a> and  <a href=\"https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/path.v\">path.v</a> you will see that they contain 70 other <code>reflect</code> lemmas for such predicates on lists as <code>all</code> , <code>has</code> (= <code>any</code>), <code>uniq</code> (uniqness of list elements), <code>constant</code> (all elements of the sequence are equal) and so forth. <br>\nHence, boolean/propositional reflection can be well-integrated in the process of developing mechanised libraries for various data structures. Here, automated generation of “API” lemmas and Decidable instances can help to minimise the effort for such developments.</p>",
        "id": 428897500,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711169086
    },
    {
        "content": "<p>From the technical side, LeanSSR reflection is easy to control. Autogenerated lemmas are added as unfolding theorems for a propositional predicate. So writing <code>simp only [even]</code> and <code>simp [-even]</code> is available.</p>",
        "id": 428897853,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711169397
    },
    {
        "content": "<p>Thanks for this answer.  I think I see a clear way forward to understand the benefits of SSR with the <code>subseqb</code> example and this reflection could very well be the MVP of this paper for me personally. I am curious to see how this can help with reducing the size of <code>Std</code> which has a lot of the computational stuff. Not sure about Mathlib since most of the stuff I know in there is built around typeclasses.</p>",
        "id": 428899227,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711170595
    },
    {
        "content": "<p>Also, another small point is that, based on the proofs written by Johann and Kyle, it seems a shortcut for Aesop would be handy</p>",
        "id": 428899435,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711170761
    },
    {
        "content": "<p>Let me also address concerns about LeanSSR as a tactic language. First, I have to admit, SSReflect proof style 90% is a matter of taste. From my own experience, all Coq users I know are either absolutely hate it, or absolutely love it.<br>\nLet me try to list my objective reasons which make me use SSReflect anytime I can. If those reasons resonate with you, you might also consider trying SSReflect in your project.</p>\n<ol>\n<li>First of all, I hate coming up with names for hypothesis. Thinking of a name for a fact that I might end up using only once (or not using at all) slows me down. SSReflect allows me to either (a) use facts on top of the stack without explicitly naming them via <code>-&gt;</code>, <code>&lt;-</code>, <code>[]</code>… or (b) reorder the elements of the goal stack (via <code>/[swap]</code> and <code>/[dup]</code>) and do (a).</li>\n<li>Informally, I always prove lemmas using forwards style of reasoning.  That is, I always make facts from my local context strong enough, such that automation can handle the rest. And it is hard for me to think of a proof in terms of backwards style   reasoning, where you simplify the goal instead. That is why it is inconvenient for me to prove lemmas by manually handcrafting the term: it enforces the backwards style of reasoning (we explain it in sec. 4.2). In vanilla Lean, I would have to use <code>obtain</code>/<code>apply at</code> to incorporate forwards style. But it forces me to name everything I might need in future. Views, from sec. 2.5, neither require explicit naming of the argument, which I apply my lemma to, nor require me to name the result. </li>\n<li>Another concern about <code>obtain</code>, is not as smart as <code>apply .. in ..</code> and <code>apply .. at ..</code>. So it will not figure out dependent arguments in application automatically. In the same time, views will figure out all dependent arguments. Here it is important that, unlike <code>apply .. at ..</code>, views will not create any subgoals for unknown arguments. It will just keep them as preconditions for the lemma after application (explained below). This is essential because you can use the result in SSReflect style of proof further. </li>\n</ol>\n<p>For example, <code>(A -&gt; B -&gt; C) -&gt; B -&gt; A -&gt; C</code> can be simply solved as <code>move=&gt; H /H //</code>, or even better using a shortcut for <code>H /H</code> as <code>move=&gt; /[apply] //</code>. Here, after we apply <code>A -&gt; B -&gt; C</code> to <code>B</code> we get <code>A -&gt; C</code> at the goal stack. For more elaborated examples, try out this <a href=\"https://github.com/verse-lab/lean-ssr/blob/f2c343cc6ca3b282082f433b88eaa70098a8fa3d/Examples/Mathlib.lean#L92\">line</a>. Here <a href=\"https://github.com/verse-lab/lean-ssr/wiki/Intro-Patterns\"><code>/(_ X)</code> pattern</a> is the reverse of <code>/X</code>: it applies the top element of the stack to <code>X</code></p>",
        "id": 429052395,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711172538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428899435\">said</a>:</p>\n<blockquote>\n<p>Also, another small point is that, based on the proofs written by Johann and Kyle, it seems a shortcut for Aesop would be handy</p>\n</blockquote>\n<p>Yeah, this is a good idea indeed. The only problem is that we don't want SSReflect to depend on anything, rather than <code>std4</code>. You might also consider augmenting <code>//</code> with <code>aesop</code> or extending <code>ssrTriv</code>/<code>ssrIntro</code> with it locally. It can easily be done following suggestions from sec 3.2</p>",
        "id": 429052673,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711172772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428434121\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428399022\">said</a>:</p>\n<blockquote>\n<p>I suspect that your LeanSSR gets that for free, in the form of pale highlights over the AST nodes when you hover over them.</p>\n</blockquote>\n<p>I had a closer look: to make this work, you need to add docstrings to each of your <code>syntax</code>es:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- simplification by evaluation -/</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"/=\"</span> <span class=\"o\">:</span> <span class=\"n\">ssrTriv</span>\n</code></pre></div>\n<p>etc</p>\n</blockquote>\n<p>That is super cool, thanks! We will add docs for each LeanSSR tactic.</p>",
        "id": 429052823,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711172908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428434152\">said</a>:</p>\n<blockquote>\n<p>Some examples of SSR-like tactics that we could have in mathlib:</p>\n<ul>\n<li>Versions of <code>apply</code> that effectively does <code>intro</code> enough times, applies those to the lemma, then revert.</li>\n<li>Version of <code>cases</code> that effectively does <code>intro</code>, does <code>cases</code> on that, and then reverts everything. (Note: you don't actually need to implement it this way.)</li>\n<li>An extension to <code>rintro</code> that in addition to being able to use a <code>rfl</code> pattern for substitution, lets you do <code>&lt;-</code> and <code>-&gt;</code> patterns to rewrite.</li>\n<li>A recursive version of <code>cases</code> that keeps doing <code>cases</code> on the last constructor argument, as an inverse to anonymous constructor notation.</li>\n<li>Versions of <code>constructor</code> that let you do <code>case =&gt;</code> or <code>case' =&gt;</code> on each goal in a structured way. (Maybe we just need a version of <code>next =&gt;</code> that is like <code>case' =&gt;</code> but pushes the goal to the end of the goal list at the end?)</li>\n</ul>\n</blockquote>\n<p>One more thing that we have in LeanSSR (and that we didn't have space to cover in the paper) are suggestions for case analysis. For example, in LeanSSR if you write <code>?[]</code> LeanSSR will suggest you to replace it with <code>[ | | ... | ]</code> with a correspondent number of alternations. As LeanSSR doesn't require mentioning constructors of the term being destructed (and doesn't require naming arguments of those constructors) <code>?[]</code> is super easy to implement.</p>",
        "id": 429053211,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711173246
    },
    {
        "content": "<p>that's close to what <code>rcases?</code> does (or did, it hasn't yet been ported to lean 4)</p>",
        "id": 429053273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711173321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428433531\">said</a>:</p>\n<blockquote>\n<p>Regarding §3.3 of the paper and the use of <code>EnvExtension</code>s to store tactic-local state; I suspect this is unsafe with regards to parallelism. I expect the recommended approach to be to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StateT#doc\">docs#StateT</a> to add extra state to a <code>TacticM</code>, though I'm not sure how to interface that with <code>elabTactic</code> without duplicating all its code.</p>\n</blockquote>\n<p>Thanks for pointing this out! I will try to ask it during Lean office hours to receive more comments.</p>",
        "id": 429053363,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711173396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429053273\">said</a>:</p>\n<blockquote>\n<p>that's close to what <code>rcases?</code> does (or did, it hasn't yet been ported to lean 4)</p>\n</blockquote>\n<p>I think you meant that <code>[ | | .. | ]</code> is close to <code>rcases</code>, right? It is true indeed. <br>\nThe difference of <code>[ | | .. | ]</code>and <code>rcases</code>/<code>rintro</code> is that <code>[ | | .. | ]</code> allows you to use all other intro patterns inside each branch (like views <code>/hyp</code>, automation <code>//</code>, applying ext lemmas <code>!</code> and so on)</p>\n<p>However, in my message, I was mostly talking about providing <code>Try this:</code> suggestions for a number of alternations.</p>",
        "id": 429053761,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711173777
    },
    {
        "content": "<p>I was speaking specifically about the <code>?[]</code> behavior, which is similar to <code>rcases?</code></p>",
        "id": 429053789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711173821
    },
    {
        "content": "<p>that is, a code action and try this which suggests a pattern match (it's more than just number of alternations because it can be nested)</p>",
        "id": 429053872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711173854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429053789\">said</a>:</p>\n<blockquote>\n<p>I was speaking specifically about the <code>?[]</code> behavior, which is similar to <code>rcases?</code></p>\n</blockquote>\n<p>Oh sorry, I missed <code>?</code> in <code>rcases?</code>. I am not familiar with this tactic, but I suppose that yes, it is similar</p>",
        "id": 429053924,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711173925
    },
    {
        "content": "<p><code>rcases</code> syntax is inspired by intro patterns in Coq</p>",
        "id": 429053939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711173958
    },
    {
        "content": "<p>As far as I can tell intro patterns are inspired by SSReflect :)</p>",
        "id": 429054023,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711173993
    },
    {
        "content": "<p>although it doesn't have the view pattern stuff (this is a deliberate design decision though, it's a bit hard to motivate applying a lemma as a \"pattern\" in the traditional sense)</p>",
        "id": 429054079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711174057
    },
    {
        "content": "<p>I think the fanciest rcases patterns get is the <code>-</code> pattern which clears the hypothesis</p>",
        "id": 429054218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711174193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428399531\">said</a>:</p>\n<blockquote>\n<p>One thing I am especially interested in is if there is a way to translate SSR to 'traditional' lean proof scripts. Given that you were able to write LeanSSR in lean I guess that all the tools are already present, but is it possible to take a SSR proof and write it entirely using regular lean tactics (even if it's much more verbose)?</p>\n</blockquote>\n<p>Thanks for asking! We were thinking of doing that as well. The only problem is <code>apply in</code> tactic for views, which doesn't correspond to anything in Lean. Modulo this tactic, I suppose we can make such translation.</p>",
        "id": 429054310,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711174250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429054218\">said</a>:</p>\n<blockquote>\n<p>I think the fanciest rcases patterns get is the <code>-</code> pattern which clears the hypothesis</p>\n</blockquote>\n<p>You can look up all LeanSSR intro patterns at our <a href=\"https://github.com/verse-lab/lean-ssr/wiki/Intro-Patterns\">wiki</a></p>",
        "id": 429054380,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711174329
    },
    {
        "content": "<p>I can definitely see that using the pattern grammar for more things is a powerful mechanism for increasing the expressivity of the language, but lean's tactic language is to some extent deliberately simplified such that it's not too unfamiliar to those with some general programming background. SSReflect to me looks like the \"vim\" of tactic languages: optimized for the expert and impenetrable to the newcomer</p>",
        "id": 429054390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711174362
    },
    {
        "content": "<p>and also so core to your interaction that you want to take it with you wherever you go once you learn it :)</p>",
        "id": 429054432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711174435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429054390\">said</a>:</p>\n<blockquote>\n<p>I can definitely see that using the pattern grammar for more things is a powerful mechanism for increasing the expressivity of the language, but lean's tactic language is to some extent deliberately simplified such that it's not too unfamiliar to those with some general programming background. SSReflect to me looks like the \"vim\" of tactic languages: optimized for the expert and impenetrable to the newcomer</p>\n</blockquote>\n<p>That is true. To somehow tackle this, we do two things:</p>\n<ol>\n<li>We (as well as initial SSR developers) try to keep it minimalistic. LeanSSR has around 20 different intro pattens, where only 15 of them, you will use in your \"every day life\". It is slightly more than CoqSSR, I think we have added 3 new intro patterns. Those patterns should be enough (at least from my experience) for almost any reasonable goal manipulation. </li>\n<li>Unlike CoqSSR, we have LeanSSR interactive: such that you can step through each symbol ad see what happens there.</li>\n</ol>",
        "id": 429054831,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711174886
    },
    {
        "content": "<p>But I acknowledge that it is might be impenetrable to the newcomer</p>",
        "id": 429054958,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711175000
    },
    {
        "content": "<p>Do you find the goals of SSR to be <em>incompatible</em> with having a newcomer friendly language? That is, if you were to take all the tactics and make a mechanical translation into \"traditional style\" tactics which is still idiomatic and effective, would it no longer serve the goals of SSR proof style? (This is a question along the lines of Kyle's reference to \"APL as a tool of thought\", where making the core commands less terse would actually defeat the purpose, or so the proponents say.) This would clearly fail in the goal of being syntactically compatible with Coq's ssreflect, so it probably wouldn't be appropriate for LeanSSR (which from what I can tell is primarily aimed at giving people with prior ssreflect experience an analogue in Lean), but it seems like this is the most promising avenue for feeding the new tactics back into lean core and mathlib.</p>",
        "id": 429055277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711175357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429055277\">said</a>:</p>\n<blockquote>\n<p>Do you find the goals of SSR to be <em>incompatible</em> with having a newcomer friendly language? That is, if you were to take all the tactics and make a mechanical translation into \"traditional style\" tactics which is still idiomatic and effective, would it no longer serve the goals of SSR proof style? This would clearly fail in the goal of being syntactically compatible with Coq's ssreflect, so it probably wouldn't be appropriate for LeanSSR (which from what I can tell is primarily aimed at giving people with prior ssreflect experience an analogue in Lean), but it seems like this is the most promising avenue for feeding the new tactics back into lean core and mathlib.</p>\n</blockquote>\n<p>That is certainly a good question which requires a thoughtful investigation. At the first glance, it seems to me that we indeed can provide LeanSSR with a friendlier syntax by implementing <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428434152\">suggestions</a>. On the other side, I don't see any obstacles in having two different dialects of the same proof language. With LeanSSR-&gt;Lean translation, we can easily transform LeanSSR proofs, if we want to merge them in Mathlib. But do you see any problems in having a second proof dialect for new end-to-end projects? As for me, it can only turn more people to Lean side.</p>",
        "id": 429055901,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711176088
    },
    {
        "content": "<p>Think the main goal of our development was not to make all Lean users switch to LeanSSR, but to provide a new proof style alternative to attract even more people.</p>",
        "id": 429056031,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711176214
    },
    {
        "content": "<p>I mean, CoqSSR community is quite big and exceptionally prolific, and they have their own reasons to use SSReflect proof style. Let's try to turn them to Lean as well.</p>",
        "id": 429056236,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711176454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/428432025\">said</a>:</p>\n<blockquote>\n<p>I've been trying to understand what reflection gives you, and it seems to me the main feature in the example is that if you make a boolean function that computes an inductively defined Prop, then you can automatically derive <code>@[simp]</code> lemmas, but I'm not sure I'm really grasping what the purpose is.</p>\n<p>I'm sure this is more interesting for something that's not a toy example, but for what it's worth, in mathlib (lacking any automation for it) we would probably just write those simp lemmas:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">even.zero</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">even_add_two</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">generalize</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">m</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hm</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">hm</span>\n      <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">even.add2</span>\n\n<span class=\"c1\">-- Written in a Lean version of SSReflect style</span>\n<span class=\"kd\">example</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"n\">generalizing</span> <span class=\"n\">m</span>\n  <span class=\"n\">case'</span> <span class=\"n\">add2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Written in a more idiomatic style</span>\n<span class=\"kd\">example</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"n\">generalizing</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Actually, Lean SSR reflect proof can be simplified to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">even</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reflect</span><span class=\"kd\">]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">evP</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Reflect</span> <span class=\"o\">(</span><span class=\"n\">even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">evenb</span> <span class=\"n\">n</span><span class=\"o\">):=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">sdone</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">Reflect.F</span><span class=\"bp\">=&gt;</span> <span class=\"bp\">//</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">scase</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">evP</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">=&gt;</span> <span class=\"bp\">/==</span> <span class=\"bp\">?-&gt;</span>\n                <span class=\"o\">{</span> <span class=\"n\">sby</span> <span class=\"n\">apply</span> <span class=\"n\">Reflect.T</span> <span class=\"o\">}</span>\n                <span class=\"n\">sby</span> <span class=\"n\">apply</span> <span class=\"n\">Reflect.F</span><span class=\"bp\">=&gt;</span> <span class=\"bp\">//</span> <span class=\"o\">[]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reflect</span> <span class=\"n\">even</span> <span class=\"n\">evenb</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">even</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">sby</span> <span class=\"n\">elim</span><span class=\"bp\">;</span> <span class=\"n\">srw</span> <span class=\"bp\">-?</span><span class=\"n\">Nat.add_assoc</span>\n</code></pre></div>\n<p>Not that in the LeanSSR proof, we also get the <code>Decidable</code> instance for <code>even</code></p>",
        "id": 429056673,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711176934
    },
    {
        "content": "<p>I'm totally on board with having LeanSSR exactly as is or even better, as a way of implementing SSReflect itself in Lean for people who prefer that style and bringing more people over from Coq which are hampered by the mismatch. But I don't see it ever making it into mathlib because of the style differences, and that's why pursuing some kind of \"disguised SSR\" which is more mathlib-compatible would also be a useful line of investigation.</p>",
        "id": 429056967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711177206
    },
    {
        "content": "<p>Certainly lean/std/mathlib have struggled a lot (mostly successfully) with trying to put up a united front with respect to having a similar proof style so that code in one project can be transplanted to another project or moved upstream. I think that one reasonable concern about LeanSSR (or more accurately, the projects using it) is that it promotes a fracturing of the ecosystem in proof style. I'm not too worried about this because the projects that use SSR style would probably not be written at all without it, but I think we should also give thought to how to breach the new barrier of translating between LeanSSR and traditional lean, through tooling and documentation.</p>",
        "id": 429057440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711177673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thanks for your comments, I totally agree. Let us aim then for LeanSSR-&gt;Lean translation first. After that, if we will get a bit more (than 0) LeanSSR users from the Lean side, we can start thinking together what would be a better syntax for SSR proofs.</p>",
        "id": 429057824,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711178074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429052395\">said</a>:</p>\n<blockquote>\n<p>Let me also address concerns about LeanSSR as a tactic language. First, I have to admit, SSReflect proof style 90% is a matter of taste. From my own experience, all Coq users I know are either absolutely hate it, or absolutely love it.<br>\nLet me try to list my objective reasons which make me use SSReflect anytime I can. If those reasons resonate with you, you might also consider trying SSReflect in your project.</p>\n<ol>\n<li>First of all, I hate coming up with names for hypothesis. Thinking of a name for a fact that I might end up using only once (or not using at all) slows me down. SSReflect allows me to either (a) use facts on top of the stack without explicitly naming them via <code>-&gt;</code>, <code>&lt;-</code>, <code>[]</code>… or (b) reorder the elements of the goal stack (via <code>/[swap]</code> and <code>/[dup]</code>) and do (a).</li>\n<li>Informally, I always prove lemmas using forwards style of reasoning.  That is, I always make facts from my local context strong enough, such that automation can handle the rest. And it is hard for me to think of a proof in terms of backwards style   reasoning, where you simplify the goal instead. That is why it is inconvenient for me to prove lemmas by manually handcrafting the term: it enforces the backwards style of reasoning (we explain it in sec. 4.2). In vanilla Lean, I would have to use <code>obtain</code>/<code>apply at</code> to incorporate forwards style. But it forces me to name everything I might need in future. Views, from sec. 2.5, neither require explicit naming of the argument, which I apply my lemma to, nor require me to name the result. </li>\n<li>Another concern about <code>obtain</code>, is not as smart as <code>apply .. in ..</code> and <code>apply .. at ..</code>. So it will not figure out dependent arguments in application automatically. In the same time, views will figure out all dependent arguments. Here it is important that, unlike <code>apply .. at ..</code>, views will not create any subgoals for unknown arguments. It will just keep them as preconditions for the lemma after application (explained below). This is essential because you can use the result in SSReflect style of proof further. </li>\n</ol>\n<p>For example, <code>(A -&gt; B -&gt; C) -&gt; B -&gt; A -&gt; C</code> can be simply solved as <code>move=&gt; H /H //</code>, or even better using a shortcut for <code>H /H</code> as <code>move=&gt; /[apply] //</code>. Here, after we apply <code>A -&gt; B -&gt; C</code> to <code>B</code> we get <code>A -&gt; C</code> at the goal stack. For more elaborated examples, try out this <a href=\"https://github.com/verse-lab/lean-ssr/blob/f2c343cc6ca3b282082f433b88eaa70098a8fa3d/Examples/Mathlib.lean#L92\">line</a>. Here <a href=\"https://github.com/verse-lab/lean-ssr/wiki/Intro-Patterns\"><code>/(_ X)</code> pattern</a> is the reverse of <code>/X</code>: it applies the top element of the stack to <code>X</code></p>\n</blockquote>\n<p>Idly wondering: how does SSReflect fare in terms of proof brittleness / how easy it is to fix proofs when definitions change?</p>",
        "id": 429062967,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1711183433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"221921\">@Marc Huisinga</span> This is a brilliant question, which would require quite a bit of empirical studies, and we are wondering if someone has done any evaluation of Lean capacities with regard to <a href=\"https://homes.cs.washington.edu/~djg/theses/ringer_dissertation.pdf\">Proof Repair</a>.</p>\n<p>For Coq, this has been done, to some extent, in the scope of <a href=\"https://dependenttyp.es/\">Talia Ringer</a>'s earlier works on refactoring proofs about functional programs, and <a href=\"https://ilyasergey.net/assets/pdf/papers/sisyphus-pldi23.pdf\">our own work on proof repair</a> for imperative code. It would be very interesting to apply these techniques for evolving mathlib-style proofs, but it would require to have some motivating examples first.</p>",
        "id": 429063698,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711184261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429053363\">said</a>:</p>\n<blockquote>\n<p>Thanks for pointing this out! I will try to ask it during Lean office hours to receive more comments.</p>\n</blockquote>\n<p>Please report back with your findings after you've done this :). I'm curious to know what the \"correct\" approach is.</p>",
        "id": 429066494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711187078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429057824\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> thanks for your comments, I totally agree. Let us aim then for LeanSSR-&gt;Lean translation first. After that, if we will get a bit more (than 0) LeanSSR users from the Lean side, we can start thinking together what would be a better syntax for SSR proofs.</p>\n</blockquote>\n<p>I think it would also be worth it to try to \"decouple\" the reflection part from the proof style part of LeanSSR: I don't see any reason why we wouldn't want the former in mathlib!</p>",
        "id": 429069049,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1711189593
    },
    {
        "content": "<p>Hello Ilya, nice to see you here!</p>\n<blockquote>\n<p>Unlike CoqSSR, we have LeanSSR interactive: such that you can step through each symbol ad see what happens there.</p>\n</blockquote>\n<p>I’m baffled that Coq users manage these kind of proofs at all without this feature. (Back in my Coq days I stepped around SSReflect, maybe partially because of that, or maybe because the APL-like syntax scared me.)</p>",
        "id": 429071572,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711192102
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span></p>\n<blockquote>\n<p>I’m baffled that Coq users manage these kind of proofs at all without this feature.</p>\n</blockquote>\n<p>They are a tough bunch indeed. But not nearly as tough as Dafny users that manage their proofs without any access to the proof context whatsoever. <span aria-label=\"nerd\" class=\"emoji emoji-1f913\" role=\"img\" title=\"nerd\">:nerd:</span></p>",
        "id": 429072905,
        "sender_full_name": "Ilya Sergey",
        "timestamp": 1711193340
    },
    {
        "content": "<p>Something I'm still not understanding is what the <code>Reflect</code> typeclass is for, and what it gives that <code>Decidable</code> can't.</p>\n<p>I can see that <code>Reflect</code> could be used to lift boolean expressions to <code>Prop</code> expressions, which is neat, since then you can, for example, do <code>cases</code> on <code>&amp;&amp;</code> or <code>||</code> like they were <code>And</code> or <code>Or</code>.</p>\n<p>But for deriving equations, it seems to me that you can get this from <code>Decidable</code>.</p>\n<p>Here's an experiment creating a <code>reflect_unfold</code> tactic that unfolds an inductive predicate by looking for a <code>Decidable</code> instance:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">DecTest</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoeOut</span> <span class=\"o\">(</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">p</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">dtrue</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">dfalse</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">isFalse</span> <span class=\"n\">h</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">decide_by</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"n\">decidable_of_iff</span> <span class=\"n\">q</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Even</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Even</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">Even.zero</span> <span class=\"n\">Even.add2</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">aesop</span> <span class=\"n\">safe</span> <span class=\"n\">cases</span><span class=\"o\">]</span> <span class=\"n\">Even</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">evend</span> <span class=\"o\">:</span> <span class=\"n\">DecidablePred</span> <span class=\"n\">Even</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dtrue</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dfalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">evend</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">decide_prop</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">decide_eq_true_eq</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">decide_decide_by</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">dq</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">q</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">decide_by</span> <span class=\"n\">q</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">getSimpUnfoldContext</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Simp.Context</span> <span class=\"o\">:=</span>\n   <span class=\"n\">return</span> <span class=\"o\">{</span>\n      <span class=\"n\">congrTheorems</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getSimpCongrTheorems</span><span class=\"o\">)</span>\n      <span class=\"n\">config</span>        <span class=\"o\">:=</span> <span class=\"n\">Simp.neutralConfig</span>\n   <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">reflect_unfold</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">declName</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">Simp.Result</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">Simp.main</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getSimpUnfoldContext</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">methods</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">pre</span> <span class=\"o\">:=</span> <span class=\"n\">pre</span> <span class=\"o\">})</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">pre</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SimpM</span> <span class=\"n\">Simp.Step</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"n\">e.isAppOf</span> <span class=\"bp\">``</span><span class=\"n\">Decidable.decide</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"o\">{</span><span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">e</span><span class=\"o\">}</span>\n    <span class=\"n\">unless</span> <span class=\"n\">e.isAppOf</span> <span class=\"n\">declName</span> <span class=\"k\">do</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span>\n    <span class=\"k\">let</span> <span class=\"n\">inst</span> <span class=\"bp\">←</span> <span class=\"n\">try</span> <span class=\"n\">synthInstance</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkAppM</span> <span class=\"bp\">``</span><span class=\"n\">Decidable</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">])</span> <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">inst</span> <span class=\"bp\">←</span> <span class=\"n\">withDefault</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">unfoldDefinition</span><span class=\"bp\">?</span> <span class=\"n\">inst</span> <span class=\"bp\">|</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">continue</span>\n    <span class=\"k\">let</span> <span class=\"n\">eq</span> <span class=\"bp\">←</span> <span class=\"n\">mkAppOptM</span> <span class=\"bp\">``</span><span class=\"n\">decide_prop</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">inst</span><span class=\"o\">]</span>\n    <span class=\"k\">let</span> <span class=\"n\">eqTy</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">eq</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"bp\">?.</span><span class=\"n\">get</span><span class=\"bp\">!</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">done</span> <span class=\"o\">{</span><span class=\"n\">expr</span> <span class=\"o\">:=</span> <span class=\"n\">eqTy.2.2</span><span class=\"o\">,</span> <span class=\"n\">proof</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">eq</span><span class=\"o\">}</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"reflect_unfold' \"</span> <span class=\"n\">declNameId</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">declName</span> <span class=\"bp\">←</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span> <span class=\"n\">declNameId</span>\n  <span class=\"n\">Tactic.liftMetaTactic1</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">target</span> <span class=\"bp\">←</span> <span class=\"n\">instantiateMVars</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">reflect_unfold</span> <span class=\"n\">target</span> <span class=\"n\">declName</span>\n    <span class=\"k\">if</span> <span class=\"n\">r.expr</span> <span class=\"bp\">==</span> <span class=\"n\">target</span> <span class=\"k\">then</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"</span><span class=\"err\">\\</span>\n<span class=\"s2\">      tactic 'reflect_unfold' failed to unfold '{declName}' at{indentExpr target}\"</span>\n    <span class=\"n\">applySimpResultToTarget</span> <span class=\"n\">mvarId</span> <span class=\"n\">target</span> <span class=\"n\">r</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"reflect_unfold \"</span> <span class=\"n\">declNameId</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">reflect_unfold'</span> <span class=\"bp\">$</span><span class=\"n\">declNameId</span> <span class=\"bp\">;</span> <span class=\"o\">(</span><span class=\"n\">try</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">decide_decide_by</span><span class=\"o\">])</span><span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"n\">simp</span><span class=\"o\">))</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">Even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    a_ih✝ : Even (m + n✝) ↔ Even m</span>\n<span class=\"cm\">    ⊢ Even (m + n✝ + 2) ↔ Even m</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"n\">reflect_unfold</span> <span class=\"n\">Even</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    a_ih✝ : Even (m + n✝) ↔ Even m</span>\n<span class=\"cm\">    ⊢ Even (m + n✝) ↔ Even m</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"n\">assumption</span>\n</code></pre></div>\n</div></div>\n<p>Two things to focus on:</p>\n<ol>\n<li>With some helper functions for <code>Decidable</code>, you can write the <code>Decidable</code> instance like it was a boolean function. This works here because the inductive predicate is simple enough, and <code>aesop</code> can do cases on it to prove the side goals.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">evend</span> <span class=\"o\">:</span> <span class=\"n\">DecidablePred</span> <span class=\"n\">Even</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dtrue</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dfalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">evend</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>An example of the tactic, which \"unfolds\" <code>Even</code> by synthesizing a <code>Decidable</code> instance, unfolding it, and converting it back to the land of propositions by applying some simp lemmas.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">Even</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">]</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    a_ih✝ : Even (m + n✝) ↔ Even m</span>\n<span class=\"cm\">    ⊢ Even (m + n✝ + 2) ↔ Even m</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"n\">reflect_unfold</span> <span class=\"n\">Even</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    a_ih✝ : Even (m + n✝) ↔ Even m</span>\n<span class=\"cm\">    ⊢ Even (m + n✝) ↔ Even m</span>\n<span class=\"cm\">    -/</span>\n    <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 429113274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711226092
    },
    {
        "content": "<p>Btw, your paper, and, in particular, your repository has been very helpful to understand the SSR tactic framework. The metaprogramming code has been a \"Rosetta stone\" for me <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>I'm just trying to understand \"what's really going on\" to see what Lean is missing -- this unfolding-via-decidable-instances is certainly not something I've seen before, and it would be good to know if <code>Reflect</code> contributes more than this idea, and/or if the typeclass isn't necessary and the rest can be done with simp lemmas, sort of like how the <code>norm_cast</code> tactics work.</p>",
        "id": 429113819,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711226611
    },
    {
        "content": "<p>I wonder how this <code>reflect_unfold</code> relates to the simp lemmas that you get for an inductive predicate in Isabelle. I think there you will get, from the <code>inductive Even</code>, the (very useful!) simp lemma <code>Even (n + 2) \\iff Even n</code> without further ado.</p>",
        "id": 429114310,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711226947
    },
    {
        "content": "<p>My understanding of Vladimir's response is that we get a bunch of simp lemmas for free</p>",
        "id": 429114544,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711227104
    },
    {
        "content": "<p>This <code>reflect_unfold</code> tactic could be turned into a simp lemma generator, but for a prototype it was easy to do it this way as a tactic.</p>",
        "id": 429114600,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711227151
    },
    {
        "content": "<p>Ah I see Joachim's message precedes mine. </p>\n<p>Anyway, I haven't had access to my machine to test this yet and won't have one for a few days. I am trying to understand precisely what this entails.</p>",
        "id": 429114605,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711227155
    },
    {
        "content": "<p>Two quick tests, just to see what it would do with the first mathlib predicates I could think of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- The global `Even`, not the `Even` from the previous code blocks.</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">reflect_unfold</span> <span class=\"n\">Even</span>\n  <span class=\"c1\">-- ⊢ n % 2 = 0</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Unfolds to `List.isPerm`, which makes sense, but it can be unfolded more.</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List.Perm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">reflect_unfold</span> <span class=\"n\">List.Perm</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ⊢ List.isPerm (x :: xs) ys = true</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">List.isPerm</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ⊢ (List.contains ys x &amp;&amp; List.isPerm xs (List.erase ys x)) = true</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 429114945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711227462
    },
    {
        "content": "<p>Maybe it's fair to say that the decidable instance deriver does more or less what Isabelle's simp lemma generator does:  both have to construct equations describing when the predicate holds; the decidable instance then additionally turns these equations into a function.</p>",
        "id": 429114952,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711227481
    },
    {
        "content": "<p>It would be neat if there were a <code>Decidable</code> deriver in Lean for this example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Even</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Even</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">add2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Even</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Decidable</span>\n</code></pre></div>\n<p>(but alas I had to write that instance myself)</p>",
        "id": 429115049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711227570
    },
    {
        "content": "<p>Were you able to run the experiment Vladimir suggested with subseqb?</p>",
        "id": 429115719,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711228055
    },
    {
        "content": "<p>Oh, I somehow assumed there was, no reason why I did. So more to play catch up with Isabelle…</p>",
        "id": 429116482,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1711228625
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> for your comment! Actually, initially, I was also thinking about generating simp lemmas by extracting them from the proof of <code>Decidable</code> instance. I think I gave up on it because of two reasons. First one is that I am not that familiar with Lean metaprogramming and this way appears to me a bit harder than via <code>Refelct</code>.  So now I am happy to see this implementation from experts. There is a second, more subtle, reason. Let me try to explain it below.<br>\nCorrect me if I am wrong, but what you essentially do is that you try to fetch the boolean representation from the proof of <code>Decidable</code> instance, right? Then the benefit of <code>Reflect</code> type class is that you can hint how to “reflect” each particular boolean sub routine used in the boolean representation. </p>\n<p>For example, have a look at <a href=\"https://github.com/verse-lab/lean-ssr/blob/98c44e3b9d04f248e8b8d8f9202a485a63720605/Examples/Seq.lean#L239\"><code>has</code></a> (equivalent to <code>List.any</code>) predicate. Our goal is to make <code>has a (x :: xs)</code> be unfolded to <code>a x \\/ has a xs</code>. <br>\nLet's see how we can prove <code>Decidbale</code> instance for <code>has</code>. One way would be to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">HasTest</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">has</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">hasd</span> <span class=\"o\">:</span>  <span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"n\">has</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"n\">False</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">has</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"k\">then</span>\n      <span class=\"n\">decide_by</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">hasd</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"n\">has</span> <span class=\"n\">a</span> <span class=\"n\">xs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">reflect_unfold</span> <span class=\"n\">has</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> (decide (has a (x :: xs)) = true) = a x ∨ decide (has a xs) = true -/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In this case, <code>reflect_unfold</code> will get stuck because it doesn't know how to deal with <code>if-then-else</code> statement in the second branch of <code>hasd</code> definition. To fix it, we will have to prove a lemma similar to <code>decide_decide_by</code> which will say how to propagate <code>decide</code> over <code>if-then-else</code> statement, and add it to <code>reflect_unfold</code> definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">decide_ite</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"n\">b</span> <span class=\"n\">t</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ite</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">decide</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">decide</span> <span class=\"n\">e</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"reflect_unfold \"</span> <span class=\"n\">declNameId</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">reflect_unfold'</span> <span class=\"bp\">$</span><span class=\"n\">declNameId</span> <span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">decide_decide_by</span><span class=\"o\">,</span> <span class=\"n\">decide_ite</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">try</span> <span class=\"n\">simp</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>However, it will still only reduce <code>has</code> to <code>if-then-else</code> statement, not <code>a x \\/ has a xs</code>. <br>\nSo another way would be to specify exactly what <code>has a (x :: xs)</code> should be simplified to by:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">hasd</span> <span class=\"o\">:</span>  <span class=\"n\">DecidablePred</span> <span class=\"o\">(</span><span class=\"n\">has</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"n\">False</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">has</span><span class=\"o\">])</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">@</span><span class=\"n\">decide_by</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">∨</span> <span class=\"n\">has</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Or.decidable</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">hasd</span> <span class=\"n\">s</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now you can check that <code>refelct_unfold</code> will unfold <code>has a (x :: xs)</code> to <code>a x \\/ has a xs</code>. <br>\nThe problem with this approach is that you will have to provide the unfolded form of the predicate to <code>decide_by</code> in each non-trivial branch. <br>\nThe benefit of <code>Reflect</code> is that if you provide an instance for each standard boolean function (in the same way as we do at Fig 13), then type class resolution will figure out what this unfolded form should look like automatically. </p>\n<p>More specifically, in our approach, we take the unfolded form of the boolean predicate and via type class resolution infer the propositional representation for it. In the case, when this unfolded form is a composite expression, type class resolution will replace each subcomponent, making use of corresponded <code>Reflect</code> instances. <br>\nHere, as we know that <code>hasb a (x :: xs)</code> is unfolded to <code>a x || hasb a xs</code>, and we have a <code>Reflect</code> instance for <code>||</code>, type class resolution will replace it with <code>a x \\/ has a xs</code>.</p>\n<p>Moreover, using instance priorities, you can control what propositional representations should we peak in each particular case.</p>",
        "id": 429330259,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711359387
    },
    {
        "content": "<p>To sum up, assume we have proven <code>Refelct P b</code>. Then types of simp lemmas generated for <code>P</code> are determined by the definition of <code>b</code>. Type class resolution will take care of replacing each sub-expression of <code>b</code> in the way we want. Note that, that is what we want: we want <code>P</code> to reduce in exactly the same way as <code>b</code> does.<br>\nIn addition, do you don't have to care, how do you actually prove <code>Refelct P b</code>. And this proof <a href=\"https://github.com/verse-lab/lean-ssr/blob/98c44e3b9d04f248e8b8d8f9202a485a63720605/Examples/Seq.lean#L454\">can be quite complicated</a>. </p>\n<p>If you want to extract simp lemmas from the proof of <code>Decidable</code>you will either </p>\n<ol>\n<li>have to take care of the construction you use in the proof, such that we know to fold them into a boolean function. This might not be so pleasant with complicated <code>Decidable</code> instances</li>\n<li>or you will have to explicitly say how your proof should be extracted (via the first arg of <code>decide_by</code>). This is exactly what type classes are meant to automate.</li>\n</ol>",
        "id": 429449681,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711382457
    },
    {
        "content": "<p>One thing to keep in mind is that for <code>Decidable</code> instances, you ought to take care in their construction anyway. They're not just proofs, and they actually get run in a few places (either in proof by reflection using the <code>decide</code> tactic, or in executable code, where <code>Decidable</code> gets extracted as a plain boolean in C). If this is too complicated, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=decidable_of_iff#doc\">docs#decidable_of_iff</a> (which is what my <code>decide_by</code> is a frontend to) to specify which boolean function to use instead, and then you are able to reduce the problem to providing a mere proof rather than interleaving proof and algorithm.</p>\n<p>Regarding needing simp lemmas to push propagate <code>decide</code>, yeah, that would be what is required for <code>reflect_unfold</code>. In Lean you can create \"simp sets\" of lemmas, which can be added to by the user, and there could be a simp set for pushing <code>decide</code> into an expression. This can be a much more powerful approach than relying on typeclass resolution. In fact, there are now simprocs, so users could add arbitrary transformations to this simp set. (When I referred to <code>norm_cast</code>, that's part of a pair of tactics that pushes or pulls coercions into or out of an expression. It's driven by simp sets. Pushing <code>decide</code> into expressions seems similar.)</p>",
        "id": 429454470,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711383400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690517\">Vladimir Gladstein</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429449681\">said</a>:</p>\n<blockquote>\n<p>And this proof <a href=\"https://github.com/verse-lab/lean-ssr/blob/98c44e3b9d04f248e8b8d8f9202a485a63720605/Examples/Seq.lean#L454\">can be quite complicated</a>. </p>\n</blockquote>\n<p>I spent a little time looking at doing this using mathlib style for comparison (though was pulled away to grade final exams for calculus...) and something that I was struggling with was that it seemed like this <code>Reflect</code> theorem would be easier to prove if I were to prove all the small \"API lemmas\" first, and these would include the equation lemmas that <code>#reflect</code> would later generate. Then, if I did that, there felt like there would be no point to the experiment.</p>\n<p>In mathlib we're generally wary of seeing a giant proof, since a giant proof is usually not irreducibly complex, and everyone would be better off if it were refactored to be a small proof applying numerous factored-out helper lemmas.</p>",
        "id": 429455422,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711383604
    },
    {
        "content": "<p>This seems like a possible framework:</p>\n<ol>\n<li><code>propify</code> and <code>boolify</code> to translate a statement to and from <code>Prop</code> and <code>Bool</code>, driven by simp sets (and perhaps the <code>Reflect</code> class). These could be aware of <code>decide</code>. The simp sets could be full of rw-style theorems like <code>p &lt;-&gt; b = true</code> to drive the translation. (It would need two simp sets, one for the <code>p &lt;-&gt; b = true</code> direction, and another for the <code>b = decide p</code> direction. There could be a <code>@[boolify]</code> attribute that validates a lemma and adds both versions to the simp sets.)</li>\n<li><code>reflect_unfold</code> that uses the <code>propify</code>/<code>boolify</code> machinery. It (1) locates the definition to unfold, (2) uses a <code>@[boolify]</code> lemma on it if one exists, and otherwise generates one from a <code>Decidable</code> instance, (3) unfolds what it sees, then (4) applies <code>propify</code>.</li>\n</ol>\n<p>Maybe the <code>reflect_unfold</code> tactic could also be provided an explicit <code>@[boolify]</code> theorem for performing the unfolding.</p>",
        "id": 429459178,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711384428
    },
    {
        "content": "<p><code>#reflect</code> could work by taking the equation lemmas for a particular boolean definition or decidable instance and then <code>propify</code> them.</p>\n<p>This all seems to be similar to what your library is doing, but having dedicated <code>propify</code> and <code>boolify</code> tactics would be very useful. Especially now that there are many library functions that take <code>Bool</code>-valued functions rather than decidable predicates (for example, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.all#doc\">docs#List.all</a>), and now that there is a <code>BEq</code> class in addition to the <code>DecidableEq</code> class.</p>",
        "id": 429460783,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711384761
    },
    {
        "content": "<p>Thanks for your clarifications! I generally feel inclined towards your suggestions, and I suspect that this framework can indeed be designed in terms of <code>Decidabe</code> using more advanced tricks with <code>simp</code>. However, I still have a couple of concerns.</p>",
        "id": 429542237,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711419177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429454470\">said</a>:</p>\n<blockquote>\n<p>Regarding needing simp lemmas to push propagate <code>decide</code>, yeah, that would be what is required for <code>reflect_unfold</code>. In Lean you can create \"simp sets\" of lemmas, which can be added to by the user, and there could be a simp set for pushing <code>decide</code> into an expression. This can be a much more powerful approach than relying on typeclass resolution. In fact, there are now simprocs, so users could add arbitrary transformations to this simp set. (When I referred to <code>norm_cast</code>, that's part of a pair of tactics that pushes or pulls coercions into or out of an expression. It's driven by simp sets. Pushing <code>decide</code> into expressions seems similar.)</p>\n</blockquote>\n<p>At this point, it would be interesting to see an example when <code>somprocs</code> can give more than type classes do in the scope of boolean/propositional reflection</p>",
        "id": 429542397,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711419308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429459178\">said</a>:</p>\n<blockquote>\n<p>This seems like a possible framework:</p>\n<ol>\n<li><code>propify</code> and <code>boolify</code> to translate a statement to and from <code>Prop</code> and <code>Bool</code>, driven by simp sets (and perhaps the <code>Reflect</code> class). These could be aware of <code>decide</code>. The simp sets could be full of rw-style theorems like <code>p &lt;-&gt; b = true</code> to drive the translation. (It would need two simp sets, one for the <code>p &lt;-&gt; b = true</code> direction, and another for the <code>b = decide p</code> direction. There could be a <code>@[boolify]</code> attribute that validates a lemma and adds both versions to the simp sets.)</li>\n<li><code>reflect_unfold</code> that uses the <code>propify</code>/<code>boolify</code> machinery. It (1) locates the definition to unfold, (2) uses a <code>@[boolify]</code> lemma on it if one exists, and otherwise generates one from a <code>Decidable</code> instance, (3) unfolds what it sees, then (4) applies <code>propify</code>.</li>\n</ol>\n<p>Maybe the <code>reflect_unfold</code> tactic could also be provided an explicit <code>@[boolify]</code> theorem for performing the unfolding.</p>\n</blockquote>\n<p>I wonder what would be situations where we need to use <code>@[boolify]</code> and <code>@[propify]</code> except translating boolean reduction principles to prop? I mean, assume we have already proven reflect statements for all our predicates. Then why would even use boolean representations again? Can't we just formulate everything in terms of those propositional representations? <br>\nAnd if we formulate everything, in terms of propositional predicates, do we need to “boolify” or “porpify” anything at all?</p>",
        "id": 429543042,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711419859
    },
    {
        "content": "<p>One more thing. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429459178\">said</a>:</p>\n<blockquote>\n<p>This seems like a possible framework:</p>\n<ol>\n<li><code>propify</code> and <code>boolify</code> to translate a statement to and from <code>Prop</code> and <code>Bool</code>, driven by simp sets (and perhaps the <code>Reflect</code> class). These could be aware of <code>decide</code>. The simp sets could be full of rw-style theorems like <code>p &lt;-&gt; b = true</code> to drive the translation. (It would need two simp sets, one for the <code>p &lt;-&gt; b = true</code> direction, and another for the <code>b = decide p</code> direction. There could be a <code>@[boolify]</code> attribute that validates a lemma and adds both versions to the simp sets.)</li>\n<li><code>reflect_unfold</code> that uses the <code>propify</code>/<code>boolify</code> machinery. It (1) locates the definition to unfold, (2) uses a <code>@[boolify]</code> lemma on it if one exists, and otherwise generates one from a <code>Decidable</code> instance, (3) unfolds what it sees, then (4) applies <code>propify</code>.</li>\n</ol>\n<p>Maybe the <code>reflect_unfold</code> tactic could also be provided an explicit <code>@[boolify]</code> theorem for performing the unfolding.</p>\n</blockquote>\n<p>This is really similar to the approach people are using in general proofs by reflection in Coq. The idea is exactly the same: </p>\n<ol>\n<li>we find an expression that we want to solve/simplify (for example <code>p</code>)</li>\n<li>we change its representation to the more convenient one (<code>p</code> → <code>decide p = true</code>)</li>\n<li>then we use some ad-hoc machinery to reason about the convenient representation (simplify <code>decide p</code> using simp sets)<br>\nThere are a bunch of Coq Reflection papers and books: chapter 15 at <a href=\"http://adam.chlipala.net/cpdt/cpdt.pdf\">CPDT</a>, ITP14 <a href=\"http://adam.chlipala.net/papers/MirrorShardITP14/MirrorShardITP14.pdf\">paper</a>, <a href=\"https://pure.itu.dk/ws/portalfiles/portal/81631209/rtac_esop16.pdf\">Rtac</a> framework for Coq. </li>\n</ol>\n<p>I strongly believe that the approach you are suggesting would be a nice alternative to the line of work on reflective proofs done in Coq. I am happy to take this discussion offline and see if we can do better in Lean with these regards.</p>",
        "id": 429544583,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711421099
    },
    {
        "content": "<p>You can have a look at 15.3 chapter of CPDT to see a good non <code>prop</code>/<code>bool</code> example of reflective proof.</p>",
        "id": 429544853,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711421304
    },
    {
        "content": "<p>Actually, general reflective proofs in Lean are something I was planning to look at in the nearest future. In particular, I am interested in program verification via reflection.</p>",
        "id": 429545264,
        "sender_full_name": "Vladimir Gladstein",
        "timestamp": 1711421623
    },
    {
        "content": "<p>I am jumping in this discussion quite late and I apologize in advance for the long post.  Indeed, LeanSSR is really cool! Like <span class=\"user-mention\" data-user-id=\"702586\">@Ilya Sergey</span> , I also find it cooler than the original ssreflect on the fragment it implements. And this is yet another example of how neat metaprogramming in Lean is.</p>",
        "id": 429754350,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711494837
    },
    {
        "content": "<p>Now I will also react to some points raised earlier in the thread.</p>",
        "id": 429754448,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711494884
    },
    {
        "content": "<p>As already emphasized, <code>ssreflect</code>  should not be confused with its characteristic choices of syntax, as characteristic and debatable as they can be. These choices could have been different, provided they satisfy the constraints of \"compositionality\" and the collection of features it provides.</p>",
        "id": 429754625,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711494975
    },
    {
        "content": "<p>The distinguishing features  of <code>ssreflect</code> are what make people adopt the language, as whole or only for a specific selection of these features. I am pretty sure a vast majority of the users would be perfectly fine with a different syntax, provided the features remain. And, as for any tactic language, the design of these features proceeds from the combination of several objectives.</p>",
        "id": 429754680,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711495013
    },
    {
        "content": "<p>Some are specific to certain formalization methodologies, e.g., small scale reflection in the case of <code>ssreflect</code>. Defining (small-scale) reflection, illustrating its benefits and evaluating whether or not lean/mathlib would benefit from additional support for this a question I am leaving aside for now, despite the title of the topic.</p>",
        "id": 429754781,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711495068
    },
    {
        "content": "<p>Other objectives are quite universal I guess, typically striving to provide appropriate tools for producing robust scripts, easy to maintain over time. At least, this point is also obviously taken very seriously by the mathlib community. And this was another of the  main concerns guiding the design of <code>ssreflect</code>. Robustness here refers both to changes in the proofs / dependencies but also in the behavior of the proof assistant itself.  The formal proof of the four color theorem is more than 20 year old, the one of the Odd Order theorem (including a large chunk of what is called today Mathematical Components) is more than 10 years old. Meanwhile, Coq has changed <strong>a lot</strong> ,  and the libraries have also of course evolved significantly. Yet the maintenance effort is really very minimal in terms of manpower.</p>",
        "id": 429755051,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1711495212
    },
    {
        "content": "<p>37 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/ssreflect.20idioms.20in.20Lean\">#general &gt; ssreflect idioms in Lean</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 429758081,
        "sender_full_name": "Notification Bot",
        "timestamp": 1711497125
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"100006\">Notification Bot</span> <a href=\"#narrow/stream/113488-general/topic/Small.20Scale.20Reflection.20for.20the.20Working.20Lean.20user/near/429758081\">said</a>:</p>\n<blockquote>\n<p>37 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/ssreflect.20idioms.20in.20Lean\">#general &gt; ssreflect idioms in Lean</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>\n</blockquote>\n<p>This link seems inaccessible. I was able to click on it and read the discussion about various <code>conv</code> patterns by Eric and Mario once, but the entire conversation seems to have disappeared.</p>",
        "id": 429876036,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711550537
    },
    {
        "content": "<p>I think it is <a href=\"#narrow/stream/113488-general/topic/subterm.20selection/near/429755191\">here</a> .</p>",
        "id": 429876573,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711550671
    },
    {
        "content": "<p>Thanks :)</p>",
        "id": 429877067,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1711550795
    }
]