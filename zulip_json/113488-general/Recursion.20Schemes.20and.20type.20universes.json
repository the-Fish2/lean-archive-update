[
    {
        "content": "<p>Hi. As an exercise I'm trying to do some basic recursion schemes  but immediately ran into problems with type universes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkMu</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cata</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Mu</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">alg</span> <span class=\"o\">(</span><span class=\"n\">Mu.mkMu</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">alg</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">f</span> <span class=\"n\">alg</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">alg</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">f</span><span class=\"bp\">✝</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">f</span><span class=\"bp\">✝</span> <span class=\"n\">α</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n</code></pre></div>\n<p>I dont have much experience dealing with type universes.  How would I go about fixing this code?</p>",
        "id": 424716544,
        "sender_full_name": "Solomon",
        "timestamp": 1709575964
    },
    {
        "content": "<p>This error doesn't seem to have to do with type universes at all! Your code is doing something confusing where you have two variables named <code>f</code>. I'll rename one of them to <code>g</code> and replace all of the universe parameters with just <code>Type</code> so we can talk about this code more easily:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkMu</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cata</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Mu</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">alg</span> <span class=\"o\">(</span><span class=\"n\">Mu.mkMu</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">alg</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>application type mismatch\n  g alg\nargument\n  alg\nhas type\n  f α → α : Type\nbut is expected to have type\n  f α✝ : Type\n</code></pre></div>",
        "id": 424719087,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709576853
    },
    {
        "content": "<p>The error is that the expression <code>g alg</code> doesn't make sense because <code>alg</code> is not the right type to be an argument to the function <code>g</code></p>",
        "id": 424719327,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709576953
    },
    {
        "content": "<p>Oh thats silly of me. I made a mistake in my definition of <code>Mu</code>.  It should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkMu</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cata</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">alg</span> <span class=\"o\">(</span><span class=\"n\">Mu.mkMu</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g</span> <span class=\"n\">alg</span>\n</code></pre></div>\n<p>Which gives me the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">g</span> <span class=\"n\">alg</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">alg</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"bp\">✝</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is this just an issue of Lean not knowing that <code>max</code> is commutative?</p>",
        "id": 424727465,
        "sender_full_name": "Solomon",
        "timestamp": 1709579812
    },
    {
        "content": "<p>It's still not about universes :). The important difference here is between <code>α</code> and <code>α✝</code>. I'll explain where <code>α✝</code> comes from.</p>\n<p>When you write <code>fun alg (Mu.mkMu g) =&gt;</code> you're pattern matching on the constructor <code>Mu.mkMu</code> which takes three arguments, <code>f</code>, <code>α</code> and <code>g</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">Mu.mkMu</span>\n<span class=\"c1\">-- Mu.mkMu.{u, v} {f : Type u → Type v} {α : Type u} (g : (f α → α) → α) : Mu f</span>\n</code></pre></div>\n<p><code>g</code> is included in your pattern because it's the only explicit argument, but the first two, <code>f</code> and <code>α</code> are implicit. <code>f</code> is fully determined by the type <code>Mu f</code>, but this value of <code>α</code> that was passed to <code>Mu.mkMu</code> to construct a <code>Mu f</code> could be anything. Since you're not explicitly giving it a name, it enters your local context as an inaccessible variable <code>α✝</code>. You can see the full local context to verify this by replacing your code with an <code>_</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cata</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Functor</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">alg</span> <span class=\"o\">(</span><span class=\"n\">Mu.mkMu</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">_</span>\n<span class=\"c1\">-- context:</span>\n<span class=\"c1\">-- f: Type u → Type v</span>\n<span class=\"c1\">-- α: Type u</span>\n<span class=\"c1\">-- inst✝: Functor f</span>\n<span class=\"c1\">-- alg: f α → α</span>\n<span class=\"c1\">-- x✝: Mu f</span>\n<span class=\"c1\">-- α✝: Type u</span>\n<span class=\"c1\">-- g: (f α✝ → α✝) → α✝</span>\n<span class=\"c1\">-- ⊢ α</span>\n</code></pre></div>",
        "id": 424732211,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709580473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"500038\">@Timo Carlin-Burns</span> Thanks for the explanation! It took me a while but I finally made it through this implementation and got it to evaluate:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>  <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkMu</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cata</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">alg</span> <span class=\"o\">(</span><span class=\"n\">Mu.mkMu</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">α</span> <span class=\"n\">alg</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ListF</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nilF</span> <span class=\"o\">:</span> <span class=\"n\">ListF</span> <span class=\"n\">α</span> <span class=\"n\">r</span>\n  <span class=\"bp\">|</span> <span class=\"n\">consF</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tail</span> <span class=\"o\">:</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ListF</span> <span class=\"n\">α</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">nil</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Mu.mkMu</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">alg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">alg</span> <span class=\"n\">ListF.nilF</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">Mu.mkMu</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Mu.mkMu</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">alg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">alg</span> <span class=\"o\">(</span><span class=\"n\">ListF.consF</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"n\">t</span> <span class=\"n\">alg</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ex</span> <span class=\"o\">:</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">cons</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">False</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">True</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"n\">Bool</span><span class=\"o\">)))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">len_algebra</span> <span class=\"o\">:</span> <span class=\"n\">ListF</span> <span class=\"n\">α</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ListF.nilF</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">ListF.consF</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">len</span> <span class=\"o\">:</span> <span class=\"n\">Mu</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cata</span> <span class=\"n\">len_algebra</span> <span class=\"n\">xs</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">len</span> <span class=\"n\">ex</span>\n</code></pre></div>\n<p>This is a lot tricker then in Haskell but I learned a lot.</p>",
        "id": 424800888,
        "sender_full_name": "Solomon",
        "timestamp": 1709618233
    },
    {
        "content": "<p>I can do <code>Nu</code> and <code>ana</code> easily enough:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Nu</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mkNu</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nu</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ana</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nu</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">coalg</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nu.mkNu</span> <span class=\"n\">α</span> <span class=\"n\">coalg</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list_coalg</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">ListF</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ListF.nilF</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ListF.consF</span> <span class=\"n\">i</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list_builder</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nu</span> <span class=\"o\">(</span><span class=\"n\">ListF</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ana</span> <span class=\"n\">list_coalg</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>But then the problem becomes how can I fold <code>Nu f</code> into some other functor (such as <code>List Nat</code> for my <code>list_builder</code> example). Is it possible to write <code>cata</code> for <code>Nu</code> and <code>ana</code> for <code>Mu</code> in this setting? In haskell we take advantage of explicit recursion or a <code>hylomorphism</code> to do that.</p>\n<p>And what about <code>Fix</code>? Is it possible to write <code>Fix</code>? I haven't made any progress on it.</p>",
        "id": 424805443,
        "sender_full_name": "Solomon",
        "timestamp": 1709621164
    }
]