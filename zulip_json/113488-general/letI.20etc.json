[
    {
        "content": "<p>Q) Why does <code>refl</code> fail to finish the proof of <code>Spv.refl</code> in the code below? </p>\n<p>I am about to write a bunch of API for a type <code>Spv</code> and I am going to have to get the hang of <code>letI</code>, <code>exactI</code> etc. I feel like my understanding of type class inference is now better than it was, and that I could do with a clearer picture of what is going on. Here's some documented minimised fully working code. Writing it has made me understand stuff better but I don't see why <code>refl</code> fails below.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">bounded_lattice</span> <span class=\"c1\">-- for with_bot</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"c1\">-- what I need from with_bot</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">with_bot</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- hΓ : partial_order Γ</span>\n  <span class=\"c1\">-- but presumably type class inference doesn&#39;t know this yet.</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now it does</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- v0 r : with_bot Γ</span>\n  <span class=\"c1\">-- ⊢ v0 r ≤ v0 r, and this ≤ is coming direct from hΓ and the</span>\n  <span class=\"c1\">-- instance in the example above.</span>\n\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  refl, -- fails!</span>\n\n<span class=\"cm\">  invalid apply tactic, failed to unify</span>\n<span class=\"cm\">  v0 r ≤ v0 r</span>\n<span class=\"cm\">with</span>\n<span class=\"cm\">  ∀ [_inst_1 : preorder ?m_1] (a : ?m_1), a ≤ a</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- version without with_bot</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valuation&#39;</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spv&#39;</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation&#39;</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Spv&#39;</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv&#39;</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Don&#39;t even need letI</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- refl must now have worked</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>So there are two variants of a reflexivity proof. Let me talk through the code.</p>\n<p>In the definition of Spv there is an inequality <code>v r ≤ v s</code> which, to make sense, relies on finding a preorder on <code>with_bot Γ</code>. The <code>by exactI</code> must be doing this. But it seems to me that what must be happening in practice is that the term generated by the definition of <code>Spv</code> must be plugging the partial order on <code>with_bot  Γ</code> directly in, rather than saying \"oh, we will deal with this using type class inference\". Maybe this is how fully elaborated terms always work -- this is just dawning on me now as I write, I guess.</p>\n<p>So in practice I am going to be writing a bunch of <code>letI := hΓ</code>'s in my code I think. In the proof of <code>Spv.refl</code>, I do this.</p>\n<p>But why does <code>refl</code> fail to finish the proof of Spv.refl? </p>\n<p>Type class inference isn't finding the pre-order on <code>with_bot Γ</code>, even though I thought I inserted the partial order on <code>Γ</code> as early as I could.</p>",
        "id": 159987835,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551777478
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exactI</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"c1\">-- works</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p><code>exactI</code> also works. What does <code>exactI</code> do? I understand <code>letI</code> and <code>haveI</code>.</p>",
        "id": 159987938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551777569
    },
    {
        "content": "<p>Independent issue:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">invalid binary relation declaration, relation &#39;reflexive&#39; must have two explicit parameters</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>??</p>",
        "id": 159988510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551778184
    },
    {
        "content": "<p>Do you know about <code>resetI</code>? <code>resetI</code> means \"make everything in the context available for type class resolution\". Of course things \"to the left of the colon\" were already available, so the point is to add things bound by a lambda, or by <code>rcases</code>, etc.--in particular your <code>hΓ</code>, I'm guessing.<br>\n<code>exactI</code> is <code>resetI</code> followed by <code>exact</code>.</p>",
        "id": 160024356,
        "sender_full_name": "Reid Barton",
        "timestamp": 1551808619
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">bounded_lattice</span> <span class=\"c1\">-- for with_bot</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u₀</span> <span class=\"n\">u₁</span>\n\n<span class=\"c1\">-- what I need from with_bot</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">valuation</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">with_bot</span> <span class=\"err\">Γ</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">Spv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">ineq</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"bp\">//</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"err\">Γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"err\">Γ</span><span class=\"o\">],</span>\n <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">valuation</span> <span class=\"n\">R</span> <span class=\"err\">Γ</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">ineq</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">Spv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Spv</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">reflexive</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"err\">Γ</span><span class=\"o\">,</span> <span class=\"n\">v0</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">v0</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">with_bot</span> <span class=\"err\">Γ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">v0</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"c1\">-- fails</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  invalid apply tactic, failed to unify</span>\n<span class=\"cm\">  v0 r ≤ v0 r</span>\n<span class=\"cm\">with</span>\n<span class=\"cm\">  ∀ [_inst_1 : preorder ?m_1] (a : ?m_1), a ≤ a</span>\n<span class=\"cm\">state:</span>\n<span class=\"cm\">R : Type u₀,</span>\n<span class=\"cm\">v : Spv R,</span>\n<span class=\"cm\">r : R,</span>\n<span class=\"cm\">Γ : Type u₀,</span>\n<span class=\"cm\">hΓ : partial_order Γ,</span>\n<span class=\"cm\">v0 : valuation R Γ,</span>\n<span class=\"cm\">h : ∀ (r s : R), v0 r ≤ v0 s ↔ v.val r s,</span>\n<span class=\"cm\">_inst : preorder (with_bot Γ) := partial_order.to_preorder (with_bot Γ)</span>\n<span class=\"cm\">⊢ v0 r ≤ v0 r</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 160025024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551809141
    },
    {
        "content": "<p>It just seems to be an issue with <code>refl</code>. <code>exact le_refl _</code> works fine.</p>",
        "id": 160025595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551809616
    },
    {
        "content": "<p>The issue with <code>attribute [refl] Spv.refl</code> is that the type of <code>Spv.refl</code> isn't asserting reflexivity of anything, it's proving <code>reflexive bla</code>. Lean is expecting a proof of <code>my_rel bla x x</code></p>",
        "id": 160028328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811323
    },
    {
        "content": "<p>I think if you just unfold <code>reflexive</code> in the statement lean will accept it... but then the relation you are proving reflexive is <code>subtype.val</code> which is a bit weird</p>",
        "id": 160028461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811386
    },
    {
        "content": "<p>You should probably hide the implementation details of <code>Spv</code> by using something other than <code>.1</code> to extract the relation from an Spv</p>",
        "id": 160028596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811457
    },
    {
        "content": "<p>like define <code>Spv.rel : Spv R -&gt; R -&gt; R -&gt; Prop := subtype.val</code> and then you can prove <code>Spv.refl : Spv.rel v x x</code> and mark it <code>@[refl]</code></p>",
        "id": 160028717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1551811546
    },
    {
        "content": "<p>I have two questions about <code>letI</code>, one about its syntax and one about the docs. First of all, how can I use <code>letI</code> in term mode? Suppose I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span> <span class=\"bp\">-</span><span class=\"kd\">instance</span> <span class=\"o\">]</span> <span class=\"n\">instInhabitedNat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inHab</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">37</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">inHab</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>The exampe could be closed by <code>infer_instance</code>, but I keep it in this way for the purpose of the question, since I would like to write it in term mode as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span><span class=\"o\">⟩</span> <span class=\"c1\">-- it does not work of course</span>\n</code></pre></div>\n<p>and I do not know how to pass the <code>letI</code>.</p>\n<p>Second question: the docs for <code>letI</code> is \"<code>letI</code> behaves like <code>let</code>, but inlines the value instead of producing a <code>let_fun</code> term.\" I have always thought that the <code>I</code> in <code>letI</code> (and <code>haveI</code>) were for \"instance\", but I now wonder whether they stand for \"inline\" and, more generally, if the doc is correct or if it should not contain a reference to the fact that it creates a local instance (perhaps <em>this is what it is saying</em>, but then it seems obscure).</p>",
        "id": 422792635,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708599686
    },
    {
        "content": "<p>Would this be good for you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">inHab</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 422793814,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708600098
    },
    {
        "content": "<p>AFAIU, the meaning of the \"I\" changed from Lean 3 to Lean 4.</p>",
        "id": 422793925,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1708600149
    },
    {
        "content": "<p>I guess that it works also with <code>where</code> syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">default</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">inHab</span>\n    <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span>\n</code></pre></div>",
        "id": 422793948,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708600158
    },
    {
        "content": "<p>Also, yes, <code>I</code> now stands for <code>inline</code>, not anymore for <code>instance</code>, I think.</p>",
        "id": 422794188,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708600224
    },
    {
        "content": "<p>And what does it mean?</p>",
        "id": 422794288,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708600257
    },
    {
        "content": "<p>BTW: Yes, your syntax works, but if the structure has more than one field, should I repeat the <code>let _ :=</code> in each of them? If working in tactic mode, I could call <code>let/letI</code> at the beginning, and it would be in scope for every proof of all fields.</p>",
        "id": 422794501,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708600339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/letI.20etc/near/422793814\">said</a>:</p>\n<blockquote>\n<p>Would this be good for you?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">inHab</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Well, no, the whole point was to use <code>where</code> (but your second answer is OK)</p>",
        "id": 422794614,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708600377
    },
    {
        "content": "<p>If you want to use <code>where</code> with multi-field instances, I can offer this -- not sure if you like it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">local</span> <span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">inHab</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n  <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">default</span>\n</code></pre></div>",
        "id": 422795165,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708600596
    },
    {
        "content": "<p>Another option:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">inHab</span>\n  <span class=\"o\">{</span> <span class=\"n\">default</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">default</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 422801817,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708603307
    },
    {
        "content": "<p><code>where</code> notation only works as a replacement for <code>def foo := { ... }</code> not <code>def foo := let x := y; { ... }</code></p>",
        "id": 422801912,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708603331
    },
    {
        "content": "<p>But in your snippet you have no <code>{</code></p>",
        "id": 422801988,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603366
    },
    {
        "content": "<p>I mean, not around <code>let</code></p>",
        "id": 422802013,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603377
    },
    {
        "content": "<p>Yes, that wouldn't make any sense</p>",
        "id": 422802032,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708603387
    },
    {
        "content": "<p>Ah, but you do not have <code>where</code></p>",
        "id": 422802054,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603394
    },
    {
        "content": "<p>I see!</p>",
        "id": 422802056,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603396
    },
    {
        "content": "<p>And what is the theoretical advantage of allowing both <code> :=</code> and <code>where</code>?</p>",
        "id": 422802131,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603433
    },
    {
        "content": "<p>I mean, from the point of view of designing lean syntax</p>",
        "id": 422802202,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603452
    },
    {
        "content": "<p>Same as allowing both <code>HMul.hMul</code> and <code>*</code>; one looks nicer, but doesn't always work</p>",
        "id": 422802222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708603462
    },
    {
        "content": "<p>(<a href=\"https://eric-wieser.github.io/lftcm-2023/#/defining-structures/1\">https://eric-wieser.github.io/lftcm-2023/#/defining-structures/1</a> has examples of all the way to make structure terms)</p>",
        "id": 422802274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708603488
    },
    {
        "content": "<p>The one that \"looks nicer\"  here is supposedly <code>where</code>, right?</p>",
        "id": 422802287,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603495
    },
    {
        "content": "<p><code>where</code> also lets you write <code>someFun x y := x + y</code> instead of <code>someFun := fun x y =&gt; x + y</code></p>",
        "id": 422802357,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708603527
    },
    {
        "content": "<p>This <em>is</em> nicer, agreed!</p>",
        "id": 422802440,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603559
    },
    {
        "content": "<p>Just to explain why I insisted on <code>where</code>: this is because it is the syntax the blue bulb in VSCode turns <code>:=</code> to when asking for help, and I would like to have a way to say \"thanks, what you suggest is OK, <em>provided I pass you this instance</em>\".</p>",
        "id": 422802938,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708603738
    },
    {
        "content": "<p>If you write the <code>let</code> first, then the blue bulb will insert <code>{}</code> instead</p>",
        "id": 422804270,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708604234
    },
    {
        "content": "<p>That is, write <code>let _ := inHab</code> then <code>_</code> on the next line</p>",
        "id": 422804318,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708604251
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 422804381,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1708604279
    },
    {
        "content": "<p>I can't remember if I demoed that at the end of the recorded version of that talk (on youtube)</p>",
        "id": 422805154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708604559
    }
]