[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"695413\">@Christoph Spiegel</span> and I want to get <code>{x ∈ s | p x}</code> notation to work for finsets. I have managed to write the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Finset</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 428137076,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711029972
    },
    {
        "content": "<p>However I have little idea how to actually reuse the same notation as for sets, because I need to reason about the expected type to decide whether it should elaborate as the set or finset notation.</p>",
        "id": 428137365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711030041
    },
    {
        "content": "<p>Is it not possible to update L106 in <code>Mathlib.Init.Set</code>?</p>",
        "id": 428137809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711030149
    },
    {
        "content": "<p>As in: what exactly is the problem you are hitting that you can solve with <code>[]</code> but not with <code>{}</code>.</p>",
        "id": 428137884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711030174
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/5befdcb9964fec0dd865b9ff6aa79dfe8bcc9d5d/Mathlib/Init/Set.lean#L106\">https://github.com/leanprover-community/mathlib4/blob/5befdcb9964fec0dd865b9ff6aa79dfe8bcc9d5d/Mathlib/Init/Set.lean#L106</a> ?</p>",
        "id": 428138438,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711030326
    },
    {
        "content": "<p>Yeah, I basically meant L100-L130 or so.</p>",
        "id": 428138723,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711030412
    },
    {
        "content": "<p>The problem I'm hitting if I do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is that the finset notation always takes over the set notation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- failed to synthesize instance Fintype α</span>\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- failed to synthesize instance Fintype α</span>\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"c1\">-- application type mismatch ...</span>\n</code></pre></div>",
        "id": 428138832,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711030441
    },
    {
        "content": "<p>Ooh, I guess it starts even higher up</p>",
        "id": 428138849,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711030443
    },
    {
        "content": "<p>And why is that not happening if you use <code>[]</code>?</p>",
        "id": 428139055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711030499
    },
    {
        "content": "<p>because set notation uses <code>{}</code>!</p>",
        "id": 428139117,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711030513
    },
    {
        "content": "<p>Ooh, the <code>[]</code> that you set up only works for finsets? I see.</p>",
        "id": 428139183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711030531
    },
    {
        "content": "<p>You could use <code>{ᶠ ... }</code> perhaps?</p>",
        "id": 428140412,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711030859
    },
    {
        "content": "<p>Michael, my post is an elaborate way to lure Mario into giving me a five lines long solution <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 428140589,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711030906
    },
    {
        "content": "<p>Of course Lean can do what I want it to. I just don't know how</p>",
        "id": 428140657,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711030922
    },
    {
        "content": "<p>(My solution is no extra lines...)</p>",
        "id": 428141911,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711031189
    },
    {
        "content": "<p>(and I would not find it so bad to distinguish the two variants in the notation; then I don't have to annotate the type when it would be ambiguous...)</p>",
        "id": 428142078,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711031230
    },
    {
        "content": "<p>Related topic: <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/How.20to.20turn.20a.20macro_rules.20into.20an.20elab\">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/How.20to.20turn.20a.20macro_rules.20into.20an.20elab</a></p>",
        "id": 428147463,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711032513
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Finset</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">filter (fun x =&gt; p x) univ : Finset α</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">filter (fun x =&gt; p x) univ : Finset α</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">filter (fun x =&gt; p x) s : Finset α</span>\n<span class=\"cm\">-/</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 428150428,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711033217
    },
    {
        "content": "<p>What is the difference with the original version posted by <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> at the top of the thread?</p>",
        "id": 428151483,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1711033482
    },
    {
        "content": "<p>I asked Damiano to write an <code>elab</code> version so that I could add some type inference logic!</p>",
        "id": 428151728,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711033546
    },
    {
        "content": "<p>Oh, when I first copy pasted Yaël's code, it gave me an error, so I thought that I \"fixed\" it!</p>",
        "id": 428151856,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711033566
    },
    {
        "content": "<p>Okay, so now the question is \"How do I get the expected type of <code>x</code> (in the first branch say)?\"</p>",
        "id": 428152546,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711033733
    },
    {
        "content": "<p>This feels harder and hackier than it should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Finset</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">q</span> <span class=\"bp\">$</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">q</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">default</span>\n    <span class=\"k\">let</span> <span class=\"n\">pexpr</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">q</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">ptype</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">pexpr</span>\n    <span class=\"k\">let</span> <span class=\"n\">alpha</span> <span class=\"o\">:=</span> <span class=\"n\">ptype.bindingDomain</span><span class=\"bp\">!</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"alpha is '{(← ppExpr alpha)}'\"</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"c1\">-- alpha is 'α'</span>\n</code></pre></div>",
        "id": 428159754,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711035692
    },
    {
        "content": "<p>I want it to output <code>Finset α</code>, not <code>α</code>, but probably I can take it from there. Thanks!</p>",
        "id": 428165679,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711037252
    },
    {
        "content": "<p>Ah, I misunderstood and indeed this is also easier (and <code>alpha</code> would be easier to get from here as well):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">fins</span> <span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n    <span class=\"k\">let</span> <span class=\"n\">finsetAlpha</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">fins</span>\n    <span class=\"n\">dbg_trace</span> <span class=\"s2\">\"Finset alpha is '{(← ppExpr finsetAlpha)}'\"</span>\n    <span class=\"n\">return</span> <span class=\"n\">fins</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"c1\">-- Finset alpha is 'Finset α'</span>\n</code></pre></div>",
        "id": 428167008,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711037607
    },
    {
        "content": "<p>Actually, I suspect this code snippet by Kyle does exactly what I want: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11563/files#diff-c49941209a153c2b638b70e148fff6528420d9dea000c98cee662ec5199d391cR1343-R1350\">https://github.com/leanprover-community/mathlib4/pull/11563/files#diff-c49941209a153c2b638b70e148fff6528420d9dea000c98cee662ec5199d391cR1343-R1350</a></p>",
        "id": 428167316,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711037681
    },
    {
        "content": "<p>It is more refined than your version in the sense that it elaborates <code>(s : Finset (?α : Sort ?u))</code> and checks what the resulting type is, where <code>s</code> is the set/finset created by the notation.</p>",
        "id": 428168007,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711037874
    },
    {
        "content": "<p>Hmm, okay, now I need to think about the details. What do we want <code>{x ∈ s | p x}</code> to elaborate to without an expected type?</p>",
        "id": 428169317,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038206
    },
    {
        "content": "<p>How do I access the expected type of the term my <code>elab_rules</code> is replacing?</p>",
        "id": 428169609,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038292
    },
    {
        "content": "<p>The problem is that I'm destructing it, so I don't have access to it anymore</p>",
        "id": 428170106,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038435
    },
    {
        "content": "<p>In the example above, what do you expect to see?</p>",
        "id": 428170172,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711038459
    },
    {
        "content": "<p>I don't think your example captures what I mean</p>",
        "id": 428170415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038526
    },
    {
        "content": "<p>The way I understand this, is that <code>elab_rules</code> creates a meaning for something.  The something does not have a prior meaning necessarily, though.</p>",
        "id": 428170658,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711038597
    },
    {
        "content": "<p>Consider Kyle's elaborator: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11563/files#diff-c49941209a153c2b638b70e148fff6528420d9dea000c98cee662ec5199d391cR1342-R1350\">https://github.com/leanprover-community/mathlib4/pull/11563/files#diff-c49941209a153c2b638b70e148fff6528420d9dea000c98cee662ec5199d391cR1342-R1350</a></p>",
        "id": 428170780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038623
    },
    {
        "content": "<p><code>t</code> there is our <code>([ $x:ident | $p ])</code>. Kyle can figure out what the expected type is, but we can't because we have destructed <code>t</code></p>",
        "id": 428170920,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038675
    },
    {
        "content": "<p>This is what I eventually want, I think</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>                  <span class=\"c1\">-- `{x | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>        <span class=\"c1\">-- `{x | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>     <span class=\"c1\">-- `Finset.univ.filter fun x ↦ p x : Finset α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>              <span class=\"c1\">-- `s.filter fun x ↦ p x : Finset α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"c1\">-- `s.filter fun x ↦ p x : Finset α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>    <span class=\"c1\">-- `{x ∈ s | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>              <span class=\"c1\">-- `{x : α | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>    <span class=\"c1\">-- `{x : α | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"c1\">-- `Finset.univ.filter fun x : α ↦ p x : Finset α`</span>\n</code></pre></div>",
        "id": 428171323,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038796
    },
    {
        "content": "<p>So you see I want the result to depend on what the <em>expected type of the notation</em> is</p>",
        "id": 428171595,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711038873
    },
    {
        "content": "<p>I think that you get access to the global syntax using <code>let r ← getRef</code>, but I think that the whole syntax needs to have a meaning already.  I.e., in the situation above, you probably cannot get Lean to elaborate the whole syntax.</p>",
        "id": 428172491,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039146
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"k\">in</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"bp\">|</span> <span class=\"o\">[</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">getRef</span>\n    <span class=\"n\">logInfo</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"I am the whole syntax: '{r}'\"</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"c1\">-- I am the whole syntax: '[x | p x]'</span>\n</code></pre></div>",
        "id": 428173393,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039397
    },
    {
        "content": "<p>I see that <code>getRef</code> gives me a <code>Syntax</code>. I assume this doesn't have expected type information?</p>",
        "id": 428173870,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711039526
    },
    {
        "content": "<p>Actually... how do I get the expected type of <em>anything</em>?</p>",
        "id": 428174069,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711039574
    },
    {
        "content": "<p>No, it is just the syntax that you are processing currently.  What I suspect should happen is that you first write the <code>elab_rules</code> for all the syntaxes that you want and then you build on top of those something that elaborates the syntax with the previous elabs and then you divert it to what you want.</p>",
        "id": 428174164,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039611
    },
    {
        "content": "<p>Otherwise, syntax by itself does not elaborate to anything: it is simply an inductive type.</p>",
        "id": 428174226,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039629
    },
    {
        "content": "<p>I'm not sure what your suggestion amounts to, concretely</p>",
        "id": 428174434,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711039696
    },
    {
        "content": "<p>Which I think is what Kyle's elaborator is doing: it is checking that the previous elaborators would give to that syntax and, depending on whether they already give a finset or not, it directs it to what he wants.</p>",
        "id": 428174458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/428174434\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what your suggestion amounts to, concretely</p>\n</blockquote>\n<p>I think that you first assign meaning to the <code>[...]</code> syntax in the simplest form, with the possibility of it being a <code>Set</code> or a <code>Finset</code>.  Next, you write another rule for the same syntax and, in the case in which it would have elaborated to a set, but you really wanted a finset, then you insert the <code>Set.toFinset</code> step, as Kyle does.</p>",
        "id": 428174777,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039807
    },
    {
        "content": "<p>Okay, but the problem here is that I have two overlapping elaborators. So what \"the previous elaborators would give to that syntax\" is meaningless. It will be whatever the latest elaborator I declare does.</p>",
        "id": 428174826,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711039825
    },
    {
        "content": "<p>I am not sure about this, but I think that you can use the previous elaborators to piggy-back the later ones.</p>",
        "id": 428174968,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039881
    },
    {
        "content": "<p>Sorry, I don't get it <span aria-label=\"frowning\" class=\"emoji emoji-1f626\" role=\"img\" title=\"frowning\">:frowning:</span></p>",
        "id": 428174989,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711039888
    },
    {
        "content": "<p>Let me try.</p>",
        "id": 428175014,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711039898
    },
    {
        "content": "<p>Ok, I think that you are right: you may need a separate syntax, like Kyle's.  In his context, he writes <code>finset% ...</code> and <code>...</code> has whatever meaning it acquires.  It might be useful to look at how the Set vs Finset overload is achieved, since it looks like this is what you would like.</p>",
        "id": 428175484,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711040032
    },
    {
        "content": "<p>What I suspect is happening is that <code>elab_rules</code> doesn't give me access to the expected type of the syntax it's replacing, so I need to go all the way to <code>elab</code></p>",
        "id": 428175796,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711040110
    },
    {
        "content": "<p>That is possible: <code>elab</code> is much more robust than <code>elab_rules</code>.</p>",
        "id": 428176339,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711040270
    },
    {
        "content": "<p>And I think that for anything other than very simple elaborators, <code>elab</code> should be preferred.</p>",
        "id": 428176475,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1711040301
    },
    {
        "content": "<p>Let me ask you this question again then <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> : <a href=\"#narrow/stream/239415-metaprogramming-.2F-tactics/topic/How.20to.20turn.20a.20macro_rules.20into.20an.20elab/near/428148216\">https://leanprover.zulipchat.com/#narrow/stream/239415-metaprogramming-.2F-tactics/topic/How.20to.20turn.20a.20macro_rules.20into.20an.20elab/near/428148216</a></p>",
        "id": 428176496,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711040308
    },
    {
        "content": "<p>@anyone writing the metaprogramming book, it would be sooo useful having a few examples showing how to replace</p>\n<ul>\n<li><code>infix</code>, <code>infixr</code>, <code>infixl</code> with <code>notation</code></li>\n<li><code>notation</code> with <code>macro_rules</code></li>\n<li><code>macro_rules</code> with <code>macro</code> or <code>elab_rules</code></li>\n<li><code>macro</code>, <code>elab_rules</code> with <code>elab</code></li>\n</ul>",
        "id": 428177346,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711040549
    },
    {
        "content": "<p><code>elab_rules</code> is not sugar for <code>elab</code>, the reverse is true: <code>elab</code> is sugar for <code>syntax</code> + <code>elab_rules</code></p>",
        "id": 428178408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711040901
    },
    {
        "content": "<p><code>elab_rules</code> is sugar for a definition with the <code>@[term_elab]</code> attribute</p>",
        "id": 428178501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711040936
    },
    {
        "content": "<p>and if you use this form you will get access to the expected type as a <code>Option Expr</code></p>",
        "id": 428178592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711040965
    },
    {
        "content": "<p>with <code>elab_rules</code> you can also get the expected type using the <code>&lt;= type</code> syntax, but it is not an <code>Option</code>, and it will basically force the elaborator to wait to call your elab until the expected type is known (think of notations like anonymous constructor brackets)</p>",
        "id": 428178840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711041046
    },
    {
        "content": "<p>Okay, so my only option is a <code>@[term_elab]</code> tagged definition. What does the argument to <code>term_elab</code> do?</p>",
        "id": 428179918,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711041410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/428178840\">said</a>:</p>\n<blockquote>\n<p>with <code>elab_rules</code> you can also get the expected type using the <code>&lt;= type</code> syntax, but it is not an <code>Option</code>, and it will basically force the elaborator to wait to call your elab until the expected type is known (think of notations like anonymous constructor brackets)</p>\n</blockquote>\n<p>Does \"until the expected type is known\" mean the expected type is fully known with no metavariables or just that the head constant is known? For constructor brackets it seems to be the latter:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">×</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"s2\">\"foo\"</span><span class=\"o\">⟩</span>\n  <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 428180075,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711041462
    },
    {
        "content": "<p>neither, it means that lean will postpone as long as possible but there are no actual guarantees regarding it being fully concrete or anything</p>",
        "id": 428186802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711043687
    },
    {
        "content": "<p>but it generally means that if you get called then whatever information you get is all lean has to offer and delaying further will not help</p>",
        "id": 428186928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711043742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/428179918\">said</a>:</p>\n<blockquote>\n<p>Okay, so my only option is a <code>@[term_elab]</code> tagged definition. What does the argument to <code>term_elab</code> do?</p>\n</blockquote>\n<p>It's the name of the <code>syntax</code> declaration associated to the elab. <code>elab_rules</code> will automatically compute this based on the syntax quotation pattern</p>",
        "id": 428187150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711043814
    },
    {
        "content": "<p>It looks like <code>&lt;= expectedType</code> causes it to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.withExpectedType#doc\">docs#Lean.Elab.Term.withExpectedType</a>, which postpones if the expected type's head (after whnfR) is a metavariable</p>",
        "id": 428187177,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711043825
    },
    {
        "content": "<p>Is there something wrong with this version using the <code>&lt;= expectedType</code> syntax? It passes Yaël's test cases.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Fintype.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Finset</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">Std.ExtendedBinder.extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkSetOf</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"bp\">$</span><span class=\"n\">pred</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"bp\">$</span><span class=\"n\">pred</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">mkSetOf</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">mkSetOf</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">([</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">])</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">desugared</span> <span class=\"bp\">←</span>\n      <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Set</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">sty</span> <span class=\"bp\">←</span> <span class=\"n\">whnfR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">))</span>\n        <span class=\"n\">match_expr</span> <span class=\"n\">sty</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n    <span class=\"n\">elabTerm</span> <span class=\"n\">desugared</span> <span class=\"n\">expectedType</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>                  <span class=\"c1\">-- `{x | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">)</span>        <span class=\"c1\">-- `{x | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span><span class=\"o\">)</span>     <span class=\"c1\">-- `Finset.univ.filter fun x ↦ p x : Finset α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>              <span class=\"c1\">-- `s.filter fun x ↦ p x : Finset α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- `s.filter fun x ↦ p x : Finset α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">)</span>    <span class=\"c1\">-- `{x ∈ s | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">[</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span>              <span class=\"c1\">-- `{x : α | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">_</span><span class=\"o\">)</span>    <span class=\"c1\">-- `{x : α | p x} : Set α`</span>\n<span class=\"k\">#check</span> <span class=\"o\">([</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"c1\">-- `Finset.univ.filter fun x : α ↦ p x : Finset α`</span>\n</code></pre></div>",
        "id": 428198917,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711048161
    },
    {
        "content": "<p>I got my own version to work, however I don't know how to override the existing macro defined in <code>Mathlib.Init.Set</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabSetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"c1\">-- Elaborate the `{x | p x}` notation</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">match</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"c1\">-- Elaborate the `{x : t | p x}` notation</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">match</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"c1\">-- Elaborate the `{x ∈ s | p x}` notation</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">match</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">whnfR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">mkApp</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Finset</span> <span class=\"o\">[</span><span class=\"n\">u</span><span class=\"o\">])</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"bp\">|</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"c1\">-- Elaborate the `{binders | p}` notation where `binders` is a sequence of binders</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">binderPred</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"n\">satisfies_binder_pred</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"c1\">-- T</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>",
        "id": 428204193,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711050112
    },
    {
        "content": "<p>I think you need to use q-matching there, otherwise that won't work for <code>abbrev NatFinset := Finset Nat</code></p>",
        "id": 428231384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711061680
    },
    {
        "content": "<p>if you are going to check the expected type and make a decision based on it you should really be using <code>withExpectedType</code> or else there will be counterintuitive behavior where you get the wrong elaboration because something is a finset but it is not yet available because it was deferred in some way</p>",
        "id": 428232608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711062386
    },
    {
        "content": "<p>Wait, but <code>withExpectedType</code> only runs my thing if there is an expected type, right? I also want it to run if there is no expected type to be had</p>",
        "id": 428277741,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711094678
    },
    {
        "content": "<p>Experimentally, it seems to run with <code>expectedType := ?mvar</code> as a last resort if the expected type is unconstrained</p>",
        "id": 428278465,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711095015
    },
    {
        "content": "<p>I mean, you can just look at the definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">withExpectedType</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">tryPostponeIfNoneOrMVar</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">expectedType</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"expected type must be known\"</span>\n  <span class=\"n\">x</span> <span class=\"n\">expectedType</span>\n</code></pre></div>",
        "id": 428278537,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711095064
    },
    {
        "content": "<p>How do you explain my code applying to <code>#check [x | p x]</code>? My guess is that <code>expectedType? := some `(?mvar)</code></p>",
        "id": 428278932,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711095244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/428277741\">said</a>:</p>\n<blockquote>\n<p>Wait, but <code>withExpectedType</code> only runs my thing if there is an expected type, right? I also want it to run if there is no expected type to be had</p>\n</blockquote>\n<p>No, it will still run even if there is no expected type (it will call your elaborator with a metavariable expected type)</p>",
        "id": 428281952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711096483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/428278537\">said</a>:</p>\n<blockquote>\n<p>I mean, you can just look at the definition:</p>\n</blockquote>\n<p>This doesn't tell the whole story, because <code>tryPostpone</code> will potentially throw a <code>.postpone</code> exception, which will cause the elaboration process containing this elab to get put on a deferred queue and retried (the elab is restarted from the beginning) with a potentially different value of <code>expectedType?</code></p>",
        "id": 428282382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711096684
    },
    {
        "content": "<p>Is there any documentation about this postponement mechanism?</p>",
        "id": 428291298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711099897
    },
    {
        "content": "<p>I don't think there is any single module doc that lays it all out, but most of the action is in <code>SyntheticMVars.lean</code> near <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Term.synthesizeSyntheticMVars#src\">src#Lean.Elab.Term.synthesizeSyntheticMVars</a> and there are a lot of small comments in that file</p>",
        "id": 428292418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711100275
    },
    {
        "content": "<p>Are PRs to add docstrings to Lean declarations welcome?</p>",
        "id": 428292540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711100306
    },
    {
        "content": "<p>very much so, although I think people get worried about the accuracy of the docstrings, it's not quite as much of a rubber-stamp process as I would like</p>",
        "id": 428292773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711100399
    },
    {
        "content": "<p>Here's my final MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Util.ExtendedBinder</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">def</span> <span class=\"n\">setOf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- Set builder syntax. This can be elaborated to either a `Set` or a `Finset` depending on context.</span>\n\n<span class=\"sd\">The elaborators for this syntax are located in:</span>\n<span class=\"sd\">* `Init.Set` for the `Set` builder notation elaborator for syntax of the form `{x | p x}`,</span>\n<span class=\"sd\">  `{x : α | p x}`, `{binder x | p x}`.</span>\n<span class=\"sd\">* `Data.Finset.Basic` for the `Finset` builder notation elaborator for syntax of the form</span>\n<span class=\"sd\">  `{x ∈ s | p x}`.</span>\n<span class=\"sd\">* `Data.Fintype.Basic` for the `Finset` builder notation elaborator for syntax of the form</span>\n<span class=\"sd\">  `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.</span>\n<span class=\"sd\">* `Order.LocallyFinite.Basic` for the `Finset` builder notation elaborator for syntax of the form</span>\n<span class=\"sd\">  `{x ≤ a | p x}`, `{x ≥ a | p x}`, `{x &lt; a | p x}`, `{x &gt; a | p x}`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"{\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"}\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"sd\">/-- Elaborate set builder notation for `Set`.</span>\n\n<span class=\"sd\">* `{x | p x}` is elaborated as `Set.setOf fun x ↦ p x`</span>\n<span class=\"sd\">* `{x : α | p x}` is elaborated as `Set.setOf fun x : α ↦ p x`</span>\n<span class=\"sd\">* `{binder x | p x}`, where `x` is bound by the `binder` binder, is elaborated as</span>\n<span class=\"sd\">  `{x | binder x ∧ p x}`. The typical example is `{x ∈ s | p x}`, which is elaborated as</span>\n<span class=\"sd\">  `{x | x ∈ s ∧ p x}`. The possible binders are</span>\n<span class=\"sd\">  * `· ∈ s`, `· ∉ s`</span>\n<span class=\"sd\">  * `· ⊆ s`, `· ⊂ s`, `· ⊇ s`, `· ⊃ s`</span>\n<span class=\"sd\">  * `· ≤ a`, `· ≥ a`, `· &lt; a`, `· &gt; a`, `· ≠ a`</span>\n\n<span class=\"sd\">  More binders can be declared using the `binder_predicate` command, see `Init.BinderPredicates` for</span>\n<span class=\"sd\">  more info.</span>\n\n<span class=\"sd\">See also</span>\n<span class=\"sd\">* `Data.Finset.Basic` for the `Finset` builder notation elaborator partly overriding this one for</span>\n<span class=\"sd\">  syntax of the form `{x ∈ s | p x}`.</span>\n<span class=\"sd\">* `Data.Fintype.Basic` for the `Finset` builder notation elaborator partly overriding this one for</span>\n<span class=\"sd\">  syntax of the form `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.</span>\n<span class=\"sd\">* `Order.LocallyFinite.Basic` for the `Finset` builder notation elaborator partly overriding this</span>\n<span class=\"sd\">  one for syntax of the form `{x ≤ a | p x}`, `{x ≥ a | p x}`, `{x &lt; a | p x}`, `{x &gt; a | p x}`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">binderPred</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"n\">satisfies_binder_pred</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">List.Mem</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.filter</span> <span class=\"n\">p</span> <span class=\"n\">s</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.compl</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">s</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.singleton</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.Iic</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.Ici</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.Iio</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.Ioi</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n\n\n<span class=\"sd\">/-- Elaborate set builder notation for `Finset`.</span>\n\n<span class=\"sd\">`{x ∈ s | p x}` is elaborated as `Finset.filter (fun x ↦ p x) s` if either the expected type is</span>\n<span class=\"sd\">`Finset ?α` or the expected type is not `Set ?α` and `s` has expected type `Finset ?α`.</span>\n\n<span class=\"sd\">See also</span>\n<span class=\"sd\">* `Init.Set` for the `Set` builder notation elaborator that this elaborator partly overrides.</span>\n<span class=\"sd\">* `Data.Fintype.Basic` for the `Finset` builder notation elaborator handling syntax of the form</span>\n<span class=\"sd\">  `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.</span>\n<span class=\"sd\">* `Order.LocallyFinite.Basic` for the `Finset` builder notation elaborator handling syntax of the</span>\n<span class=\"sd\">  form `{x ≤ a | p x}`, `{x ≥ a | p x}`, `{x &lt; a | p x}`, `{x &gt; a | p x}`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Set</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">try</span> <span class=\"n\">whnfR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">))</span> <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n      <span class=\"n\">match_expr</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n\n<span class=\"sd\">/-- Elaborate set builder notation for `Finset`.</span>\n\n<span class=\"sd\">* `{x | p x}` is elaborated as `Finset.filter (fun x ↦ p x) Finset.univ` if the expected type is</span>\n<span class=\"sd\">  `Finset ?α`.</span>\n<span class=\"sd\">* `{x : α | p x}` is elaborated as `Finset.filter (fun x : α ↦ p x) Finset.univ` if the expected</span>\n<span class=\"sd\">  type is `Finset ?β`.</span>\n<span class=\"sd\">* `{x ∉ s | p x}` is elaborated as `Finset.filter (fun x ↦ p x) sᶜ` if either the expected type is</span>\n<span class=\"sd\">  `Finset ?α` or the expected type is not `Set ?α` and `s` has expected type `Finset ?α`.</span>\n<span class=\"sd\">* `{x ≠ a | p x}` is elaborated as `Finset.filter (fun x ↦ p x) {a}ᶜ` if the expected type is</span>\n<span class=\"sd\">  `Finset ?α`.</span>\n\n<span class=\"sd\">See also</span>\n<span class=\"sd\">* `Init.Set` for the `Set` builder notation elaborator that this elaborator partly overrides.</span>\n<span class=\"sd\">* `Data.Finset.Basic` for the `Finset` builder notation elaborator partly overriding this one for</span>\n<span class=\"sd\">  syntax of the form `{x ∈ s | p x}`.</span>\n<span class=\"sd\">* `Data.Fintype.Basic` for the `Finset` builder notation elaborator handling syntax of the form</span>\n<span class=\"sd\">  `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.</span>\n<span class=\"sd\">* `Order.LocallyFinite.Basic` for the `Finset` builder notation elaborator handling syntax of the</span>\n<span class=\"sd\">  form `{x ≤ a | p x}`, `{x ≥ a | p x}`, `{x &lt; a | p x}`, `{x &gt; a | p x}`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∉</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Set</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">try</span> <span class=\"n\">whnfR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">))</span> <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n      <span class=\"n\">match_expr</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.compl</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">)))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">≠</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.compl</span> <span class=\"o\">(</span><span class=\"n\">Finset.singleton</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">))))</span>\n      <span class=\"n\">expectedType</span>\n\n<span class=\"sd\">/-- Elaborate set builder notation for `Finset`.</span>\n\n<span class=\"sd\">* `{x ≤ a | p x}` is elaborated as `Finset.filter (fun x ↦ p x) (Finset.Iic a)` if the expected type</span>\n<span class=\"sd\">  is `Finset ?α`.</span>\n<span class=\"sd\">* `{x ≥ a | p x}` is elaborated as `Finset.filter (fun x ↦ p x) (Finset.Ici a)` if the expected type</span>\n<span class=\"sd\">  is `Finset ?α`.</span>\n<span class=\"sd\">* `{x &lt; a | p x}` is elaborated as `Finset.filter (fun x ↦ p x) (Finset.Iio a)` if the expected type</span>\n<span class=\"sd\">  is `Finset ?α`.</span>\n<span class=\"sd\">* `{x &gt; a | p x}` is elaborated as `Finset.filter (fun x ↦ p x) (Finset.Ioi a)` if the expected type</span>\n<span class=\"sd\">  is `Finset ?α`.</span>\n\n<span class=\"sd\">See also</span>\n<span class=\"sd\">* `Init.Set` for the `Set` builder notation elaborator that this elaborator partly overrides.</span>\n<span class=\"sd\">* `Data.Finset.Basic` for the `Finset` builder notation elaborator partly overriding this one for</span>\n<span class=\"sd\">  syntax of the form `{x ∈ s | p x}`.</span>\n<span class=\"sd\">* `Data.Fintype.Basic` for the `Finset` builder notation elaborator handling syntax of the form</span>\n<span class=\"sd\">  `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">≤</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.Iic</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">≥</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.Ici</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.Iio</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">&gt;</span> <span class=\"bp\">$</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.Ioi</span> <span class=\"bp\">$</span><span class=\"n\">a</span><span class=\"o\">)))</span> <span class=\"n\">expectedType</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span><span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 428312918,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711108095
    },
    {
        "content": "<p>Now let's try to make it work in mathlib...</p>",
        "id": 428312986,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711108123
    },
    {
        "content": "<p>I have now opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a></p>",
        "id": 428317225,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711109796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/428232608\">said</a>:</p>\n<blockquote>\n<p>if you are going to check the expected type and make a decision based on it you should really be using <code>withExpectedType</code></p>\n</blockquote>\n<p>Is the build error in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a> something that should be fixed by changing the order in which the expected type is passed, or something that should be worked around? From my (limited) understanding, the build error is rather directly a consequence of the elaborator for the <code>Set</code> builder notation now using <code>withExpectedType</code>.</p>",
        "id": 428317364,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711109855
    },
    {
        "content": "<p>Actually it just seems like the notation doesn't elaborate to a set when no expected type is available, but clearly it does in the MWE <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 428319093,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711110451
    },
    {
        "content": "<p>Isn't the issue that <code>elab_rules : term &lt;= expectedType</code> calls <code>withExpectedType</code> even though we don't want it to?</p>",
        "id": 428319524,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711110606
    },
    {
        "content": "<p>Here's some previous discussion about this: <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Optional.20expected.20type.20in.20.60elab_rules.60/near/425791354\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/.E2.9C.94.20Optional.20expected.20type.20in.20.60elab_rules.60/near/425791354</a></p>\n<p>It would be nice to have some syntax for <code>elab_rules</code> to let you get the expected type without requiring an expected type.</p>",
        "id": 428392291,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711133767
    },
    {
        "content": "<p>I like <span class=\"user-mention\" data-user-id=\"501683\">@Raghuram</span>'s idea in <a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Optional.20expected.20type.20in.20.60elab_rules.60/near/425854013\">this message</a> to allow <code>elab_rules</code> patterns take a second match pattern for the expected type.</p>\n<p>This is not a straightforward thing to implement (syntax <code>match</code>s are its own elaborator, so that would need to be modified to support this!) but it seems to be a really clean-looking solution.</p>\n<p>Maybe as a first version, it could support just pattern variables for the expected type. No matching on whether it's <code>some</code> or <code>none</code>.</p>",
        "id": 428392717,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711133969
    },
    {
        "content": "<p>I agree <span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span>'s solution looks clean, but I have no idea how to implement it. Is it possible to simply make</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n  <span class=\"bp\">|</span> <span class=\"n\">match₁</span><span class=\"o\">,</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">matchₙ</span><span class=\"o\">,</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>(without pattern-matching on <code>expectedType</code>!) notation for \"current <code>elab_rules</code> but you have access to <code>expectedType</code>\"?</p>",
        "id": 428421776,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711148795
    },
    {
        "content": "<p>That sounds easy enough to do and it will unblock me here (I think <span class=\"user-mention silent\" data-user-id=\"695413\">Christoph Spiegel</span> would like to have finset builder notation in rather quickly). In fact, is there any other way to unblock me here?</p>",
        "id": 428421919,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711148915
    },
    {
        "content": "<p>I'm not sure what the block is? If you want the expected type as an <code>Option</code> and don't want to force it with <code>withExpectedType</code>, you need to use <code>@[term_elab] def</code> but <code>elab_rules</code> isn't actually providing all that much that you can't do yourself with this form: you just need a <code>| _ =&gt; throwUnsupportedSyntax</code> branch at the end and to use the name of the syntax kind in <code>@[term_elab &lt;kind&gt;]</code></p>",
        "id": 428441281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711166423
    },
    {
        "content": "<p>Well I guess I need to figure out how to turn <code>elab_rules</code> into <code>@[term_elab _] def</code></p>",
        "id": 429062745,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711183196
    },
    {
        "content": "<p>Okay nevermind that was easy</p>",
        "id": 429063129,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711183586
    },
    {
        "content": "<p>I take it back, it still doesn't do the same thing as before, namely dot notation on <code>{x | p x}</code> now complains with <code>expected type must be known</code>.</p>",
        "id": 429064912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711185501
    },
    {
        "content": "<p>Mario, or anyone else, do you mind turning</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">binderPred</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"n\">satisfies_binder_pred</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>into a <code>term_elab</code>? My attempt is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabSetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">binderPred</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"n\">satisfies_binder_pred</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>",
        "id": 429064940,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711185556
    },
    {
        "content": "<p>That looks correct to me. I think the difference is that you no longer postpone when the expected type is not known, but I thought that was kind of the point of you asking to switch to <code>term_elab</code></p>",
        "id": 429067619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711188135
    },
    {
        "content": "<p>No, the point of me asking to switch from <code>macro_rules</code> to <code>term_elab</code> is that <code>macro_rules</code> doesn't let me override it.</p>",
        "id": 429067731,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711188269
    },
    {
        "content": "<p>The point of me asking to switch from <code>elab_rules</code> to <code>term_elab</code> is indeed to not postpone when the expected type is not known</p>",
        "id": 429069051,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711189600
    },
    {
        "content": "<p>I find that there are too many fixes to be done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a> to make up for the weaker elaboration, so I am asking again: How do I turn the <code>macro_rules</code> in <code>Init.Set</code> into a <code>term_elab</code> verbatim?</p>",
        "id": 429071257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711191784
    },
    {
        "content": "<p>Here's a MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Util.ExtendedBinder</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">def</span> <span class=\"n\">setOf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setBuilder</span><span class=\"o\">)</span> <span class=\"s2\">\"{\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"}\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabSetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"c1\">-- expected type must be known</span>\n</code></pre></div>",
        "id": 429071923,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711192445
    },
    {
        "content": "<p>Isn't the answer \"add <code>withExpectedType</code>\" as Mario said above?</p>",
        "id": 429093630,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711210663
    },
    {
        "content": "<p>your MWE does not have the behavior you claim when I try it</p>",
        "id": 429101644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711217006
    },
    {
        "content": "<p>the elab is missing a <code>  | _, _ =&gt; throwUnsupportedSyntax</code> arm, and when I fix that the <code>#check</code> at the bottom works with no error</p>",
        "id": 429101676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711217042
    },
    {
        "content": "<p>Sorry, I had overminimised. Here is a correct MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Util.ExtendedBinder</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">def</span> <span class=\"n\">setOf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">List.Mem</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.filter</span> <span class=\"n\">p</span> <span class=\"n\">s</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setBuilder</span><span class=\"o\">)</span> <span class=\"s2\">\"{\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"}\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabSetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n\n<span class=\"sd\">/-- Elaborate set builder notation for `Finset`.</span>\n\n<span class=\"sd\">`{x ∈ s | p x}` is elaborated as `Finset.filter (fun x ↦ p x) s` if either the expected type is</span>\n<span class=\"sd\">`Finset ?α` or the expected type is not `Set ?α` and `s` has expected type `Finset ?α`.</span>\n\n<span class=\"sd\">See also</span>\n<span class=\"sd\">* `Init.Set` for the `Set` builder notation elaborator that this elaborator partly overrides.</span>\n<span class=\"sd\">* `Data.Fintype.Basic` for the `Finset` builder notation elaborator handling syntax of the form</span>\n<span class=\"sd\">  `{x | p x}`, `{x : α | p x}`, `{x ∉ s | p x}`, `{x ≠ a | p x}`.</span>\n<span class=\"sd\">* `Order.LocallyFinite.Basic` for the `Finset` builder notation elaborator handling syntax of the</span>\n<span class=\"sd\">  form `{x ≤ a | p x}`, `{x ≥ a | p x}`, `{x &lt; a | p x}`, `{x &gt; a | p x}`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">elab_rules</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Set</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">try</span> <span class=\"n\">whnfR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">))</span> <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n      <span class=\"n\">match_expr</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">linter.unusedVariables</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"c1\">-- expected type must be known</span>\n</code></pre></div>",
        "id": 429102601,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711217786
    },
    {
        "content": "<p>I think I understand what's going on:</p>\n<ul>\n<li>The second <code>elab_rules</code> is tried first.</li>\n<li>It is given no expected type, hence <code>withExpectedType</code>throws <code>postpone</code></li>\n<li>No expected type becomes available, hence elaboration fails</li>\n</ul>",
        "id": 429102876,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711217983
    },
    {
        "content": "<p>My expectation was rather:</p>\n<ul>\n<li>The second <code>elab_rules</code> is tried first.</li>\n<li>It is given no expected type, hence <code>withExpectedType</code>throws <code>postpone</code></li>\n<li>The first <code>elab_rules</code> is tried</li>\n<li>It succeeds and notation is elaborated</li>\n</ul>",
        "id": 429102989,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711218036
    },
    {
        "content": "<p>if you want the first elab_rules to be tried you need to throw <code>throwUnsupportedSyntax</code> like I showed in my version</p>",
        "id": 429103022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711218095
    },
    {
        "content": "<p>Yes I agree. So it seems I cannot use <code>withExpectedType</code> after all. Instead I must use something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">withExpectedTypeOrUnsupported</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">tryPostponeIfNoneOrMVar</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">expectedType</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwUnsupportedSyntax</span>\n  <span class=\"n\">x</span> <span class=\"n\">expectedType</span>\n</code></pre></div>",
        "id": 429103160,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711218196
    },
    {
        "content": "<p>I think you just need the first line</p>",
        "id": 429103272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711218283
    },
    {
        "content": "<p>Are you sure? Where is the <code>throwUnsupportedSyntax</code> then?</p>",
        "id": 429103326,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711218353
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">withExpectedTypeOrUnsupported</span> <span class=\"o\">(</span><span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"n\">tryPostponeIfNoneOrMVar</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">expectedType</span> <span class=\"bp\">←</span> <span class=\"n\">pure</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwUnsupportedSyntax</span>\n  <span class=\"n\">x</span> <span class=\"n\">expectedType</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabFinsetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">withExpectedTypeOrUnsupported</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">fun</span> <span class=\"n\">expectedType</span> <span class=\"bp\">↦</span> <span class=\"k\">do</span>\n      <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>",
        "id": 429104293,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711219156
    },
    {
        "content": "<p>This doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabFinsetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">tryPostponeIfNoneOrMVar</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>\n<p>as then</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">True</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Finite</span> <span class=\"c1\">-- invalid field 'Finite', the environment does not contain 'Finset.Finite' ...</span>\n</code></pre></div>",
        "id": 429104402,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711219222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/429103326\">said</a>:</p>\n<blockquote>\n<p>Are you sure? Where is the <code>throwUnsupportedSyntax</code> then?</p>\n</blockquote>\n<p>the original code already has it</p>",
        "id": 429104573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711219369
    },
    {
        "content": "<p>Not in the</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>branch?</p>",
        "id": 429104767,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711219512
    },
    {
        "content": "<p>in the original version</p>",
        "id": 429104786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711219526
    },
    {
        "content": "<p>Can you link to it? I don't know what \"original\" means anymore</p>",
        "id": 429104842,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711219549
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">elabFinsetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">∈</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">tryPostponeIfNoneOrMVar</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"k\">let</span> <span class=\"n\">unknown</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Set</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">true</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">true</span>\n    <span class=\"k\">if</span> <span class=\"n\">unknown</span> <span class=\"k\">then</span>\n      <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"bp\">←</span> <span class=\"n\">try</span> <span class=\"n\">whnfR</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">elabTerm</span> <span class=\"n\">s</span> <span class=\"n\">none</span><span class=\"o\">))</span> <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n      <span class=\"n\">match_expr</span> <span class=\"n\">ty</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n      <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div>",
        "id": 429104913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711219589
    },
    {
        "content": "<p>How is that better than my version with <code>withExpectedTypeOrUnsupported</code>?</p>",
        "id": 429105155,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711219727
    },
    {
        "content": "<p>because you don't want to throw unsupported immediately in this case, you want to treat it the same as \"unknown expected type\"</p>",
        "id": 429105220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711219780
    },
    {
        "content": "<p>Hmm, I'm failing to come up with an example where that matters</p>",
        "id": 429105619,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711220064
    },
    {
        "content": "<p>Your elab doesn't work with <code>have : x ∈ {x | p x} := h</code> somehow</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Parser.Term</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Util.ExtendedBinder</span>\n<span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span> <span class=\"n\">Std.ExtendedBinder</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">def</span> <span class=\"n\">setOf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">List.Mem</span><span class=\"o\">⟩</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidablePred</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.filter</span> <span class=\"n\">p</span> <span class=\"n\">s</span>\n<span class=\"kd\">def</span> <span class=\"n\">Finset.univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">setBuilder</span><span class=\"o\">)</span> <span class=\"s2\">\"{\"</span> <span class=\"n\">extBinder</span> <span class=\"s2\">\" | \"</span> <span class=\"n\">term</span> <span class=\"s2\">\"}\"</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabSetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"c1\">-- works as expected</span>\n  <span class=\"n\">trivial</span>\n\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">elabFinsetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">tryPostponeIfNoneOrMVar</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n    <span class=\"k\">let</span> <span class=\"n\">known</span> <span class=\"bp\">←</span> <span class=\"k\">match</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">match_expr</span> <span class=\"n\">expectedType</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Finset</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">true</span>\n        <span class=\"bp\">|</span> <span class=\"n\">Set</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n        <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n    <span class=\"n\">unless</span> <span class=\"n\">known</span> <span class=\"k\">do</span> <span class=\"n\">throwUnsupportedSyntax</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">=</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  h</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  true = true : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  true ∈ ?m.4762 : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 429120369,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711231489
    },
    {
        "content": "<p>If I remove the <code>tryPostponeIfNoneOrMVar</code>, it works again, but I doubt that's the solution.</p>",
        "id": 429120372,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711231496
    },
    {
        "content": "<p>Okay so it seems that all elabs for the same syntax run in the same <code>TermElabM</code> context, which means that postponing in one elab means postponing in all elabs that run later, which is not what we want.</p>",
        "id": 429180600,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711274731
    },
    {
        "content": "<p>I'm gonna remove the <code>tryPostponeIfNoneOrMVar</code>, on the basis that my main concern is to keep the set builder notation unchanged. We can make do with a finset builder notation that requires some hints on the type.</p>",
        "id": 429180716,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711274820
    },
    {
        "content": "<p>Again: Why not use something like <code>{ᶠ ... }</code>for <code>Finset</code>s? That should avoid all the problems with overloading set builder notation and will make type annotations mostly unncessary.</p>",
        "id": 429184348,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711277315
    },
    {
        "content": "<p>because it's not exactly what you write down on paper, and the overloaded set notation does the job in almost all cases</p>",
        "id": 429184452,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711277405
    },
    {
        "content": "<p>We have, e.g., <code>×ˢ</code> or <code>∑'</code>, which is also not how you write things on paper.</p>",
        "id": 429184501,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711277483
    },
    {
        "content": "<p>But conversely we don't have <code>+ℕ</code> vs <code>+ℤ</code> for specifying what type of addition we want</p>",
        "id": 429185868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711278214
    },
    {
        "content": "<p>My point is: there is a trade-off here. Of course it is desirable to be able to write things as closely as we can manage to what we do on paper, but there are limits to that. Note that we do not write <code>{a, b, c} : Finset ℕ</code> when we do paper math either.</p>",
        "id": 429187257,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711279248
    },
    {
        "content": "<p>Incidentally, you don't need to write <code>({a, b, c} : Finset ℕ)</code> very often because usually some expected type is available.</p>",
        "id": 429193411,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711282470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/429193411\">said</a>:</p>\n<blockquote>\n<p>Incidentally, you don't need to write <code>({a, b, c} : Finset ℕ)</code> very often because usually some expected type is available.</p>\n</blockquote>\n<p>I disagree, maybe your contexts are better than mine but I write this sort of nonsense all the time.</p>",
        "id": 429226004,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1711298684
    },
    {
        "content": "<p>I fully agree with Michael that we should spell this out, because not only will this cause future ambiguities, I bet you that it turns current non-ambiguous cases into ambiguous ones. If it doesn't, I think it'd be nice to have both, but otherwise I think we should stick to the least problematic one.</p>",
        "id": 429226065,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1711298761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/429226065\">said</a>:</p>\n<blockquote>\n<p>I bet you that it turns current non-ambiguous cases into ambiguous ones.</p>\n</blockquote>\n<p>If you read this thread, you will see that all my effort is directed towards this, and it seems I have managed!</p>",
        "id": 429229866,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711301443
    },
    {
        "content": "<p>I've not been following this thread too closely; in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10962\">#10962</a> I face a similar problem where I want to overload notation but have <code>Finsupp</code> take priority over <code>DFinsupp</code> in the absence of an expected type. Does <code>elab_rules</code> have builtin support for this kind of overloading, or do I need to crawl the thread above for tricks?</p>",
        "id": 429246324,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711313283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/429246324\">said</a>:</p>\n<blockquote>\n<p>Does <code>elab_rules</code> have builtin support for this kind of overloading?</p>\n</blockquote>\n<p>Basically: no</p>",
        "id": 429246510,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711313398
    },
    {
        "content": "<p>I'm putting together what I learned over the last few days. Here is what I understood:</p>\n<ul>\n<li>When elaborating a syntax node <code>myNotation</code>, every def tagged <code>@[term_elab myNotation]</code> (I'll call those <code>myNotation</code> elabs) is tried.</li>\n<li>The last <code>myNotation</code> elab is tried first. I don't know what happens when you have two <code>myNotation</code> elabs defined in mutually non-importing files. I assume it's arbitrary.</li>\n<li>The only way to escape a <code>myNotation</code> elab (so that the next one can be tried) is to make it use <code>throwUnsupportedSyntax</code>.</li>\n<li>Postponing is not scoped to the <code>myNotation</code> elab. Very concretely, this means that if you want a <code>myNotation</code> elab to not postpone (eg so that it forces the expected type to be something specific), you cannot postpone in any later <code>myNotation</code> elab.</li>\n</ul>",
        "id": 429247109,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711313842
    },
    {
        "content": "<p>To me, that last point is the most surprising (and annoying) one.</p>",
        "id": 429247138,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711313870
    },
    {
        "content": "<p>So \"overloading\" really means \"insert <code>throwUnsupportedSyntax</code> whenever you want another elab to take over, but any postponing you have done in the <code>TermElabM</code> monad will be passed on\".</p>",
        "id": 429247252,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711313954
    },
    {
        "content": "<p>Turns out my first attempt just worked in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10962\">#10962</a></p>",
        "id": 429247535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711314056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, are my explanations above correct? If so, is there any way for me to not break the existing set builder notation more than it needs in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a> while still getting things like <code>{x | p x} = s</code> where <code>s : Finset α</code> to elaborate as <code>Finset.univ.filter (fun x ↦ p x) = s</code>? this is not the case in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11582\">#11582</a> anymore now that I've commented out <code>TryPostponeIfNoneOrMVar</code>)</p>",
        "id": 429298979,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711348920
    },
    {
        "content": "<p>I think it should be possible to keep the <code>tryPostpone</code> but I don't have time to investigate this ATM. It might be good to find out why the type mismatch is happening</p>",
        "id": 429299205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349018
    },
    {
        "content": "<p>There may be a feature request in here somewhere</p>",
        "id": 429299288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349053
    },
    {
        "content": "<p>Okay, I can't make more progress than this without your help so please just tell me when you get to have a look <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 429299588,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711349195
    },
    {
        "content": "<p>My gut feeling is that postponing brings me to the end of time, while I only want to be fastforwarded to the extinction of humanity.</p>",
        "id": 429299670,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711349242
    },
    {
        "content": "<p>could you make a MWE with tests you would like to work?</p>",
        "id": 429299709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349268
    },
    {
        "content": "<p>Sure thing, let me put that together.</p>",
        "id": 429299968,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711349379
    },
    {
        "content": "<p>Actually, here is a (hopefully simple) feature request that would make everything work according to my understanding so far: When an elab (of a specific syntax kind) postpones on a piece of notation, let the other elabs (of that specific syntax kind) run on the piece of notation <em>before</em> you call the original elab again.</p>",
        "id": 429300337,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711349529
    },
    {
        "content": "<p>I don't think that is correct behavior in general</p>",
        "id": 429300443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349580
    },
    {
        "content": "<p>postponing isn't supposed to result in a behavior change</p>",
        "id": 429300466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349594
    },
    {
        "content": "<p>A possible solution is for postpones to come with a priority, and pending mvars are retried in priority order (and possibly there is a mode where postpones below a certain priority are masked?)</p>",
        "id": 429300614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349675
    },
    {
        "content": "<p>because I think there are a few cases where an elab wants to say \"I'm holding out for more information, but if you <em>really</em> need me to proceed I can\"</p>",
        "id": 429300737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349748
    },
    {
        "content": "<p>and we don't want to get into a deadlock situation with these kind of \"tentative elabs\"</p>",
        "id": 429300844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349796
    },
    {
        "content": "<p>Yeah that sounds like some kind of priority system would work here.</p>",
        "id": 429300904,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711349831
    },
    {
        "content": "<p>I had similar implementation sadness trying to implement auto-eta-reduction for the cdot parser (<a href=\"https://github.com/leanprover/lean4/pull/2267\">lean4#2267</a>)</p>",
        "id": 429301089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711349923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/429064940\">said</a>:</p>\n<blockquote>\n<p>Mario, or anyone else, do you mind turning</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro_rules</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">binderPred</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">})</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"n\">satisfies_binder_pred</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>into a <code>term_elab</code>? My attempt is</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">setBuilder</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">elabSetBuilder</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">↦</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">({</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">$</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">binderPred</span> <span class=\"bp\">|</span> <span class=\"bp\">$</span><span class=\"n\">p</span> <span class=\"o\">}),</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabTerm</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"k\">fun</span> <span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"bp\">↦</span> <span class=\"n\">satisfies_binder_pred</span><span class=\"bp\">%</span> <span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">$</span><span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">$</span><span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">expectedType</span><span class=\"bp\">?</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwUnsupportedSyntax</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>One small warning about doing this conversion mechanically (perhaps for future reference for someone else reading this later): if the different patterns of the <code>macro/elab_rules</code> correspond to different parsers (different <code>syntax</code> declarations), then the <code>elab_rules</code> expands to multiple <code>@[_elab] def</code>s, one for each parser (if I'm remembering correctly).</p>",
        "id": 433691433,
        "sender_full_name": "Raghuram",
        "timestamp": 1713339181
    },
    {
        "content": "<p>It seems like there's a general kind of \"task\" here:</p>\n<blockquote>\n<p>You have an existing notation. You want to override it with a different optional interpretation in some context (where \"context\" is either about the expected type or type of one of the inputs), but in such a way that without any specific type information it reverts back to the default behaviour.</p>\n</blockquote>\n<p>that it might be helpful to have a general \"recipe\" for dealing with.</p>\n<p>(I was doing something along these lines some time back, experimenting with overloading the notation for propositional operators.)</p>",
        "id": 433693386,
        "sender_full_name": "Raghuram",
        "timestamp": 1713339868
    },
    {
        "content": "<p>One suggestion I received (<a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Interaction.20between.20notation.20and.20coercion/near/425698304\">here</a>) was to reimplement the notation if necessary to use a typeclass, and then just make instances, with the original interpretation receiving a default instance.<br>\n(In fact, I vaguely remember seeing a set-comprehension-notation typeclass somewhere - maybe somewhere near <code>SetLike</code> and related stuff?)<br>\nThe only problem with this is that you get something (usually definitionally, but) not syntactically equal to the original notation. This can be worked around by adding an elaborator to unfold the typeclass instance applications (mentioned in the above chat; I also wrote out an implementation that seems to work, if wanted).</p>\n<p>Another was to add an elaborator that checks whether the overloaded interpretation is applicable by inspecting the context, returns it if so, and throws unsupported otherwise. One gotcha here is that (IIRC) macros are tried before elabs, so if the original notation used a macro (this includes <code>notation</code> and hence <code>infix</code>, <code>prefix</code>, etc.), the new elaborator never runs; essentially, the old thing runs first when we want the new thing to run first. The only way around this is to get rid of the original macro rule, either by disabling it with <code>attribute [-macro]</code> (not 100% sure this works), or redeclaring the notation with higher priority so that the original notation and attached macro are shadowed; and adding it back as an elaborator. Within macros or within elaborators, newer rules are tried first, so it works out.<br>\nIt's in this approach that the question of <code>expectedType? : Option Expr</code> v.s. <code>withExpectedType</code> comes up. I <em>thought</em> that the former is the desirable one here, but I'm not sure now.</p>",
        "id": 433696591,
        "sender_full_name": "Raghuram",
        "timestamp": 1713341046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"501683\">Raghuram</span> <a href=\"#narrow/stream/113488-general/topic/.7Bx.20.E2.88.88.20s.20.7C.20p.20x.7D.20notation.20for.20finset/near/433696591\">said</a>:</p>\n<blockquote>\n<p>One suggestion I received (<a href=\"#narrow/stream/270676-lean4/topic/.E2.9C.94.20Interaction.20between.20notation.20and.20coercion/near/425698304\">here</a>) was to reimplement the notation if necessary to use a typeclass, and then just make instances, with the original interpretation receiving a default instance.</p>\n</blockquote>\n<p>I don't see how this can possibly buy you anything that you can't do yourself in a custom elab</p>",
        "id": 433698879,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713341762
    }
]