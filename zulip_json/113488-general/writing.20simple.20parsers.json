[
    {
        "content": "<p>I'm embarrassed to admit my almost complete ignorance about writing simple parsers in Lean, but could someone show me the lowest overhead way to write a parser that takes a string representation of a list of pairs of natural numbers, e.g. <code>\"[(1, 2), (3, 4)]\"</code> and returns a <code>List (\\nat \\times \\nat)</code>?</p>\n<p>I'm trying to help some people who are currently implementing this by splitting on comma, filtering non-digit characters, and then chunking, and I'm horrified I don't know what to tell them to do instead.</p>\n<p>No error handling required, happy to just return the empty list if anything goes wrong. I just want <code>String \\to List (\\nat \\times \\nat)</code> as the signature.</p>\n<p>(Mathlib compatible answers, i.e. no extra <code>require</code>s preferred but not essential.)</p>",
        "id": 441013569,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716893824
    },
    {
        "content": "<p>How does this look like?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">digs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">toDigits</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">toDigits</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">digs</span><span class=\"bp\">.</span><span class=\"n\">toNat!</span>\n</code></pre></div>\n<p>a hand-rolled parser!</p>",
        "id": 441014208,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716894082
    },
    {
        "content": "<p>Oh, I missed that you start with a <em>string</em>!</p>",
        "id": 441014265,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1716894109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/113488-general/topic/writing.20simple.20parsers/near/441013569\">said</a>:</p>\n<blockquote>\n<p>I'm embarrassed to admit my almost complete ignorance about writing simple parsers in Lean, but could someone show me the lowest overhead way to write a parser that takes a string representation of a list of pairs of natural numbers, e.g. <code>\"[(1, 2), (3, 4)]\"</code> and returns a <code>List (\\nat \\times \\nat)</code>?</p>\n<p>I'm trying to help some people who are currently implementing this by splitting on comma, filtering non-digit characters, and then chunking, and I'm horrified I don't know what to tell them to do instead.</p>\n<p>No error handling required, happy to just return the empty list if anything goes wrong. I just want <code>String \\to List (\\nat \\times \\nat)</code> as the signature.</p>\n<p>(Mathlib compatible answers, i.e. no extra <code>require</code>s preferred but not essential.)</p>\n</blockquote>\n<p>The proper way not write non trivial parsers would be to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parsec#doc\">docs#Lean.Parsec</a>. You can still get away with split based stuff for a certain complexity level but at some point you'll want to write a real parser.</p>",
        "id": 441018065,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716895525
    },
    {
        "content": "<p>Are there basic examples of Parsec available somewhere that I can point people to?</p>",
        "id": 441027236,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1716898718
    },
    {
        "content": "<p>Lean core has a JSON parser in parsec at <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Data/Json/Parser.lean\">src/Lean/Data/Json/Parser.lean</a>. Parsec is also a big name in the haskell eco system so there should be lots of tutorials there that use libraries with very similar (though often more featureful) APIs than our Parsec.</p>",
        "id": 441028243,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716899058
    },
    {
        "content": "<p>There were many useful links in <a href=\"#narrow/stream/270676-lean4/topic/Parsec.20parser.20for.20decoding.20Uri.20escapes/near/397592256\">this old topic</a>.</p>",
        "id": 441028665,
        "sender_full_name": "Utensil Song",
        "timestamp": 1716899201
    },
    {
        "content": "<p>There is for example this very long haskell tutorial on (one of, there are multiple forks) parsec <a href=\"https://jakewheat.github.io/intro_to_parsing/\">https://jakewheat.github.io/intro_to_parsing/</a>. Of course the syntax doesn't translate 1:1 but the library that we have is very heavily inspired by and has very similar functions to Haskell parsec.</p>\n<p>I was in general hoping to improve the Parsec situation now that having parsers is actually starting to become a necessity for projects that are on the FRO roadmap.</p>",
        "id": 441028723,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1716899217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/113488-general/topic/writing.20simple.20parsers/near/441027236\">said</a>:</p>\n<blockquote>\n<p>Are there basic examples of Parsec available somewhere that I can point people to?</p>\n</blockquote>\n<p>Sounds like a good excuse for people to link to their old Advent of Code solutions :)</p>",
        "id": 441029620,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1716899535
    },
    {
        "content": "<p>I used parsec most of my AoC entries. For example, <a href=\"https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Day2/Format.lean\">day 2</a></p>\n<p>Something to know about Parsec is that it's really algorithmic vs grammar-based parsers. It commits to parses by default, and it's up to you to say where you'd want any lookahead. Not really any support for efficient nondeterminism. That's not needed for a list of pairs of nats though.</p>",
        "id": 441032960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716900650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/writing.20simple.20parsers/near/441032960\">said</a>:</p>\n<blockquote>\n<p>I used parsec most of my AoC entries. For example, <a href=\"https://github.com/kmill/kmill-aoc2023/blob/main/AoC2023/Day2/Format.lean\">day 2</a></p>\n<p>Something to know about Parsec is that it's really algorithmic vs grammar-based parsers. It commits to parses by default, and it's up to you to say where you'd want any lookahead. Not really any support for efficient nondeterminism. That's not needed for a list of pairs of nats though.</p>\n</blockquote>\n<p>You can do static precomputations better with Arrows. See tutorial : <a href=\"https://www.haskell.org/arrows/\">https://www.haskell.org/arrows/</a><br>\nEDIT: The original paper introduced them to write efficient lookahead parsers: <a href=\"https://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf\">https://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf</a></p>",
        "id": 441052861,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1716906470
    },
    {
        "content": "<p>I have a simple bibtex parser that uses <code>Lean.Parsec</code> <a href=\"https://github.com/dupuisf/BibtexQuery\">here</a>.</p>",
        "id": 441053838,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1716906784
    },
    {
        "content": "<p>When I was learning parsing with lean, I found Arthur Paulino's fxylang a useful non-parsec example : <a href=\"https://github.com/arthurpaulino/FxyLang\">https://github.com/arthurpaulino/FxyLang</a></p>",
        "id": 441054410,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1716906951
    },
    {
        "content": "<p>A caveat there is that using <code>runParserCategory</code> means you're tied to the compile-time Lean environment (i.e., you need an <code>Environment</code>). For compiled programs you can get around by either including the Lean interpreter and having it import oleans or by using a project like <a href=\"https://github.com/tydeu/lean4-partax\">https://github.com/tydeu/lean4-partax</a> to compile the parser definitions.</p>\n<p>Regarding arrows, they're interesting, but just to clarify, you're not suggesting that there's any Lean implementation, right?</p>",
        "id": 441064457,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716910029
    },
    {
        "content": "<p>Nope. I don't think there is a lean implementation of Arrows yet</p>",
        "id": 441072341,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1716912699
    },
    {
        "content": "<p>there's also <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> 's <a href=\"#narrow/stream/270676-lean4/topic/Introducing.20Partax.2C.20the.20Parser.20Compiler/near/379967441\">partax</a> for using lean syntax extensions but avoiding the whole <code>runParserCategory</code> stuff</p>",
        "id": 442541101,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1717510773
    },
    {
        "content": "<p>I'm also starting to learn parsing. I figured I would start with trying to write a lexer, and for that I assume that I need regular expressions, hence I started trying to implement a computable version of those in Lean.</p>",
        "id": 442692599,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1717562192
    },
    {
        "content": "<p>I'm hoping to end up with a LR parser generator in Lean, but that may be more ambitious than I can accomplish in a reasonable amount of time.</p>",
        "id": 442693068,
        "sender_full_name": "Kayla Thomas",
        "timestamp": 1717562488
    }
]