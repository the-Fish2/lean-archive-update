[
    {
        "content": "<p>Hi, are there any axioms for IO.Ref? I'd expect something like <code>(IO.mkRef a &gt;&gt;= λref =&gt; ref.get) = pure a</code>, but I don't see anything in the std.<br>\nIs there any \"prior art\" on this? Or is there any reason why it's not possible?</p>",
        "id": 424967677,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709677114
    },
    {
        "content": "<p>There are no axioms like that by default. Go ahead and postulate them yourself. Actually, I would be quite interested in them. I'm working on automatic differentiation and some time ago I was thinking about differentiating w.r.t. value stored in IORef. Such axioms would be quite  handy. However, getting the axioms right might be quite subtle considering multithreading.</p>",
        "id": 424984935,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709685969
    },
    {
        "content": "<blockquote>\n<p>Go ahead and postulate them yourself</p>\n</blockquote>\n<p>I spent few hours playing with it yesterday, but the above axiom is the only thing I came up with so far. And yes, multithreading is partially to blame for that :)</p>",
        "id": 424985700,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709686475
    },
    {
        "content": "<p>As a general note, I find things not very discoverable in lean. It took me more then an hour to find <code>LawfulMonad</code>, and I succeeded only because I knew something like this had to exist. So I kinda hoped someone would point me to a <code>LawfulRef</code> or something similar.</p>",
        "id": 424986334,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709686889
    },
    {
        "content": "<p>Do you know about loogle and moogle ?</p>",
        "id": 424987232,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1709687528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> damn it. I actually was wondering why something like hoogle doesn't exists for lean. Thank you, that helps!</p>",
        "id": 424987623,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709687795
    },
    {
        "content": "<p>I think working with <a href=\"https://github.com/leanprover/lean4/blob/01f0fedef8dafd21ec2d8d8fc742d99af4f1372f/src/Init/System/Mutex.lean#L81\"><code>Mutex</code></a> instead of <code>IO.Ref</code> might allow you to state more useful axioms.</p>",
        "id": 424991812,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709690810
    },
    {
        "content": "<p>I also find lsp functionality 'List Workspace Symbols' to be very useful.</p>",
        "id": 424992174,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709691026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> why? If <code>IO.Ref</code> works as I think it works, then <code>IO.Ref.set</code> is atomic.</p>",
        "id": 424992185,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709691033
    },
    {
        "content": "<p>But calling <code>get</code> after <code>set</code> does not have to yield the value you assigned.</p>",
        "id": 424992310,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709691112
    },
    {
        "content": "<p>Two separate <code>IO.Mutex.atomically</code> have the same issue. I mean, yes, with <code>Mutex</code> you can have useful statements about an individual transaction, but that's it. (I never used <code>IO.Mutex</code>, so I might be misunderstanding everything)</p>",
        "id": 424992529,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709691265
    },
    {
        "content": "<p>Yes, <code>get</code> after <code>set</code> doesn't yield the assigned value. That's why you have to include <code>IO.mkRef</code> into each statement, making sure ref doesn't escape</p>",
        "id": 424992679,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709691360
    },
    {
        "content": "<p>Sure the stuff holds only within <code>IO.Mutex.atomically</code>. Well the question is, what do you want to prove about using <code>IO.Ref</code>?</p>",
        "id": 424992719,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709691364
    },
    {
        "content": "<p>I.e. I think this makes sense: <code>(IO.mkRef a &gt;&gt;= \\fun ref =&gt; ref.set b =&gt; \\fun _ =&gt; ref.get) = pure b</code></p>",
        "id": 424992835,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709691460
    },
    {
        "content": "<p>I see,  you guarantee that you are the only owner of <code>IO.Ref</code> and you do not need to do locking.</p>",
        "id": 424992956,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709691561
    },
    {
        "content": "<p>yep. Also <code>(IO.mkRef a &gt;&gt;= \\fun ref =&gt; x &gt;&gt;= \\fun _ =&gt; ref.get) = x</code> might work if I can express \"x doesn't use the ref\" somehow.</p>",
        "id": 424993109,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709691663
    },
    {
        "content": "<p>Another potentially useful thing might be to have a global accumulator. There would not be any <code>set</code>, only <code>add</code> and <code>get</code> and you can state that later <code>get</code> always yields a larger value then previous <code>get</code>.</p>",
        "id": 424993146,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709691689
    },
    {
        "content": "<p>However, I'm a bit skeptical that stating axioms that always start with <code>IO.Ref a &gt;&gt;= ...</code> are of any practical use. It would be best if you have an actual code using <code>IO.Ref</code> you want to prove stuff about.</p>",
        "id": 424993469,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709691868
    },
    {
        "content": "<blockquote>\n<p>Another potentially useful thing might be to have a global accumulator</p>\n</blockquote>\n<p>That actually might be a good \"standard\" example. I.e. any useful set of axioms should be able to proof at least this.</p>\n<blockquote>\n<p>It would be best if you have an actual code using IO.Ref you want to prove stuff about.</p>\n</blockquote>\n<p>It all started from this code: <a href=\"https://github.com/Yuras/lean4-http-client/blob/ee100c2dbbb10a01f4344fe5d8d5c7f7caf8aadb/HttpClient/Connection.lean\">https://github.com/Yuras/lean4-http-client/blob/ee100c2dbbb10a01f4344fe5d8d5c7f7caf8aadb/HttpClient/Connection.lean</a><br>\nI wanted <code>Connection</code> to carry with it a proof that <code>receive</code> after <code>push</code> gives back the pushed value. I quickly realized that this case is far more complicated then I can handle, so I backed off to simple <code>IO.Ref</code></p>",
        "id": 424993868,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709692195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698233\">Yuras Shumovich</span> <a href=\"#narrow/stream/113488-general/topic/axioms.20for.20IO.2ERef.20.28noob.29/near/424993109\">said</a>:</p>\n<blockquote>\n<p>yep. Also <code>(IO.mkRef a &gt;&gt;= \\fun ref =&gt; x &gt;&gt;= \\fun _ =&gt; ref.get) = x</code> might work if I can express \"x doesn't use the ref\" somehow.</p>\n</blockquote>\n<p>Yeah this is interesting and I do not know how to approach this. An ugly solution would be to postulate prop </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">DoesNotUseRef</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">IO.Ref</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>and then start writing axioms for every IO function like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">printlnDoesNotUseRef</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">IO.Ref</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">DoesNotUseRef</span> <span class=\"o\">(</span><span class=\"n\">IO.println</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 424994007,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709692289
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698233\">Yuras Shumovich</span> <a href=\"#narrow/stream/113488-general/topic/axioms.20for.20IO.2ERef.20.28noob.29/near/424993868\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Another potentially useful thing might be to have a global accumulator</p>\n</blockquote>\n<p>That actually might be a good \"standard\" example. I.e. any useful set of axioms should be able to proof at least this.</p>\n<blockquote>\n<p>It would be best if you have an actual code using IO.Ref you want to prove stuff about.</p>\n</blockquote>\n<p>It all started from this code: <a href=\"https://github.com/Yuras/lean4-http-client/blob/ee100c2dbbb10a01f4344fe5d8d5c7f7caf8aadb/HttpClient/Connection.lean\">https://github.com/Yuras/lean4-http-client/blob/ee100c2dbbb10a01f4344fe5d8d5c7f7caf8aadb/HttpClient/Connection.lean</a><br>\nI wanted <code>Connection</code> to carry with it a proof that <code>receive</code> after <code>push</code> gives back the pushed value. I quickly realized that this case is far more complicated then I can handle, so I backed off to simple <code>IO.Ref</code></p>\n</blockquote>\n<p>Is that true? I can copy the connection object and spawn two threads that simultaneously call <code>push</code> . I think you again need some kind of locking mechanism to prevent race conditions.</p>",
        "id": 424994443,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709692670
    },
    {
        "content": "<blockquote>\n<p>Is that true?</p>\n</blockquote>\n<p>Of course it's not true. That's why I'm playing with refs for now :)</p>",
        "id": 424994656,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709692824
    },
    {
        "content": "<p>Well I know nothing about networking :) I think it would be great to first write an interesting program and state what we want to prove about it. Then we can ponder what the axioms should be.</p>",
        "id": 424994871,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709692959
    },
    {
        "content": "<p>As always, understanding the problem is the hardest part of solving it.<br>\nI'm just a regular software engineer, trying to figure out whether lean can be useful for me in day to day work. My goal right now is to assess whether proving anything about IO-heavy code is a posibility. And the \"global accumulator\" would actually be enough for the first example.<br>\nI mean, proving things about pure code is useful as well, but that's much more limited.</p>",
        "id": 424995953,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709693610
    },
    {
        "content": "<p>I pushed a commit to the repo with the test case for receive after push: <a href=\"https://github.com/Yuras/lean4-http-client/blob/bf80e74d2a10197fdae603462b8ee36e8cdcaebf/Spec.lean#L49-L53\">https://github.com/Yuras/lean4-http-client/blob/bf80e74d2a10197fdae603462b8ee36e8cdcaebf/Spec.lean#L49-L53</a><br>\nBasically my goal is to eliminate this test case by replacing it with a theorem.</p>",
        "id": 424996733,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709694086
    },
    {
        "content": "<p>I could have sworn I had a post somewhere explaining why I think that the IO.Ref axioms are inconsistent, but the best I can find is <a href=\"#narrow/stream/270676-lean4/topic/Ensuring.20naive.20purity/near/396153183\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Ensuring.20naive.20purity/near/396153183</a></p>",
        "id": 424996841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709694140
    },
    {
        "content": "<p>Is that connected to the fact that <code>IO</code> is not opaque right now? Or are they still inconsistent even if you can't break apart <code>IO</code>?</p>",
        "id": 424997394,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709694550
    },
    {
        "content": "<blockquote>\n<p>I could have sworn I had a post somewhere explaining why I think that the IO.Ref axioms are inconsistent</p>\n</blockquote>\n<p>Please send me a link if you happen to find it later!</p>\n<blockquote>\n<p>the best I can find is</p>\n</blockquote>\n<p>It's pushing my ability to understand lean a bit too far, but I think you are breaking referential transparency by directly manipulating RealdWorld, which is not a surprice to be honest.</p>",
        "id": 424997570,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709694668
    },
    {
        "content": "<p>For posterity, here is a DM conversation I had with <span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span> on the topic:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>I saw your comment arbitrarily large types in <code>ST</code> due to <code>ST.Ref</code>.  Could you elaborate on where those are coming from.  I saw <code>ST.Ref</code> seems to be only parameterized by <code>Type</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Ref</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>There's been some discussions in the FRO about monadic verification and Hoare triples.  I've been thinking it would be good to provide that, but in a way that avoids introducing an escape mechanism for <code>IO</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>The <code>ST</code> monad lets you create new references with <code>ST.mkRef</code>, and these references can store values of any type</p>\n<p>and the current state of all references is conceptually \"stored in\" the monad state</p>\n<p>This is in stark contrast to <code>StateT</code>, which has space for exactly one \"reference\", and the type of this reference is part of the monad itself</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>Oh, I interpreted that as meaning types in bigger universes.  It does seem tricky to formalize.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>Well the fact that it's any type in the same universe is already bad</p>\n<p>If <code>ST</code> lived one universe up it would be fine</p>\n<p>but you can create <code>ST.Ref</code>s containing the whole monad state, this is a short trip to cantor's paradox</p>\n<p><code>ST</code> was originally designed for haskell, which uses System F as it's underlying theory, and there the whole thing with quantifying over types as a means of abstraction works marvelously. But in lean we can't do this because it's basically <code>Type : Type</code>, and in the context of a universe hierarchy it is deeply suspicious that <code>ST</code> doesn't involve a universe bump</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>Thanks for the explanation.  It seems like a universe bump for the state would be reasonable, but my impression is that would mean that <code>ST</code> itself was in one universe higher which would preclude storing computations in references (among other things).</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> </p>\n<blockquote>\n<p>Not necessarily, because you can still use <code>runST</code> to get small types out</p>\n<p>so you would just be storing pure functions in the references</p>\n<p>Also you could make <code>ST</code> universe polymorphic which would allow storing references to ST in an ST in a higher universe</p>\n<p>but it's true that this will probably just get people tangled up</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>Could one solve this through a different conceptual model where ST states were just some index into an uninterpreted type and each reference defined an function from indices to values?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>no, because that uninterpreted type has some cardinality and so there is a limit on how large reference types can get before there cannot possibly be an injective function into the uninterpreted type</p>\n<p>which means that the references with extremely large types are not lawful</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>By large you mean a large universe?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>no, I mean like <code>A -&gt; A</code> where <code>A</code> is the uninterpreted type</p>\n<p>just large in the sense of cardinality</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>Ok</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>But if you don't assume the references are lawful, then everything is fine, you could just take <code>ST</code> to be the <code>Id</code> monad</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>It seems like a variety of not-great choices.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>the one that is closest to existing practice is to just keep the type opaque so that you can't prove or disprove the reference axioms</p>\n<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ST'</span> <span class=\"o\">(</span><span class=\"n\">_ω</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Id</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ST'</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ref</span> <span class=\"o\">(</span><span class=\"n\">_ω</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">α</span>\n\n<span class=\"n\">opaque</span> <span class=\"n\">mkRef</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST'</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Ref.get</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">r</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Ref.set</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST</span> <span class=\"n\">σ</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Ref.swap</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">r</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Ref.take</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST</span> <span class=\"n\">σ</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">r</span>\n<span class=\"n\">opaque</span> <span class=\"n\">Ref.ptrEq</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"n\">r2</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">σ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST</span> <span class=\"n\">σ</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n</code></pre></div>\n<p>maybe with an additional opaque wrapper so you can't unfold <code>ST</code> or <code>ST.Ref</code></p>\n<p>The other not-great choice is to just get rid of ST and only allow IO refs</p>\n<p>force people to use <code>StateT</code> if they want references in pure code</p>\n<p>Which is not-great because <code>StateRefT</code> is used a lot as a performance optimization of <code>StateT</code></p>\n<p>Then again, exactly because <code>StateRefT</code> has the same interface as <code>StateT</code> we could make it an opaque wrapper which overrides the functions to ones using IO refs</p>\n<p>and we could still safely give it axioms making it provably isomorphic to <code>StateT</code></p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span> </p>\n<blockquote>\n<p>What was your thinking on the need for an injective function?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> said:</p>\n<blockquote>\n<p>no, because that uninterpreted type has some cardinality and so there is a limit on how large reference types can get before there cannot possibly be an injective function into the uninterpreted type</p>\n</blockquote>\n<p>I was thinking of something like:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">STState</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ref</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">STState</span> <span class=\"n\">w</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">A</span>\n<span class=\"kd\">def</span> <span class=\"n\">ST</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">ReaderT</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">STState</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">State</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">A</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>the idea is that <code>Ref w (STState w -&gt; STState w)</code> cannot have its state properly stored in the monad</p>\n<p>Injectivity comes up when you have axioms like <code>(do r.set x; r.get) = pure x</code></p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>That wouldn't hold, but you would have <code>(do r.set x; r.get) = (do r.set x; pure x)</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>oh yes</p>\n<p>when you combine this with <code>runST</code> you know that <code>pure</code> is injective, and so the only way for <code>(do r.set x; r.get)</code> and <code>(do r.set x'; r.get)</code> to be different is if <code>r.set x</code> and <code>r.set x'</code> are different (as elements of <code>ST w Unit</code>), so there is an injective function from the type of <code>x</code> to <code>ST w Unit</code> - but the type of <code>x</code> is arbitrary and can be set to be larger than any fixed type</p>\n<p>This is not to say that anyone is actually interested in having references with such types as <code>STState w -&gt; STState w</code>, but it foils naive attempts to write axioms for references which are true for any <code>A</code></p>\n<p>Another relatively minor change that would make this consistent is to actually do something useful with <code>w</code>: if we use it as an upper bound on the size of the types of references then a reasonable model exists</p>\n<p>This would impact the interface though</p>\n<p>Ideally it would be something like the disjoint union of all types the user is interested in using in the ST block</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>I was playing around with making <code>STState</code> has type Prop, but then <code>runST</code> doesn't work.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>Is that because it expects a Type?</p>\n<p>You can use ULift if that is an issue</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>I was thinking more in terms of semantics since the STState value affects the result.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>yes, from a modeling perspective it needs to be a rather large type</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span></p>\n<blockquote>\n<p>Thanks for the discussion.  Maybe we can try to flesh this out if/when the LawfulMonad core PR goes in.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>\n<blockquote>\n<p>Here's an implementation of <code>ST</code> using bounded size references:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ST'</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">StateM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ST'</span>\n<span class=\"kd\">class</span> <span class=\"n\">IsRef</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">get</span> <span class=\"o\">:</span> <span class=\"n\">ω</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">α</span>\n  <span class=\"n\">set</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ω</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Ref</span> <span class=\"o\">(</span><span class=\"n\">ω</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">IsRef</span> <span class=\"n\">ω</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkRef</span> <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inst</span> <span class=\"o\">:</span> <span class=\"n\">IsRef</span> <span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST'</span> <span class=\"n\">ω</span> <span class=\"o\">(</span><span class=\"n\">Ref</span> <span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">m.size</span><span class=\"o\">,</span> <span class=\"n\">inst</span><span class=\"o\">),</span> <span class=\"n\">m.push</span> <span class=\"o\">(</span><span class=\"n\">inst.set</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ref.get</span> <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST'</span> <span class=\"n\">ω</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"n\">m</span><span class=\"o\">[</span><span class=\"n\">r.1</span><span class=\"o\">]</span><span class=\"bp\">?.</span><span class=\"n\">bind</span> <span class=\"n\">r.2.get</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"bp\">!</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"c1\">-- ignore the `get!` here</span>\n<span class=\"kd\">def</span> <span class=\"n\">Ref.set</span> <span class=\"o\">{</span><span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">@&amp;</span> <span class=\"n\">Ref</span> <span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ST'</span> <span class=\"n\">ω</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((),</span> <span class=\"n\">m.set</span><span class=\"bp\">!</span> <span class=\"n\">r.1</span> <span class=\"o\">(</span><span class=\"n\">r.2.set</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">run</span> <span class=\"o\">(</span><span class=\"n\">ω</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ST'</span> <span class=\"n\">ω</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">#</span><span class=\"o\">[])</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>Remarks:</p>\n<ul>\n<li><code>mkRef</code> has an additional instance argument, to ensure that only types bounded by <code>ω</code> are allowed.</li>\n<li>The <code>get!</code> in <code>ST'.Ref.get</code> is unnecessary (along with <code>Inhabited α</code>) and can be eliminated with sufficient additional invariants and proof work</li>\n<li><code>ST'.run</code> has a different type: it is not <code>(∀ ω, ST ω α) → α</code> (use a type quantifier as a means of abstraction, something we never do in lean otherwise) but <code>∀ ω, ST' ω α → α</code> (the user picks the type <code>ω</code>, which can be anything provided that it is sufficient for satisfying the <code>IsRef</code> conditions)</li>\n</ul>\n</blockquote>",
        "id": 424998339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709695180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/axioms.20for.20IO.2ERef.20.28noob.29/near/424996841\">said</a>:</p>\n<blockquote>\n<p>I could have sworn I had a post somewhere explaining why I think that the IO.Ref axioms are inconsistent</p>\n</blockquote>\n<p>I remembered that too and spent a few minutes earlier trying to find it, but I wasn't able to. I think it was just about a year ago.</p>",
        "id": 424998423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709695224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/axioms.20for.20IO.2ERef.20.28noob.29/near/424997394\">said</a>:</p>\n<blockquote>\n<p>Is that connected to the fact that <code>IO</code> is not opaque right now? Or are they still inconsistent even if you can't break apart <code>IO</code>?</p>\n</blockquote>\n<p>As the discussion I just posted should clarify, this is not about <code>IO</code> opaqueness. That other conversation was about IO opaqueness but I believe there are issues with axiomatizing ST even without that, due to \"size considerations\"</p>",
        "id": 424999040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709695672
    },
    {
        "content": "<p>That said I don't actually have a proof, only a strong suspicion and some circumstantial evidence that it won't go well</p>",
        "id": 424999194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709695787
    },
    {
        "content": "<p>But do I understand correctly that it is more like a bug in the current definition of <code>IO.Ref</code>? With a bit more clever definition there would be no problem in axiomatizing <code>IO.Ref</code>.</p>",
        "id": 424999660,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709696114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'll need more time to read it carefully, but it already looks promising. Thanks for posting it.<br>\nA question: I kinda see (not necessary understand though) the issue with cantor's paradox here, but you mentioned:</p>\n<blockquote>\n<p>The other not-great choice is to just get rid of ST and only allow IO refs</p>\n</blockquote>\n<p>I read is like this: if IO ref made opaque, it would be OK. Is my understanding correct?</p>",
        "id": 424999679,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709696138
    },
    {
        "content": "<p>that is correct</p>",
        "id": 425004180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709699100
    },
    {
        "content": "<p>more specifically, as long as you don't require that the IO.Ref axioms hold there is a trivial model which shows that it is consistent</p>",
        "id": 425004227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709699141
    },
    {
        "content": "<p>that's the code block with the <code>opaque</code>s</p>",
        "id": 425004298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709699165
    },
    {
        "content": "<p>Note: perhaps <a class=\"stream-topic\" data-stream-id=\"236449\" href=\"/#narrow/stream/236449-Program-verification/topic/Verification.20of.20functions.20using.20mutability.20.28STRef.29\">#Program verification &gt; Verification of functions using mutability (STRef)</a> is relevant to this thread, because it contains a message by <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> which links to some comments about <code>ST</code> on <a href=\"https://github.com/leanprover/std4/pull/416\">std4#416</a>—maybe the post was on github, not zulip? Though this was more recently than a year ago.</p>",
        "id": 425014002,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1709705181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/axioms.20for.20IO.2ERef.20.28noob.29/near/424994871\">said</a>:</p>\n<blockquote>\n<p>Well I know nothing about networking :) I think it would be great to first write an interesting program and state what we want to prove about it. Then we can ponder what the axioms should be.</p>\n</blockquote>\n<p>I stripped the code down to the absolute minimum and stated a theorem, see  <a href=\"https://github.com/Yuras/lean4-http-client/blob/e6ae3376673055036c870f457b7a7de220218e1e/HttpClient/Conn.lean#L31\">https://github.com/Yuras/lean4-http-client/blob/e6ae3376673055036c870f457b7a7de220218e1e/HttpClient/Conn.lean#L31</a> Does it work as a model example?</p>\n<p>Note that the ref is created inside <code>Conn.make</code>, i.e. it's essentially using the trick with non-escaping ref, so it should hopefully be immune to concurrency issues.</p>",
        "id": 425100771,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709735669
    },
    {
        "content": "<blockquote>\n<p>Note: perhaps #Program verification &gt; Verification of functions using mutability (STRef) is relevant to this thread</p>\n</blockquote>\n<p>It's totally relevant, thanks! I'll need time to absorb it though.</p>",
        "id": 425101778,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709735922
    },
    {
        "content": "<blockquote>\n<p>I stripped the code down to the absolute minimum and stated a theorem</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>  I actually managed to prove the theorem with just three axioms. Whether the axioms make any sense at all is still an open question though.<br>\n<a href=\"https://github.com/Yuras/lean4-http-client/blob/wip/yuras/connection_theorem/HttpClient/Conn.lean#L57\">https://github.com/Yuras/lean4-http-client/blob/wip/yuras/connection_theorem/HttpClient/Conn.lean#L57</a></p>",
        "id": 425385784,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709841960
    },
    {
        "content": "<p>I think this is a great start, but I'm still sceptical about starting every axiom with <code>mkRef</code>. What if you want to prove properties about a program that does not create references but just uses them.</p>",
        "id": 425388029,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709842818
    },
    {
        "content": "<p>Yep, though it's not clear whether such programs have any useful properties at all</p>",
        "id": 425388273,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709842933
    },
    {
        "content": "<p>They do when you allow for locking :)</p>",
        "id": 425388332,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709842966
    },
    {
        "content": "<p>Or any kind of multithreading synchronization</p>",
        "id": 425388408,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709842992
    },
    {
        "content": "<p>ah, yeah, sure. But you start every axiom with <code>lock</code> then :)</p>",
        "id": 425388413,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709842994
    },
    {
        "content": "<p>Well shouldn't every function that modifies shared global state start with lock?</p>",
        "id": 425388665,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709843084
    },
    {
        "content": "<p>it should. I mean, you have to start either with <code>mkRef</code> (aka \"I have exclusive access, so I don't need locking\") or <code>lock</code> (aka \"I explicitly lock it\")</p>",
        "id": 425388980,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709843198
    },
    {
        "content": "<p>I have a hunch that all the axiom should start with <code>lock</code> plus there would be one stating \"you don't need a <code>lock</code> if you start with <code>mkRef</code>\"</p>",
        "id": 425389309,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709843336
    },
    {
        "content": "<p>I was thinking about exactly the same thing just now :)</p>",
        "id": 425389587,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709843436
    },
    {
        "content": "<p>Anyway, I think you should proceed by writing a bit more complicated program and state its specification. That will lead you to what you actually need.</p>",
        "id": 425389646,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709843468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"698233\">Yuras Shumovich</span> has marked this topic as resolved.</p>",
        "id": 425389689,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709843496
    },
    {
        "content": "<p>Surprisingly the original code required only one additional axiom, <code>mkRef</code> commutativity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">mk_comm</span> <span class=\"o\">{</span><span class=\"n\">T1</span> <span class=\"n\">T2</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">T1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">IO.Ref</span> <span class=\"n\">T1</span> <span class=\"bp\">→</span> <span class=\"n\">IO.Ref</span> <span class=\"n\">T2</span> <span class=\"bp\">→</span> <span class=\"n\">IO</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">r1</span> <span class=\"bp\">←</span> <span class=\"n\">mkRef</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">r2</span> <span class=\"bp\">←</span> <span class=\"n\">mkRef</span> <span class=\"n\">b</span>\n  <span class=\"n\">x</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">r2</span> <span class=\"bp\">←</span> <span class=\"n\">mkRef</span> <span class=\"n\">b</span>\n  <span class=\"k\">let</span> <span class=\"n\">r1</span> <span class=\"bp\">←</span> <span class=\"n\">mkRef</span> <span class=\"n\">a</span>\n  <span class=\"n\">x</span> <span class=\"n\">r1</span> <span class=\"n\">r2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Sounds too good to be true...<br>\n<a href=\"https://github.com/Yuras/lean4-http-client/blob/2ee163c01dee9193c2ea2814190823058b9abeb8/HttpClient/Connection.lean#L102\">https://github.com/Yuras/lean4-http-client/blob/2ee163c01dee9193c2ea2814190823058b9abeb8/HttpClient/Connection.lean#L102</a></p>",
        "id": 425401036,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709848119
    },
    {
        "content": "<blockquote>\n<p>Surprisingly the original code required only one additional axiom</p>\n</blockquote>\n<p>OK, it actually makes sense. The above 4 axioms are actually enough to reduce any \"closed\" sequence of any number of <code>mkRef</code>, <code>set</code> and <code>set</code> to <code>pure _</code>.  (Here \"closed\" means that all refs used in the sequence are created inside the sequence itself). And my initial goal happened to be exactly such sequence. To prove anything more complicated I'll need to  generalize the last axiom to the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">mk_io_comm</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">IO</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">IO.Ref</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">IO</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">mkRef</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">y</span>\n  <span class=\"n\">x</span> <span class=\"n\">r</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">v</span> <span class=\"bp\">←</span> <span class=\"n\">y</span>\n  <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span> <span class=\"n\">mkRef</span> <span class=\"n\">a</span>\n  <span class=\"n\">x</span> <span class=\"n\">r</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 425601602,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709929444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20axioms.20for.20IO.2ERef.20.28noob.29/near/425389309\">said</a>:</p>\n<blockquote>\n<p>I have a hunch that all the axiom should start with <code>lock</code> plus there would be one stating \"you don't need a <code>lock</code> if you start with <code>mkRef</code>\"</p>\n</blockquote>\n<p>That probably won't work, at least not in general. In the <code>mk_io_comm</code> axiom above I'm relying on <code>y</code> not having access to <code>r</code>. It obviously won't work with <code>lock</code>.</p>",
        "id": 425602015,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709929665
    },
    {
        "content": "<p>anyway, I managed to prove a number of theorems about my code: <a href=\"https://github.com/Yuras/lean4-http-client/blob/wip/yuras/connection_theorem/HttpClient/Connection.lean\">https://github.com/Yuras/lean4-http-client/blob/wip/yuras/connection_theorem/HttpClient/Connection.lean</a><br>\nSo, sinse the goal is achieved, I'll probably stop posting updates in this topic. Thanks everyone for help!</p>",
        "id": 425602643,
        "sender_full_name": "Yuras Shumovich",
        "timestamp": 1709929932
    }
]