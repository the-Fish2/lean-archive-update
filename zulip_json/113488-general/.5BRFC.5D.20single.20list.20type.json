[
    {
        "content": "<p>Imagine a list type that</p>\n<ul>\n<li>Supports induction/pattern-matching on <code>nil</code> and <code>cons</code> (like <code>List</code>)</li>\n<li>Uses the unmarked <code>[x, y, z]</code> syntax for literals (like <code>List</code>)</li>\n<li>Has comprehensive standard library functions with nice defeqs and good kernel reduction performance (like <code>List</code>)</li>\n<li>Has comprehensive lemmas for those functions (like <code>List</code>)</li>\n<li>Supports O(1) random access when compiled (like <code>Array</code>)</li>\n<li>Supports O(1) slicing (like <code>Subarray</code>)</li>\n</ul>\n<p>If such a type existed, it would subsume all use cases for <code>Array</code> and <code>Subarray</code> and all use cases for <code>List</code> except for when you actually want a linked list data structure. It would be a major simplification to go from frequently needing to program using <code>Array</code> and write proofs using <code>List</code> to almost always using <code>NewList</code> and almost never using <code>LinkedList</code>.</p>\n<p><code>NewList</code> could be implemented as:</p>\n<ul>\n<li>In the logic, an inductive type with <code>nil</code> and <code>cons</code> like <code>List</code></li>\n<li>At runtime, a more optimized version of <code>Subarray</code></li>\n</ul>\n<p>There is one snag: <code>cons</code> at runtime would be an O(n) array prepend operation, so functions which produce <code>NewList</code>s and have nice defeqs would have bad runtime performance. This is easy to fix for specific functions by adding a <code>@[csimp]</code> lemma with a variant that builds the list using append operations instead, which is what all of the standard library would do. I imagine that this would not be a big problem in user code because it would be most common to use generic standard library functions which encode the pattern of construction, such as <code>map</code>.</p>\n<p>Prior art: <a href=\"https://roc-lang.org\">Roc</a> is a minimalist functional language which uses the same approach to memory management as Lean, with reference counting and opportunistic mutation. They have only <a href=\"https://www.roc-lang.org/builtins/List\">one list type</a> in the standard library, and it is effectively <a href=\"https://docs.google.com/document/d/1sYA8lgUW836OJoH_kFJz1WPzwJrFLnWbTCCYNhMSI80/edit\">an optimized version of Lean's <code>Subarray</code></a>.</p>",
        "id": 430304738,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711739279
    },
    {
        "content": "<p>Isn't that type just <code>Array</code>? <code>Array</code> is a structure that wraps a <code>List</code> for the Lean logic side and an efficient <code>Array</code> for the Lean runtime.</p>",
        "id": 430305009,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1711739402
    },
    {
        "content": "<p>The proposed implementation of <code>NewList</code> is indeed very close to the current implementation of <code>Array</code> (although slicing is an important difference), but <code>Array</code> currently doesn't meet almost any of my bullet points for usability.</p>",
        "id": 430305531,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711739660
    },
    {
        "content": "<p>(The slicing piece is important, otherwise pattern-matching on <code>(x :: xs)</code> would be an O(n) remove operation.)</p>",
        "id": 430305798,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711739797
    },
    {
        "content": "<p>Is your list persistent?  I think that is expected out of most functional data structures, and can be quite useful.  Also, is it easy to avoid copying your list when you mean to do a destructive update.  That is an issue with array and why it may not be a good default for every use case.</p>",
        "id": 430308035,
        "sender_full_name": "Jason Rute",
        "timestamp": 1711740928
    },
    {
        "content": "<p>No, <code>NewList</code> would not be persistent. Indeed persistence is the reason that <code>LinkedList</code> would still need to exist, but my experience with using <code>Vec</code> very often and persistent collections never in Rust suggests to me that it is very rarely needed.</p>",
        "id": 430308473,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711741166
    },
    {
        "content": "<p>Data structures in rust aren’t immutable. Mutability of Array in Lean is sort of a hack that happens at compilation time.  I don’t know how it is in your toy functional language.  There are persistent, immutable, O(log n) access data structures like Scala’s Vector.</p>",
        "id": 430317255,
        "sender_full_name": "Jason Rute",
        "timestamp": 1711745931
    },
    {
        "content": "<p>(To be clear, when I was referring to \"persistent collections in Rust\" I was thinking of <a href=\"https://docs.rs/im/latest/im/struct.Vector.html\"><code>im::Vector</code></a> which is like you describe)</p>",
        "id": 430322539,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711749107
    },
    {
        "content": "<blockquote>\n<p>Mutability of Array in Lean is sort of a hack that happens at compilation time.</p>\n</blockquote>\n<p>I don't see mutation in Lean as a hack. Coming from Rust, I see Lean's \"functional but in-place\" style as an attempt to separate reasoning about safety and cost. You can achieve Rust-level performance if you write your code in the fragment of Lean that Rust's borrow checker would accept (all mutable values used linearly), and otherwise your code still runs, just maybe slowly.</p>",
        "id": 430323773,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711749880
    },
    {
        "content": "<p>There is certainly an argument for using persistent data structures with reasonable worst-case performance on all operations as a default and only using more specialized data structures upon micro-optimization, but given that there isn't currently even an implementation of a persistent vector in Lean, I think that's a separate RFC. If down the line we wanted to make such an implementation the \"default\" list (i.e. assign it the unmarked <code>[x, y, z]</code> syntax), all of the other suggestions in this RFC would still be an improvement over the status quo.</p>",
        "id": 430324938,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711750635
    },
    {
        "content": "<p>By “hack” I mean Lean doesn’t have a borrow checker, so using <code>Array</code>s, <code>HashMap</code>s, and such is an advanced feature.</p>",
        "id": 430327949,
        "sender_full_name": "Jason Rute",
        "timestamp": 1711752824
    },
    {
        "content": "<p>Actually, as for your O(n) <code>cons</code>, if what you are suggesting is an array underneath, then couldn’t cons (if destructive, in place) just be amortized O(1) like in python’s <code>list.append</code> (Which I believe uses a resizable array underneath.). I don’t know if Lean’s array already has this (but maybe when appending to the tail which is more common in an array).</p>",
        "id": 430339063,
        "sender_full_name": "Jason Rute",
        "timestamp": 1711759571
    }
]