[
    {
        "content": "<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib4/pull/11308\">#11308</a> with a \"pointless tactic linter\": the linter inspects the goals before and after each tactic and emits a warning if it detects no change.</p>\n<p>The PR also contains some of the tactic-removals arising from the linter.</p>\n<p>If you have any comments, I'd be happy to hear them!</p>\n<p>(Also, I am not done removing the pointless tactics and there is some decision to be taken about explicit <code>skip</code>s in the code.)</p>",
        "id": 426045608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710212376
    },
    {
        "content": "<p>As this PR gets discussed, it is probably a good idea to agree on a few style guidelines.</p>\n<p>Here is a first question: should the linter flag tactics like <code>done</code> and <code>skip</code>?  If you have an opinion give <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span>/<span aria-label=\"thumbs down\" class=\"emoji emoji-1f44e\" role=\"img\" title=\"thumbs down\">:thumbs_down:</span>  for support/rejection and whichever other emoji you want for whatever else you want to express!</p>",
        "id": 426229028,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710285822
    },
    {
        "content": "<p>I personally find <code>done</code> very good pedagogically, but I probably prefer it to not appear in <code>Mathlib</code> (unless nolinted).</p>",
        "id": 426229040,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710285830
    },
    {
        "content": "<p>With <code>skip</code>, ideally I would like to flag uses of <code>skip</code> such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">skip</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>(of which the linter found quite a few!).  I would rather it not flag uses of <code>skip</code> as in <code>... &lt;;&gt; [skip, ring]; aesop</code>.  However, I am not sure how to achieve both in a robust way.</p>",
        "id": 426229044,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710285833
    },
    {
        "content": "<p>I would rather uses of <code>skip</code> be flagged by the linter.</p>",
        "id": 426229120,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710285859
    },
    {
        "content": "<p>The point of a linter is to suggest a modification which it thinks is better. (Ideally with a code action to perform it.) If it can't find a way to express that modification, then it should probably just be quiet.</p>\n<p>Applying this principle to the <code>&lt;;&gt; [skip; ring]</code> case, the basic idea is that useless tactics can only be removed from a <code>tacticSeq</code> if there is more than one tactic in the seq (otherwise it would result in an erroneous 0-tactic list), and tactics appearing where a <code>tactic</code> is expected can't be removed at all, and can at best be replaced by <code>skip</code>. So you should flag useless tactics in a tacticSeq if they are either not the only thing in the list, or if they are not <code>skip</code>.</p>",
        "id": 426268925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710312022
    },
    {
        "content": "<p>Mario, that clarifies a lot, thanks!  I'll try to make the linter aware of the ranges of <code>tacticSeq</code> and update its behaviour accordingly.</p>",
        "id": 426271127,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710313268
    },
    {
        "content": "<ol>\n<li>Given the vote above, I have decided that <code>done</code>, by default triggers a warning.  If there is a strong differing opinion, changing this decision is simply a matter of adding <code>done</code> to the already existing whitelist.</li>\n</ol>",
        "id": 426484799,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710402100
    },
    {
        "content": "<ol start=\"2\">\n<li>I made the linter not inspect <code>seq_focus</code> blocks altogether.  It is true that there could be some really unused tactics inside there, but I think that entering <code>seq_focus</code> is a task for a second pass!</li>\n</ol>",
        "id": 426484937,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710402181
    },
    {
        "content": "<ol start=\"3\">\n<li>As mathlib is almost compliant with the unused tactic linter, I am looking at whether the linter should also act on <code>test</code>s.  I suspect that it should, since getting feedback about whether a tactic is or isn't doing something is valuable.  However, inside <code>test</code>, I am finding it hard to not whitelist a lot of tactics.</li>\n</ol>",
        "id": 426485185,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710402303
    },
    {
        "content": "<p>So, should <code>test</code>s be \"unused tactic linted\"?</p>",
        "id": 426485231,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710402323
    },
    {
        "content": "<p>A possibility is always to disable the unused tactic linter inside <code>test</code>s and everyone can opt in via <code>set_option linter.unusedTactic true</code>.</p>",
        "id": 426485422,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710402425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426485422\">said</a>:</p>\n<blockquote>\n<p>A possibility is always to disable the unused tactic linter inside <code>test</code>s and everyone can opt in via <code>set_option linter.unusedTactic true</code>.</p>\n</blockquote>\n<p>I would recommend the opposite: you should use this <code>set_option</code> in every test that involves unused tactics</p>",
        "id": 426494044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710406386
    },
    {
        "content": "<p>Ok, I will make the linter act everywhere.</p>\n<p>I will add <code>fail_if_success</code> and its friends to the whitelisted tactics, though, right?  Those seem to already have their own control of what should work/not work, so, in some sense are already taking over what the blanket \"unused tactic\" would do.</p>",
        "id": 426495466,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710406908
    },
    {
        "content": "<p>yeah, <code>fail_if_success</code> should be whitelisted, since there is basically no reason to use it for an effect accidentally</p>",
        "id": 426499200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710408111
    },
    {
        "content": "<p>I mean I suppose it's conceivable that someone could have written it in a proof and it isn't doing anything, but most likely such a proof is for teaching or demonstration purposes anyway, and flagging it won't be useful</p>",
        "id": 426499541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710408230
    },
    {
        "content": "<p>although that does relate to a potential issue with linters like this, which is that it is difficult for downstream projects to disable it globally</p>",
        "id": 426499709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710408281
    },
    {
        "content": "<p>e.g. if they want to use <code>done</code></p>",
        "id": 426499732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710408289
    },
    {
        "content": "<p>Would it make sense to store a local file with the whitelist and the tactic parses that file to know which tactics to whitelist and which ones to check?  That would make customizable what you want and do not want to use.</p>",
        "id": 426500129,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710408446
    },
    {
        "content": "<p>The linter is now green!</p>\n<p>I wrote a summary of the files touched by the PR in the description and the linter comes with its documentation.</p>\n<p>Essentially, even though the PR touches 23 files,</p>\n<ul>\n<li>17 are for <code>set_option</code>s in tests,</li>\n<li>1 is the file with the linter,</li>\n<li>3 are <code>noshake</code> and the <code>Mathlib</code> and <code>Mathlib.Tactic</code> additions,</li>\n<li>1 is the file to import the linter early in the hierarchy,</li>\n<li>1 is <em>the</em> file in <code>Mathlib</code> that opts out of the linter!</li>\n</ul>",
        "id": 426609148,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710442848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426495466\">said</a>:</p>\n<blockquote>\n<p>Ok, I will make the linter act everywhere.</p>\n<p>I will add <code>fail_if_success</code> and its friends to the whitelisted tactics, though, right?  Those seem to already have their own control of what should work/not work, so, in some sense are already taking over what the blanket \"unused tactic\" would do.</p>\n</blockquote>\n<p>Could the whitelisted parsers just be tagged with an attribute instead of stored in a list, e.g. <code>@[allow_unused_tactic]</code>? (It might be easy to spin one up with <code>register_label_attr</code>.)</p>",
        "id": 426613132,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710444243
    },
    {
        "content": "<p>I was thinking the same, but, since I never wrote anything involving an attribute, I did not want to slow down the PR.</p>",
        "id": 426613353,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710444319
    },
    {
        "content": "<p>Also, it is something that can be added after the linter is in place, so it did not seem urgent.  I would be happy to take the opportunity to learn about attributes, though!</p>",
        "id": 426613498,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710444367
    },
    {
        "content": "<p>(This does not appear from the current status of the PR, but over 100 files had unused tactics, so, at the beginning, it was not clear how long it would take to fix everything!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>",
        "id": 426613930,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710444514
    },
    {
        "content": "<p>Aside: I've been handling some attribute and environment extension stuff lately, and I don't want to keep all that I've learned to myself—I wonder if it would be alright to start a page in the mathlib4 wiki on attributes where I could develop a sort of \"how to write an attribute\" piece. (I notice that the lean manual and metaprogramming book don't seem to cover attributes in an in-depth fashion yet.)</p>",
        "id": 426615570,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710445176
    },
    {
        "content": "<p>I was thinking of doing something analogous for linters...</p>",
        "id": 426615711,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710445223
    },
    {
        "content": "<p>I do not know about others, but I found those wiki pages very helpful.  In particular, I've consulted the monads page more than I would like to admit...  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 426615840,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710445277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426613132\">said</a>:</p>\n<blockquote>\n<p>Could the whitelisted parsers be tagged with an attribute instead of stored in a list, e.g. <code>@[allow_unused_tactic]</code>? </p>\n</blockquote>\n<p>Please don't write one attribute per linter!</p>",
        "id": 426626710,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710449537
    },
    {
        "content": "<p>One attribute to lint them all...</p>",
        "id": 426627249,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710449723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426626710\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426613132\">said</a>:</p>\n<blockquote>\n<p>Could the whitelisted parsers be tagged with an attribute instead of stored in a list, e.g. <code>@[allow_unused_tactic]</code>? </p>\n</blockquote>\n<p>Please don't write one attribute per linter!</p>\n</blockquote>\n<p>You mean write <em>more</em> than 1 attribute per linter? <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span> (Just kidding. :P )</p>",
        "id": 426631298,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710451259
    },
    {
        "content": "<p>I think a label attribute is pretty lightweight and low-maintenance here! Here's the entirety of how it might look:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"n\">register_label_attr</span> <span class=\"n\">allow_unused_tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span> <span class=\"k\">in</span>\n<span class=\"sd\">/-- Gets the array of tactic nodekinds which are allowed to be unused. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">getAllowedUnusedTacKinds</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">liftCoreM</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">labelled</span> <span class=\"bp\">`</span><span class=\"n\">allow_unused_tactic</span>\n</code></pre></div>\n<p>(the monad of <code>labelled</code> should be lowered to <code>IO</code>, I think—then we wouldn't need <code>liftCoreM</code>.)</p>\n<p>Though I haven't looked closely at the PR yet.</p>",
        "id": 426632491,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710451762
    },
    {
        "content": "<p>If I am following what you are saying, the <code>SyntaxNodeKinds</code> of the tactics that are allowed to be unused would be stored in the environment, so that the linter could dynamically pick them up as it goes through the declarations, right?</p>\n<p>This makes me think that the monad should have access to the environment, though and so this may rule out IO, maybe?</p>",
        "id": 426640697,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710455510
    },
    {
        "content": "<p>I think there is already a setup for this in the unreachable tactic linter</p>",
        "id": 426640832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710455557
    },
    {
        "content": "<p>it uses the really-super-basic version of an attribute: there is an IO ref and you use <code>initialize</code> to add things to it</p>",
        "id": 426640942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710455633
    },
    {
        "content": "<p>Ok, the part with <code>initialize</code> I did copy, but I did not understand it much.  So, from what you are saying, not only it is in the unreachable tactic, but it is actually also already in the unused tactic linter!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 426641146,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710455722
    },
    {
        "content": "<p>the way to add something to it would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">initialize</span> <span class=\"n\">addIgnoreTacticKind</span> <span class=\"bp\">``</span><span class=\"n\">tacticStx</span>\n</code></pre></div>",
        "id": 426641201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710455760
    },
    {
        "content": "<p>Ok, let me try</p>",
        "id": 426641256,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710455775
    },
    {
        "content": "<p>The unnecessary seq focus uses a slightly heavier weight version, a <code>TagAttribute</code> which is basically what is suggested above. So you would tag a tactic you don't want linted as <code>@[multigoal]</code></p>",
        "id": 426641384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710455867
    },
    {
        "content": "<p>Both versions also come with a list of \"builtins\" which come pre-tagged</p>",
        "id": 426641568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710455966
    },
    {
        "content": "<p>this is necessary for the <code>TagAttribute</code> case because you can't tag something in another file</p>",
        "id": 426641616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710456001
    },
    {
        "content": "<p>Ok, I think that there is something that I am not understanding now and it is also getting late here: I'll sleep on it and will get back to it later!</p>\n<p>In the meantime, the linter may already be extendable, without me being able to extend it!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 426643622,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710457065
    },
    {
        "content": "<p>(And by the way: a label attribute is just meant to be a tag attribute which lets you add labels in other files! It's also implemented slightly differently, though.)</p>",
        "id": 426645200,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710457892
    },
    {
        "content": "<p>The major advantage of the attributes with the same-file restriction is that they have zero overhead at import time. Just remember that if you use any <code>initialize</code> code then that code runs whenever someone does <code>import Mathlib</code> for each and every tagged definition...</p>",
        "id": 426648816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710460147
    },
    {
        "content": "<p>Hmm—in principle, is the lack of overhead intrinsic to the same-file restriction? (I do see that label attributes use a scoped env extension, which it’s clear has more overhead in general, though.)</p>\n<p>I’m not totally clear on what’s special about adding a declaration to the extension while in the same module as opposed to otherwise. (There might be a clue in the fact that we have both <code>addEntryFn</code> and <code>addImportedFn</code>, and the latter is constant for tag attributes…but it’s not clear to me how and why it can get away with being constant.)</p>",
        "id": 426657247,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710465408
    },
    {
        "content": "<blockquote>\n<p>Hmm—in principle, is the lack of overhead intrinsic to the same-file restriction? (I do see that label attributes use a scoped env extension, which it’s clear has more overhead in general, though.)</p>\n</blockquote>\n<p>The way they are related is that there are the following options for lookup into an extension:</p>\n<ol>\n<li>Find the file containing the declaration -&gt; check the extension map for that file to see if the declaration is marked</li>\n<li>Search all extension maps to see if the declaration is marked in any of them</li>\n<li>Merge extension maps on import, then look up into the merged map</li>\n</ol>\n<p>Option 1 is only correct if you have the same file restriction. Option 2 is expensive at lookup time, which usually disqualifies it from consideration. Option 3 has import-time overhead. <code>TagDeclarationExtension</code> uses option 1, while <code>ScopedEnvExtension</code> uses option 3.</p>",
        "id": 426658078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710465971
    },
    {
        "content": "<p>Oh, ok, makes sense! (The existence of extension maps for files in the first place was my blind spot. I can understand why we’d want to hide them under abstractions, though.)</p>\n<p>I suppose one other option (maybe) (in principle) is that we could always also search the extension map for one other specific “initial” file (specified when the extension was registered). That would let us “start off” by tagging a bunch of declarations.</p>\n<p>(Or a more generic hybrid approach where we dynamically keep track of a list of modules that add tags to decls from other modules, then just merge <em>those</em> modules’ extension maps, and fallback to lookup in that merged map if lookup-by-original-module fails. Not sure if this would actually be needed by anything though.)</p>",
        "id": 426659848,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710467379
    },
    {
        "content": "<blockquote>\n<p>(The existence of extension maps for files in the first place was my blind spot. I can understand why we’d want to hide them under abstractions, though.)</p>\n</blockquote>\n<p>Well, it's not necessarily a map; extensions can put basically whatever they like in a .olean file. The constraint is that you have to prepare that data structure per-file and while they get loaded from disk for ~free using mmap, any processing of the data is going to add overhead at import time, so the best thing you can do is just leave that data as is and consult it later. Of course we still have the import-time overhead of producing the constant map of the <code>Environment</code>, but that's pretty fundamental to lean so it's unlikely we can avoid that cost.</p>",
        "id": 426670623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710475590
    },
    {
        "content": "<blockquote>\n<p>I suppose one other option (maybe) (in principle) is that we could always also search the extension map for one other specific “initial” file (specified when the extension was registered). That would let us “start off” by tagging a bunch of declarations.</p>\n</blockquote>\n<p>That's what <code>TagAttributeExtra</code> implements. More precisely, it augments a <code>TagAttribute</code> with a hard-coded list of declarations that are consulted if the lookup in option (1) fails.</p>",
        "id": 426670809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710475755
    },
    {
        "content": "<blockquote>\n<p>(Or a more generic hybrid approach where we dynamically keep track of a list of modules that add tags to decls from other modules, then just merge those modules’ extension maps, and fallback to lookup in that merged map if lookup-by-original-module fails. Not sure if this would actually be needed by anything though.)</p>\n</blockquote>\n<p>I don't think this works, because how would you know whether a module is \"of interest\" and in need of merging unless you look inside it? Or maybe the idea is more that it's actually two extensions (or behaves roughly like that), and you only use the \"expensive\" extension for cross-module entries. I think that would be useful as an optimization of many of mathlib's extensions which use the more heavyweight extensions because of the fewer restrictions even though it is rare to actually make use of the mechanism.</p>",
        "id": 426671199,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710476041
    },
    {
        "content": "<p>The implementation I had in mind was something like: “store the names of modules  with cross-module entries in an auxiliary “merge-style” extension” (with the hope that most modules won’t contribute their name and so merging to obtain this list of names will be efficient(?)), then for the decls we actually care about, either: “try module-of-origin lookup, and if that fails, look in each listed module in turn” or instead “merge the entries from each listed module at import time, then lookup based on module of origin, and fall back to the merged data if that fails”. Though I don’t know how the costs compare.</p>\n<p>But at that point (in the second option), I guess your notion is that you might not really need the list in the first place (depending on how the implementation shakes out) and this is basically equivalent to two [parallel, internal] extensions!</p>",
        "id": 426676446,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710480011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426670809\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I suppose one other option (maybe) (in principle) is that we could always also search the extension map for one other specific “initial” file (specified when the extension was registered). That would let us “start off” by tagging a bunch of declarations.</p>\n</blockquote>\n<p>That's what <code>TagAttributeExtra</code> implements. More precisely, it augments a <code>TagAttribute</code> with a hard-coded list of declarations that are consulted if the lookup in option (1) fails.</p>\n</blockquote>\n<p>Oh, nice! I wonder if that would be appropriate for this linter—I suppose it depends on whether you can still erase the hardcoded tags locally. (But I’m on mobile right now, so can’t easily check.)</p>",
        "id": 426676603,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710480169
    },
    {
        "content": "<p>(Wait, you <em>can</em> erase tag attributes, at least in a way that doesn’t persist over imports, right? I’m figuring that would just be an addition to some <code>erased</code> collection in the environment, as usual, not something written to oleans. But I haven’t checked that <code>TagAttribute</code>(<code>Extra</code>)s actually implement erasure.)</p>",
        "id": 426677249,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710480767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"548935\">Thomas Murrills</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/426677249\">said</a>:</p>\n<blockquote>\n<p>Wait, you <em>can</em> erase tag attributes, at least in a way that doesn’t persist over imports, right?</p>\n</blockquote>\n<p>No, at least not currently. There is nothing fundamentally preventing this but it's not implemented.</p>",
        "id": 426679875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710482984
    },
    {
        "content": "<p>I <code>!bench</code>ed the PR and it is incredibly slow!</p>",
        "id": 426699094,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710493171
    },
    {
        "content": "<p>Maybe this is a topic for testing linters more generally, but I wanted to add a test file, delimiting some of the boundaries of the linter.</p>\n<p>I can certainly put in tests for tactics that are allowed to not make progress -- that's easy.</p>\n<p>However, <code>#guard_msgs</code> does not seem to catch the warnings thrown by the linter, so I do not know how to produce a quiet test verifying, for instance this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">warning: 'skip' tactic does nothing [linter.unusedTactic]</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">skip</span>  <span class=\"c1\">-- the warning is still here!</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>",
        "id": 426707494,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710496187
    },
    {
        "content": "<p>For a minimized example, this suffers from the same issue:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- warning: unused variable `n` [linter.unusedVariables] -/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"c1\">-- warning is still here</span>\n</code></pre></div>",
        "id": 426708303,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710496468
    },
    {
        "content": "<p>see <a href=\"#narrow/stream/348111-std4/topic/.23guard_msgs.20doesn't.20silence.20warnings\">https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/.23guard_msgs.20doesn't.20silence.20warnings</a></p>",
        "id": 426797013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710525993
    },
    {
        "content": "<p>A low key solution could be to have part of the test files to allow warnings but not errors and use #guard_msgs there.</p>",
        "id": 426799136,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710526864
    },
    {
        "content": "<p>If anyone is looking for a speeding up opportunity, the linter at <a href=\"https://github.com/leanprover-community/mathlib4/pull/11308\">#11308</a> causes an 8.5% slowdown (see <a href=\"https://github.com/leanprover-community/mathlib4/pull/11399#issuecomment-1999918796\">this !bench</a>).</p>\n<p>I found that the linter worked well, in that it caught several tactics that were not actually doing anything.  The only possible problem that I can see with it, is the slow down.  Honestly, though, I do not really know what <code>interpretation</code> really means.</p>",
        "id": 427686990,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710852724
    },
    {
        "content": "<p><code>interpretation</code> is time in the lean interpreter, i.e. running your code</p>",
        "id": 427693190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710854648
    },
    {
        "content": "<p>You could use a hashset for <code>allowed</code></p>",
        "id": 427694302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710854995
    },
    {
        "content": "<p>also I think you should make <code>swap_var</code> an <code>allowed</code> tactic, I doubt the bespoke check is worth it</p>",
        "id": 427694625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710855072
    },
    {
        "content": "<p>The structure of the unused tactic linter is also not optimal for this job because you don't care about tactics that are never executed, so you can just look at tacticinfo nodes and not worry about syntax</p>",
        "id": 427695010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710855179
    },
    {
        "content": "<p>Mario, thanks a lot for your comments!</p>\n<p>I was thinking that maybe it makes sense to merge the unreachable and unused tactic linters: do you think that it would be an improvement?</p>",
        "id": 427757631,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710863963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/pointless.20tactic.20linter/near/427694302\">said</a>:</p>\n<blockquote>\n<p>You could use a hashset for <code>allowed</code></p>\n</blockquote>\n<p>This is mostly for developing my intuition: you think that making <code>allowed</code> a <code>HashSet</code> might have a measurable speed improvement?</p>",
        "id": 427758038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1710864062
    },
    {
        "content": "<p>yes</p>",
        "id": 427827835,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710890865
    },
    {
        "content": "<p>because on every tactic you are checking against <code>allowed</code> and failing it is the common case, so that's 1 hash check vs 15 or so equality checks</p>",
        "id": 427827965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710890928
    }
]