[
    {
        "content": "<p>Hello, sorry for not simplifying the below code more. I was not able to reproduce the issue even after minor modifications, so I've left it as is. </p>\n<p>Here is some working code. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.MeasurableSpace.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CountableInterFilter</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlmostMeasurableSpace</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">MeasurableSet'</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">t</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"bp\">=ᶠ</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"n\">t</span>\n  <span class=\"n\">measurableSet_empty</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet.empty</span><span class=\"o\">,</span> <span class=\"n\">EventuallyEq.refl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">measurableSet_compl</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span> <span class=\"n\">ht.compl</span><span class=\"o\">,</span> <span class=\"n\">hts.compl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">measurableSet_iUnion</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">choose</span> <span class=\"n\">t</span> <span class=\"n\">ht</span> <span class=\"n\">hts</span> <span class=\"n\">using</span> <span class=\"n\">hs</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet.iUnion</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">EventuallyEq.countable_iUnion</span> <span class=\"n\">hts</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">AlmostMeasurableSet</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">MeasurableSet</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">AlmostMeasurableSpace</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">MeasurableSet.almostMeasurableSet</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AlmostMeasurableSet</span> <span class=\"n\">l</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">EventuallyEq.refl</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">silly</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">MeasurableSet</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">instMeasurableSingletonClass</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">AlmostMeasurableSpace</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">silly</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">MeasurableSet.singleton</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">almostMeasurableSet</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>To summarize, I define a new measurable space <code>AlmostMeasurableSpace l</code> from a given one <code>m</code> and a filter. I want to prove that the new one inherits the <code>MeasurableSingletonClass</code> property. </p>\n<p>Note the use of the tautological theorem <code>silly</code>. Here's what happens when I try and start proving the last theorem directly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">instMeasurableSingletonClass</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">MeasurableSingletonClass</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">AlmostMeasurableSpace</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"gr\">sorry</span><span class=\"o\">⟩</span> <span class=\"c1\">--error!</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">synthesized type class instance is not definitionally equal to expression inferred by typing rules, synthesized</span>\n<span class=\"cm\">  m</span>\n<span class=\"cm\">inferred</span>\n<span class=\"cm\">  AlmostMeasurableSpace l-/</span>\n</code></pre></div>\n<p>Note that the theorem statement itself does not cause any issues. It is when I write \\langle \\rangle (with the intention of filling it with a proof that singletons are measurable) that the error appears. The same error appears if I try and use <code>where</code>. I would appreciate help understanding this.</p>",
        "id": 421948098,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1708122182
    },
    {
        "content": "<p>Nvm, I realized the answer is to use @MeasurableSingletonClass.mk</p>",
        "id": 421952188,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1708124592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"464202\">Felix Weilacher</span> has marked this topic as resolved.</p>",
        "id": 421952196,
        "sender_full_name": "Notification Bot",
        "timestamp": 1708124597
    },
    {
        "content": "<p>This is indeed pretty annoying, and is a painpoint that we didn't have in Lean 3. Using <code>@MeasurableSingletonClass.mk _ (_) h</code> will probably work for you</p>",
        "id": 421952300,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708124652
    },
    {
        "content": "<p>Note that the <code>()</code> around the <code>_</code> are load-bearing!</p>",
        "id": 421952331,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708124679
    }
]