[
    {
        "content": "<p>In computer algebra systems, one can enter an equation and ask for integer solutions. Sometimes it is solved. But the output is not guaranteed to be correct.</p>\n<p>In Lean, one can formalize the solutions to specific equations, for example, prove that the only integer solutions to y^2=x^3−1 is (x,y)=(1,0).</p>\n<p>I would like to have the best of two words, and be able to enter the equation, and get either message that it is too difficult to be solved, or the description of all its integer solutions VERIFIED BY LEAN.</p>\n<p>The first step is to consider easy equations, say, in one variable. Then all possible solutions are divisors of the free term (if it is not zero). We need to find all divisors and substitute.</p>\n<p>A naive way of doing this is to try to write a computer program (say in Python) where the input is the equation and the output is the Lean code for its solution, which should compile in Lean.</p>\n<p>The question is whether this is a correct way to proceed or is there a better way for doing such things in Lean?</p>\n<p>After all, we are implementing an algorithm for solving one-variable equations in integers. Are there other algorithms implemented in Lean? How this is usually organised? Is there any specific support in Lean for algorithms implementation?</p>\n<p>We may also consider this task as the task of writing new tactic in Lean for solving equations. Can users write new tactics in Lean? Is this the correct way to proceed?</p>",
        "id": 411904950,
        "sender_full_name": "Bogdan Grechuk",
        "timestamp": 1704796026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span></p>",
        "id": 411905783,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1704796269
    },
    {
        "content": "<p>Matiyesevich et al show that the best of all possible worlds (\"type in an equation, get the solutions\") is not possible. You might want to check out the <code>polyrith</code> tactic which is related: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">7</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">11</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">polyrith</span> <span class=\"c1\">-- succeeds</span>\n</code></pre></div>\n<p>It calls out to a sage-math process which gives an informal argument which lean then proves is correct. Note that this works best over fields though (not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>).</p>",
        "id": 411910730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704797791
    },
    {
        "content": "<p>The group in Amsterdam has also been working on formally verified solutions to Diophantine equations, including some tactic support. I guess <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  or <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> can tell a bit more about it.</p>",
        "id": 411911065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704797902
    },
    {
        "content": "<p>This is also on PASE: <a href=\"https://proofassistants.stackexchange.com/questions/2665/implementing-and-verifying-algorithms-for-solving-equations-in-lean\">https://proofassistants.stackexchange.com/questions/2665/implementing-and-verifying-algorithms-for-solving-equations-in-lean</a></p>",
        "id": 411920061,
        "sender_full_name": "Jason Rute",
        "timestamp": 1704801247
    },
    {
        "content": "<p>For single variable equations its very doable indeed, but you should decide what sort of interaction you want, verified code or a tactic. Both should be possible with Lean as it is today.<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=num_dvd_of_is_root#doc\">docs#num_dvd_of_is_root</a> or something similar is the result you are referring to I think.<br>\nThis coupled with a tactic to compute the divisors of a non-zero number and <code>fin_cases</code> (or just cases?) to break into cases for each divisor and <code>norm_num</code> to evaluate would already be quite close to a tactic for solving all single variable equations in integers, you might not need much metaprogramming at all to write it really.</p>\n<p>For multivariate equations, of course it is undecidable in general, and we don't even have an algorithm for curves as far as I know.<br>\nThe example you give first is an elliptic curve.<br>\nGenerally you need quite a bit of theory to implement any algorithm that would provably find all integral points on an elliptic (or more complicated) curve.<br>\nSome specific types of curve are simpler, which include the one you mention, which we did actually write lean code to find all integral solutions to, but we had to write a whole paper about it <a href=\"https://dl.acm.org/doi/10.1145/3573105.3575682\">https://dl.acm.org/doi/10.1145/3573105.3575682</a>!<br>\nThe hard part is of course showing that you have all solutions, in this case we used Mordell-style descent in the class group (though for that example there are likely simpler techniques availiable).</p>",
        "id": 411921584,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704801846
    },
    {
        "content": "<p>I guess I'll post this on SE too?</p>",
        "id": 411921777,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704801938
    },
    {
        "content": "<p>At the moment we're focussing in Amsterdam on building more foundations for future equation solving. But I did talk last month with Joey van Langen who <a href=\"https://research.vu.nl/en/publications/automating-the-modular-method-for-q-curves-to-solve-diophantine-e\">designed a computer algebra-based solver</a> for Diophantine equations, how to adapt this to the interactive theorem proving setting.</p>",
        "id": 411931481,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1704805651
    }
]