[
    {
        "content": "<p>A while ago when preparing some lib for Advent of Code, I provided the Union-Find data structure as a <a href=\"https://github.com/philnguyen/aoc/blob/main/2023/Lib.lean#L583\">state monad(-transformer)</a>, where I needed the state to allow path-compression.</p>\n<p>What I found unsatisfactory was that there was no way to hide the path-compression \"effect\" that the client shouldn't have to worry about. The paper <a href=\"https://www.lri.fr/~filliatr/ftp/publis/puf-wml07.pdf\">A Persistent Union-Find Data Structure</a> suggests the following functional interface (translated to Lean by me):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">UnionFind</span> <span class=\"o\">(</span><span class=\"n\">uf</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">create</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">uf</span> <span class=\"n\">α</span>\n  <span class=\"n\">find</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">uf</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">uf</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">uf</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>The problem with this interface is that it only has an efficient implementation in an impure language, where we can sneak path-compression imperatively behind the scene.</p>\n<p>Do we have any guideline for the cleanest way to provide the Union-Find data structure in a pure FP language, specifically Lean?</p>\n<p>Thanks!!</p>",
        "id": 410226974,
        "sender_full_name": "Phil Nguyen",
        "timestamp": 1703729539
    },
    {
        "content": "<p>Note that mathlib has a union-find implementation at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UnionFind#doc\">docs#UnionFind</a>, and lean4lean has an improved/simplified version at <a href=\"https://github.com/digama0/lean4lean/blob/master/Lean4Lean/UnionFind.lean\">https://github.com/digama0/lean4lean/blob/master/Lean4Lean/UnionFind.lean</a></p>",
        "id": 410228441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703730742
    },
    {
        "content": "<p>This implementation does not attempt to address the problem you are indicating however, the functions that mutate return a mutated version of the original as is normal for other such functions in lean (and it has efficient in-place modification if you use the value linearly)</p>",
        "id": 410228531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703730837
    },
    {
        "content": "<p>It looks like both of those do the obvious FP solution, which is to make <code>find</code> return <code>uf α × α</code> (using the analogous types in this thread). That's the explicit version of hiding the union-find state in a state monad.</p>\n<p>I wonder -- what if union-find type were a quotient type of the UnionFind type by the relation where two terms are equal if they have the same <code>find : uf α → α → α</code>. Could you then cheat by having <code>find</code> be replaced by an implementation that mutates the term under the quotient to do path compression?</p>",
        "id": 410228925,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703731134
    },
    {
        "content": "<p>That's mutable quotients, we investigated that a while ago and IIRC there were issues in getting the compiler to do the right thing. Currently the only hidden mutation we have is the <code>Thunk A</code> type</p>",
        "id": 410229332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703731461
    },
    {
        "content": "<p>I've seen in some papers about persistent data structures that replace a node that may be referenced many times with an equivalent node to keep the amortization analysis valid. It would be great if this could be implemented in Lean.</p>",
        "id": 410436173,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1703858941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Any chance for the L4L implementation to make it into Std?</p>",
        "id": 410472593,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703879925
    },
    {
        "content": "<p>Probably not (it would go to core if anything), but union-find might</p>",
        "id": 410472622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703879952
    },
    {
        "content": "<p>or maybe that's what you mean</p>",
        "id": 410472632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703879963
    },
    {
        "content": "<p>I was asking about union-find.</p>",
        "id": 410472645,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703879974
    },
    {
        "content": "<p>TBH it's looking a bit out of place in mathlib</p>",
        "id": 410472672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703880001
    },
    {
        "content": "<p>I'd be in support of moving it to std, I have some correctness proofs for it too</p>",
        "id": 410472808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703880059
    },
    {
        "content": "<p>Cool! I can do the initial move if that's okay with you.</p>",
        "id": 410473246,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703880258
    },
    {
        "content": "<p>Should I use the L4L version or the Mathlib version?</p>",
        "id": 410473284,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703880298
    },
    {
        "content": "<p>IMO the L4L version, that one is more recent and had various modifications to support the proofs</p>",
        "id": 410473320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703880323
    },
    {
        "content": "<p>Sounds good. I'll get on it.</p>",
        "id": 410473350,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703880350
    },
    {
        "content": "<p>the proofs are in <code>Lean4Lean.Verify.UnionFind</code></p>",
        "id": 410473422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703880395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  I did a raw import that compiles (but doesn't pass the linter yet) at <a href=\"https://github.com/leanprover/std4/pull/489\">std4#489</a>. I'll get back to it tomorrow and I hope to have a PR ready very soon. If you want to add some edits in the mean time that's totally fine by me.</p>",
        "id": 410479067,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703884331
    },
    {
        "content": "<p>All done! <a href=\"https://github.com/leanprover/std4/pull/489\">std4#489</a> is ready for review.</p>",
        "id": 410540466,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703937590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"476925\">Phil Nguyen</span> <a href=\"#narrow/stream/113488-general/topic/Best.20way.20to.20provide.20Union-Find.20in.20Lean.3F/near/410226974\">said</a>:</p>\n<blockquote>\n<p>What I found unsatisfactory was that there was no way to hide the path-compression \"effect\" that the client shouldn't have to worry about. </p>\n</blockquote>\n<p>I tried to implement it. See <a href=\"https://negiizhao.github.io/Algorithm/Algorithm/Data/UnionFind.html#UnionFind\">https://negiizhao.github.io/Algorithm/Algorithm/Data/UnionFind.html#UnionFind</a></p>",
        "id": 439861040,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1716310765
    },
    {
        "content": "<p>UnionFind has been merged into Batteries btw, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Batteries.UnionFind#doc\">docs#Batteries.UnionFind</a></p>",
        "id": 439881411,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716317567
    },
    {
        "content": "<p>It would be great if we could have a hidden mutation version in Batteries too...</p>",
        "id": 440211193,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1716424542
    },
    {
        "content": "<p>IIRC mutable quotients were proposed (by me) and an implementation attempted by Simon Hudon while visiting Leo a while ago, and they ran into some issues getting sound behavior from the compiler, although I forget the exact issues with it</p>",
        "id": 440211463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1716424688
    }
]