[
    {
        "content": "<p>I'm trying to wrap my head around probability monads for discrete measures. I've found <a href=\"https://www.cs.ru.nl/B.Jacobs/PAPERS/probability-monads.pdf\">this paper</a> by Bart Jacobs and <a href=\"https://www.math.harvard.edu/media/JulianAsilisThesis.pdf\">this MSc thesis</a> by Julian Asilis, both of which have been a good help to start, but I wonder if there is any Lean-specific resource out there, or any resources that closely match Lean's PMF monad, in particular.</p>\n<p>I think I've seen <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> mention before that the Giry Monad is impossible in Lean - but I'm not sure I understand why that's the case. Any enlightenment anyone can is appreciated. <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 421182180,
        "sender_full_name": "Ashley Blacquiere",
        "timestamp": 1707804679
    },
    {
        "content": "<p>Not sure it’s relevant, but I did a bunch of finitely supported probability monad stuff for <a href=\"https://github.com/google-deepmind/debate\">https://github.com/google-deepmind/debate</a> and it was very pleasant.</p>",
        "id": 421194283,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707812139
    },
    {
        "content": "<p>The finitely supported case is simpler to work with, since all functions are integrable.</p>",
        "id": 421194415,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707812180
    },
    {
        "content": "<p>Hi Ashley, I would be very surprised if Adam said that, since the Giry monad (either on the category of measurable spaces or that of Polish spaces) is an ordinary piece of mathematics, so of course it’s possible to formalize it in Lean. However, judging from the first paragraph, you’re more interested in the computational/CS aspects of probability monads, for which the classical Giry monad(s) aren’t very useful, as classical measure theory is probably as far from constructive as one can get. </p>\n<p>Incidentally, I’m currently working on a “toy probabilistic programming language” implemented in Lean, whose purpose is mainly to illustrate the concept of a probability monad, for whenever people ask me about it. A first version should be ready soon, I can let you know if you like.</p>",
        "id": 421202142,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1707815312
    },
    {
        "content": "<p>Indeed we already have the Giry monad in mathlib: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasCat.Giry#doc\">docs#MeasCat.Giry</a></p>",
        "id": 421203536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707815894
    },
    {
        "content": "<p>I suspect the Giry monad might be tricky in a simple type theory like Isabelle/HOL, maybe this is where the confusion lies (or maybe I'm just adding to the confusion)</p>",
        "id": 421203703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707815969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"378478\">Ashley Blacquiere</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421182180\">said</a>:</p>\n<blockquote>\n<p>I think I've seen <span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> mention before that the Giry Monad is impossible in Lean - but I'm not sure I understand why that's the case. Any enlightenment anyone can is appreciated. <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>\n</blockquote>\n<p>I don't remember saying this <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> .... On the contrary, I think the Giry monad should make its way to mathlib! Note that the one Kevin mentioned is not the monad of probability measures, but rather <em>all</em> measures.</p>",
        "id": 421237862,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707828797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421202142\">said</a>:</p>\n<blockquote>\n<p>Hi Ashley, I would be very surprised if Adam said that, since the Giry monad (either on the category of measurable spaces or that of Polish spaces) is an ordinary piece of mathematics, so of course it’s possible to formalize it in Lean. However, judging from the first paragraph, you’re more interested in the computational/CS aspects of probability monads, for which the classical Giry monad(s) aren’t very useful, as classical measure theory is probably as far from constructive as one can get. </p>\n<p>Incidentally, I’m currently working on a “toy probabilistic programming language” implemented in Lean, whose purpose is mainly to illustrate the concept of a probability monad, for whenever people ask me about it. A first version should be ready soon, I can let you know if you like.</p>\n</blockquote>\n<p>Concerning this, I wrote a bit of code along these lines here: <a href=\"https://github.com/adamtopaz/lean_pdist\">https://github.com/adamtopaz/lean_pdist</a></p>",
        "id": 421238526,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707829009
    },
    {
        "content": "<p>It's certainly nowhere near a probabalistic programming language, so I would be curious to see what Benedikt has been working on!</p>",
        "id": 421239359,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707829307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"378478\">Ashley Blacquiere</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421182180\">said</a>:</p>\n<blockquote>\n<p>I think I've seen <span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> mention before that the Giry Monad is impossible in Lean - but I'm not sure I understand why that's the case. Any enlightenment anyone can is appreciated. <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>\n</blockquote>\n<p>In Lean, there are two types of monads.  Programming monads (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monad#doc\">docs#Monad</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulMonad#doc\">docs#LawfulMonad</a>) and category theory monads (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Monad#doc\">docs#CategoryTheory.Monad</a>).  The first includes things like <code>Option</code> and the <code>IO</code> monad and supports <code>do</code> notation.  There used to be a programming monad for the Giry monad.  <a href=\"#narrow/stream/113488-general/topic/Giry.20monad.20for.20product.20measures/near/165295693\">5 years ago I said that was impossible</a>  even though it existed at the time, but that was based on a subtlety on my part.  The (programming) Giry Monad was conditional on the functions being measurable, so it wasn't a lawful monad.  (For example, if you tried to do <code>map</code> with a non-measurable function it would be a junk result.)  But that didn't necessarily stop it from being useful as long as you only used it with measurable functions.</p>",
        "id": 421261599,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707836597
    },
    {
        "content": "<p>This looks to be the remnants of the programming Giry Monad: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/GiryMonad.html#The-Giry-monad\">GiryMonad</a> All the monatic operations are implemented, but I guess it isn't an instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monad#doc\">docs#Monad</a>.</p>",
        "id": 421264270,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707837319
    },
    {
        "content": "<p>It can't be an instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monad#doc\">docs#Monad</a> because there's a typeclass assumption on the type you feed in.</p>",
        "id": 421264550,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707837392
    },
    {
        "content": "<p>Ok.  Yes, that makes sense (and goes back to my confusion 5 years ago).</p>",
        "id": 421264812,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707837467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421202142\">said</a>:</p>\n<blockquote>\n<p>Incidentally, I’m currently working on a “toy probabilistic programming language” implemented in Lean, whose purpose is mainly to illustrate the concept of a probability monad, for whenever people ask me about it. A first version should be ready soon, I can let you know if you like.</p>\n</blockquote>\n<p>Thanks for the insight. Definitely interested to take a look at your probabilistic DSL, whenever you are ready to share!</p>",
        "id": 421266505,
        "sender_full_name": "Ashley Blacquiere",
        "timestamp": 1707837955
    },
    {
        "content": "<p>Ok, so in summary about the two Giry Monads in Lean:</p>\n<ul>\n<li>The closest you can get an instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monad#doc\">docs#Monad</a>: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/MeasureTheory/Measure/GiryMonad.html#The-Giry-monad\">GiryMonad</a></li>\n<li>An instance of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Monad#doc\">docs#CategoryTheory.Monad</a>: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasCat.Giry#doc\">docs#MeasCat.Giry</a></li>\n</ul>",
        "id": 421266681,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707837998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421237862\">said</a>:</p>\n<blockquote>\n<p>I don't remember saying this <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> .... On the contrary, I think the Giry monad should make its way to mathlib! Note that the one Kevin mentioned is not the monad of probability measures, but rather <em>all</em> measures.</p>\n</blockquote>\n<p>Sorry,  <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> that was a complete misinterpretation on my part - you were just <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401652610\">referring to the do notation</a> for the Giry monad, which I guess is in line with <span class=\"user-mention\" data-user-id=\"115715\">@Jason Rute</span>s comments?</p>",
        "id": 421267216,
        "sender_full_name": "Ashley Blacquiere",
        "timestamp": 1707838164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421261599\">said</a>:</p>\n<blockquote>\n<p>In Lean, there are two types of monads.  Programming monads (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monad#doc\">docs#Monad</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulMonad#doc\">docs#LawfulMonad</a>) and category theory monads (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Monad#doc\">docs#CategoryTheory.Monad</a>).  The first includes things like <code>Option</code> and the <code>IO</code> monad and supports <code>do</code> notation.  </p>\n</blockquote>\n<p>This is super helpful. I don't know much about category theory, so I wasn't sure that they weren't, in fact, the same thing. Thanks for clarifying.</p>",
        "id": 421267599,
        "sender_full_name": "Ashley Blacquiere",
        "timestamp": 1707838269
    },
    {
        "content": "<p>Oh yes, I did say that :) this is essentially because of what was said above here, that the Giry monad as it appears in mathlib (e.g. Jason's links) require a measurability typeclass hypothesis, so you can't provide a monad instance.</p>",
        "id": 421267612,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707838271
    },
    {
        "content": "<p>So unless <code>do</code> notation is generalized a bit (right now it requires a monad instance), it won't work out of the box.</p>",
        "id": 421267762,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707838322
    },
    {
        "content": "<p>And to be clear, you could implement the same Giry monad implementation with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monad#doc\">docs#Monad</a> that you see programmers write with <a href=\"https://jtobin.io/giry-monad-implementation\">Haskell</a> and <a href=\"https://www.chrisstucchio.com/blog/2016/probability_the_monad.html\">Scala</a>.  It wouldn't be truly a lawful monad but it could still be convenient and/or fun to implement.</p>",
        "id": 421268845,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707838590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421202142\">said</a>:</p>\n<blockquote>\n<p>Incidentally, I’m currently working on a “toy probabilistic programming language” implemented in Lean, whose purpose is mainly to illustrate the concept of a probability monad, for whenever people ask me about it. A first version should be ready soon, I can let you know if you like.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> is also currently working on probabilistic programming in Lean, so you may want to talk to him.</p>",
        "id": 421269152,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1707838669
    },
    {
        "content": "<p>(And in some sense, all computable functions are continuous for the \"natural\" topology on a type, so the non-lawfulness wouldn't be a serious issue in practice I think if you are writing executable probabilistic code.)</p>",
        "id": 421269581,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707838774
    },
    {
        "content": "<p>Yes I'm looking into probabilistic programming. Right now, I'm refining the specifications and skipping most of the proofs. Here is what I can do (<a href=\"https://github.com/lecopivo/SciLean/blob/leancolls/SciLean/Modules/Prob/Distributions/FlipTest.lean\">see the full file</a>):</p>\n<p>Define a probabilistic program</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Rand</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"bp\">~</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">θ</span><span class=\"o\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span>\n    <span class=\"n\">Rand.pure</span> <span class=\"mi\">0</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">Rand.pure</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">θ</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Derive a new probabilistic programs, such that the derivative of the mean of <code>test θ</code> w.r.t. to <code>θ</code> is equal to the mean of <code>fdtest_v1</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fdtest_v1</span> <span class=\"o\">:=</span>\n  <span class=\"n\">derive_mean_fwdDeriv</span> <span class=\"n\">R</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">θ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">test</span> <span class=\"n\">θ</span><span class=\"o\">)</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">enter</span> <span class=\"o\">[</span><span class=\"n\">θ</span><span class=\"o\">,</span><span class=\"n\">dθ</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">test</span>\n\n    <span class=\"n\">rand_AD</span>\n    <span class=\"n\">rand_push_E</span>\n    <span class=\"n\">rand_fdE_as_E</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">θ</span><span class=\"o\">)</span>\n    <span class=\"n\">simp'</span>\n    <span class=\"n\">rand_pull_E</span>\n</code></pre></div>\n<p>Derive closed form formula for the mean of <code>fdtest_v1</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fdtest_v1_mean</span> <span class=\"o\">(</span><span class=\"n\">θ</span> <span class=\"n\">dθ</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fdtest_v1</span> <span class=\"n\">θ</span> <span class=\"n\">dθ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mean</span>\n  <span class=\"n\">rewrite_by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">fdtest_v1</span>\n    <span class=\"n\">rand_compute_mean</span>\n</code></pre></div>\n<p>The random monad is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Rand</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Erased</span> <span class=\"o\">(</span><span class=\"n\">Measure</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"n\">is_prob</span> <span class=\"o\">:</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">μ.out</span>\n  <span class=\"n\">rand</span> <span class=\"o\">:</span> <span class=\"n\">_root_.Rand</span> <span class=\"n\">X</span>   <span class=\"c1\">-- ugh why doesn't mathlib have `Mathlib` namespace?</span>\n</code></pre></div>\n<p>which uses Giry monad(i.e. <code>Measure</code>) for specification and Mathlib's <code>Rand</code> for computation. Currently there is nothing connecting those two and I try to prove stuff under this axiom</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Rand</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.μ</span> <span class=\"bp\">=</span> <span class=\"n\">y.μ</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>Which is effectively saying that all random number generators are the same and you can ignore them.</p>\n<p>It would be great to somehow combine efforts in this direction. I also noticed that <span class=\"user-mention\" data-user-id=\"671979\">@Fabian Zaiser</span>  is interested in Lean and doing probabilistic programming.</p>",
        "id": 421272773,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707839634
    },
    {
        "content": "<p>As mentioned above there are issues in using <code>Measure</code> as a monad. In Lean, you can't even provide instance <code>Monad Measure</code> because <code>Measure</code> consumes only measurable spaces and when proving <code>LawfulMonad</code> you get into trouble with measurability. </p>\n<p>Here is my proposed solution to that, instead of <code>Measure</code> use the continuation(into complete normed spaces) monad:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Distribution</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">action</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n</code></pre></div>\n<p>I call it <code>Distribution</code> as it relates to generalized functions/distributions. The idea is that <code>f : Distribution X</code> is a distribution on <code>X</code> for <code>Y</code>-valued test functions but if you provide <code>φ : (X → Y)</code> that is not a test function then <code>f.action φ</code> is just a zero.</p>\n<p>The great thing is that<code>Distribution</code> is  now <code>Monad</code> and <code>LawfulMonad</code> by <code>rfl</code>.</p>\n<p>You can embed <code>Measure X</code> into <code>Distribution X</code> by:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">_root_.MeasureTheory.Measure.toDistribution</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Distribution</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">φ</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Another great thing is that it is easy to define what a derivative of <code>f : X → Distribution Y</code> should be. Do it in distributional sense.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">distribDeriv</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Distribution</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">dx</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Distribution</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">φ</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fderiv</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"bp\">⟪</span><span class=\"n\">f</span> <span class=\"bp\">·</span><span class=\"o\">,</span> <span class=\"n\">φ</span><span class=\"bp\">⟫</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">dx</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Here is the <a href=\"https://github.com/lecopivo/SciLean/blob/leancolls/SciLean/Modules/Prob/DistribDeriv/Distribution.lean\">file</a> defining <code>Distribution</code> and here is the <a href=\"https://github.com/lecopivo/SciLean/blob/leancolls/SciLean/Modules/Prob/DistribDeriv/DistribDeriv.lean\">file</a> defining <code>distribDeriv</code></p>",
        "id": 421276958,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707840628
    },
    {
        "content": "<p>Very interesting, <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>. My approach is a bit different and only really gives a toy version of probabilistic programming which is only supposed to demonstrate how “do elementary probability theory with monads” (see below for what that’s supposed to mean). In particular, it won’t be useful for any serious statistical applications. But you can solve the Monty Hall problem: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">winCar</span> <span class=\"o\">:</span> <span class=\"n\">random</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">conditionally</span> <span class=\"k\">do</span>  <span class=\"c1\">-- Define event \"winCar\" conditionally.</span>\n  <span class=\"k\">let</span> <span class=\"n\">carDoor</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">UniformDist</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span>  <span class=\"c1\">-- A car is placed uniformly at random behind one of three doors.</span>\n  <span class=\"k\">let</span> <span class=\"n\">initialDoor</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">UniformDist</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span>  <span class=\"c1\">-- You choose a door, uniformly at random.</span>\n  <span class=\"k\">let</span> <span class=\"n\">montysDoor</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">UniformDist</span> <span class=\"o\">((</span><span class=\"n\">Finset.range</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">\\</span> <span class=\"o\">{</span><span class=\"n\">carDoor</span><span class=\"o\">,</span> <span class=\"n\">initialDoor</span><span class=\"o\">})</span>     <span class=\"c1\">-- Monty Hall picks a door (neither your initially chosen door, nor the one with the car).</span>\n  <span class=\"n\">return</span> <span class=\"n\">carDoor</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">|</span> <span class=\"n\">initialDoor</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">montysDoor</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span>  <span class=\"c1\">-- The event that the car is behind Door 1, given that you chose Door 0, and Monty Door 2.</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">MontyHallProblem</span> <span class=\"o\">:</span> <span class=\"n\">Probability</span> <span class=\"n\">winCar</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"bp\">/</span><span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Or a version of the Birthday Paradox: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">numberOfPeople</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"c1\">-- What's the probability that among three people, two of them were born in the same quarter of the year?</span>\n<span class=\"kd\">def</span> <span class=\"n\">twoPeopleWithSameQuarterOfBirth</span> <span class=\"o\">:</span> <span class=\"n\">random</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">IID</span> <span class=\"o\">(</span><span class=\"n\">UniformDist</span> <span class=\"o\">(</span><span class=\"n\">Finset.range</span> <span class=\"mi\">4</span><span class=\"o\">))</span> <span class=\"n\">numberOfPeople</span>\n  <span class=\"n\">return</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">numberOfPeople</span><span class=\"o\">),</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"bp\">∧</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span>\n\n<span class=\"c1\">-- #eval Probability twoPeopleWithSameMonthOfBirth</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">BirthdayParadox</span> <span class=\"o\">:</span> <span class=\"n\">Probability</span> <span class=\"n\">twoPeopleWithSameQuarterOfBirth</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"bp\">/</span><span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The monad is defined as a submonad of the double dualization (a.k.a. continuation monad) for the rationals: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">random</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">expectation</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span>  <span class=\"c1\">-- expectation functional</span>\n  <span class=\"n\">nonnegative</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">expectation</span> <span class=\"n\">f</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n  <span class=\"n\">additive</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span> <span class=\"n\">expectation</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">expectation</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">expectation</span> <span class=\"n\">g</span>\n  <span class=\"n\">normalized</span> <span class=\"o\">:</span> <span class=\"n\">expectation</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Probability</span> <span class=\"o\">(</span><span class=\"n\">event</span> <span class=\"o\">:</span> <span class=\"n\">random</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"n\">event.expectation</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>As a consequence, modeling continuous distributions is not really possible using this \"baby Giry monad\". But given that (anecdotally) even Paul Erdős struggled with the Monty Hall problem, maybe elementary probability theory can already be quite interesting.</p>",
        "id": 421318602,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1707855423
    },
    {
        "content": "<p>Very nice! I'm impressed and confused that those proofs are by <code>rfl</code>. Do you have a repo somewhere with your code I could have a look at?</p>\n<p>I gave up on the <code>nonnegative</code>, <code>additive</code> and <code>normalized</code> conditions and have them under <code>LawfulRand</code>. That way I can keep <code>Rand</code> to be <code>LawfulMonad</code>.</p>",
        "id": 421329780,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707860318
    },
    {
        "content": "<p>I just want to call out Tomas's comment here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rand</span> <span class=\"o\">:</span> <span class=\"n\">_root_.Rand</span> <span class=\"n\">X</span>   <span class=\"c1\">-- ugh why doesn't mathlib have `Mathlib` namespace?</span>\n</code></pre></div>\n<p>and give my extreme endorsement of this sentiment. :-)</p>\n<p>I encourage anyone who disagrees to look at the list of short identifiers Mathlib exports!</p>",
        "id": 421367949,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707884281
    },
    {
        "content": "<p>Is this list easy to find?</p>",
        "id": 421372395,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707887851
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421329780\">said</a>:</p>\n<blockquote>\n<p>Very nice! I'm impressed and confused that those proofs are by <code>rfl</code>. Do you have a repo somewhere with your code I could have a look at?</p>\n</blockquote>\n<p>Can't change the visibility to public at the moment (possibly a browser issue), but if you DM me, I can add you as a collaborator.</p>",
        "id": 421414453,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1707906321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421414453\">said</a>:</p>\n<blockquote>\n<p>Can't change the visibility to public at the moment (possibly a browser issue), but if you DM me, I can add you as a collaborator.</p>\n</blockquote>\n<p>Okay, now it worked. You can find the repo <a href=\"https://github.com/BenediktPeterseim/BabyGiry\">here</a>.</p>",
        "id": 421416276,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1707906912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421372395\">said</a>:</p>\n<blockquote>\n<p>Is this list easy to find?</p>\n</blockquote>\n<p>Found the old gist: <a href=\"https://gist.github.com/semorrison/378c198a657a138c3831f7df8ce1d18f\">https://gist.github.com/semorrison/378c198a657a138c3831f7df8ce1d18f</a></p>\n<p>I think this is Lean+Std+Mathlib jumbled together.</p>",
        "id": 421420114,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707908166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421416276\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421414453\">said</a>:</p>\n<blockquote>\n<p>Can't change the visibility to public at the moment (possibly a browser issue), but if you DM me, I can add you as a collaborator.</p>\n</blockquote>\n<p>Okay, now it worked. You can find the repo <a href=\"https://github.com/BenediktPeterseim/BabyGiry\">here</a>.</p>\n</blockquote>\n<p>Thank you very much! Really nice approach.</p>",
        "id": 421629277,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707994826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626609\">Benedikt Peterseim</span> <a href=\"#narrow/stream/113488-general/topic/Probability.20monad.20resources/near/421202142\">said</a>:</p>\n<blockquote>\n<p>Incidentally, I’m currently working on a “toy probabilistic programming language” implemented in Lean, whose purpose is mainly to illustrate the concept of a probability monad, for whenever people ask me about it. A first version should be ready soon, I can let you know if you like.</p>\n</blockquote>\n<p>With colleagues of mine, we verified a toy \"probabilistic program\" using the Giry monad in Lean3. This was partly meant as  a tutorial on what it means and how it is done. You can <a href=\"https://jtristan.github.io/papers/cpp21.pdf\">read more about it</a> if you're interested and the code is available. These days, I use <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Probability/ProbabilityMassFunction/Monad.lean\">the PMF monad that's already available in mathlib4</a> and supports do notation out of the box.</p>",
        "id": 421749500,
        "sender_full_name": "John Tristan",
        "timestamp": 1708034963
    },
    {
        "content": "<p>Thanks for the pointer!</p>",
        "id": 421810849,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1708071953
    },
    {
        "content": "<p>In case anyone is interested (e.g. <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> , <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  or <span class=\"user-mention\" data-user-id=\"378478\">@Ashley Blacquiere</span>), I have a small update on <code>BabyGiry</code>. It now looks a lot like an actual probabilistic programming language, including an <code>observe</code> statement to condition on events. Here's a Bayesian statistics example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Posterior</span> <span class=\"o\">:</span> <span class=\"n\">Random</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"n\">randomly</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;-~</span> <span class=\"n\">Unif</span> <span class=\"o\">(</span><span class=\"n\">Linspace</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"c1\">-- Let p be uniformly distributed on {0/10, 1/10, ..., 10/10}.</span>\n  <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;-~</span> <span class=\"n\">Binomial</span> <span class=\"mi\">5</span> <span class=\"n\">p</span> <span class=\"c1\">-- Let k be the number of successes in 5 Bernoulli trials with success probability p.</span>\n  <span class=\"n\">observe</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"c1\">-- Observe that k = 3.</span>\n  <span class=\"n\">return</span> <span class=\"n\">p</span>\n\n<span class=\"c1\">-- #eval ℙ[p ≥ 4/10 ∧ p ≤ 6/10 | p ~ Posterior]</span>\n<span class=\"c1\">-- &gt;&gt; (1777 : Rat)/3333</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℙ</span><span class=\"o\">[</span><span class=\"n\">p</span> <span class=\"bp\">≥</span> <span class=\"mi\">4</span><span class=\"bp\">/</span><span class=\"mi\">10</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"mi\">6</span><span class=\"bp\">/</span><span class=\"mi\">10</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"bp\">~</span> <span class=\"n\">Posterior</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">1777</span><span class=\"bp\">/</span><span class=\"mi\">3333</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>The nice thing is that everything actually has a proper mathematical definition -- and can be used in proofs. In contrast to \"real-world\" probabilistic programming, it doesn't use sampling, but directly computes the precise probability. This in turn also makes it inefficient for larger examples, of course. So I guess you can now use Lean to solve every first problem sheet of intro to probability theory ever. Not yet sure what this could be useful for, but I had a lot of fun. :)</p>",
        "id": 425708115,
        "sender_full_name": "Benedikt Peterseim",
        "timestamp": 1710008107
    },
    {
        "content": "<p>Ooh interesting. Thanks for sharing. I still haven't had time to dig more deeply into some of the other details you had added above, but will hopefully examine both more carefully soon.</p>",
        "id": 425710881,
        "sender_full_name": "Ashley Blacquiere",
        "timestamp": 1710010540
    }
]