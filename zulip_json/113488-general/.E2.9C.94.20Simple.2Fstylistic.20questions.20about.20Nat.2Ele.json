[
    {
        "content": "<p>I have a few questions about <code>Nat.le</code> which may be very basic or boil down \"submit a PR\". Mostly they arose from browsing the Lean standard lib in an effort to improve my own coding style. I hope I don't come across as monday-morning-quarterbacking.</p>\n<p><strong>Q1</strong>: Why does  <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/Nat/Basic.lean#L347\"><code>Nat.le.dest</code></a> use recursion on <code>Nat</code>? An alternative is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_dest</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.le.refl</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Nat.le.step</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">k0</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">le_dest</span> <span class=\"n\">h</span>\n  <span class=\"o\">⟨</span><span class=\"n\">k0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">]⟩</span>\n</code></pre></div>\n<p>which happens to be shorter. I'm more interested in whether one or the other is more \"natural\"?</p>\n<p><strong>Q2</strong>: Why doesn't the statement of <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Data/Nat/Basic.lean#L340\"><code>Nat.le_add_right</code></a> use implicit variables? E.g., something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">le_add_right</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">k</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.le_refl</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat.le.step</span> <span class=\"n\">le_add_right</span> <span class=\"c1\">-- version in Basic.lean uses `le_succ_of_le`</span>\n</code></pre></div>\n<p><strong>Q3</strong>: Why does <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L1657\"><code>Nat.le_succ_of_le</code></a> exist given that it is the same as <code>Nat.le.step</code>? If it is for notational uniformity, then why isn't its proof simply <code>Nat.le.step</code>?</p>",
        "id": 410361496,
        "sender_full_name": "Luis O'Shea",
        "timestamp": 1703808526
    },
    {
        "content": "<p>Note, proofs from Init may not be the best choice for studying proof style, they are not maintained as aggressively as Std and moreover constraints due to low dependencies may cause them to be written in an unidiomatic way</p>",
        "id": 410363601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703809673
    },
    {
        "content": "<p>Q1: I think your proof is fine, it is exposing a bit more implementation details of <code>Nat.le</code> but this seems fine to me given that we are in the middle of setting up the API for the relation. And it is indeed shorter than the <code>Nat.ble</code> inspired proof in Init</p>",
        "id": 410363957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703809854
    },
    {
        "content": "<p>Q2: It is conventional to use explicit variables for arguments which are not implied by later arguments. In other words, if you write <code>have := Nat.le_add_right a b</code> passing in all explicit arguments and without expected type, this should be fully unified without any remaining metavariables</p>",
        "id": 410364234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703810016
    },
    {
        "content": "<p>It is true that you also often want to use a theorem like this with known expected type, in which case you can use <code>Nat.le_add_right ..</code> to make all the arguments implicit, but maybe we might also want a version of the function with implicit arguments already. It's a judgment call though, since we don't want to duplicate everything</p>",
        "id": 410364425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703810117
    },
    {
        "content": "<p>Q3: <code>Nat.le.step</code> uses the inductive type <code>Nat.le</code>, which is an implementation detail. Outside of a small number of theorems about it we don't want this type to show up in proofs. But along similar lines as Q1, I think it would be fine to use it here since <code>Nat.le_succ_of_le</code> is one of the API theorems for the type, and I'm sure it wasn't used simply because either the author was thinking of it in higher level terms (the given proof is also quite natural) or because it was the result of refactoring and <code>Nat.le</code> was not the definition at the time</p>",
        "id": 410364887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703810331
    },
    {
        "content": "<p>Why isn't the type called <code>Nat.LE</code>?</p>",
        "id": 410406437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703839695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> : Thank you for your answers to all three questions. They were vey helpful.  If I correctly understand your comments about Q1 and Q3, the way to think about <code>LE Nat</code> is that it happens to be implemented as an inductive type today, but, as you say, that is an implementation detail. It might have been implemented as <code>∃ k, x + k = y</code>. The way theorems the library are structured is that they start with the definition of inequality followed by the \"API theorems\". Once the API is done, further theorems should rely only on the API (and subsequent theorems) and not on the implementation details. In other words, <code>Nat.le</code> should be considered \"private\". (As it happens, is there any way in Lean of not exporting the implementation details, which would force me to use the API?)</p>",
        "id": 410440412,
        "sender_full_name": "Luis O'Shea",
        "timestamp": 1703861880
    },
    {
        "content": "<p>You could use <code>opaque</code>, but it's a bit messy to set up and also sometimes blocks desirable proofs by <code>rfl</code>. (This is less of an issue for <code>Nat.le</code> because it's a proposition and inductive type meaning it doesn't have many defeqs to begin with, but for example <code>a &lt; b</code> being definitionally equal to <code>a + 1 &lt;= b</code> is exploited in mathlib and can be considered a piece of the public API.)</p>",
        "id": 410440807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703862089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'm sure this type was on my list of core definitions that don't follow the naming convention (<a href=\"https://github.com/leanprover/lean4/pull/1897\">lean4#1897</a>) - but no! I guess I missed that one</p>",
        "id": 410441384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703862434
    },
    {
        "content": "<p>Isn't it mentioned there?</p>\n<blockquote>\n<p>I considered but did not rename Ne -&gt; NE. The rationale is that it is an acronym, matching the distinction between Eq and LE. Discuss.</p>\n</blockquote>",
        "id": 410443297,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703863618
    },
    {
        "content": "<p>That's about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ne#doc\">docs#Ne</a>, not <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le#doc\">docs#Nat.le</a></p>",
        "id": 410443345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703863642
    },
    {
        "content": "<p>But the second sentence? Were you not saying you had some reason why Eq and LE shouldn't match or am I misunderstanding the implication there</p>",
        "id": 410443468,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703863702
    },
    {
        "content": "<p>I guess this all stems from LE.le being deliberately \"wrong\"</p>",
        "id": 410443470,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703863704
    },
    {
        "content": "<p>And so Nat.le is stuck between following the rules or following LE.le</p>",
        "id": 410443508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703863731
    },
    {
        "content": "<p>Ohh sorry, I see, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LE#doc\">docs#LE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le#doc\">docs#Nat.le</a>, never mind me.</p>",
        "id": 410443534,
        "sender_full_name": "Julian Berman",
        "timestamp": 1703863749
    },
    {
        "content": "<p>LE.le is a structure field though, it seems like those might get a special rule</p>",
        "id": 410443543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703863753
    },
    {
        "content": "<p>Nat.le is an inductive type itself, I think this is more unambiguously wrong and should be Nat.LE</p>",
        "id": 410443577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703863783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242206\">Luis O'Shea</span> has marked this topic as resolved.</p>",
        "id": 410655569,
        "sender_full_name": "Notification Bot",
        "timestamp": 1704051683
    }
]