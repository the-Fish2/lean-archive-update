[
    {
        "content": "<p>In implementing a 2D Array indexing operation, I'm stuck at how to substitute a let binding like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">get</span>\n  <span class=\"o\">(</span><span class=\"n\">mat</span> <span class=\"o\">:</span> <span class=\"n\">Mat</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i_m</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">i_n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span>\n  <span class=\"k\">let</span> <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">idx</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mat.arr.size</span> <span class=\"o\">:=</span>\n       <span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">pred_n</span> <span class=\"o\">:=</span> <span class=\"n\">n_succ_pred_n</span> <span class=\"bp\">▸</span> <span class=\"n\">this</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">idx</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">pred_n</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"c1\">-- here</span>\n        <span class=\"gr\">sorry</span>\n  <span class=\"n\">mat.arr.get</span> <span class=\"o\">⟨</span><span class=\"n\">idx</span><span class=\"o\">,</span> <span class=\"n\">isLt</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>It's not an equality, so I can't use <code>Eq.subst</code> or the <code>rw</code> tactic.</p>",
        "id": 410715329,
        "sender_full_name": "Nikolai Morin",
        "timestamp": 1704108364
    },
    {
        "content": "<p><code>rfl</code> should work</p>",
        "id": 410715459,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704108486
    },
    {
        "content": "<p>If I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"n\">idx</span> <span class=\"bp\">=</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>then <code>rfl</code> complains</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">HEq.rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">HEq</span> <span class=\"bp\">?</span><span class=\"n\">m.3990</span> <span class=\"bp\">?</span><span class=\"n\">m.3990</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">↑</span><span class=\"n\">i_m</span><span class=\"bp\">✝</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">i_n</span><span class=\"bp\">✝</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">i_m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"bp\">↑</span><span class=\"n\">i_n</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>I guess the cross means it's a shadowed variable? I didn't redefine <code>i_m</code> or <code>i_n</code> though. Here's the full function in case that's relevant:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>full function</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>structure Mat (m : Nat) (n : Nat) (α : Type) where<br>\n  arr : Array α<br>\n  size_ok : arr.size = m * n<br>\nderiving Repr</p>\n<p>def get<br>\n  (mat : Mat m n α)<br>\n  (i_m : Fin m)<br>\n  (i_n : Fin n)<br>\n: α :=<br>\n  let idx : Nat := i_m.val * n + i_n.val<br>\n  let isLt : idx &lt; mat.arr.size :=<br>\n    match m with<br>\n    | .zero =&gt; absurd i_m.isLt (Nat.not_lt_zero i_m.val)<br>\n    | .succ pred_m =&gt;<br>\n      have hm₁ : i_m.val ≤ pred_m := Nat.le_of_lt_succ i_m.isLt<br>\n      have hm₂ : i_m.val * n ≤ pred_m * n := Nat.mul_le_mul_right n hm₁<br>\n      match n_succ_pred_n : n with<br>\n      | .zero =&gt; absurd i_n.isLt (Nat.not_lt_zero i_n.val)<br>\n      | .succ pred_n =&gt;<br>\n        have : i_n.val ≤ pred_n := Nat.le_of_lt_succ i_n.isLt<br>\n        have : i_m.val * Nat.succ pred_n + i_n.val ≤ pred_m * Nat.succ pred_n + pred_n :=<br>\n          Nat.add_le_add hm₂ this<br>\n        have : i_m.val * n + i_n.val ≤ pred_m * n + pred_n := n_succ_pred_n ▸ this<br>\n        have aux : idx = i_m.val * n + i_n.val := by simp; rfl<br>\n        -- have : idx ≤ pred_m * n + pred_n := rfl<br>\n        sorry<br>\n  mat.arr.get ⟨idx, isLt⟩</p>\n</div></div>",
        "id": 410715784,
        "sender_full_name": "Nikolai Morin",
        "timestamp": 1704108842
    },
    {
        "content": "<p>You should learn how to write functioning that someone can just paste to see what the problem is. Please see <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 410715901,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704108952
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Sorry, I've now added the missing <code>Mat</code> definition to my previous post and verified that it's self-contained.</p>",
        "id": 410716090,
        "sender_full_name": "Nikolai Morin",
        "timestamp": 1704109111
    },
    {
        "content": "<p>Oh I see, the problem is that the subsequent <code>match</code> creates new variables <code>i_m</code> and <code>i_n</code> instead of changing the type of the old ones but it doesn't create a new <code>let</code> binding for <code>idx</code> either. That's a bit dumb.</p>",
        "id": 410716338,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704109342
    },
    {
        "content": "<p>This works, however,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Mat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n<span class=\"n\">size_ok</span> <span class=\"o\">:</span> <span class=\"n\">arr.size</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">get</span>\n<span class=\"o\">(</span><span class=\"n\">mat</span> <span class=\"o\">:</span> <span class=\"n\">Mat</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">i_m</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">i_n</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span>\n<span class=\"k\">have</span> <span class=\"n\">aux</span> <span class=\"o\">:</span> <span class=\"n\">idx</span> <span class=\"bp\">=</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"k\">let</span> <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">idx</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mat.arr.size</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">absurd</span> <span class=\"n\">i_m.isLt</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">i_m.val</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">pred_m</span> <span class=\"bp\">=&gt;</span>\n<span class=\"k\">have</span> <span class=\"n\">hm₁</span> <span class=\"o\">:</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_m</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le_of_lt_succ</span> <span class=\"n\">i_m.isLt</span>\n<span class=\"k\">have</span> <span class=\"n\">hm₂</span> <span class=\"o\">:</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.mul_le_mul_right</span> <span class=\"n\">n</span> <span class=\"n\">hm₁</span>\n<span class=\"k\">match</span> <span class=\"n\">n_succ_pred_n</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">absurd</span> <span class=\"n\">i_n.isLt</span> <span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span> <span class=\"n\">i_n.val</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"n\">pred_n</span> <span class=\"bp\">=&gt;</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">i_n.val</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.le_of_lt_succ</span> <span class=\"n\">i_n.isLt</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">pred_n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_m</span> <span class=\"bp\">*</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">pred_n</span> <span class=\"bp\">+</span> <span class=\"n\">pred_n</span> <span class=\"o\">:=</span>\n<span class=\"n\">Nat.add_le_add</span> <span class=\"n\">hm₂</span> <span class=\"n\">this</span>\n<span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">i_m.val</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">i_n.val</span> <span class=\"bp\">≤</span> <span class=\"n\">pred_m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">pred_n</span> <span class=\"o\">:=</span> <span class=\"n\">n_succ_pred_n</span> <span class=\"bp\">▸</span> <span class=\"n\">this</span>\n<span class=\"c1\">-- have : idx ≤ pred_m * n + pred_n := rfl</span>\n<span class=\"gr\">sorry</span>\n<span class=\"n\">mat.arr.get</span> <span class=\"o\">⟨</span><span class=\"n\">idx</span><span class=\"o\">,</span> <span class=\"n\">isLt</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 410716399,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704109412
    },
    {
        "content": "<p>Thanks. Is there a way to preserve the old variables (like <code>n</code>) when matching?</p>",
        "id": 410717837,
        "sender_full_name": "Nikolai Morin",
        "timestamp": 1704110607
    }
]