[
    {
        "content": "<p>As part of the lean fro roadmap, I am working on a feature that can greatly simplify proving things about recursive functions.</p>\n<p>If your function is <em>structurally</em> recursive, then normal <code>induction</code> on the decreasing parameter works fine. But if the function isn’t, things often get hairy: You often have to replicate the function’s case using <code>split</code>s, navigating to the recursive calls, and to get your induction hypothesis for the recursive calls you often have to recreate the full termination argument and proof (e.g. using <code>termination_by</code>) in every theorem.</p>\n<p>With this feature you will get a an induction principle that exactly captures the structure of your recursive function, with one subgoal per branch of the function, and the induction hypthesis provided exactly for the arguments to the recursive calls. For example, given</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ackermann</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ackermann</span> <span class=\"n\">n</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ackermann</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ackermann</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>you’ll get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">ackermann.induct</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">ackermann</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">m</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>This also works for mutual and nested recursion, for example for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Tree</span> <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span>\n<span class=\"kd\">def</span> <span class=\"n\">Tree.rev</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"n\">Tree</span> <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">ts</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">ts.attach.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">_ht</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t.rev</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">reverse</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>you’ll get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Tree.rev.induct</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">ts</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Tree</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">),</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"n\">ts</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Tree.node</span> <span class=\"n\">ts</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Tree</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>Here is an example proof using one of these induction principles (not the best example, because <code>induction n</code> would work here as well, but still):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ackermann_pos</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ackermann</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"n\">using</span> <span class=\"n\">ackermann.induct</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ackermann</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"c1\">-- reduce function application</span>\n  <span class=\"n\">case</span> <span class=\"n\">case1</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.zero_lt_succ</span> <span class=\"n\">m</span>\n  <span class=\"n\">case</span> <span class=\"n\">case2</span> <span class=\"n\">n</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">IH</span>\n  <span class=\"n\">case</span> <span class=\"n\">case3</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">_IH1</span> <span class=\"n\">IH2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">IH2</span>\n</code></pre></div>\n<p>A larger, realistic example, including mutual recursion and a notable reduction in size and proof complexity, can be found on <a href=\"https://github.com/cedar-policy/cedar-spec/pull/211/files#diff-37f86f67bcc5afdfa1908e9a77627a987adb5b85d1232ba882f42fd0ca48588f\">the Cedar repo</a>.</p>\n<p>Eventually, this should work out of the box (as it already does in Isabelle and others), but before I move my prototype (currently at <a href=\"https://github.com/nomeata/lean-wf-induct\">https://github.com/nomeata/lean-wf-induct</a>) into lean I’d like to collect more user feedback and get more testing. So if you are using well-founded recursion in your Lean work and are eager to get your hands early on this tool (or just want to help), that would be greatly appreciated.</p>\n<p>To use this, add</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">require</span> <span class=\"n\">wfinduct</span> <span class=\"k\">from</span> <span class=\"n\">git</span>\n  <span class=\"s2\">\"https://github.com/nomeata/lean-wf-induct\"</span>\n</code></pre></div>\n<p>to your <code>lakefile.lean</code>, use the command</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">derive_induction</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>after you defined your function <code>foo</code>, and then you can use <code>induction x, y, z using foo.induct</code>.</p>\n<p>Also let me know if you have trouble getting <code>wfinduct</code> to work with your particular version of lean.</p>",
        "id": 420628765,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707476338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> if there is interest from Mathlib users it seems reasonable we could add this as a dependency there. This project has a pretty short half-life before it is absorbs into Lean, so it's not a long-term commitment.</p>",
        "id": 420654950,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707486259
    },
    {
        "content": "<p>Is it a easy generalization to produce a version where <code>motive .. : Sort u</code> instead of <code>Prop</code>? Or is that an ill-defined request?</p>",
        "id": 420661111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707488281
    },
    {
        "content": "<p>Not sure about easy, and I don’t know it would reduce usefully, also and not sure how hard it will be to provide equational lemmas. But besides that it’s very likely doable.  Do you have a concrete application in mind?</p>",
        "id": 420663609,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1707489104
    },
    {
        "content": "<p>A contrived case would be a function with a return type of <code>Fin (ackermann m n)</code> that I want to compute via the same recursion pattern, but I indeed don't have a concrete application right now</p>",
        "id": 420681410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707494360
    },
    {
        "content": "<p>Perhaps a better justification is that if such a <code>Sort</code>-valued function existed, it could perhaps be used in the compilation of <code>ackermann</code> itself.</p>",
        "id": 420681520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707494395
    }
]