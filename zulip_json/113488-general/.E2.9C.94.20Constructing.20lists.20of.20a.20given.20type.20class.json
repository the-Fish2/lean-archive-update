[
    {
        "content": "<p>I'm new to Lean and to Dependent Type Theory. Hence, my question is perhaps not quite specific to Lean, but functional programming with dependent types.</p>\n<p>I have a type class M such that every instance <code>A</code> of this type class <code>M</code> has a function <code>fm: A -&gt; Int</code>.<br>\nIs it possible to create a <code>List</code> of <code>M</code>s? In other words, I'd like to define a \"type\" <code>List M</code>. But since <code>M</code> is actually a type class, and not a type, I was wondering if there was a way around this. In Julia (the programming language I'm most used to),  this can be done using subtypes. I can define an abstract type <code>M</code>, such that an \"instance\" of <code>M</code> is just a subtype of <code>M</code>. Thus, the <code>List M</code> is a valid abstract type.</p>",
        "id": 443283664,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717761821
    },
    {
        "content": "<p>i'm not sure i get your question... what do you mean when you say an instance <code>A</code> of the type class <code>M</code>? it seems like you're saying you want to interpret a value with type <code>M</code> as a type itself? or do you perhaps rather mean that <code>fm (A:M) : Int</code> holds? (making the signature of <code>fm: M -&gt; Int</code>?</p>",
        "id": 443289724,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717763906
    },
    {
        "content": "<p>a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> would help explain what you want to know</p>",
        "id": 443289777,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717763929
    },
    {
        "content": "<p>or prehaps you were thinking of <code>fm : [M A] -&gt; A -&gt; Int</code>?</p>",
        "id": 443294224,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717765390
    },
    {
        "content": "<p>Here is an example. I'm implementing a type class <code>M</code> and making <code>Nat</code> and <code>String</code> instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>My question is if I can define stuff like a <code>List M</code>, where the elements are each a value of an instance of <code>M</code>. For example <code>[1, \"example\", 3]</code> would be a term of type <code>List M</code>, since both <code>String</code> and <code>Int</code> are instances of <code>M</code>.</p>",
        "id": 443302490,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717768207
    },
    {
        "content": "<p>The thing is then, if I have a \"<code>List M</code>\" , I know that I can pass a mapping function over such list using <code>M.fm</code> in each element, and this would get me a <code>List Int</code>.</p>",
        "id": 443302732,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717768291
    },
    {
        "content": "<p>i don't think that is possible in the exact way you want it to... what is the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here?<br>\nthat aside, i think there is a misunderstanding here as to what it means to have an instance of a typeclass.<br>\nif <code>M</code> is a typeclass (which in your case can be denoted as having a type <code>Type -&gt; Type</code>), then for there to be an instance of that typeclass for some type <code>A</code>, means that there is a value of <code>M A</code>. in your case, you do this for <code>String</code> by telling Lean how to construct the field <code>M.fm</code>, meaning that there is some function <code>String -&gt; Int</code>. </p>\n<p>if you <em>really</em> <em>really</em> need to be able to store them in a single list, there are two options.</p>\n<ul>\n<li>If you know ahead of time that you will only want to store <code>Nat</code> or <code>String</code> (or some other specific collection of types) in the same list, use an inductive pattern:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"n\">ofString</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">ofString</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>note that you need to split into cases of which constructor you use to define a function depending on the value of <code>M</code>.</p>\n<ul>\n<li>if you want to make some kind of api which will be able to treat arbitrary types the same way, you can do the following, which i higly discourage, particularly for someone unfamiliar with type theories:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toInt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"n\">inst</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 443311413,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717770991
    },
    {
        "content": "<p>particularly a drawback for the second approach is that you cannot compare all elements of <code>M</code></p>",
        "id": 443313127,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717771483
    },
    {
        "content": "<p>The use case is the following, suppose I have a type class<code>Render</code>, which is used to express whether a certain type can be rendered, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">Render</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">render</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Drawing</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">Render</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">render</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Drawing.mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String.append</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String.append</span><span class=\"w\"> </span><span class=\"s2\">\"&lt;text&gt;\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"&lt;/text&gt;\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The idea then is to create a list of value that have renderable types. Now, the situation is actually your second example. I want to be able to create new renderable types.  Perhaps there is a smart way that does not requires typeclasses. This way of doing it was natural to me, because I came from Julia, and Julia code design focuses on multiple dispatch (using types and subtypes to specialize functions).</p>",
        "id": 443331308,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717778707
    },
    {
        "content": "<p>The idea is that users should be able to create new types and make them renderable. For example, a user can create a type <code>House</code> and a type <code>Tree</code>, and make both of them instances of <code>Render</code> by defining the render function. Then, to \"draw\" a house with a tree in front would be to define a list <code>[house, tree]</code> where <code>house</code> is of type <code>House</code> and <code>tree</code> of type <code>Tree</code>. Since both types would be of class <code>Render</code>, then <code>[house, tree]</code> by passing the <code>Render.render</code> to the elements in the list, and then appending the strings, we would get something like an SVG specification:</p>\n<div class=\"codehilite\" data-code-language=\"svg\"><pre><span></span><code>&lt;path&gt; ... &lt;/path&gt; # drawing a house using SVG spec\n&lt;path&gt; ... &lt;/path&gt;# drawing a tree using SVG spec\n</code></pre></div>",
        "id": 443332080,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717778966
    },
    {
        "content": "<p>I guess <a href=\"http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP\">here</a> is how one does this in Haskell.</p>",
        "id": 443333771,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717779596
    },
    {
        "content": "<p>Elaborating on <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>'s second point, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MInterface</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">fm</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"s2\">\"example\"</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">3</span><span class=\"bp\">⟩</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 443336789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1717780607
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> . Does it also have the drawbacks, as pointed by <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> ?</p>",
        "id": 443337081,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717780690
    },
    {
        "content": "<p>Edited above</p>",
        "id": 443337149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1717780714
    },
    {
        "content": "<p>Yeah, this looks similar to how I got it to work in Julia, and also similar to existential types in Haskell.</p>",
        "id": 443337419,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717780802
    },
    {
        "content": "<p>Yes, the drawbacks are the same</p>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113488-general/topic/Constructing.20lists.20of.20a.20given.20type.20class/near/443313127\">said</a>:</p>\n<blockquote>\n<p>particularly a drawback for the second approach is that you cannot compare all elements of <code>M</code></p>\n</blockquote>\n<p>Well, you can compare their <code>toInt</code>s!</p>",
        "id": 443337487,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1717780810
    },
    {
        "content": "<p>Would this structure be highly discouraged due to not allowing comparison? Or there is some other reason? I'm not well versed in type theory, my background in FP is mostly category theory.</p>",
        "id": 443337989,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717780979
    },
    {
        "content": "<p>In the link I posted, this type of structure was used as an example to define a renderer on arbitrary types, which is what I need... But if there is a better more robust way of doing it, I'd love to know.  <a href=\"http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP\">Here.</a></p>",
        "id": 443338155,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717781034
    },
    {
        "content": "<p>I think probably you should just try it and see</p>",
        "id": 443340561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1717781827
    },
    {
        "content": "<p>Thanks both of you! This has helped a ton. Indeed this reproduces the behavior I'm looking for. Glad to know it is fully doable in LEAN.</p>",
        "id": 443342005,
        "sender_full_name": "Davi Sales Barreira",
        "timestamp": 1717782452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"709428\">Davi Sales Barreira</span> has marked this topic as resolved.</p>",
        "id": 443342014,
        "sender_full_name": "Notification Bot",
        "timestamp": 1717782457
    }
]