[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/djb's.20formalization.20of.20McEliece/near/384313356\">said</a>:</p>\n<blockquote>\n<p>But if lean had a proof mode like HOL light's <code>e(...)</code> steps broken out as separate lean commands then you would certainly get back the speed benefits you are seeing in HOL Light</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/djb's.20formalization.20of.20McEliece/near/384313940\">said</a>:</p>\n<blockquote>\n<p>now I think I want to try to demo something like that in lean</p>\n</blockquote>\n<p>Here's what I was talking about <span class=\"user-mention\" data-user-id=\"630204\">@D. J. Bernstein</span> : This is a prototype implementation of a \"proof mode\" in which you can save the context of a proof in a <code>by</code> block by writing <code>start_proof</code>, and then you can start writing tactics in separate commands thereafter using <code>##</code> before each tactic (or group of tactics). Because lean automatically snapshots between commands, you get the benefits of a line-by-line proof like in Coq or HOL light in terms of general responsiveness. This may be considered as an alternative to the <code>save</code> tactic, which tries to do something similar but without linearizing the AST structure.</p>",
        "id": 384324558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691862732
    },
    {
        "content": "<p><code>Mathlib.Tactic.ProofMode</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">ProofState</span> <span class=\"n\">where</span>\n  <span class=\"n\">tacCtx</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Tactic.Context</span>\n  <span class=\"n\">tacState</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Tactic.State</span>\n  <span class=\"n\">termCtx</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.Context</span>\n  <span class=\"n\">termState</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Term.State</span>\n  <span class=\"n\">metaCtx</span> <span class=\"o\">:</span> <span class=\"n\">Meta.Context</span>\n  <span class=\"n\">metaState</span> <span class=\"o\">:</span> <span class=\"n\">Meta.State</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ProofState.get</span> <span class=\"o\">:</span> <span class=\"n\">Elab.Tactic.TacticM</span> <span class=\"n\">ProofState</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">tacCtx</span> <span class=\"n\">tacState</span> <span class=\"n\">termCtx</span> <span class=\"n\">termState</span> <span class=\"n\">metaCtx</span> <span class=\"n\">metaState</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">tacState</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">tacState.get</span>\n    <span class=\"k\">let</span> <span class=\"n\">termState</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">termState.get</span>\n    <span class=\"k\">let</span> <span class=\"n\">metaState</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">metaState.get</span>\n    <span class=\"n\">return</span> <span class=\"o\">{</span> <span class=\"n\">tacCtx</span><span class=\"o\">,</span> <span class=\"n\">tacState</span><span class=\"o\">,</span> <span class=\"n\">termCtx</span><span class=\"o\">,</span> <span class=\"n\">termState</span><span class=\"o\">,</span> <span class=\"n\">metaCtx</span><span class=\"o\">,</span> <span class=\"n\">metaState</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ProofState.with</span> <span class=\"o\">:</span> <span class=\"n\">ProofState</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Elab.Tactic.TacticM</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">CoreM</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"o\">{</span> <span class=\"n\">tacCtx</span><span class=\"o\">,</span> <span class=\"n\">tacState</span><span class=\"o\">,</span> <span class=\"n\">termCtx</span><span class=\"o\">,</span> <span class=\"n\">termState</span><span class=\"o\">,</span> <span class=\"n\">metaCtx</span><span class=\"o\">,</span> <span class=\"n\">metaState</span> <span class=\"o\">}</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">tacState</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">IO.mkRef</span> <span class=\"n\">tacState</span>\n    <span class=\"k\">let</span> <span class=\"n\">termState</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">IO.mkRef</span> <span class=\"n\">termState</span>\n    <span class=\"k\">let</span> <span class=\"n\">metaState</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">IO.mkRef</span> <span class=\"n\">metaState</span>\n    <span class=\"n\">x</span> <span class=\"n\">tacCtx</span> <span class=\"n\">tacState</span> <span class=\"n\">termCtx</span> <span class=\"n\">termState</span> <span class=\"n\">metaCtx</span> <span class=\"n\">metaState</span>\n\n<span class=\"n\">initialize</span> <span class=\"n\">proofStateExt</span> <span class=\"o\">:</span> <span class=\"n\">EnvExtension</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">ProofState</span><span class=\"o\">)</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">registerEnvExtension</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"o\">[])</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"start_proof\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">state</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">ProofState.get</span>\n  <span class=\"n\">modifyEnv</span> <span class=\"o\">(</span><span class=\"n\">proofStateExt.modifyState</span> <span class=\"bp\">¬∑</span> <span class=\"o\">(</span><span class=\"n\">state</span> <span class=\"o\">::</span> <span class=\"bp\">¬∑</span><span class=\"o\">))</span>\n  <span class=\"n\">Elab.Tactic.evalTactic</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">repeat</span> <span class=\"gr\">sorry</span><span class=\"o\">))</span>\n\n<span class=\"n\">elab</span> <span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"s2\">\"##\"</span> <span class=\"n\">tac</span><span class=\"o\">:(</span><span class=\"n\">tacticSeq</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">state</span> <span class=\"o\">::</span> <span class=\"n\">rest</span> <span class=\"o\">:=</span> <span class=\"n\">proofStateExt.getState</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"n\">getEnv</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"proof mode not started, use `start_proof`\"</span>\n  <span class=\"n\">Elab.Command.liftTermElabM</span> <span class=\"k\">do</span>\n    <span class=\"n\">state.with</span> <span class=\"k\">do</span>\n      <span class=\"n\">Elab.Tactic.withTacticInfoContext</span> <span class=\"n\">tk</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">tac</span> <span class=\"o\">:=</span> <span class=\"n\">tac</span> <span class=\"k\">then</span>\n          <span class=\"n\">Elab.Tactic.evalTactic</span> <span class=\"n\">tac</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"n\">Elab.Tactic.getUnsolvedGoals</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span> <span class=\"k\">then</span>\n        <span class=\"n\">logInfoAt</span> <span class=\"n\">tk</span> <span class=\"s2\">\"Goals accomplished üéâ\"</span>\n        <span class=\"n\">modifyEnv</span> <span class=\"o\">(</span><span class=\"n\">proofStateExt.setState</span> <span class=\"bp\">¬∑</span> <span class=\"n\">rest</span><span class=\"o\">)</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">modifyEnv</span> <span class=\"o\">(</span><span class=\"n\">proofStateExt.setState</span> <span class=\"bp\">¬∑</span> <span class=\"o\">((</span><span class=\"bp\">‚Üê</span> <span class=\"n\">ProofState.get</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">rest</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 384324747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691862802
    },
    {
        "content": "<p>test file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.ProofMode</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">start_proof</span> <span class=\"c1\">-- this pushes the current proof state (note, it doesn't work in `example`)</span>\n\n<span class=\"bp\">##</span> <span class=\"c1\">-- cursor here to see proof state</span>\n<span class=\"bp\">##</span> <span class=\"n\">refine</span> <span class=\"n\">Nat.lt_succ_self</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"c1\">-- you can write a tactic or tactic block here</span>\n<span class=\"bp\">##</span> <span class=\"n\">exact</span> <span class=\"mi\">1</span> <span class=\"c1\">-- when the goal is finished, it pops the proof state and reports \"Goals accomplished üéâ\"</span>\n</code></pre></div>",
        "id": 384324958,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691862889
    },
    {
        "content": "<p>It would be nice to get some experience reports with this from people who like to write long tactic proofs and struggle to keep things responsive</p>",
        "id": 384335780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691866936
    },
    {
        "content": "<p>Will try with my next Lean project, thanks!</p>",
        "id": 384337699,
        "sender_full_name": "D. J. Bernstein",
        "timestamp": 1691867843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/proof.20mode.3A.20split.20out.20tactics.20into.20separate.20commands/near/384335780\">said</a>:</p>\n<blockquote>\n<p>It would be nice to get some experience reports with this from people who like to write long tactic proofs and struggle to keep things responsive</p>\n</blockquote>\n<p>I just tried it on my long-running crypto proof (~35 tactic calls, most of the long ones are simp only calls on a bunch of hypotheses, runs in about 200 seconds on my laptop)</p>\n<ul>\n<li>Tactic processing restarts from the point of my last edit, not the beginning <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </li>\n<li>I can see about how long each tactic call is taking without any other kind of profiling, frankly this alone makes it a useful tool.</li>\n<li>Works on the tactics defined in my project as well as standard mathlib tactics</li>\n</ul>\n<p>I am not being able to see the actual proof state, it perpetually says \"loading messages\". (This was already a problem for this codebase - it was taking a long time to update the info view as I moved my cursor around, but now it just doesn't show things at all). Still, tactics like <code>polyrith</code> I can see the output by mousing over, so it's clear the tactics are being run.</p>",
        "id": 412535947,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1705062771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> Can you make a MWE for the loading issue? Or a project I can pull</p>",
        "id": 412579262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705077121
    },
    {
        "content": "<p>After VSCode froze and I rebooted it, I'm not actually getting the perpetual loading problem anymore.</p>",
        "id": 412580766,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1705077538
    },
    {
        "content": "<p>It's still slow to change the infoview when moving the cursor, but that was the case before I added start_proof. I haven't put up the code yet, I was planning to just replace my lean3 repository with my lean 4 code when it's ported.</p>",
        "id": 412581431,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1705077774
    },
    {
        "content": "<p>Ok the code is now <a href=\"https://github.com/BoltonBailey/formal-snarks-project\">here</a> the file I am working on is FormalSnarksProject.SNARKs.Groth16TypeIII</p>",
        "id": 412582858,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1705078331
    },
    {
        "content": "<p>I just found this by coincidence - this seems amazing! Mario, have you further worked on this?</p>",
        "id": 419255168,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1706797000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> is preparing the ultimate solution to this issue. See his talk at the Lean Together conference a couple of weeks ago.</p>",
        "id": 419263295,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1706799237
    },
    {
        "content": "<p>I think it might be good to have it in mathlib anyway, this has been on the roadmap for ages</p>",
        "id": 419395459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706858006
    },
    {
        "content": "<p>and to answer your question <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> , no I haven't done anything else with this but it's usable as is. It's mainly intended for temporary use while working on long meandering proofs that have not yet been put in mathlib style</p>",
        "id": 419395623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706858104
    }
]