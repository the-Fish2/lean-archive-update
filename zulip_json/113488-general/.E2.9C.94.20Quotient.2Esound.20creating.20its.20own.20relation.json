[
    {
        "content": "<p>In my lean 4 project, I have constructed a type Z (isomorphic to the integers) as the quotient of Nat x Nat by the relation R (x y : Nat x Nat) : Prop := x.1 + y.2 = x.2 + y.1 (I proved Equivalence R). I am now trying to lift the function zSucc : T → Z := λ (x : T) ↦ ⟦(x.1 + 1,x.2)⟧ to Z using Quotient.sound to prove the well-defined theorem. But whenever I apply it, it rewrites the goal to (x.1 + 1, x.2) ≈ (y.1 + 1, y.2), completely inventing the ≈ symbol. How can I rewrite ≈ to the definition of R to continue my proof?</p>",
        "id": 426272865,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710314201
    },
    {
        "content": "<p>The symbol is <em>by definition</em> equal to your <code>R</code>, it's the notation for <code>Setoid</code>. So you could just write your own lemmas of the form <code>a \\~~ b \\iff R a b</code> and <code>(p,q) \\~~ (r,s) \\iff p + s = q + r</code> or whatever else you find helpful, and prove them all in tactic mode with <code>rfl</code>, and then you'll be able to rewrite with these lemmas and you'll be back on track.</p>\n<p>I usually skip <code>succ</code> and go straight onto addition (or negation, if you want to practice a unary definition first). Let me know if you want to see my version of this exercise.</p>",
        "id": 426275471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710315516
    },
    {
        "content": "<p>Do we still have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.sound%27#doc\">docs#Quotient.sound'</a> as well?</p>",
        "id": 426276854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710316185
    },
    {
        "content": "<p>By the way if you tag my suggested lemmas <code>simp</code> then you'll be able to use the simplifier to apply them (and the simplifier might end up doing other helpful stuff too, which you may or may not want).</p>\n<p>PS proving multiplication is well-defined is, IIRC, the hardest level in this game. One proof is <code>zify at *; polyrith</code> but this raises philosophical issues :-)</p>",
        "id": 426278120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710316770
    },
    {
        "content": "<p>Thank you so much for your help, and thank you for publishing your course notes, they were an incredibly valuable study material for me.</p>",
        "id": 426279226,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710317215
    },
    {
        "content": "<p>Your solution appears not to be working. I am receiving the error \"failed to synthesize instance HasEquiv T\" over <br>\n<code>a \\~~ b</code> in the statement of the lemma. T is my name for Nat x Nat, by the way.</p>",
        "id": 426282073,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710318334
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 426282936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710318652
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span> <span class=\"c1\">-- (a : Nat, b : Nat) : T</span>\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"n\">y.2</span> <span class=\"bp\">=</span> <span class=\"n\">x.2</span> <span class=\"bp\">+</span> <span class=\"n\">y.1</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">reflMoment</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">symMoment</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">},</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">transMoment</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">},</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">eqMoment</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.mk</span> <span class=\"n\">R</span> <span class=\"n\">eqMoment</span>\n<span class=\"kd\">def</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">S</span> <span class=\"c1\">-- Z = T/R</span>\n<span class=\"c1\">-- After multiple hours of toil, we have finally declared the integers</span>\n<span class=\"c1\">-- Joy of joys</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.mk</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">zSucc</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">x.1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"n\">x.2</span><span class=\"o\">)</span><span class=\"bp\">⟧</span>\n\n<span class=\"c1\">-- lemma helpfulLemma (a b : T) : a ≈ b ↔ R a b := rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zSucc_well_defined</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">),</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">zSucc</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">zSucc</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">repeat</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">funnySucc</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Quotient.sound</span>\n  <span class=\"gr\">admit</span>\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">ZSucc</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.lift</span> <span class=\"n\">zSucc</span> <span class=\"n\">zSucc_well_defined</span>\n</code></pre></div>\n<p>( I have omitted the working proofs of the first four theorems to save space)</p>",
        "id": 426283492,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710318854
    },
    {
        "content": "<p>The <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid#doc\">docs#Setoid</a> should be an instance not a def, I believe</p>",
        "id": 426284143,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710319132
    },
    {
        "content": "<p>Your <code>def S</code> should be <code>instance S</code> because <code>Setoid</code> is a class and you want to insert <code>S</code> into the typeclass inference system so that Lean knows what the \"canonical\" equivalence relation on <code>T</code> is. And then <code>helpfulLemma</code> will typecheck, but the proof will fail, because in term mode <code>rfl</code> only proves goes of the form <code>a = a</code>, so you need to use <code>by rfl</code>, which will prove <code>a &lt;-&gt; a</code> as well.</p>",
        "id": 426284199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710319158
    },
    {
        "content": "<p>Ah, that works. Thank you!</p>",
        "id": 426284364,
        "sender_full_name": "Brandon Harad",
        "timestamp": 1710319214
    },
    {
        "content": "<p>PS</p>\n<blockquote>\n<p>( I have omitted the working proofs of the first four theorems to save space)</p>\n</blockquote>\n<p>yeah, thanks, that's exactly what the M in MWE is asking you to do :-) (avoid clutter)</p>",
        "id": 426284371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710319216
    },
    {
        "content": "<p>If you use <code>abbrev T : Type := Nat × Nat</code> instead of <code>def</code> then you'll also be able to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">helpfulLemma2</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">≈</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n</code></pre></div>\n<p>(note that you can prove it in term mode anyway, you just need to use a different flavour of <code>rfl</code>)</p>",
        "id": 426284919,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710319443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"699800\">Brandon Harad</span> has marked this topic as resolved.</p>",
        "id": 426287619,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710320400
    },
    {
        "content": "<p>But if you do that, then the setoid shouldn't be an <code>instance</code> after all!</p>",
        "id": 426288508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710320678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Quotient.2Esound.20creating.20its.20own.20relation/near/426276854\">said</a>:</p>\n<blockquote>\n<p>Do we still have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.sound%27#doc\">docs#Quotient.sound'</a> as well?</p>\n</blockquote>\n<p>You should use this lemma instead if you make the <code>Setoid</code> a def.</p>",
        "id": 426288591,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710320708
    }
]