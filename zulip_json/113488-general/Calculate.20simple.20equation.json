[
    {
        "content": "<p>I am just starting to learn Lean4. I have a simple equation a = b - c + d and I try to calculate the missing variable by giving any other three of the variables.</p>\n<p>My code looks like this:</p>\n<p>import Mathlib.Data.Real.Basic</p>\n<p>structure equation :=<br>\n  (a b c d : ℤ)<br>\n  (rule : a = b - c + d)</p>\n<p>def example1 : equation :=<br>\n{<br>\n  a := 2<br>\n  --b := 4<br>\n  c := 3<br>\n  d := 1<br>\n  rule := rfl<br>\n}</p>\n<p>#eval example1.b<br>\nAnd it does not work. It can calculate only the a variable when commenting it out. And also it can \"check\" the equation when all the variables are given.</p>\n<p>I assume that my code can be totally wrong and the solution requires another approach. Maybe the \"rfl\" is a wrong choice.</p>",
        "id": 418634848,
        "sender_full_name": "Oliver Smith",
        "timestamp": 1706534315
    },
    {
        "content": "<p>My two cents:<br>\n(1) <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a><br>\n(2) Lean is not Prolog. Lean is not a computer algebra package either. You can use <code>rfl</code> for some inference when it is like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">equation</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">example1</span> <span class=\"o\">:</span> <span class=\"n\">equation</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n<span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span>\n<span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"n\">rule</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">example1.a</span>\n</code></pre></div>",
        "id": 418641983,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706536681
    },
    {
        "content": "<p>If you’d like Lean to solve for b, c, or d given the other three variables, you need to define a function to compute each of them. Even in Mathematica, you have to write <code>Solve[…, b]</code>, which is now the function that you have to implement in Lean. Then you can <code>#eval</code> that function. Try and see if you can do that.</p>",
        "id": 418912390,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706645528
    },
    {
        "content": "<p>And for that, I would just write <code>fun (a : ℤ) (b : ℤ) (c : ℤ) : ℤ := …</code> instead of using the structure you defined.</p>",
        "id": 418913569,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706646039
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 418913871,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706646164
    },
    {
        "content": "<p>Do you mean to define 4 different functions for every variable a b c d? If yes, then I am actually trying to avoid it.<br>\nI want Lean to work by rearranging the function by itself. <br>\nAfter some trial and error, I found that by changing the type to natural numbers and rearranging the formula, Lean can calculate the a and b variables, but not the c and d.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">equation</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">example1</span> <span class=\"o\">:</span> <span class=\"n\">equation</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n  <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span>\n  <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n  <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n  <span class=\"n\">rule</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">example1.a</span>\n</code></pre></div>",
        "id": 418992713,
        "sender_full_name": "Oliver Smith",
        "timestamp": 1706691469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416472\">Winston Yin (尹維晨)</span></p>",
        "id": 419019132,
        "sender_full_name": "Oliver Smith",
        "timestamp": 1706700291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687572\">Oliver Smith</span> <a href=\"#narrow/stream/113488-general/topic/Calculate.20simple.20equation/near/418992713\">said</a>:</p>\n<blockquote>\n<p>I want Lean to work by rearranging the function by itself. </p>\n</blockquote>\n<p>Lean is not a computer algebra system.</p>",
        "id": 419024757,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706702559
    },
    {
        "content": "<p>Maybe you have some misconception about what Lean is for.<br>\nTypical workflow in Lean is this:<br>\n(1) You define a function.<br>\n(2) You specify what properties you believe the function has.<br>\n(3) You write a proof of those properties.<br>\n(4) Lean checks that your proof is correct, assuring you that your function indeed has those properties.</p>",
        "id": 419025391,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706702814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687572\">@Oliver Smith</span> what is the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here?  Why do you want this?  What are you trying to do?</p>",
        "id": 419027950,
        "sender_full_name": "Jason Rute",
        "timestamp": 1706703756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span>  <br>\nYes, I understand it. But still, even in <a href=\"https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\">https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html</a> everyone can find as an example a structural recursion the Fibonacci function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span>   <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"mi\">7</span> <span class=\"bp\">=</span> <span class=\"mi\">21</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>So, let's say, I am trying to get Lean to check that my proof (equation) is correct by finding (calculating) the value.</p>",
        "id": 419044616,
        "sender_full_name": "Oliver Smith",
        "timestamp": 1706709367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/113488-general/topic/Calculate.20simple.20equation/near/419027950\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"687572\">Oliver Smith</span> what is the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> here?  Why do you want this?  What are you trying to do?</p>\n</blockquote>\n<p>I have different simple geometry formulas (theorems),  like a = b + c. And I want Lean to prove them, by giving Lean some of the variables. And the goal is not to write the rearranged formula by myself.</p>",
        "id": 419045895,
        "sender_full_name": "Oliver Smith",
        "timestamp": 1706709734
    },
    {
        "content": "<blockquote>\n<p>So, let's say, I am trying to get Lean to check that my proof (equation) is correct by finding (calculating) the value.</p>\n</blockquote>\n<p>If you had a different equation for Fibonacci numbers, say,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fasterFib</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">GoldenRatio</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">–</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"n\">GoldenRatio</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">GoldenRatio</span> <span class=\"bp\">–</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then you would prove this is correct with a statement like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">fasterFib_eq_fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">fasterFib</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- proof goes here</span>\n</code></pre></div>\n<p>This doesn't necessarily mean that it's \"correct\" in the sense of \"does what you want\", it just means that one implementation <code>fasterFib</code> is equal to another reference implementation, <code>fib</code>, that is just the manifest _definition_ of the Fibonacci numbers. Alternately you could prove things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">fasterFib_has_fibonacci_properties</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">fasterFib</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span>\n   <span class=\"n\">fasterFib</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span>\n   <span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">fasterFib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fasterFib</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fasterFib</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"gr\">sorry</span> <span class=\"c1\">-- proof goes here</span>\n</code></pre></div>",
        "id": 419049821,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706710821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"687572\">Oliver Smith</span> <a href=\"#narrow/stream/113488-general/topic/Calculate.20simple.20equation/near/418992713\">said</a>:</p>\n<blockquote>\n<p>After some trial and error, I found that by changing the type to natural numbers and rearranging the formula, Lean can calculate the a and b variables, but not the c and d.</p>\n</blockquote>\n<p>This is because addition on natural numbers is defined by recursion on the second argument, and Lean cannot see through recursion unless the argument is already fixed. See: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.add#doc\">docs#Nat.add</a></p>\n<p>I think what <span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> said is your best answer here. Lean is for checking your answers, not finding them. If solving equations on numbers is all you need, then perhaps a computer algebra system or SMT solver is what you're looking for.</p>",
        "id": 419665140,
        "sender_full_name": "Chris Wong",
        "timestamp": 1707017579
    }
]