[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Span</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">LinearMap.range</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.id</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">span_induction</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_mem</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">add_mem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">smul_mem</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>After using <code>refine</code> the current goal becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n  <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n  <span class=\"n\">inst</span><span class=\"bp\">✝³</span> <span class=\"n\">inst</span><span class=\"bp\">✝²</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span> <span class=\"n\">R</span>\n  <span class=\"n\">inst</span><span class=\"bp\">✝¹</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span>\n  <span class=\"n\">inst</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span>\n  <span class=\"n\">x</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n  <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span>\n  <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">S</span>\n  <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span>\n  <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span>\n  <span class=\"bp\">⊢</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span> <span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"n\">LinearMap.range</span> <span class=\"n\">LinearMap.id</span>\n</code></pre></div>\n<p>But <code>{ val := y, property := hx }</code> is <strong>NOT</strong> a legal element in <code>span R S</code>. Is this a bug?</p>",
        "id": 432799722,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712875690
    },
    {
        "content": "<p>Why isn't it a legal element? This <code>{ val := y, property := hx }</code> term is a term of type <code>↥(span R S)</code> (this is the set <code>span R S</code> as a type using <code>Subtype</code>), and <code>LinearMap.range LinearMap.id</code> has type <code>Submodule R ↥(span R S)</code>. Elements of such a <code>Submodule</code> are terms of <code>↥(span R S)</code>.</p>",
        "id": 432813307,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712885158
    },
    {
        "content": "<p>Oh, I see, I missed that <code>hx</code> is that <code>x ∈ span R S</code> not <code>y ∈ span R S</code>. That is indeed weird.</p>\n<p>Here's the rest of the \"proof\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">LinearMap.range</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.id</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">span_induction</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_mem</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">add_mem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">smul_mem</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_span</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">hy</span>\n</code></pre></div>\n<p>There's an error at <code>example</code> from a type error in the proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  { val := x✝, property := hx }</span>\n<span class=\"cm\">argument has type</span>\n<span class=\"cm\">  x ∈ span R S</span>\n<span class=\"cm\">but function has type</span>\n<span class=\"cm\">  (fun x ↦ x ∈ span R S) x✝ → ↥(span R S)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 432817079,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712887965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/.60refine.60.20produces.20an.20illegal.20element.3F/near/432817079\">said</a>:</p>\n<blockquote>\n<p>There's an error at <code>example</code> from a type error in the proof:</p>\n</blockquote>\n<p>Oh, I missed that line.</p>",
        "id": 432865271,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712913742
    },
    {
        "content": "<p>I found this weird thing when I was writing the proof in &lt;<a href=\"https://github.com/leanprover-community/mathlib4/blob/2732c6f95040c3cc372c19511952de7f850c3ef8/Mathlib/RingTheory/FiniteType.lean#L765-L770\">https://github.com/leanprover-community/mathlib4/blob/2732c6f95040c3cc372c19511952de7f850c3ef8/Mathlib/RingTheory/FiniteType.lean#L765-L770</a>&gt;. At first I use <code>refine span_induction</code> directly, and then that bug occurred. To fix it, I added <code>suffices ...</code> before <code>refine span_induction</code>.</p>\n<p>Back to the above minimal example. Since the current goal is <code>{ val := y, property := hx }</code>, it's natural to write <code>exact ⟨⟨y, hx⟩, rfl⟩</code>, but it doesn't work. <code>exact ⟨⟨y, subset_span hy⟩, rfl⟩</code> works. Nevertheless, there is still a red line on <code>example</code>.</p>",
        "id": 432866166,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712914154
    },
    {
        "content": "<p>The red line on <code>example</code> is present in the original sample too</p>",
        "id": 432867868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712914833
    },
    {
        "content": "<p>The solution here is to use <code>span_induction'</code>, which is easiest to use as <code>induction hx using span_induction'</code></p>",
        "id": 432868009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712914895
    },
    {
        "content": "<p>Does anyone understand the issue though? Is this an app elaborator bug?</p>",
        "id": 432869505,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712915499
    },
    {
        "content": "<p>I think this is a bug in <code>elab_as_elim</code></p>",
        "id": 432880008,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712919857
    },
    {
        "content": "<p>Possibly <code>elab_as_elim</code> should just reject the lemma, because it isn't stated in the correct generality</p>",
        "id": 432880040,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712919873
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.60refine.60.20produces.20an.20illegal.20element.3F/near/432868009\">said</a>:</p>\n<blockquote>\n<p>The solution here is to use <code>span_induction'</code>, which is easiest to use as <code>induction hx using span_induction'</code></p>\n</blockquote>\n<p>Give up; seems that the code is not shorter than my original code in <a href=\"https://github.com/leanprover-community/mathlib4/pull/12076\">#12076</a>.</p>",
        "id": 432886157,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712922268
    },
    {
        "content": "<p>It may not be shorter, but it should be much more readable, especially if you use <code>induction hx using span_induction' with</code> which names all the subgoals</p>",
        "id": 432887150,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712922666
    }
]