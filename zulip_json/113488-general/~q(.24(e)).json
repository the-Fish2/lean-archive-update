[
    {
        "content": "<p>Is it documented anywhere that <code>$(e)</code> is how you unquote an expression to be unified with the target inside <code>~q()</code> patterns? It may seem like an exaggeration but I think it's nearly impossible to use Qq pattern matching without this single bit of knowledge, because without it (e.g. if you try matching a fresh variable <code>$e</code>) the pattern ends up as the wrong type, or you can't get typed subterms out of it. But I don't even see it in the examples. I eventually just guessed it but it took me a long time.</p>",
        "id": 419321228,
        "sender_full_name": "David A",
        "timestamp": 1706816920
    },
    {
        "content": "<p>I think the best way to learn Qq is (sadly) to read real-life examples, eg some of these: <a href=\"https://leanprover-community.github.io/mathlib4_docs/search.html?sitesearch=https%3A%2F%2Fleanprover-community.github.io%2Fmathlib4_docs&amp;q=positivityeval\">https://leanprover-community.github.io/mathlib4_docs/search.html?sitesearch=https%3A%2F%2Fleanprover-community.github.io%2Fmathlib4_docs&amp;q=positivityeval</a></p>",
        "id": 419321476,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706817018
    },
    {
        "content": "<p>I'm not sure this trick is known by anyone. Could you give an example of it?</p>",
        "id": 419321685,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706817102
    },
    {
        "content": "<p>I'm pretty sure this isn't documented because it's not true?</p>",
        "id": 419321694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706817105
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">String</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">two</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"s2\">\"two\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">one</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"s2\">\"one\"</span>\n</code></pre></div>\n<p>gives <code>two</code></p>",
        "id": 419321715,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706817113
    },
    {
        "content": "<p>So it doesn't do unification, but it does make the types right.</p>",
        "id": 419321848,
        "sender_full_name": "David A",
        "timestamp": 1706817155
    },
    {
        "content": "<p>Oh sorry, I see I misunderstood what you were talking about</p>",
        "id": 419321932,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706817183
    },
    {
        "content": "<p>This also gives \"two\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">String</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">two</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">q</span><span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">two</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"s2\">\"two\"</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">one</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"s2\">\"one\"</span>\n</code></pre></div>",
        "id": 419321951,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706817189
    },
    {
        "content": "<p>I think <code>$(two)</code> is still introducing a new match variable</p>",
        "id": 419322035,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706817228
    },
    {
        "content": "<p>In general pattern matching doesn't support using variables in the patterns</p>",
        "id": 419322061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706817238
    },
    {
        "content": "<p>Hmm... you're right, a minimal example shows a fresh variable is bound. Yet in my code I changed from something to the effect of <code>~q(@id $ty $a)</code> to <code>~q(@id $(ty) $a)</code> and it stopped complaining about the Q types being wrong. Something else was going on.</p>",
        "id": 419322696,
        "sender_full_name": "David A",
        "timestamp": 1706817455
    },
    {
        "content": "<p>This takes me back to \"Qq pattern-matching is almost impossible to use\", because you can't ensure that dependently-typed subterms have the right type.</p>",
        "id": 419323019,
        "sender_full_name": "David A",
        "timestamp": 1706817578
    },
    {
        "content": "<p>If you produce a mwe then I might be able to help</p>",
        "id": 419323425,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706817723
    },
    {
        "content": "<p>It's a silly example but this is impossible to do correctly, without just coercing the type of <code>val</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">Lean.Expr</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"bp\">$</span><span class=\"n\">ty'</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419324152,
        "sender_full_name": "David A",
        "timestamp": 1706817973
    },
    {
        "content": "<p>Do you have a less silly example? Are you aware of <code>inferTypeQ</code>, that lets you get a set of dependently-typed Qq values from an <code>Expr</code>?</p>",
        "id": 419324404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706818082
    },
    {
        "content": "<p>It's a fine line between mwe and silly, but here's an incrementally more difficult situation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">Lean.Expr</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ty</span> <span class=\"bp\">-&gt;</span> <span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat.succ</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span> <span class=\"bp\">$</span><span class=\"n\">ty'</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">default</span>\n</code></pre></div>\n<p>Of course you have to imagine that <code>ty</code> is not a constant, and the dependency in the pattern is not coming from something so simple as <code>id</code>.</p>\n<p>Is there a way to use <code>inferTypeQ</code> in this situation?</p>",
        "id": 419325576,
        "sender_full_name": "David A",
        "timestamp": 1706818540
    },
    {
        "content": "<p>Going back to your original example; is this what you want?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"k\">show</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">Lean.Expr</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">((</span><span class=\"bp\">$</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">))</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419325796,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706818634
    },
    {
        "content": "<p>It's hard to work out the real problem from your example still, but the trick is to match the type and value simultaneously</p>",
        "id": 419325996,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706818714
    },
    {
        "content": "<p>Is <code>q(1)</code> meant to have dependent type <code>Q($ty)</code> there?</p>",
        "id": 419326061,
        "sender_full_name": "David A",
        "timestamp": 1706818752
    },
    {
        "content": "<p>(you're missing a <code>_,</code> in the second branch)</p>",
        "id": 419326077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706818760
    },
    {
        "content": "<p>But anyways, I don't think this works when <code>ty</code> isn't a constant, because then you can't match on it. Let me see if I can think of an example that actually  demonstrates that issue.</p>",
        "id": 419326476,
        "sender_full_name": "David A",
        "timestamp": 1706818925
    },
    {
        "content": "<p>I would like this to typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">val</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">want_this_to_be_n</span><span class=\"o\">),</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">default</span>\n</code></pre></div>\n<p>I almost saw a way to do it, by matching on n and f at the same time as ty. But it seems you can't share a pattern variable between a <code>non-~q()</code> pattern and a <code>~q()</code>; they bind separately unlike inside a single <code>~q()</code>. In my hallucinated feature you'd just write <code>~q(Fin $(n))</code> and off you go.</p>\n<p>(Here, I guess you can match on <code>decEq n want_this_to_be_n</code> so the next level of this example would be to replace <code>Nat</code> with <code>Q(some type that isn't DecidableEq)</code>, where we still want to be able to <code>isDefEq</code> on it.)</p>",
        "id": 419328069,
        "sender_full_name": "David A",
        "timestamp": 1706819581
    },
    {
        "content": "<p>(In fact, replace <code>n : Nat</code> with <code>n : Q(Nat)</code> just to make the example more general.)</p>",
        "id": 419328720,
        "sender_full_name": "David A",
        "timestamp": 1706819816
    },
    {
        "content": "<p>Yes, this is just the standard \"you can't use variables in match patterns\"</p>",
        "id": 419331733,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706820983
    },
    {
        "content": "<p>You also can't do it when matching <code>Nat</code>s for instance, <code>match n with | .(m) =&gt;</code> is not legal</p>",
        "id": 419331780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706821011
    },
    {
        "content": "<p>(in Lean 3 it would silently succeed even when <code>m</code> and <code>n</code> were unequal)</p>",
        "id": 419331853,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706821029
    },
    {
        "content": "<p>I spent some time trying to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.isDefEqQ#doc\">docs#Lean.Meta.isDefEqQ</a> to try to unify <code>want_this_to_be_n</code> and <code>q($n)</code>, but I had no success. (\"invalid match-expression, type of pattern variable 'h' contains metavariables\")</p>",
        "id": 419331897,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706821048
    },
    {
        "content": "<p>This would at least be fixable in Qq, but we would need to invent a syntax (or adopt the <code>.()</code> syntax used in regular matching that means something vaguelly similar)</p>",
        "id": 419331996,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706821082
    },
    {
        "content": "<p>Regarding Qq in general, perhaps this helps demonstrate how to use dependent matching?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isNatAdd</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Level</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">u</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">true</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">false</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">isNatAdd</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"n\">isNatAdd</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 419332097,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706821104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/~q.28.24.28e.29.29/near/419331897\">said</a>:</p>\n<blockquote>\n<p>I spent some time trying to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.isDefEqQ#doc\">docs#Lean.Meta.isDefEqQ</a> to try to unify <code>want_this_to_be_n</code> and <code>q($n)</code>, but I had no success. (\"invalid match-expression, type of pattern variable 'h' contains metavariables\")</p>\n</blockquote>\n<p>Right, I think this is the problem - normally when the value on which your type is dependent is <code>DecidableEq</code>, you can continue the match \"manually\" with a <code>dite</code> and suitable <code>Eq.rec</code> and so on. Tactics even make this not so painful. When I'm working with Qq, I think of expressions as having a kind of decidable equality, we just call it <code>isDefEq</code>. Qq pattern matching works to lift this decidable equality into match expressions. But you can't do the equivalent thing as with <code>dite</code>/<code>Eq.rec</code>; you're stuck, other than checking <code>isDefEq</code> and then coercing the type of the expression. That's what I'll end up doing.</p>",
        "id": 419332967,
        "sender_full_name": "David A",
        "timestamp": 1706821407
    },
    {
        "content": "<p>Are you aware of <code>=Q</code>?</p>",
        "id": 419333795,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706821726
    },
    {
        "content": "<p>I'm aware it exists but I've been unable to figure out if there's anything you can do with it.</p>",
        "id": 419333882,
        "sender_full_name": "David A",
        "timestamp": 1706821767
    },
    {
        "content": "<p>Instead of casting from <code>X</code> to <code>Y</code>, you can add <code>have : X =Q Y := ⟨⟩</code> to tell Qq that the two should be considered defeq</p>",
        "id": 419333900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706821779
    },
    {
        "content": "<p>Oh, does having this in the context cause Qq to change its behavior? If so that is also not obvious from the docs...</p>",
        "id": 419334027,
        "sender_full_name": "David A",
        "timestamp": 1706821819
    },
    {
        "content": "<p>I think the intended spelling of your example above is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Qq</span>\n<span class=\"kn\">open</span> <span class=\"n\">Qq</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ty</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Lean.Meta.MetaM</span> <span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"n\">ty</span><span class=\"o\">,</span> <span class=\"n\">val</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n'</span><span class=\"o\">),</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"bp\">←</span> <span class=\"n\">isDefEqQ</span> <span class=\"n\">n'</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"c1\">-- either this needs an explicit annotation, or `isDefEqQ (u := 1)` above</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">defEq</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"n\">n'</span> <span class=\"bp\">=</span><span class=\"n\">Q</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">q</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">f</span> <span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">default</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">default</span>\n</code></pre></div>",
        "id": 419334900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706822235
    },
    {
        "content": "<p>~~However, this runs into <a href=\"https://github.com/leanprover-community/quote4/issues/30~~\">https://github.com/leanprover-community/quote4/issues/30~~</a> fixed above!</p>",
        "id": 419334933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706822255
    },
    {
        "content": "<p>It's not clear to me whether this is a Qq bug or a Lean bug</p>",
        "id": 419334947,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706822263
    },
    {
        "content": "<p>Hmm... I think that might be what I want :)<br>\nBut now I have to fix the problem which caused my hallucinated feature to \"work\":<br>\nIf I've acquired my <code>=Q</code> in a nested <code>do</code> block, how do I express that the result of that <code>do</code> block should have the type visible in the outer do block, without just coercing it? If I don't coerce it my quoted terms end up being inferred as <code>Expr</code>. So it would be nice if <code>=Q</code>s had some kind of explicit <code>rec</code> function. I guess I can just write that...</p>",
        "id": 419336166,
        "sender_full_name": "David A",
        "timestamp": 1706822774
    },
    {
        "content": "<p>I think you just return an object of type <code>$n' =Q $n</code> from the inner do block?</p>",
        "id": 419336361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706822877
    },
    {
        "content": "<p>Okay, first I have to figure out why <code>assertDefEqQ</code> doesn't work when one side is <code>q($ty)</code> where <code>ty : T</code>, <code>[Lean.ToExpr T]</code>, <code>[CoeSort T]</code>, lol</p>",
        "id": 419336687,
        "sender_full_name": "David A",
        "timestamp": 1706823013
    },
    {
        "content": "<p>this is now deeply a problem of my own making though <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 419336744,
        "sender_full_name": "David A",
        "timestamp": 1706823038
    },
    {
        "content": "<p>How did you fix the issue 30 problem you had? I think I'm hitting the same thing with <code>q($ty)</code> even when I tried <code>(show Q(Type) from q($ty))</code>.</p>",
        "id": 419337347,
        "sender_full_name": "David A",
        "timestamp": 1706823298
    },
    {
        "content": "<p>The comment in the code above (edited) shows what the 30 workaround was</p>",
        "id": 419338227,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706823672
    },
    {
        "content": "<p>got it, just found the same solution. kind of bizarre but then the type of <code>=Q</code> is kind of bizarre</p>",
        "id": 419338288,
        "sender_full_name": "David A",
        "timestamp": 1706823702
    },
    {
        "content": "<p>Hmm... just having that in the context caused the nested do block to revert to yielding <code>Expr</code> even when I coerced the type. This is probably not necessary at this point...</p>",
        "id": 419338785,
        "sender_full_name": "David A",
        "timestamp": 1706823903
    }
]