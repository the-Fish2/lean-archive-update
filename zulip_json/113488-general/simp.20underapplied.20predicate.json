[
    {
        "content": "<p>Is it possible to make <code>simp</code> apply <code>p_iff_q</code> here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">p_iff_q</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">q</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 410591287,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703986896
    },
    {
        "content": "<p>no, you would have to make the underapplied version a simp rule as well if you want this</p>",
        "id": 410591390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703986955
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>: I define an inductive predicate and generate an <code>iff</code> lemma for it using <code>@[mk_iff]</code>. Later, I want to generate an instance about the predicate by rewriting using the <code>iff</code> lemma (I have an instance for the RHS of the <code>iff</code>).</p>",
        "id": 410591394,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703986962
    },
    {
        "content": "<p>I guess, I'll have to read and understand the code of <code>mk_iff</code>.</p>",
        "id": 410591443,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703986998
    },
    {
        "content": "<p>How would <code>mk_iff</code> generate this kind of thing?</p>",
        "id": 410591463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987015
    },
    {
        "content": "<p>Normally it won't just be two equal constants unless your predicate is just a newtype wrapper</p>",
        "id": 410591535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987049
    },
    {
        "content": "<p>In practice, it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">mk_iff</span><span class=\"kd\">]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">IsSubsemigroup</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SomeClass</span> <span class=\"n\">M</span> <span class=\"n\">IsSubsemigroup</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 410591631,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987133
    },
    {
        "content": "<p>okay, so what's the <code>p = q</code> here?</p>",
        "id": 410591647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987149
    },
    {
        "content": "<p>I have a generic instance of <code>SomeClass</code> that generates an instance for the predicate <code>fun s =&gt; ∀ x ∈ s, ∀ y ∈ s, x * y ∈ s</code></p>",
        "id": 410591721,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987187
    },
    {
        "content": "<p>I want to rewrite using a lemma generated by <code>mk_iff</code> or something similar, then apply this generic instance.</p>",
        "id": 410591753,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987216
    },
    {
        "content": "<p>It's in <a href=\"https://github.com/leanprover-community/mathlib4/tree/YK-bundled-set\">branch#YK-bundled-set</a></p>",
        "id": 410591788,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987242
    },
    {
        "content": "<p>Hm, I would avoid doing this in general, newtype wrappers are generally not equal (as types) to the things they wrap</p>",
        "id": 410591814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987264
    },
    {
        "content": "<p>This is in <code>Prop</code></p>",
        "id": 410591878,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987295
    },
    {
        "content": "<p>in this case you can do it, but I'm not sure we want to build much infrastructure for this style of proof</p>",
        "id": 410591914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987337
    },
    {
        "content": "<p>why not just <code>rw [show IsSubsemigroup = _ by ext x; simp]</code>?</p>",
        "id": 410591957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987371
    },
    {
        "content": "<p>I'm using <code>rw [show IsSubsemigroup = _ from funext (fun s ↦ propext (IsSubsemigroup_iff s))]</code> now</p>",
        "id": 410592057,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987449
    },
    {
        "content": "<p>does <code>simp</code> not trigger once you have the <code>funext</code>?</p>",
        "id": 410592089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987475
    },
    {
        "content": "<p><code>rw [show IsSubsemigroup = _ from funext fun _ ↦ by simp [IsSubsemigroup_iff]]</code> doesn't work because it fails to close the goal with a metavariable in the RHS by reflexivity.</p>",
        "id": 410592243,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987590
    },
    {
        "content": "<p><code>; rfl</code>?</p>",
        "id": 410592278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703987622
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 410592357,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987668
    },
    {
        "content": "<p>I'll see what's easier to make work semi-automatically.</p>",
        "id": 410592413,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703987723
    },
    {
        "content": "<p>I want to have this type of proof as a <code>derive</code> handler for <code>BundledSet.InterPred</code> etc from <code>Data/BundledSet/Lattice</code> in that branch.</p>",
        "id": 410593004,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703988164
    }
]