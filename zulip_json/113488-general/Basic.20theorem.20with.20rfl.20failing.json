[
    {
        "content": "<p>I'm writing some propositional logic proofs and am confused on an attempt of mine to prove a basic property of substitution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">α</span> <span class=\"s2\">\";\"</span> <span class=\"n\">n</span> <span class=\"s2\">\"]\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">  A boolean signature is made up of sets of symbols for each arity `n`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Signature</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- For each arity `n`, a set of symbols. -/</span>\n  <span class=\"n\">symbols</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"sd\">/-- Formulas of a signature with at most `n` unbound variables. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Signature.Formula</span> <span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">Signature</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Variables. -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"n\">n</span>\n  <span class=\"sd\">/-- Function application. -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S.symbols</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φs</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">Formula</span> <span class=\"n\">n</span>\n\n<span class=\"sd\">/-- Substitutes instances of `α` with `β` in `φ`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">subst</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Signature</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"o\">(</span><span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S.Formula</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">α</span> <span class=\"k\">then</span>\n    <span class=\"n\">β</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">match</span> <span class=\"n\">φ</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"n\">i</span>\n    <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">φs</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">subst</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">φs</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">subst_eq</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Signature</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"o\">(</span><span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">subst</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">    n : ℕ</span>\n<span class=\"cm\">    S : Signature</span>\n<span class=\"cm\">    inst✝ : DecidableEq (Signature.Formula n)</span>\n<span class=\"cm\">    α β : Signature.Formula n</span>\n<span class=\"cm\">    ⊢ subst α β α = β</span>\n<span class=\"cm\">    Messages (1)</span>\n<span class=\"cm\">    Section2.lean:68:63</span>\n<span class=\"cm\">    type mismatch</span>\n<span class=\"cm\">      HEq.rfl</span>\n<span class=\"cm\">    has type</span>\n<span class=\"cm\">      HEq ?m.11025 ?m.11025 : Prop</span>\n<span class=\"cm\">    but is expected to have type</span>\n<span class=\"cm\">      subst α β α = β : Prop</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I wasn't able to use <code>simp [subst]</code> in another theorem, an in an attempt to minimize an example of my difficulty, I realized that <code>subst_eq</code> can't be proven with <code>rfl</code>. Any ideas why <code>rfl</code> doesn't work here? Also please let me know if the definitions of <code>Signature</code> or <code>Formula</code> would help at all.</p>",
        "id": 412620496,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705093560
    },
    {
        "content": "<p>Have you tried <code>if_pos rfl</code>?</p>",
        "id": 412620820,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705093715
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">subst_eq</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">subst</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">if_pos</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>results in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">if_pos</span> <span class=\"n\">rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"bp\">?</span><span class=\"n\">m.11026</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m.11026</span> <span class=\"k\">then</span> <span class=\"bp\">?</span><span class=\"n\">m.11028</span> <span class=\"k\">else</span> <span class=\"bp\">?</span><span class=\"n\">m.11029</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m.11028</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">subst</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 412620984,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705093802
    },
    {
        "content": "<p>I feel like lean isn't simplifying the definition of <code>subst</code>. Doing this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">subst_eq</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">S.Formula</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">subst</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">subst</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>gives a <code>simp made no progress</code>, which is surprising because it should unfold the definition of <code>subst</code> at least.</p>",
        "id": 412621101,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705093848
    },
    {
        "content": "<p>You will need to read <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (this is a link) and update your message accordingly so that we can help you further.</p>",
        "id": 412621496,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705094035
    },
    {
        "content": "<p>I've updated the original question so it is a MWE.</p>",
        "id": 412621860,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705094207
    },
    {
        "content": "<p>I feel like <code>subst</code> is not being unfolded for some reason.</p>",
        "id": 412622213,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705094393
    },
    {
        "content": "<p>Try <code>unfold subst</code>?</p>",
        "id": 412623420,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705095060
    },
    {
        "content": "<p>That does work! Hadn't seen that tactic before</p>",
        "id": 412623654,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705095169
    },
    {
        "content": "<p>I'm used to using <code>simp</code> in these cases, still unsure why it doesn't work here.</p>",
        "id": 412623731,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705095213
    },
    {
        "content": "<p>I agree that I would expect <code>simp [subst]</code> to work.</p>",
        "id": 412623994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705095378
    },
    {
        "content": "<p>This is because of <del>well-founded</del> recursion, right?</p>",
        "id": 412624179,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705095502
    },
    {
        "content": "<p>Oh that's likely it. <code>subst</code> being recursive would cause <code>simp</code> to apply it indefinitely.</p>",
        "id": 412624308,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705095590
    },
    {
        "content": "<p>would be nice to see an error that <code>simp</code> is ignoring one of it's terms though, assuming that is what is happening.</p>",
        "id": 412624439,
        "sender_full_name": "Enrico Borba",
        "timestamp": 1705095647
    },
    {
        "content": "<p>IIRC then <code>simp [foo]</code> works well if foo is defined by pattern matching and one of the patterns applies, via the generated “equation” lemmas. In this case, there is an <code>if</code> on the RHS, so no equations exist, and you have to manually unfold.</p>\n<p>Presumably one could imagine a top-level if to cause two equations with preconditions to be created and applied by simp. Not sure if that would help in general, or be too unpredictable.</p>",
        "id": 412632221,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1705099691
    }
]