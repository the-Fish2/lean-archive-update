[
    {
        "content": "<p>I am working on a problem involving the cardinality of certain sets.  Although the sets are all finite, sometimes I find it easier to use Sets because of the implicit set notation.  For example, during the proof I define the following set</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">S₂</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">Finset.Ico</span> <span class=\"mi\">25</span> <span class=\"mi\">1000</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I cannot easily define that set as a Finset.  Even if I try </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">S₂</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.Ico</span> <span class=\"mi\">25</span> <span class=\"mi\">1000</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I get an error saying <code>failed to synthesize instance DecidablePred fun i =&gt; ∃ n ∈ S i, ∃ m, m * m = n</code>.  I know that I could instead demand that <code>Nat.sqrt n = n</code>, but I'm just illustrating some of the difficulty working with Finsets.</p>\n<p>To state the problem, which involves finding a cardinality, I use Set.encard S.  I have found that despite the ease of working with the implicit set notation, I have now entered a different realm of difficulty dealing with the WithTop naturals instead of numbers.  Despite my best efforts, I have not even been able to solve the following extremely simple equation</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">encard_eq</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S.encard</span> <span class=\"bp\">+</span> <span class=\"mi\">267</span> <span class=\"bp\">=</span> <span class=\"mi\">975</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">S.encard</span> <span class=\"bp\">=</span> <span class=\"mi\">708</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Clearly, my decision to use Sets instead of Finsets has backfired.</p>\n<p>My questions are as follows:<br>\n1.) In this type of situation, is it more common to use Finsets for everything and try to prove finiteness for every new definition.  Is that a superior method?<br>\n2.) How would I prove the above equation for S.encard.<br>\n3.) I am also aware that you can use ncard which bypasses withTop, but based on some reading it looks like that might not be the preferred method either.</p>\n<p>Any help will be greatly appreciated, thanks in advance!</p>",
        "id": 409753818,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1703370077
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">encard_eq</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">S.encard</span> <span class=\"bp\">+</span> <span class=\"mi\">267</span> <span class=\"bp\">=</span> <span class=\"mi\">975</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">S.encard</span> <span class=\"bp\">=</span> <span class=\"mi\">708</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">lift</span> <span class=\"n\">S.encard</span> <span class=\"n\">to</span> <span class=\"n\">ℕ</span> <span class=\"k\">with</span> <span class=\"n\">N</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">H</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">top_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">cast_ofNat</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ENat.top_ne_coe</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">norm_cast</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_tsub_of_add_eq</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I think avoiding <code>Finset</code> is doing you more harm than good</p>",
        "id": 409755650,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703371656
    },
    {
        "content": "<p>Maybe you could work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.ncard#doc\">docs#Set.ncard</a> instead of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.encard#doc\">docs#Set.encard</a> ? Rather than using extended naturals to capture finiteness, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.finite#doc\">docs#Set.finite</a> proof or a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a> instance, to separate cardinality from finiteness.</p>",
        "id": 409755893,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703371853
    }
]