[
    {
        "content": "<p>I'm currently in the process of defining a generalised notion of Metric, such that the codomain is less constricted. with the current definition, the only options (as far as i know) are to either use <code>Real</code>, <code>NNReal</code>, or <code>ENNReal</code>. however, for my project i need to be able to use <code>Nat</code> (or <code>ENat</code>, i'm not quite sure about that yet). i have already made definitions for <code>GDist</code>, <code>GPseudoMetricSpace</code>, and <code>GMetricSpace</code>. I would like some help and/or advice about how to go about porting lemmas and theorems about these spaces.<br>\nMy definition extends these notions to mostly only require an instance <code>LinearOrderedCancelAddCommMonoid β</code>, which all of the current possible versions should support i think? (maybe not Real, but im not too sure that this should be a problem, as for most notions of distance that i'm aware of, you cannot have negative distances.)<br>\nAbout 400 lines into copying and rewriting lemmas of <code>PseudoMetricSpace</code> i realised that there quite possibly is a better way of going about this kind of porting... As i'm new to this community, i'm not quite sure how to contribute, or how the process of generalising definitions goes...</p>\n<p>Can someone explain how i should go about getting this notion into mathlib, and are there people willing to help with such a process?</p>\n<p>I currently have my definitions and ported lemmas at <a href=\"https://github.com/edegeltje/Mathieu_12_simple\">the repo for the project i'm currently working on</a> in the folders <code>GPseudoMetricSpace</code> and <code>GMetricSpace</code>, but i understand if it will be better for workflow if this gets moved somewhere else</p>",
        "id": 420887883,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707656100
    },
    {
        "content": "<p>I would strongly advise against adding another typeclass with data, since it is not really necessary as your spaces are in fact particular cases of metric spaces (or emetric spaces): instead, you could have a mixin like <code>IsNatValuedDist</code>, saying that the distance is Nat-valued on a metric space. On a space satisfying <code>[PseudoMetricSpace X] [IsNatValuedDist X]</code>, you could introduce a new function <code>natDist</code> (which would just be the cast of the distance function to <code>Nat</code>) and prove the properties you need on it. With this approach, you wouldn't have to reprove all the topological properties of the metric spaces, and focus on the novelties that the <code>Nat</code>-valued distance would give you.</p>",
        "id": 420890420,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1707658744
    },
    {
        "content": "<p>i suppose that would indeed work for my case... however, you'd have to have such a mixin for each codomain, and that seems to me like the less elegant way of going about this, rather than just having a class <code>GDist α β</code> where the type is a parameter</p>",
        "id": 420890988,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707659358
    },
    {
        "content": "<p>it would be like defining only the symmetric groups, along with mixins saying \"only look at these elements today\"</p>",
        "id": 420891065,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707659417
    },
    {
        "content": "<p>rather than the general notion of a group</p>",
        "id": 420891097,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707659457
    },
    {
        "content": "<p>The problem with the <code>GDist</code> approach is that the way the real, nnreal and ennreal distances are mixed together is highly nontrivial in mathlib (notably to make sure that the uniform structure coming from the three of them is definitionally the same, which is crucial for many things), so having just one class and three independent implementations for real, nnreal and ennreal would just not work. The current implementation is one of mathlib's most delicate constructions, that's why I would just build on top of it instead of trying to tinker with it.</p>",
        "id": 420891271,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1707659587
    },
    {
        "content": "<p>i think there is a single property which all three of those have, which lets you define that structure, right? then maybe we would rather have a singular definition for that uniform structure such that it works... i don't see the problem with this approach yet</p>",
        "id": 420891807,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707659842
    },
    {
        "content": "<p>i looked a bit, and for domain <code>Real</code> the property that was used was that <code> ∀ ε &gt; 0, ∃ δ &gt; 0, ∀ x &lt; δ, ∀ y &lt; δ, x + y &lt; ε</code>...</p>",
        "id": 420892375,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707660257
    },
    {
        "content": "<p>looks to me like the same was used for <code>ENNReal</code></p>",
        "id": 420892430,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707660357
    },
    {
        "content": "<p>this can just be an extra assumption before defining the induced <code>UniformSpace</code></p>",
        "id": 420892609,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707660498
    },
    {
        "content": "<p>If you look at the definition of metric spaces and emetric spaces in mathlib, you will see that they are not symmetric: a metric space contains an emetric space as a subfield (for good reasons related to forgetful inheritance, as I was trying to explain above). This means that you can not have a single class that will work for everything.</p>",
        "id": 420897750,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1707664937
    },
    {
        "content": "<p>so then other than the fact that the domain allows for infinity, what's the difference?</p>",
        "id": 420897944,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707665072
    },
    {
        "content": "<p>at the very least the pseudometric and pseudoEMetric versions don't look to be dependent on each other...</p>",
        "id": 420898159,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707665280
    },
    {
        "content": "<p>From the mathematical point of view, the only difference is that the distance is allowed to take the value infinity. From the implementation point of view, there are subtle details because when you want to look at the topological structure on a metric space, typeclass inference could follow different pathes, going or not through the emetric structure, and you want the topological structure along the different paths to be definitionally equal.</p>",
        "id": 420898264,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1707665354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113488-general/topic/Generalised.20notion.20of.20.28Pseudo.29MetricSpace/near/420898159\">said</a>:</p>\n<blockquote>\n<p>at the very least the pseudometric and pseudoEMetric versions don't look to be dependent on each other...</p>\n</blockquote>\n<p>You can have a look at the definition of a pseudometric space: there are both <code>dist</code> and <code>edist</code> fields there, for the reason I have just explained. While there is no <code>dist</code> field in the definition of pseudoemetric spaces. The definitions are really different.</p>",
        "id": 420898581,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1707665598
    },
    {
        "content": "<p>Would there be any problem in having <code>GPseudoMetricSpace</code> extend <code>PseudoMetricSpace</code>, along with a field stating they agree?</p>",
        "id": 420898682,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707665664
    },
    {
        "content": "<p>the whole point is having it be the other way around though?</p>",
        "id": 420898703,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707665687
    },
    {
        "content": "<p>The advantage over <code>IsNatValuedDist </code> is that you could potentially have a computable distance function</p>",
        "id": 420898706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707665691
    },
    {
        "content": "<p>because you'd like to say that a metric space really is just the special case where the domain is <code>Real</code></p>",
        "id": 420898752,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707665734
    },
    {
        "content": "<p>i can imagine having something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">MetricSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">GMetricSpace</span> <span class=\"n\">α</span> <span class=\"n\">ℝ</span>\n</code></pre></div>",
        "id": 420898919,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707665858
    },
    {
        "content": "<p>although i'm can imagine it's not quite going to be that easy...</p>",
        "id": 420899113,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707665985
    },
    {
        "content": "<p>You're missing the (tricky and subtle) point that <span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> is making about forgetful inheritance. If you do something like this, then all of a sudden you will break things, because there will be multiple topological structures that are not definitionally equal.</p>",
        "id": 420899129,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707666001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113488-general/topic/Generalised.20notion.20of.20.28Pseudo.29MetricSpace/near/420898703\">said</a>:</p>\n<blockquote>\n<p>the whole point is having it be the other way around though?</p>\n</blockquote>\n<p>Oh indeed, I'm just explaining how you could build something on top of what mathlib has if a refactor turns out to be too much work.</p>",
        "id": 420899237,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707666055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113488-general/topic/Generalised.20notion.20of.20.28Pseudo.29MetricSpace/near/420899129\">said</a>:</p>\n<blockquote>\n<p>You're missing the (tricky and subtle) point that <span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> is making about forgetful inheritance. If you do something like this, then all of a sudden you will break things, because there will be multiple topological structures that are not definitionally equal.</p>\n</blockquote>\n<p>if you make sure that the ordering on the restriction from ENNReal to NNReal is definitionally equivalent, i think that should fix it?</p>",
        "id": 420899334,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707666131
    },
    {
        "content": "<p>It's not clear to me how the epsilon/delta argument in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformSpace.ofDist#doc\">docs#UniformSpace.ofDist</a> would generalize to <code>Nat</code></p>",
        "id": 420899488,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707666267
    },
    {
        "content": "<p>there is no natural instance of UniformSpace on GMetricSpace i think... because you don't get to split distances per sé</p>",
        "id": 420899549,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707666326
    },
    {
        "content": "<p>Right, and therein lies the issue; you now need a separate typeclass that says \"the uniform space and metric space agree\", which is a much larger (but not impossible) refactor</p>",
        "id": 420899571,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707666355
    },
    {
        "content": "<p>Now, maybe you can get away with something along the lines of</p>\n<ul>\n<li>Introduce <code>GMetricSpace α ℝ</code></li>\n<li>Introduce <code>IsInducedUniformity α ℝ</code></li>\n<li>Redefine <code>MetricSpace</code> as the combination of the above two classes</li>\n</ul>",
        "id": 420899710,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707666458
    },
    {
        "content": "<p>Others have needed Nat-valued metrics before.  I think the simplest thing is to add a mixin class for that, with some simple API. If we end up needing more than just Nat, then we consider a larger refactor.</p>",
        "id": 420899798,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707666517
    },
    {
        "content": "<p>One refactor that I think would be sensible would be to combine the <code>EDist</code>, <code>NNDist</code>, and <code>Dist</code> classes into a single class, and restore <code>edist</code>, <code>nndist</code>, and <code>dist</code> as abbreviations</p>",
        "id": 420899867,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707666572
    },
    {
        "content": "<p>just so i get this...<br>\nif you define something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">toUniformSpace</span> <span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span><span class=\"o\">:</span><span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">δ</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">δ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">δ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">....</span>\n</code></pre></div>\n<p>what goes wrong?</p>",
        "id": 420899883,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707666596
    },
    {
        "content": "<p>Also note, Edward, that ENNReal isn't cancellative, so it doesn't fit your current type class constraints (likely this is minor).</p>",
        "id": 420899887,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707666601
    },
    {
        "content": "<p>ah, good catch</p>",
        "id": 420899959,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707666629
    },
    {
        "content": "<p>See the relevant chapter of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> for why it breaks things.</p>",
        "id": 420899996,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707666666
    },
    {
        "content": "<p>(I'll try to find it, but I'm on mobile)</p>",
        "id": 420900018,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707666682
    },
    {
        "content": "<p>i'm guessing it's in the chapter about metric spaces?</p>",
        "id": 420900038,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1707666708
    },
    {
        "content": "<p>Maybe I'm thinking of the wrong reference, sorry</p>",
        "id": 420900170,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707666812
    },
    {
        "content": "<p>You can add</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">NatDist</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">natDist</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">X</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">NatMetricSpace</span> <span class=\"kd\">extends</span> <span class=\"n\">MetricSpace</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">NatDist</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"n\">dist_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">natDist</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">NatMetricSpace.ofNatDist</span> <span class=\"o\">[</span><span class=\"n\">NatDist</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hsymm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">natDist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">natDist</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">htriangle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">natDist</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">natDist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">natDist</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">NatMetricSpace</span> <span class=\"n\">X</span> <span class=\"n\">where</span>\n  <span class=\"c1\">-- fill in all elements, probably using discrete uniformity</span>\n</code></pre></div>",
        "id": 420949999,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707711814
    },
    {
        "content": "<p>Generalizing all <code>*Dist</code> will make it hard to extend both <code>Dist</code> and <code>EDIst</code> in a single typeclass.</p>",
        "id": 420950071,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707711862
    }
]