[
    {
        "content": "<p>I have a dependent type <code>Φ</code> which takes arguments in a distributive lattice, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">[</span><span class=\"n\">DistribLattice</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Equality of terms in the lattice transports down <code>Φ</code> into equivalence of types, and a great many of the theorems that I'm trying to formalize implicitly utilize these equivalences as coercions, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span>\n  <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">ϕ</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊔</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊔</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ψ</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">⊔</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ϕ</span>\n</code></pre></div>\n<p>I've been writing coercion instances ad-hoc for each of the theorems I've gotten to so far, but it's feeling pretty unwieldy. Lattice equality is decidable, right? That being said,  can I leverage type-class resolution to automatically decide equality between lattice terms? </p>\n<p>I don't know much about logic programming, or the implementation of the type-class resolution algorithm, but as far as I can tell I might only be able to use it to simplify terms with substitution, and that's not promising. </p>\n<p>Anyone ever done anything like this? Am I missing a simpler way to do this?</p>",
        "id": 409973870,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703566629
    },
    {
        "content": "<p>Isn't there a similar problem with Nat-indexed stuff like graded rings? The general solution seems to be just developing enough API to move between various formalisms, for instance your <code>D -&gt; Type</code> is equivalently a big universal type <code>T</code> with a function <code>T -&gt; D</code> assigning each element its corresponding lattice point</p>",
        "id": 409974974,
        "sender_full_name": "Trebor Huang",
        "timestamp": 1703567279
    },
    {
        "content": "<p>Good point; I'll take a look at what Mathlib has going on with its graded rings &amp;c. tomorrow morning.</p>",
        "id": 409983308,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703573806
    },
    {
        "content": "<p>To that end, you may find <a href=\"https://www.repository.cam.ac.uk/items/1ca6b177-8773-47a6-8246-a26a948f5cfd\">https://www.repository.cam.ac.uk/items/1ca6b177-8773-47a6-8246-a26a948f5cfd</a> helpful</p>",
        "id": 410003557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703584836
    },
    {
        "content": "<p>Ha! How appropriate.</p>",
        "id": 410045995,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703608889
    },
    {
        "content": "<p>It's not completely related, and I don't think it really helps, but just for sake of pointing out a nice idea to handle dependent types in algebra, here is a definition for a general version of chain complexes: <a href=\"https://github.com/leanprover-community/mathlib4/blob/5a809b6adb326ce351012b12a484544844277798//Mathlib/Algebra/Homology/HomologicalComplex.lean#L57-L61\">https://github.com/leanprover-community/mathlib4/blob/5a809b6adb326ce351012b12a484544844277798//Mathlib/Algebra/Homology/HomologicalComplex.lean#L57-L61</a></p>\n<p>The differential for a chain complex indexed by the integers is a map <code>d i : X i -&gt; X (i - 1)</code> (or the other way), however this leads to dependent type issues since this fixes the latter term to being defeq to <code>i - 1</code> rather than anything that equals <code>i - 1</code>.</p>\n<p>The trick is to define <code>d i j : X i -&gt; X j</code> for all <code>i</code> and <code>j</code> and then make it be <code>0</code> when <code>j </code> isn't equal to <code>i - 1</code>. This trick is possible because there's a default value <code>d</code> can take for invalid inputs -- the zero morphism.</p>",
        "id": 410049731,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1703611641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Wicked<br>\n<a href=\"/user_uploads/3121/MUgx5YVXfqjdWwp4rhrI0azH/Screenshot-2023-12-26-at-2.01.54-PM.png\">Screenshot-2023-12-26-at-2.01.54-PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/MUgx5YVXfqjdWwp4rhrI0azH/Screenshot-2023-12-26-at-2.01.54-PM.png\" title=\"Screenshot-2023-12-26-at-2.01.54-PM.png\"><img src=\"/user_uploads/3121/MUgx5YVXfqjdWwp4rhrI0azH/Screenshot-2023-12-26-at-2.01.54-PM.png\"></a></div>",
        "id": 410057117,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703617330
    },
    {
        "content": "<p>For those following and interested, I'll give a brief description of what Wieser and Zhang write.</p>\n<p>First, they highlight the point that <span class=\"user-mention\" data-user-id=\"404479\">@Trebor Huang</span> made, that there's an equivalence between \"internally\" and \"externally\" graded types: internal gradation is a map from a large type to the grade; and external gradation is a dependent type from the grade. They use externally graded types for discussion.</p>\n<p>Using the construction of a graded semi-group as an example, they present 6 options for pushing an identity in the domain of an externally graded type to equivalence between components (quoting directly from the paper):</p>\n<ol>\n<li>\n<p>Use heterogenous equality (denoted <code>==</code>), which allows us to express equality<br>\nbetween distinct types (<a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L16?decl=heq.g_semigroup\">ex</a>.</p>\n</li>\n<li>\n<p>Express the equality in terms of sigma types or dependent pairs, denoted<br>\n<code>Σ i, A i</code> (<a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L21?decl=sigma.g_semigroup\">ex</a>).</p>\n</li>\n<li>\n<p>Express the grading constraint as an equality on sigma types (<a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L26?decl=extends.g_semigroup\">ex</a>).</p>\n</li>\n<li>\n<p>Provide an explicit proof that the equality is type correct using the recursor<br>\nfor equality, <code>eq.rec</code> (<a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L30?decl=eq.rec.g_semigroup\">ex</a>).</p>\n</li>\n<li>\n<p>Store a canonical map between objects of the “same” grade to use instead<br>\nof using <code>eq.rec</code>, to allow better definitional control (<a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L35?decl=cast.g_semigroup\">ex</a>).</p>\n</li>\n<li>\n<p>Take an additional index into <code>mul</code> (they're talking about a graded semigroup) and a proof that it is equal to <code>i + j</code> (<a href=\"https://github.com/eric-wieser/lean-graded-rings/blob/cf463b1b9317e16499a51b20037ad8319311bd21/src/cicm2022/examples/graded_semigroup.lean#L42?decl=h%20:%20i+j=k.g_semigroup\">ex</a>).</p>\n</li>\n</ol>",
        "id": 410059564,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703619034
    },
    {
        "content": "<p>In retrospect I think 5 was in fact the better design, and we're now in a good place to do the refactor and evaluate if it makes things simpler</p>",
        "id": 410059708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703619140
    },
    {
        "content": "<p>Ah, good to know. I'll start with that in my toy problem.</p>",
        "id": 410059789,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703619236
    },
    {
        "content": "<p>This is what I ended up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ValuationAlgebras</span>\n\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Principal</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">//</span> <span class=\"n\">j</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span> <span class=\"o\">}</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Lattice</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoeOut</span> <span class=\"o\">(</span><span class=\"n\">Principal</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">ι</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">j.val</span>\n\n\n<span class=\"kd\">class</span> <span class=\"n\">ValuationAlgebra</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Cast terms of one grade to another when those grades can be equated -/</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">j</span>\n  <span class=\"sd\">/-- Reflexivity casts to the identity -/</span>\n  <span class=\"n\">cast_rfl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cast</span> <span class=\"n\">rfl</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- Inter-grade multiplication -/</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">⊔</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Inter-grade multiplication is commutative -/</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cast</span> <span class=\"n\">sup_comm</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- Inter-grade multiplication is associative -/</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cast</span> <span class=\"n\">sup_assoc</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Each grade has a `one` -/</span>\n  <span class=\"n\">one</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span>\n  <span class=\"sd\">/-- Intra-grade multiplication by the grade's `one` is the identity -/</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cast</span> <span class=\"n\">sup_idem</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- Inter-grade multiplication of `one` elements produces a `one` element -/</span>\n  <span class=\"n\">mul_one_one</span> <span class=\"o\">:</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">⊔</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Marginalization over sub-grades -/</span>\n  <span class=\"n\">margin</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Principal</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">j</span>\n  <span class=\"sd\">/-- Marginalization respects transitivity of sub-grades -/</span>\n  <span class=\"n\">margin_trans</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Principal</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Principal</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">margin</span> <span class=\"n\">x</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">margin</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">k.property</span> <span class=\"n\">j.property</span><span class=\"o\">⟩</span>\n  <span class=\"sd\">/-- Marginalization distributes across multiplication in a particular way -/</span>\n  <span class=\"n\">margin_mul</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">le_sup_left</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"n\">sup_inf_self</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">margin</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">⊓</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">inf_le_right</span><span class=\"o\">⟩))</span>\n</code></pre></div>\n<p>The last two properties have a kind of gnarly declaration (made marginally better if we declare a <code>instance [Lattice ι] (i : ι) : Lattice (Principal i</code>) and promise to propagate annoying manual dependent constructions all over the place, but that's really because of the nasty dependent type of <code>ValuationAlgebra.margin</code>.</p>\n<p>I wonder if I can apply some of the abstractive principles we used here in grading algebras to treat a lattice of principal ideals. I'll give it a shot later.</p>\n<p>Haven't put this to use, yet. I'll drop an update about ease-of-use later as well.</p>",
        "id": 410077230,
        "sender_full_name": "N Gelwan",
        "timestamp": 1703633295
    },
    {
        "content": "<p>Ended up having to add a bunch of <code>cast</code> identities:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ValuationAlgebras</span>\n\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DistribLattice</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">class</span> <span class=\"n\">ValuationAlgebra</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Cast terms of one grade to another when those grades can be equated -/</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span>\n  <span class=\"sd\">/-- Reflexivity casts to the identity -/</span>\n  <span class=\"n\">cast_rfl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">rfl</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span>\n  <span class=\"sd\">/-- Casting across the symmetry of equality produces inverses -/</span>\n  <span class=\"n\">cast_symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">p</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ψ</span> <span class=\"bp\">↔</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">Eq.symm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">ψ</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Casting across two equalities is casting across their transitivity -/</span>\n  <span class=\"n\">cast_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">p</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">φ</span>\n  <span class=\"sd\">/-- Inter-grade multiplication -/</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">Φ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊔</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Inter-grade multiplication is commutative -/</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"n\">sup_comm</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">ψ</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Inter-grade multiplication is associative -/</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ϕ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">sup_assoc</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"o\">)</span> <span class=\"n\">ϕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">ψ</span> <span class=\"n\">ϕ</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Casting respects multiplication -/</span>\n  <span class=\"n\">cast_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">p</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"n\">ψ</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊔</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Each grade has a `one` -/</span>\n  <span class=\"n\">one</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- Intra-grade multiplication by the grade's `one` is the identity -/</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"n\">sup_idem</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"sd\">/-- Inter-grade multiplication of `one` elements produces a `one` element -/</span>\n  <span class=\"n\">mul_one_one</span> <span class=\"o\">:</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊔</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Marginalization over sub-grades -/</span>\n  <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span>\n  <span class=\"sd\">/-- Marginalization respects reflexivity of sub-grades -/</span>\n  <span class=\"n\">margin_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"n\">φ</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span>\n  <span class=\"sd\">/-- Marginalization respects transitivity of sub-grades -/</span>\n  <span class=\"n\">margin_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"n\">φ</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">margin</span> <span class=\"n\">φ</span> <span class=\"n\">y</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"n\">p</span>\n  <span class=\"sd\">/-- Marginalization distributes across multiplication in a particular way -/</span>\n  <span class=\"n\">margin_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">le_sup_left</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"n\">sup_inf_self</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">margin</span> <span class=\"n\">ψ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊓</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n  <span class=\"sd\">/-- Casting respects marginalization when a grade is cast -/</span>\n  <span class=\"n\">cast_margin_le_of_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"n\">φ</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">margin</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">q.symm</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">le_of_le_of_eq</span> <span class=\"n\">p</span> <span class=\"n\">q.symm</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Casting respects marginalization when a sub-grade is cast -/</span>\n  <span class=\"n\">cast_margin_eq_of_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">margin</span> <span class=\"n\">φ</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">margin</span> <span class=\"n\">φ</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">le_of_eq_of_le</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I have a couple of proofs formalized but am starting to grind to a halt on the third. There's a substantial overhead to managing the casting; I'm constantly pulling it out of sub-terms with <code>cast_mul</code>, <code>cast_margin_le_of_eq</code>, and <code>cast_margin_eq_of_le</code>, consolidating casts with <code>cast_trans</code>, and bouncing them around with <code>cast_symm</code> derivatives. </p>\n<p>With the proof I'm currently working on I've finally hit a wall and might have to re-examine the approach. I'll admit that I don't have a handle on how to get the most out of the proof system so there might be some more juice I can squeeze without having to build or tear-down any machinery.</p>",
        "id": 411423948,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704484358
    },
    {
        "content": "<p>I don't think you need to add all those extra axioms for <code>cast</code>; they follow from <code>cast_rfl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ValuationAlgebras</span>\n\n\n<span class=\"kd\">variable</span>\n  <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">DistribLattice</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">class</span> <span class=\"n\">ValuationAlgebra</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Cast terms of one grade to another when those grades can be equated -/</span>\n  <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span>\n  <span class=\"sd\">/-- Reflexivity casts to the identity -/</span>\n  <span class=\"n\">cast_rfl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">cast</span> <span class=\"n\">rfl</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">ValuationAlgebra</span> <span class=\"bp\">Φ</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Casting across the symmetry of equality produces inverses -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ValuationAlgebra.cast_symm</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">p</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ψ</span> <span class=\"bp\">↔</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">Eq.symm</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cast_rfl</span><span class=\"o\">,</span> <span class=\"n\">cast_rfl</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Casting across two equalities is casting across their transitivity -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ValuationAlgebra.cast_trans</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cast</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"n\">p</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">p</span>\n  <span class=\"n\">cases</span> <span class=\"n\">q</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cast_rfl</span><span class=\"o\">,</span> <span class=\"n\">cast_rfl</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 411424354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704484589
    },
    {
        "content": "<p>Ah, I was wondering whether they were superfluous! Thanks for the tip.</p>",
        "id": 411424416,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704484627
    },
    {
        "content": "<p>I think you can drop <code>cast_margin_le_of_eq </code> and <code>cast_margin_eq_of_le </code> for the same reason</p>",
        "id": 411424493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704484679
    },
    {
        "content": "<p>One thing that I think you do is build a type akin to <code>GradedMonoid</code>, and put a <code>CommSemigroup</code> structure on it using your <code>Mul</code> fields</p>",
        "id": 411427263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704485961
    },
    {
        "content": "<p>Then whenever you need to do algebraic manipulation, you can switch to that type</p>",
        "id": 411427283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704485974
    },
    {
        "content": "<p>The annoying thing about this structure is that the grade of an element is almost always relevant when you're marginalizing, since the signature of that function is dependent on the grade. Such a pain.</p>\n<p>I'm going to see how much mileage I can get out of your suggestion, though.</p>",
        "id": 411431424,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704488102
    },
    {
        "content": "<p>Oh, I just found out about <code>▸</code>. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is there any reason to prefer using the ad-hoc <code>cast</code> method over this, ex.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ValuationAlgebra</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Inter-grade multiplication -/</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">Φ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊔</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"sd\">/-- Inter-grade multiplication is commutative -/</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sup_comm</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⊔</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">⊔</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">ψ</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 411634366,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704663738
    },
    {
        "content": "<p>Yes, the advantage of the custom cast is that when you make instances of this class, you can choose a cast that is nicer to prove things with.</p>",
        "id": 411634400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704663792
    },
    {
        "content": "<p>It's only when you're in the abstract setting that it makes no difference</p>",
        "id": 411634493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704663878
    },
    {
        "content": "<p>Oh man, the triangle has so much useful machinery <a href=\"https://github.com/leanprover/lean4/blob/903493799dd943193aa019e7df042b1e656203a7/src/Lean/Elab/BuiltinNotation.lean#L325\">built-in</a> (seems like it is automatically applying symmetry arguments?). I've got to explore whether it will be more productive to use this, given that I'm not writing a production-grade library or anything.</p>",
        "id": 411635286,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704664678
    },
    {
        "content": "<p>Oh, but your point is a matter of semantics. Ok, I'll check ahead in the work I'm formalizing and see if I'm pursuing too deep a level of abstraction right now, gauge whether I'll actually be working with some nice concrete structures.</p>",
        "id": 411635393,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704664786
    },
    {
        "content": "<p>Thanks for the tips, again.</p>",
        "id": 411635484,
        "sender_full_name": "N Gelwan",
        "timestamp": 1704664829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Identities.20to.20Equivalences.20in.20Graded.20Structures/near/411634400\">said</a>:</p>\n<blockquote>\n<p>Yes, the advantage of the custom cast is that when you make instances of this class, you can choose a cast that is nicer to prove things with.</p>\n</blockquote>\n<p>In particular, it keeps the cast focused on a particular index. If you use triangle (a.k.a. <code>Eq.rec</code>) this is an unrestricted cast and it's hard (or maybe impossible?) to write lemmas you can be sure can apply with <code>simp</code> or <code>rw</code>. With <code>cast</code>, you can write the casts as algebraic rules.</p>",
        "id": 411644918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704672834
    },
    {
        "content": "<p>If there's no reason for each class instance to have a custom cast, you might consider doing this instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ValuationAlgebra.cast</span> <span class=\"o\">{</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ValuationAlgebra</span> <span class=\"bp\">Φ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Φ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 411645215,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704672990
    }
]