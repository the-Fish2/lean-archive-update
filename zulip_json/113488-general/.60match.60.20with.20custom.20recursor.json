[
    {
        "content": "<p>Is it possible to make <code>match</code> (and other pattern matching stuff) use a custom eliminator? Suppose I have <em>defined</em> my custom inductive type as follows and have a custom recursor for it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Vec</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">def</span> <span class=\"n\">Vec.nil</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">def</span> <span class=\"n\">Vec.cons</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n<span class=\"kd\">def</span> <span class=\"n\">Vec.rec</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>This example is an inductive type, but I will probably have an eliminator for an inductive-inductive type.<br>\nCan I make <code>match</code> use <code>Vec.rec</code> in some way? Is there an attribute I can tag my recursor with to make that work?</p>",
        "id": 433265005,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713180624
    },
    {
        "content": "<p>Unfortunately no</p>",
        "id": 433265183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713180684
    },
    {
        "content": "<p><span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 433265219,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713180697
    },
    {
        "content": "<p>Fair enough</p>",
        "id": 433265283,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713180718
    },
    {
        "content": "<p>I regard this as one of the more important prerequisites for getting coinductive types in lean</p>",
        "id": 433265380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713180737
    },
    {
        "content": "<p>Or inductive-inductive types, since those are fully reducible to inductive types, and are very handy when doing type theory.</p>",
        "id": 433265503,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713180775
    },
    {
        "content": "<p>Although I imagine <code>match</code> might get confused by recursors for IITs / coinductive types being shaped differently, and would have to be adjusted for those use cases specifically?</p>",
        "id": 433265733,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713180839
    },
    {
        "content": "<p>It's a bit unfortunate that lean decided to fix the issues with mutual/nested inductive types by baking them into the kernel instead of improving the support for simulating inductives, because there is a long and open ended list of inductive-likes that we would like to support and not all of them can be baked in</p>",
        "id": 433265866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713180867
    },
    {
        "content": "<p>When you say \"inductive-likes\", you mean anything reducible to indexed W-types, or also types which are more powerful, such as ind-rec?</p>\n<p>Was the original approach to just have indexed W-types and then a reduction to indexed W-types that doesn't live in the kernel? That would have been really neat.</p>",
        "id": 433266373,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713180993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak 游낼</span> <a href=\"#narrow/stream/113488-general/topic/.60match.60.20with.20custom.20recursor/near/433265733\">said</a>:</p>\n<blockquote>\n<p>Although I imagine <code>match</code> might get confused by recursors for IITs / coinductive types being shaped differently, and would have to be adjusted for those use cases specifically?</p>\n</blockquote>\n<p>If I was designing an interface for this it would probably be that <code>match</code> has some plugin functionality of the form \"make me a casesOn for this pattern match I want to do here\", and a coinductive or IIT package would use this as a hook to add the needed functionality</p>",
        "id": 433266488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713181029
    },
    {
        "content": "<p>That sounds sensible yeah!</p>",
        "id": 433266745,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713181095
    },
    {
        "content": "<blockquote>\n<p>Was the original approach to just have indexed W-types and then a reduction to indexed W-types that doesn't live in the kernel? That would have been really neat.</p>\n</blockquote>\n<p>Not quite that far, it would reduce to indexed inductive types</p>",
        "id": 433266760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713181098
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> describes the supported schema of indexed inductives. It did not have to cover nested and mutual inductives exactly because these were simulated</p>",
        "id": 433266962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713181161
    },
    {
        "content": "<p>You can judge this better than me: How hard would it be to add that functionality to <code>match</code>? If it's not too difficult I might actually have a go at it myself.</p>",
        "id": 433267023,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713181178
    },
    {
        "content": "<p>This is the kind of thing that would probably have to be done by the FRO on their schedule, and it's not on the agenda any time soon AFAIK</p>",
        "id": 433268012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713181455
    },
    {
        "content": "<p>Fair enough, I'll be using bare recursors until then.</p>",
        "id": 433268119,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713181497
    },
    {
        "content": "<p>Thank you for answers my questions so quickly btw!</p>",
        "id": 433268441,
        "sender_full_name": "Max Nowak 游낼",
        "timestamp": 1713181588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/.60match.60.20with.20custom.20recursor/near/433266488\">said</a>:</p>\n<blockquote>\n<p>If I was designing an interface for this it would probably be that <code>match</code> has some plugin functionality of the form \"make me a casesOn for this pattern match I want to do here\", and a coinductive or IIT package would use this as a hook to add the needed functionality</p>\n</blockquote>\n<p>On the topic of plugin interfaces for <code>match</code>, it would be nice if <code>~q()</code> matching and <code>match_expr</code> could be absorbed into the same mechanism</p>",
        "id": 433273241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713182908
    },
    {
        "content": "<p>Why can't the community write its own <code>match</code> which solves both the problem indicated here and the one about it sometimes being unnecessarily classical?</p>",
        "id": 433297456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713189259
    },
    {
        "content": "<p>In the case of <code>~q</code>; because <code>match</code> is hard-coded by the <code>do</code> elaborator, so the community would have to write their own version of <code>do</code> too</p>",
        "id": 433301228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713190165
    },
    {
        "content": "<blockquote>\n<p>and the one about it sometimes being unnecessarily classical?</p>\n</blockquote>\n<p>I don't think this problem exists?</p>",
        "id": 433301452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713190207
    },
    {
        "content": "<p>Oh sorry, it sounds like I'm mistaken. I'm on a train in the Netherlands, I'll try and see if I can reconstruct what I actually meant to say once I have a better internet connection</p>",
        "id": 433302665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713190531
    },
    {
        "content": "<p>the issue is with <code>split</code> being classical, not <code>match</code> (although <code>split</code> is kind of a version of <code>match</code>, and is basically the only reasonable way to prove theorems about <code>match</code> expressions)</p>",
        "id": 433305900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713191275
    },
    {
        "content": "<p>Ok so can the community write its own version of <code>do</code> and <code>split</code>?</p>",
        "id": 433484545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713261424
    },
    {
        "content": "<p>Writing our own <code>do</code> would mean duplicating some fraction of <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Elab/Do.lean\">these ~2000 lines</a>, which sounds like the type of fragmentation that is bad for the FRO and the community</p>",
        "id": 433495009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713265169
    },
    {
        "content": "<p>Writing our own <code>split</code> means writing our own <code>simp</code> and everything downstream too, which causes similarly undesirable fragmentation.</p>",
        "id": 433495298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713265263
    },
    {
        "content": "<p>I see. I was just asking because I really had no concept of (a) the scale of the problem and (b) the trouble it might cause. I am very naive about these matters.</p>",
        "id": 433517017,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713272419
    }
]