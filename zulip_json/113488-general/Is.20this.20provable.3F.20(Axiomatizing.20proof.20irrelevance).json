[
    {
        "content": "<p>To make Lean proofs more readily translatable to Dedukti (and eventually other proof assistants), I've been experimenting with using an axiom representing proof irrelevance to allow me to modify terms that implicitly make use of (definitional) proof irrelevance in their typing to instead do so explicitly via type casts (i.e. propositional proof irrelevance). My goal is to build the proofs needed for such casts recursively, in parallel to typechecking, and \"inject\" them where necessary. For example, here is what I (initially) envisioned this \"patching\" would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">prfIrrel</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">q'</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Test</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PatchTest</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">q'</span> <span class=\"o\">:=</span> <span class=\"n\">Test.mk</span> <span class=\"n\">p</span> <span class=\"n\">p'</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">PatchTest'</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">q'</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">q'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">p'</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"n\">prfIrrel</span> <span class=\"n\">P</span> <span class=\"n\">q</span> <span class=\"n\">p</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">prfIrrel</span> <span class=\"n\">P</span> <span class=\"n\">q'</span> <span class=\"n\">p'</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Test.mk</span> <span class=\"n\">p</span> <span class=\"n\">p'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I was quite happy with this approach, until I encountered a somewhat worrysome edge case. It looks like Lean allows for propositions to be indexed by proofs (analogously to how types can be indexed by type instances), which seems to make it difficult to patch examples like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">irrel</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Qp</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">p</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Qq</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- replacing `Type` with `Prop` above, `t` suffices</span>\n</code></pre></div>\n<p>(of course, I will eventually be using <code>Prop</code> instead of <code>Type</code>). I could not manage to prove this with existing theorems (though I may be missing something obvious). I was eventually able to do so, but only by adding an axiom for congruence for <code>HEq</code>, and an extra <code>HEq</code> irrelevance axiom:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">irrelHEq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">congr'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">α₁</span> <span class=\"n\">α₂</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">β₁</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β₂</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β₁</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β₂</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">a₂</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex'</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">eq_of_heq</span> <span class=\"o\">(</span><span class=\"n\">congr'</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">congr'</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">HEq.rfl</span> <span class=\"bp\">$</span> <span class=\"n\">heq_of_eq</span> <span class=\"o\">(</span><span class=\"n\">irrel</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">irrelHEq</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">Q</span> <span class=\"bp\">$</span> <span class=\"n\">irrel</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">Qp</span> <span class=\"n\">Qq</span><span class=\"o\">)))</span>\n  <span class=\"n\">t</span>\n</code></pre></div>\n<p>Looking at the <code>HEq</code> docs, however, it seems like such a congruence theorem cannot be proven. So, my questions are:</p>\n<ol>\n<li>Is the theorem <code>ex</code> above provable?</li>\n<li>If not, would it be problematic to add the <code>congr'</code> axiom above? I imagine doing so might lead to inconsistency somehow (I need to analyze this more thoroughly myself, but if someone already knows...)</li>\n<li>Is this case of proof-indexed propositions even worth considering? Again, this is something I will probably investigate myself by modifying the typechecker to disallow such a case and seeing if mathlib still typechecks, but just wondering if someone already has an idea.</li>\n</ol>",
        "id": 430298633,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1711736468
    },
    {
        "content": "<p>What do you mean by \"<code>ex</code> being provable\"? It is data, hence it cannot be proved, but it certainly can be constructed, eg <code>def ex (t : Test q Qq) : Test p Qp := fun _ _ ↦ Unit</code></p>",
        "id": 430299948,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711737019
    },
    {
        "content": "<p><code>congr'</code> is independent of Lean's logic, so it is not inconsistent to add it</p>",
        "id": 430300012,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711737048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/Is.20this.20provable.3F.20.28Axiomatizing.20proof.20irrelevance.29/near/430299948\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"<code>ex</code> being provable\"? It is data, hence it cannot be proved, but it certainly can be constructed, eg <code>def ex (t : Test q Qq) : Test p Qp := fun _ _ ↦ Unit</code></p>\n</blockquote>\n<p>Right, I guess having changed <code>Prop</code> to <code>Type</code> I should have said \"inhabited\". I'm not sure I follow your construction though, it looks like you gave an instance of the type of <code>Test</code> rather than of <code>Test p Qp</code>?</p>",
        "id": 430301234,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1711737576
    },
    {
        "content": "<p>Oh sorry, I completely misread <code>Test</code></p>",
        "id": 430301877,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711737894
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.SimpRw</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">irrel</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- `ex` is not true if `Q : P → Type`</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Qp</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">p</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Qq</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"c1\">-- I need this because I can only substitute variables, not axioms</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ex_aux</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Qp</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Qq</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">irrel</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n  <span class=\"n\">exact</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"o\">:=</span> <span class=\"n\">ex_aux</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 430305411,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711739602
    },
    {
        "content": "<p>Just so you know, if you specialize <code>congr'</code> to have <code>Prop</code> as the codomain, it's a theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">congr'_prop.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">α₁</span> <span class=\"n\">α₂</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">β₁</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β₂</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β₁</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β₂</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">f₁</span> <span class=\"n\">f₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">exact</span> <span class=\"n\">proof_irrel_heq</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">a₁</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 430306879,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711740340
    },
    {
        "content": "<p><code>irrelHEq</code> is inconsistent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">irrelHEq</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">heq</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"n\">p</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">irrelHEq</span> <span class=\"n\">Bool</span> <span class=\"n\">Bool</span> <span class=\"n\">rfl</span> <span class=\"n\">true</span> <span class=\"n\">false</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n</code></pre></div>",
        "id": 430307153,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711740467
    },
    {
        "content": "<p>The Prop version is fine, and it's the theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=proof_irrel_heq#doc\">docs#proof_irrel_heq</a></p>",
        "id": 430307240,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711740499
    },
    {
        "content": "<p>It turns out you can omit h1 and h2 from <code>congr'_prop</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">congr'_prop.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">α₁</span> <span class=\"n\">α₂</span><span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">β₁</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β₂</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β₁</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β₂</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">a₁</span> <span class=\"o\">:</span> <span class=\"n\">α₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a₂</span> <span class=\"o\">:</span> <span class=\"n\">α₂</span><span class=\"o\">}</span>\n    <span class=\"o\">:</span> <span class=\"n\">HEq</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">a₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">a₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">congr</span><span class=\"bp\">!</span> <span class=\"c1\">-- this ends up being `exact proof_irrel_heq (f₁ a₁) (f₂ a₂)`</span>\n</code></pre></div>",
        "id": 430307421,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711740601
    },
    {
        "content": "<p>Thanks a lot! Though unfortunately both <code>ex_aux</code> and <code>congr'_prop</code>need proof irrelevance in order to type, so I can't (directly) translate them a system where proof irrelevance doesn't exist. This is why I kept things in <code>Type</code> rather than <code>Prop</code> (so that you could try to prove this without having to do any kernel modifications; perhaps I should have been more clear about that).</p>\n<p>However, since <code>congr'</code> is a theorem if I make the <code>f</code>s end in <code>Prop</code>, that tells me that it should be okay for me to add that as an axiom in my translation without risking inconsistency. So I think I'll roll with that for now. Thanks again!</p>",
        "id": 430402783,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1711816267
    },
    {
        "content": "<p>Oh, and actually I think <code>congr'_prop</code> is typable without proof irrelevance using the simpler patching approach I mentioned initially (using just normal <code>congr</code> and <code>prfIrrel</code>), so I think it doesn't even have to be an axiom after all!</p>",
        "id": 430403050,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1711816532
    },
    {
        "content": "<p>Ah yes, and the same could apply to Yael's <code>ex_aux</code>, I suppose. That auxilliary theorem with abstracted variables strategy gives me an idea for how to potentially simplify the patching and perhaps avoid <code>HEq</code> entirely...</p>",
        "id": 430403879,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1711817308
    },
    {
        "content": "<p>Alright! Taking inspiration from Yael's proof, I was able to prove the original statement (sorry, I forgot to include the proposition argument to <code>irrel</code>) without using <code>HEq</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">irrel</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Qp</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">p</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Qq</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">Test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.mpr</span> <span class=\"o\">(</span><span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Eq.ndrec</span> <span class=\"n\">P</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">Qq</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">q</span><span class=\"o\">),</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"bp\">=</span> <span class=\"n\">Test</span> <span class=\"n\">q</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">Qq</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">@</span><span class=\"n\">Eq.ndrec</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Qp</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">Qq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qp</span> <span class=\"bp\">=</span> <span class=\"n\">Test</span> <span class=\"n\">p</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"n\">rfl</span> <span class=\"n\">Qq</span> <span class=\"o\">(</span><span class=\"n\">irrel</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Qp</span> <span class=\"n\">Qq</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"n\">irrel</span> <span class=\"n\">P</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"n\">Qq</span><span class=\"o\">)</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>So, it seems like my handling of the application case of definitional equality will require building the proof linearly (in the left-to-right order of the arguments) rather than recursively so that I can handle any dependent propositions. A bit more complex, but should be doable I think. Thanks again!</p>",
        "id": 430734360,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1712045225
    },
    {
        "content": "<p><code>irrel</code> seems problematic though, as you can use it to prove <code>False</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">irrel</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">irrel</span> <span class=\"n\">Bool</span> <span class=\"n\">true</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 430879334,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712094238
    },
    {
        "content": "<p>this is basically what Kyle pointed out earlier</p>",
        "id": 430879513,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712094301
    },
    {
        "content": "<p><code>irrel</code> is an axiom that says \"all types are subsingletons\", which is clearly not true</p>",
        "id": 430881083,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1712094930
    },
    {
        "content": "<p>Yeah, the final version will have P in Prop, that was just for demo purposes (I’ll be typechecking the patched terms with proof irrelevance disabled)</p>",
        "id": 430912712,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1712115508
    },
    {
        "content": "<p>Though I do see how the inconsistency could be problematic in allowing me to prove things I shouldn’t — I didn’t make use of this inconsistency in my proof above, but if I want to be sure I could instead replace it with a few axioms specializing it to each of the “propositions” (here, types) that I use it with.</p>",
        "id": 430915164,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1712117122
    }
]