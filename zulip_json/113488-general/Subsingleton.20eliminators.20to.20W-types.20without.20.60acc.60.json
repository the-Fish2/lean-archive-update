[
    {
        "content": "<p>I was reading <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ’s thesis and in Section 5.3 he describes the process for translating subsingleton eliminators into W-types. As I understand it, subsingleton eliminators are defined as inductive types where:</p>\n<ol>\n<li>they have ≤ 1 constructor;</li>\n<li>all arguments to all constructors live in <code>Prop</code>, or appear directly as indices.</li>\n</ol>\n<p>The definition given in the paper of the W-type is given for universe levels at least one, meaning subsingleton eliminators have to be handled specially. However, is there any reason why we can’t generalize W-types to any universe level including zero, giving us subsingleton elimination as a natural result and eliminating the need for <code>acc</code>? Lean is perfectly happy to accept the universe-zero inductive-type definition of <code>W</code>, and it large-eliminates:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sup</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">W</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">W</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n</code></pre></div>\n<p>It seems to me that subsingleton eliminators  very naturally fall out of this (as long as we have <strong>1</strong> living in <code>Prop</code>, I suppose, and we erase indices sufficiently). I guess my main question is if this works, what advantages are there of the two approaches?</p>",
        "id": 410064736,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1703622861
    },
    {
        "content": "<p>No, that inductive type is too weak. Keep in mind that <code>Sort 0</code> is just <code>Prop</code>, so this is a fancy proposition, and the recursion doesn't do much - it is equivalent to <code>∃ a : α, ¬β a</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">⟩⟩</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sup</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 410088184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703640286
    },
    {
        "content": "<p>Right, I think I was a bit confused because I didn’t reälize that recursive subsingleton eliminators are so rare anyway, with <code>Acc</code> beïng the only example I can actually think of.</p>\n<p>I still don’t quite understand though. Would it be correct to say that the only power these recursive subsingleton eliminators give you over everything introduced prior is the ability for <code>β</code> to depend on the indices?</p>",
        "id": 410447655,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1703866189
    },
    {
        "content": "<p>The thing that <code>Acc</code> has an no previous inductive does is that it's an <em>indexed</em> large eliminating recursive inductive proposition.</p>",
        "id": 410451636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703868513
    },
    {
        "content": "<p><code>Eq</code> is the only other indexed large eliminating inductive prop introduced prior and it's not recursive</p>",
        "id": 410451720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703868567
    },
    {
        "content": "<p><code>W</code> types aren't indexed. You can consider having indexed <code>W</code> types, and these can potentially subsume <code>Acc</code>, but you still have trouble because <code>α</code> and <code>β</code> had to have their types changed above, that's not a normal <code>W</code> type which has no universe restrictions on <code>α</code> and <code>β</code>. So this is a new type regardless of whether you call it <code>W</code> or a variant thereof</p>",
        "id": 410451919,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703868690
    },
    {
        "content": "<p><code>Acc</code> just happens to be the simplest inductive in its class, indexed <code>W</code> has more parameters</p>",
        "id": 410452010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703868731
    },
    {
        "content": "<p>That makes more sense. I think my main point of confusion is why indexed large eliminating recursive propositions need to be their own class of inductive type as opposed to regular indexed large eliminating recursive types. But I’m willing to accept that <code>Prop</code> is weird enough that it’s just true.</p>",
        "id": 410452553,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1703869129
    },
    {
        "content": "<p>well, the rules for <code>LE ctor</code> basically make these two separate cases: a regular large eliminating type has to have a target universe which does not allow <code>Sort 0</code></p>",
        "id": 410461314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703872893
    },
    {
        "content": "<p>Sorry to necropost, but I’ve come to a reälization that I believe <code>Acc</code> can be implemented using function comprehension (principle of unique choice) if one chooses, as <a href=\"https://gist.github.com/SabrinaJewson/3ce1b01c3976dd21bd6ff7798e20966b\">this gist should demonstrate</a>.</p>\n<p>After this thread I was still very confused, but I think this helps: the fundamental thing that’s “special” about <code>Acc</code> is it allows function comprehension for one specific type family.</p>",
        "id": 420927069,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1707690519
    },
    {
        "content": "<p>Unique choice is not computable though, in the sense that the compiler cannot produce code for it. <code>Acc</code> does not have this issue, even if we say that Acc proofs are opaque and kernel reduction on Acc is blocked.</p>",
        "id": 420939254,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707701253
    },
    {
        "content": "<p>I think the use of <code>noncomputable</code> in the gist because of direct use of recursors is obscuring this; you should import <code>Mathlib.Util.CompileInductive</code> and then the things you have to mark as <code>noncomputable</code> should be more informative</p>",
        "id": 420939371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707701397
    },
    {
        "content": "<p>Yes, that is true — I was just trying to justify in my mind why we need it. And the answer to that, I now see, can be “we need it as a fundamental primitive because otherwise it is noncomputable“.</p>",
        "id": 420972294,
        "sender_full_name": "Sabrina Jewson",
        "timestamp": 1707725802
    }
]