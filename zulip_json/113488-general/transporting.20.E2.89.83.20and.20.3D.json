[
    {
        "content": "<p>Has there been any work done on automatically generating congruence principles for inductive types like the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Fin.equivCongr</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">≃</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">Vector.equivCongr</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">≃</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">T</span> <span class=\"n\">n</span> <span class=\"bp\">≃</span> <span class=\"n\">Vec</span> <span class=\"n\">U</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">Sigma.equivCongr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">≃</span> <span class=\"n\">β'</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Sigma</span> <span class=\"n\">β</span> <span class=\"bp\">≃</span> <span class=\"n\">Sigma</span> <span class=\"n\">β'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(Notice that the appropriate hypotheses get a bit more complicated as dependent types get involved)</p>\n<p>I've been playing around with this, and in the case of inductive families like <code>Vector</code>, proving the congruence principles require induction on the index type (e.g. <code>Nat</code>). This induction would only get more complicated if you had e.g. a family indexed by values in another family, so I think it might take some insight to design a modular procedure for generating these.</p>",
        "id": 430168041,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711663021
    },
    {
        "content": "<p>I don't know of any work toward this, but I think it's a worthwhile metaprogramming challenge. For one, you have to decide when to use equality and when to use an equivalence (maybe even go further, and ask for an equivalence of categories as a parameter when appropriate?!).</p>",
        "id": 430168492,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1711663254
    },
    {
        "content": "<p>I was thinking about this a couple months ago.</p>\n<p>Ideally, there would be something that could figure out whether the maps on type parameters have to be covariant, contravariant, an equivalence, or an equality, and then produce the functor, rather than just an equivalence.</p>",
        "id": 430168577,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711663302
    },
    {
        "content": "<p>For example, you could generate this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Vector.map</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">Vec</span> <span class=\"n\">T</span> <span class=\"n\">n</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Vec</span> <span class=\"n\">U</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 430168749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711663381
    },
    {
        "content": "<p>The <code>Sigma</code> example is more interesting, and what I remember is that can deduce that <code>e</code> has to be an equivalence if you want to write it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Sigma.map</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">β'</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">Sigma</span> <span class=\"n\">β</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Sigma</span> <span class=\"n\">β'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(I'm not sure what factoring out that equality <code>e a = a'</code> could do. It seems like it could potentially be useful to make it easier to apply, but usually it's not necessary.)</p>",
        "id": 430169054,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711663555
    },
    {
        "content": "<p>My thinking was that <code>e a = a'</code> might be the way to express \"<code>a</code> is equivalent to <code>a'</code>\" given <code>e : α ≃ α</code> and it seemed simplest to have the consistent \"shape\" for congruence hypotheses \"if the inputs are equivalent, the outputs are equivalent\"</p>",
        "id": 430170181,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711664244
    },
    {
        "content": "<p>I don't remember which type needed that to be an equiv, bot <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sigma.map#doc\">docs#Sigma.map</a> shows equivalence isn't necessary here.</p>\n<p>Maybe it was just for the purpose of putting <code>e</code> to the left side, which could be necessary for some applications. (I was imagining using these auto-generated congruences for implementing a <code>simp</code> for equivalences.)</p>",
        "id": 430170849,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711664633
    }
]