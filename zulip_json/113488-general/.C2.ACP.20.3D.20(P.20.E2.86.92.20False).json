[
    {
        "content": "<p>I was humiliated by Lean today during my undergrad lecture: I was explaining definitional equality and I confidently wrote</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>only for it to fail (this was after I had explained <code>set_option pp.notation false</code> and <code>unfold Not</code> in the middle of some other proof). I had not yet spoken about <code>P &lt;-&gt; Q</code>, but my hand was forced and this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>does work, which forced me to go on a digression, although I could not explain why the <code>=</code> version failed to my class. Can someone explain this to me?</p>",
        "id": 412972085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705329930
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 412972321,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1705330003
    },
    {
        "content": "<p>I had been so careful to put the brackets around <code>P -&gt; False</code> too! Thanks Alex :-)</p>",
        "id": 412973409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705330358
    },
    {
        "content": "<p>BTW how do we call this kind of equality? Certainly <code>¬P</code> and <code>P → False</code> are definitionally equal. However, is it even more? I heard <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span> say they are syntactically equal, which should be even stronger than definitionally equal?</p>",
        "id": 412982446,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705332786
    },
    {
        "content": "<p>they are not syntactically equal</p>",
        "id": 412983216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705333002
    },
    {
        "content": "<p>I'm not sure it's syntactic, given that we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Not#doc\">docs#Not</a></p>",
        "id": 412983238,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705333008
    },
    {
        "content": "<p>it's also not a reducible defeq, <code>Not</code> is a regular definition</p>",
        "id": 412983310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705333039
    },
    {
        "content": "<p>Oh, so syntactic equality is a valid concept but <code>¬P</code> and <code>P → False</code> is not an example of syntactic equality?</p>",
        "id": 412984371,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705333342
    },
    {
        "content": "<p>Yes. It would be an example if we had only notation involved and no definition.</p>",
        "id": 412984823,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1705333496
    },
    {
        "content": "<p>So for example <code> ¬P</code> and <code>Not P</code> are syntactically equal</p>",
        "id": 412985020,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705333561
    },
    {
        "content": "<p>Thank you!<br>\nIs there any reason to distinguish syntactic equality from definitional equality?</p>",
        "id": 412985306,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705333631
    },
    {
        "content": "<p>Some tactics are sensitive to this, notably <code>rw</code></p>",
        "id": 412985401,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1705333664
    },
    {
        "content": "<p>Also (and this is related to why <code>rw</code> works with syntactic equality), definitional equality can be quite expensive to determine sometimes (cf. \"heavy rfl\")</p>",
        "id": 412985558,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705333707
    },
    {
        "content": "<p>The elaborator relies on syntactical equality for a few things during type-checking. Among other things, many tactics such as <code>simp</code> and <code>rw</code> use syntactical checks, type-class synthesis is almost syntactical (only definitions marked as <code>reducible</code> will reduce), and the unification algorithm (what's used to fill-in implicit arguments/wildcards <code>_</code>) has to be careful with reduction if it wants to solve meta-variables efficiently.</p>",
        "id": 412986100,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705333898
    },
    {
        "content": "<p>Do <code>reducible</code> definitions also work for <code>rw</code> and its variants?</p>",
        "id": 412986304,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705333954
    },
    {
        "content": "<p>The following fails, so I'm guessing <code>rw</code> never reduces things:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 412986512,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705334025
    },
    {
        "content": "<p>Do I get it right now? From the strongest to the weakest:<br>\n(1) syntactic equality<br>\n(2) definitional equality (a.k.a. algorithmic equality)<br>\n(3) judgemental equality (not accessible in Lean)<br>\n(4) propositional equality</p>",
        "id": 412987008,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334162
    },
    {
        "content": "<p>Definitional and judgemental equality are the same thing.</p>",
        "id": 412987448,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705334287
    },
    {
        "content": "<p>I thought judgemental equality is supposed to be the transitive one (from some very general type theory).</p>",
        "id": 412987559,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334316
    },
    {
        "content": "<p>Unless you differentiate between the theoretical judgemental equality of LeanTT and the implemented definitional equality</p>",
        "id": 412987569,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705334321
    },
    {
        "content": "<p>Right, then there is a difference between the two. In most proof assistants, algorithmic equality (what you refer to as definitional equality) is equal to judgemental equality, but this isn't the case in Lean.</p>",
        "id": 412987800,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705334388
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 412987900,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1705334408
    },
    {
        "content": "<p>I suppose this is because of <code>rfl</code> after <code>rw</code>?</p>",
        "id": 412987998,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1705334446
    },
    {
        "content": "<p>OK, but to use to right terminology when teaching, \"definitional equality\" is the (2), not (3), right?</p>",
        "id": 412988009,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113488-general/topic/.C2.ACP.20.3D.20.28P.20.E2.86.92.20False.29/near/412987900\">said</a>:</p>\n<blockquote>\n<p>This works:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It is because <code>2</code> is matched successfully (here the syntactic equality clicks) and then the cheap <code>rfl</code> is executed, closing the goal.</p>",
        "id": 412988473,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334589
    },
    {
        "content": "<p>Yeah. Further replacing <code>rw</code> with <code>simp_rw</code> in Arthur's code works (with <code>import Mathlib.Tactic</code>). so is the following correct?:</p>\n<ol>\n<li><code>rw</code> is for rewriting with syntactic equality</li>\n<li><code>simp_rw</code> is roughly for rewriting with definitional equality.</li>\n</ol>",
        "id": 412988869,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1705334726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113488-general/topic/.C2.ACP.20.3D.20.28P.20.E2.86.92.20False.29/near/412986100\">said</a>:</p>\n<blockquote>\n<p>The elaborator relies on syntactical equality for a few things during type-checking. Among other things, many tactics such as <code>simp</code> and <code>rw</code> use syntactical checks, type-class synthesis is almost syntactical (only definitions marked as <code>reducible</code> will reduce), and the unification algorithm (what's used to fill-in implicit arguments/wildcards <code>_</code>) has to be careful with reduction if it wants to solve meta-variables efficiently.</p>\n</blockquote>\n<p>Do we have a name for the equality where only <code>reducible</code> definitions get reduced? It would fall into the gap between (1) and (2) probably.</p>",
        "id": 412988912,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334742
    },
    {
        "content": "<p>\"definitional equality\" and \"judgmental equality\" are synonyms, we generally use the former</p>",
        "id": 412989479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705334927
    },
    {
        "content": "<p>What is (3) called then?</p>",
        "id": 412989618,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334975
    },
    {
        "content": "<p>Conversion would be suitable.</p>",
        "id": 412989672,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705334993
    },
    {
        "content": "<p>Or are they both (3)... (2) would then be called \"algorithmic equality\" and nothing else?</p>",
        "id": 412989776,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705335019
    },
    {
        "content": "<p>I'd say calling (2) \"algorithmic equality/conversion\" and (3) \"conversion\", \"definitional equality\" or \"judgemental equality\" would be best. However, one could also argue that the type-theory that Lean implements simply doesn't have transitivity of judgemental equality as a judgement. In that case, (2) and (3) would be \"the same\" in some sense.</p>",
        "id": 412990347,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705335212
    },
    {
        "content": "<p>In the same manner, one could argue that Coq doesn't implement the same type-theory as the one formalised in Metacoq, since Coq's conversion has η-expansion, but PCUIC doesn't. In that case, both would be \"definitional equality\", but they would simply be the definitional equalities of two different type theories.</p>",
        "id": 412990762,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705335353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/.C2.ACP.20.3D.20.28P.20.E2.86.92.20False.29/near/412988912\">said</a>:</p>\n<blockquote>\n<p>Do we have a name for the equality where only <code>reducible</code> definitions get reduced? It would fall into the gap between (1) and (2) probably.</p>\n</blockquote>\n<p>Probably <code>abbrev</code> in idiomatic Lean 4 code.</p>",
        "id": 412990776,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705335358
    },
    {
        "content": "<p>Let me refine it. From the strongest to the weakest:<br>\n(1) syntactic equality (which <code>rw</code> cares about when \"matching the subterms\")<br>\n(2) syntactic + <code>reducible</code> definitions equality (which type-class synthesis uses; can close the goal after <code>rw</code>)<br>\n(3) algorithmic equality (which <code>rfl</code> decides)<br>\n(4) type-theoretic equality (which isn't accessible from Lean)<br>\n(5) propositional equality (which we can prove theorems about)</p>\n<p>This is a summary of what I learnt so far.<br>\nThe words \"definitional equality\" and \"judgemental equality\" can be used to describe (3) or (4), depending on the context.</p>\n<p>I have questions:<br>\nAre all of them symmetric?<br>\nAre only (4) and (5) transitive?<br>\nDoes (2) have a name?</p>\n<p>PS: Sorry for such a long detour.</p>",
        "id": 413126340,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705401668
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885883\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/is.20there.20a.20way.20to.20rename.20a.20type.20such.20as.20N.20.3A.3D.20Nat/near/412885883</a></p>",
        "id": 413127873,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705402191
    },
    {
        "content": "<ul>\n<li>All of them should be symmetric, yes (unless some bugs makes it otherwise)</li>\n<li>(1) is also transitive, but (2) and (3) aren't</li>\n<li>not really.</li>\n</ul>\n<p>If you want to refine this even more, in practice, there are 4 kinds of algorithmic equality at the elaborator level, they correspond to the different <a href=\"https://github.com/leanprover/lean4/blob/f8edf452dec50d2d310737c266a1db112386ecda/src/Init/MetaTypes.lean#L23\"><code>TransparencyMode</code>s</a> (even more than that if you also consider <code>EtaStructMode</code>s). At the kernel level however, there is only one kind of algorithmic equality, which would correspond to the <code>all</code> transparency /etaStruct mode.</p>",
        "id": 413128393,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1705402339
    },
    {
        "content": "<p>I'm pretty sure rw uses 2 not 1</p>",
        "id": 418763984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706587510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.C2.ACP.20.3D.20.28P.20.E2.86.92.20False.29/near/418763984\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure rw uses 2 not 1</p>\n</blockquote>\n<p>Both for matching things and for closing the goal after rewrite?</p>",
        "id": 418805321,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1706609942
    },
    {
        "content": "<p>I believe so, otherwise <code>abbrev</code> wouldn't be very useful</p>",
        "id": 419124679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706735859
    }
]