[
    {
        "content": "<p>Consider this definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I just managed to provide an instance of <code>DecidableEq Term</code>, but it wasn't easy. Is there a better way to do it?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>open Term in<br>\nmutual <br>\n  private def aux₁ : DecidableEq Term<br>\n    | var x, var y =&gt; by simp; infer_instance<br>\n    | var x, app f args =&gt; by simp; infer_instance <br>\n    | app f args, var y =&gt; by simp; infer_instance<br>\n    | app f₁ args₁, app f₂ args₂ =&gt; by<br>\n      rw [app.injEq]<br>\n      apply @instDecidableAnd _ _ _ (aux₂ args₁ args₂)</p>\n<p>private def aux₂ : DecidableEq (List Term)<br>\n    | [], [] =&gt; by simp; infer_instance<br>\n    | [], y::ys =&gt; by simp; infer_instance<br>\n    | x::xs, [] =&gt; by simp; infer_instance<br>\n    | x::xs, y::ys =&gt; by<br>\n      rw [List.cons.injEq]<br>\n      apply @instDecidableAnd _ _ (aux₁ x y) (aux₂ xs ys)<br>\nend</p>\n<p>instance : DecidableEq Term := aux₁ </p>\n</div></div>\n<p>In any case, I am impressed that Lean can handle such recursive definitions.</p>",
        "id": 429099551,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1711215390
    },
    {
        "content": "<p>With a few helper functions for <code>Decidable</code>, you can write it pretty much like a boolean function directly, which I think is about the bare minimum you'd expect if you had to write an equality function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CoeOut</span> <span class=\"o\">(</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">@</span><span class=\"n\">decide</span> <span class=\"n\">p</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">dtrue</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">isTrue</span> <span class=\"n\">h</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">dfalse</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">isFalse</span> <span class=\"n\">h</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">decide_by</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"n\">decidable_of_iff</span> <span class=\"n\">q</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Term</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">args</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Term</span>\n\n<span class=\"kd\">mutual</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">deq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">var</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">var</span> <span class=\"bp\">..</span><span class=\"o\">,</span> <span class=\"n\">app</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dfalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"bp\">..</span><span class=\"o\">,</span> <span class=\"n\">var</span> <span class=\"bp\">..</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dfalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">app</span> <span class=\"n\">f₁</span> <span class=\"n\">args₁</span><span class=\"o\">,</span> <span class=\"n\">app</span> <span class=\"n\">f₂</span> <span class=\"n\">args₂</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"bp\">==</span> <span class=\"n\">f₂</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">Term.deq_list</span> <span class=\"n\">args₁</span> <span class=\"n\">args₂</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">deq_list</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"bp\">=</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dtrue</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dfalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">::</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dfalse</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">decide_by</span> <span class=\"o\">(</span><span class=\"n\">Term.deq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">Term.deq_list</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">DecidableEq</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span> <span class=\"n\">Term.deq</span>\n</code></pre></div>",
        "id": 429106694,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711220969
    },
    {
        "content": "<p>Little warning about your version: if you do <code>by simp; infer_instance</code> or use <code>rw</code>, it's possible to get <code>Decidable</code> terms that can't reduce (for example, it can cause the <code>decide</code> tactic to fail). It's better to use <code>decidable_of_iff</code>, which pushes the rewrite into the proofs. Here, I wrapped that up in <code>decide_by</code>.</p>",
        "id": 429106809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711221058
    },
    {
        "content": "<p>A neat thing that works out with my version is that the compiled code even respects the short-circuiting behavior of <code>&amp;&amp;</code>, so it's as efficient as it looks (if you treat <code>decide_by</code> as being this weird cast you have to insert.)</p>",
        "id": 429107507,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711221577
    },
    {
        "content": "<p>(Ideally we could just write <code>deriving DecidableEq</code>, but that doesn't support nested inductives yet.)</p>",
        "id": 429108014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711221976
    }
]