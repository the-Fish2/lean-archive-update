[
    {
        "content": "<p>Mathlib has new tactic <code>fun_prop</code> that can prove FUNction PROperties like differentiability, continuity, measurability etc. It should be faster then <code>continuity</code> and hopefully work in more cases. </p>\n<p>Example use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.ContDiff</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.fun_prop</span> <span class=\"n\">true</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ContDiffOn</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">Real.log</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">Real.exp</span> <span class=\"n\">x</span> <span class=\"bp\">/</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">aesop</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>To use this tactic just mark some function property and corresponding theorems with the attribute  <code>@[fun_prop]</code>, <a href=\"https://github.com/leanprover-community/mathlib4/tree/master//test/fun_prop.lean\">here is a short literate lean file</a> that explains how to set it up for <code>Measurable</code>.</p>\n<p>Right now, only the tactic itself has been added to mathlib. What needs to be done is to mark all the relevant theorems wit h <code>@[fun_prop]</code>. </p>\n<p>As a start there are few files setting up <code>fun_prop</code> for <a href=\"https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Tactic/FunProp/Continuous.lean\"><code>Continuous(At/On)</code></a>, <a href=\"https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Tactic/FunProp/Differentiable.lean\"><code>Differentiable(At/On)</code></a>, <a href=\"https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Tactic/FunProp/ContDiff.lean\"><code>ContDiff(At/On)</code></a>, <a href=\"https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Tactic/FunProp/Measurable.lean\"><code>Measurable</code></a> and <a href=\"https://github.com/leanprover-community/mathlib4/tree/master/Mathlib/Tactic/FunProp/AEMesurable.lean\"><code>AEMeasurable</code></a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.Continuous</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.Differentiable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.ContDiff</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.Measurable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.AEMeasurable</span>\n</code></pre></div>\n<p>The tactic still needs refinement and testing. Before we start putting the <code>fun_prop</code> attribute all over mathlib I would appreciate if people help expand these files with relevant theorems. This would help me a lot to iron out all the wrinkles of the tactic. Adding analogous files for another function properties (like linearity) would be also great.</p>",
        "id": 419743429,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707090677
    },
    {
        "content": "<p>This is fantastic, thank you <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>!</p>\n<p>One request I missed during review: could you rename the <code>disch</code> config option to <code>discharger</code>, for consistency with all the other tactics?</p>\n<p>Oh, and again for consistency I think it should be <code>fun_prop (config := {discharger := aesop})</code> if possible, even if it is more verbose.</p>",
        "id": 419744619,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707091779
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.discharger#doc\">docs#Lean.Parser.Tactic.discharger</a> specifically for discharger syntax, and it allows both <code>(discharger := ...)</code> and <code>(disch := ...)</code></p>",
        "id": 419744795,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707091945
    },
    {
        "content": "<p>I followed <code>simp</code> <a href=\"https://github.com/leanprover/lean4/blob/cf092e79416c959a8238d89841963a8eb89c2a77/src/Init/Tactics.lean#L504\">convention</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"s2\">\"simp\"</span> <span class=\"o\">(</span><span class=\"n\">config</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">discharger</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">&amp;</span><span class=\"s2\">\" only\"</span><span class=\"o\">)</span><span class=\"bp\">?</span>\n  <span class=\"o\">(</span><span class=\"s2\">\" [\"</span> <span class=\"n\">withoutPosition</span><span class=\"o\">((</span><span class=\"n\">simpStar</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">simpErase</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">simpLemma</span><span class=\"o\">),</span><span class=\"bp\">*</span><span class=\"o\">,</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"s2\">\"]\"</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">location</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>Right now the syntax is defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">funPropTacStx</span><span class=\"o\">)</span> <span class=\"s2\">\"fun_prop\"</span> <span class=\"o\">(</span><span class=\"n\">discharger</span><span class=\"o\">)</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>so I'm using the same parser for discharger as simp. In future I will add some configuration, but I'm still not sure what.</p>",
        "id": 419744818,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707091978
    },
    {
        "content": "<p>This is great. Thanks!</p>\n<p>One minor remark: can we move the tests from <code>Mathlib/Tactic/FunProp</code> to the <code>test</code> folder? Especially the tests that add new (private) axioms.</p>",
        "id": 419886513,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1707152293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/419886513\">said</a>:</p>\n<blockquote>\n<p>This is great. Thanks!</p>\n<p>One minor remark: can we move the tests from <code>Mathlib/Tactic/FunProp</code> to the <code>test</code> folder? Especially the tests that add new (private) axioms.</p>\n</blockquote>\n<p>Ok, makes sense.</p>\n<p>My thinking with the current file was that before we add <code>fun_prop</code> attribute all over mathlib we expand the files like <code>Mathlib.Tactic.FunProp.Continuous</code> and you can import it to get <code>fun_prop</code> working for <code>Continuous</code>. But maybe there is no point in waiting and I just start labeling theorems.</p>",
        "id": 419905479,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707158721
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I think that approach is fine, especially if there is a certain form of lemma that should be tagged <code>fun_prop</code>, and others that shouldn't, as is the case with <code>gcongr</code>. That will allow Mathlib users to get a feel for which lemmas should be marked that way. (we can redistribute the tags later.)</p>\n<p>Floris' point was just about the <em>tests</em>.</p>",
        "id": 419906043,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707158903
    },
    {
        "content": "<p>Ohh I didn't read the message properly <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 419906470,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707159032
    },
    {
        "content": "<p>Ok done <a href=\"https://github.com/leanprover-community/mathlib4/pull/10281\">#10281</a></p>",
        "id": 419909933,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707160341
    },
    {
        "content": "<p>A PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/10724\">#10724</a> fixing bunch of issues is ready. Here are the changes:</p>\n<ol>\n<li><code>fun_prop</code> now correctly uses inductive hypothesis </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousAt</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ContinuousAt</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span>\n  <span class=\"n\">case</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">fun_prop</span>\n  <span class=\"n\">case</span> <span class=\"n\">succ</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">fun_prop</span>\n</code></pre></div>\n<ol start=\"2\">\n<li>Improved error messages. <br>\nConsider this example where you  you forget to state continuity theorem for <code>foo</code></li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Real</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Real</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n</code></pre></div>\n<p>You get an error saying what might went wrong</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"n\">fun_prop</span><span class=\"bp\">`</span> <span class=\"n\">was</span> <span class=\"n\">unable</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"bp\">`</span><span class=\"n\">Continuous</span> <span class=\"n\">foo</span><span class=\"bp\">`</span>\n\n<span class=\"n\">Try</span> <span class=\"n\">running</span> <span class=\"k\">with</span> <span class=\"n\">discharger</span> <span class=\"bp\">`</span><span class=\"n\">fun_prop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">aesop</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"n\">or</span> <span class=\"k\">with</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">discharger</span> <span class=\"n\">tactic</span> <span class=\"n\">like</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">linarith</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">omega</span><span class=\"bp\">`.</span>\n<span class=\"n\">Sometimes</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">useful</span> <span class=\"n\">to</span> <span class=\"n\">run</span> <span class=\"bp\">`</span><span class=\"n\">fun_prop</span> <span class=\"o\">(</span><span class=\"n\">disch</span><span class=\"o\">:=</span><span class=\"n\">trace_state</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span><span class=\"bp\">`</span> <span class=\"n\">which</span> <span class=\"n\">will</span> <span class=\"n\">print</span> <span class=\"n\">all</span> <span class=\"n\">the</span> <span class=\"n\">necessary</span> <span class=\"n\">subgoals</span> <span class=\"n\">for</span> <span class=\"bp\">`</span><span class=\"n\">fun_prop</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">succeed.</span>\n\n<span class=\"n\">Potential</span> <span class=\"n\">issues</span> <span class=\"n\">to</span> <span class=\"n\">fix</span><span class=\"o\">:</span>\n  <span class=\"n\">No</span> <span class=\"n\">theorems</span> <span class=\"n\">found</span> <span class=\"n\">for</span> <span class=\"bp\">`</span><span class=\"n\">foo</span><span class=\"bp\">`</span> <span class=\"k\">in</span> <span class=\"n\">order</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">Continuous</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo</span> <span class=\"n\">x</span>\n\n<span class=\"n\">For</span> <span class=\"n\">more</span> <span class=\"n\">detailed</span> <span class=\"n\">information</span> <span class=\"n\">use</span> <span class=\"bp\">`</span><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.fun_prop</span> <span class=\"n\">true</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>I'm still unsure what to report and how much or in what order. Feedback and examples when it goes wrong on this would be greatly appreciated.</p>\n<ol start=\"3\">\n<li>Unfolding definitions by calling <code>fun_prop [foo]</code> which makes above proof to go through without stating a continuity theorem about <code>foo</code>.</li>\n<li>Functions <code>id</code>, <code>Function.comp</code>, <code>Function.uncurry</code> and <code>HasUncurry.uncurry</code> are considered reducible by default.<br>\nMany mathlib theorems are stated using <code>id</code> or <code>∘</code> so there is no need to formulate them again  using lambda functions.<br>\nSphere-eversion project uses heavily uncurry notation <code>↿</code> and <code>Function.uncurry</code> to state theorems and their assumptions.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">surroundingLoop</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">Loop</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Loop.roundTripFamily</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">O_conn.somePath</span> <span class=\"n\">hb</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">O_conn.pathThrough</span> <span class=\"n\">hp</span> <span class=\"n\">d</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">continuous_surroundingLoop</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"bp\">↿</span><span class=\"o\">(</span><span class=\"n\">surroundingLoop</span> <span class=\"n\">O_conn</span> <span class=\"n\">hp</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Loop.roundTripFamily_continuous</span>\n</code></pre></div>\n<p><code>fun_prop</code> correctly detects that <code>continuous_surroundingLoop</code> is a continuity theorem about <code>surroundingLoop</code> in two arguments(<code>Loop F</code> are just periodic functions with values in <code>F</code>)</p>\n<ol start=\"5\">\n<li>\n<p>Extended support for bundled morphisms. <br>\nIf you want to use <code>fun_prop</code> with a new bundled morphism you have to register the coercion to functions with <code>@[fun_prop_coe]</code> attribute. If the new bundled morphism uses <code>FunLike</code> typeclass then you do not have to do anything as <code>DFunLike.coe</code> is already marked with this attribute.</p>\n</li>\n<li>\n<p>Argument annotations like <code>outParam</code> and <code>autoParam</code> do not prevent <code>fun_prop</code> from working correctly.</p>\n</li>\n<li>Added a counter that should prevent infinite loop causing stack overflow crash.</li>\n</ol>",
        "id": 422486747,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708457030
    },
    {
        "content": "<p>Regarding 5: can we reuse the existing <code>@[coe]</code> mechanism for registering function coercions, rather than making a new one?</p>",
        "id": 422572621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708506410
    },
    {
        "content": "<p>(this is the mechanism that controls <code>⇑</code> pretty printing)</p>",
        "id": 422572805,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708506484
    },
    {
        "content": "<p>Do we have the standard attribute storage issue?</p>",
        "id": 422575147,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1708507399
    },
    {
        "content": "<p>I will have a look if I can reuse <code>coe</code> but it might not be possible as it is used for normal coercion and function coercion. That could cause problems when for example proving continuity of coercion from reals to complex numbers.</p>",
        "id": 422598025,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708515505
    },
    {
        "content": "<p>The different types of coercion are recorded separately</p>",
        "id": 422600481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708516441
    },
    {
        "content": "<p><code>DFunlike.coe</code> is registered as <code>.coeFun</code> with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Lean.Elab.Command.liftTermElabM</span> <span class=\"k\">do</span>\n  <span class=\"n\">Std.Tactic.Coe.registerCoercion</span> <span class=\"bp\">``</span><span class=\"n\">DFunLike.coe</span>\n    <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">{</span> <span class=\"n\">numArgs</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"n\">coercee</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">coeFun</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 422600615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708516486
    },
    {
        "content": "<p>Obviously we could have better syntax for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.Coe.registerCoercion#doc\">docs#Std.Tactic.Coe.registerCoercion</a>, but we should reuse that mechanism if possible</p>",
        "id": 422600670,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708516508
    },
    {
        "content": "<p>This looks great and that it already has the number of arguments is also very useful.</p>",
        "id": 422600975,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708516648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/422575147\">said</a>:</p>\n<blockquote>\n<p>Do we have the standard attribute storage issue?</p>\n</blockquote>\n<p>You can get the data back out with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Tactic.Coe.getCoeFnInfo%3F#doc\">docs#Std.Tactic.Coe.getCoeFnInfo?</a></p>",
        "id": 422601280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708516776
    },
    {
        "content": "<p>I see that <code>DFunLike.coe</code> is registered with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">Lean.Elab.Command.liftTermElabM</span> <span class=\"k\">do</span>\n  <span class=\"n\">Std.Tactic.Coe.registerCoercion</span> <span class=\"bp\">``</span><span class=\"n\">DFunLike.coe</span>\n    <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">{</span> <span class=\"n\">numArgs</span> <span class=\"o\">:=</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"n\">coercee</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">coeFun</span> <span class=\"o\">})</span>\n</code></pre></div>\n<p>Should I make a PR to std4 or to mathlib for <code>coe_fun</code> attribute?</p>",
        "id": 422617986,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708522270
    },
    {
        "content": "<p>I think it belongs in Std</p>",
        "id": 422619128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708522597
    },
    {
        "content": "<p>Certainly a nicer syntax would be good, although I suspect mathlib is not ever going to use it more than once</p>",
        "id": 422619170,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708522614
    },
    {
        "content": "<p>I have one application in mind. I'm working on differentiation of functions that return measures or distributions. To state that function <code>f : X → Distribution Y</code> is differentiable I say that for any differentiable function <code>φ</code>, <code>(hφ : Differentiable ℝ φ)</code>, we have <code>Differentiable ℝ (fun x =&gt; ⟪f x, φ x⟫)</code>.  In this case, if I treat the function <code>fun f =&gt; ⟪f,·⟫</code> as function coerction then I can use <code>fun_prop</code> to automate proofs.</p>",
        "id": 422620825,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708523057
    },
    {
        "content": "<p>That feels like a very weird thing to register as a coercion to me, though I also can't tell exactly what you mean by it. Can you write out the version with and without <code>⇑</code> to make it super clear?</p>",
        "id": 422622316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708523539
    },
    {
        "content": "<p>Do you mean that you want <code>⇑f φ = (fun x =&gt; ⟪f x, φ x⟫)</code>?</p>",
        "id": 422622495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708523597
    },
    {
        "content": "<p>I agree that it feels a bit wrong as function coerction. </p>\n<p>But here we go: <br>\n<code>Distribution Y = (Y → ℝ) → ℝ</code>, normally it should be  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mi>C</mi><mi>c</mi><mi mathvariant=\"normal\">∞</mi></msubsup><mo stretchy=\"false\">(</mo><mi>Y</mi><mo separator=\"true\">,</mo><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">C^\\infty_c(Y,\\mathbb{R}) \\rightarrow \\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-2.453em;margin-left:-0.0715em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">c</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">∞</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> but I do not want to commit to a particular choice of test functions. Then for <code>y' : Distribubution Y</code> and <code>φ : Y → ℝ</code> we define <code>⟪y', φ⟫ = y' φ</code>.</p>",
        "id": 422623224,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708523820
    },
    {
        "content": "<p>So <code>⇑y' = (y' : (Y → ℝ) → ℝ)</code></p>",
        "id": 422623508,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708523917
    },
    {
        "content": "<p>Your <code>⟪⟫</code>is not  mathlib's <code>inner</code> then, since it sounds like the two arguments have different types?</p>",
        "id": 422623524,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708523924
    },
    {
        "content": "<p>Ahh yes it is not mathlibs inner, sorry for the confusion</p>",
        "id": 422623584,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708523946
    },
    {
        "content": "<p>... in paper math people use the same notation</p>",
        "id": 422623650,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708523962
    },
    {
        "content": "<p>Now I'm even more confused, because it sounds like you're defining <code>⟪⟫</code> as notation for function application, not the other way around?</p>",
        "id": 422623953,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524045
    },
    {
        "content": "<p>In which case, there's no coercion in the first place</p>",
        "id": 422624030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524067
    },
    {
        "content": "<p>Yes it is just function application but if it is detected as function application or not depends on the transparency settings.</p>",
        "id": 422624506,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708524209
    },
    {
        "content": "<p>If you're not using reducible transparency, the one good answer is to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Distribution</span> <span class=\"n\">Y</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>and then you can make a regular <code>DFunLike</code> instance</p>",
        "id": 422624849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524316
    },
    {
        "content": "<p>You can of course do it without a structure, but you are much more likely to end up in a reducibility mess where sometimes you write <code>f x</code> and other times you write <code>DFunLike.coe f x</code></p>",
        "id": 422624962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524362
    },
    {
        "content": "<p>(matrices have this problem in Mathlib, or at least they did in Lean 3)</p>",
        "id": 422625061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524384
    },
    {
        "content": "<p>Looks like I'm already doing it :) this is my actual definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Generalized function with domain `X` -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Distribution</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">action</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span>\n</code></pre></div>",
        "id": 422625259,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708524453
    },
    {
        "content": "<p>But I do not wan't to provide <code>FunLike</code> instance as it won't reflect what people do on paper.</p>",
        "id": 422625617,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708524563
    },
    {
        "content": "<p>FunLike is orthogonal to what happens on paper; are you avoiding it because it brings the wrong notation?</p>",
        "id": 422626526,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524826
    },
    {
        "content": "<p>In theory you could write a custom elaborator that displays <code>@DFunLike.coe (Distribution X)</code> with your inner product notation</p>",
        "id": 422626684,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/422626526\">said</a>:</p>\n<blockquote>\n<p>FunLike is orthogonal to what happens on paper; are you avoiding it because it brings the wrong notation?</p>\n</blockquote>\n<p>yes</p>",
        "id": 422626730,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1708524884
    },
    {
        "content": "<p>The advantage is that you still get lemmas like <code>DFunLike.coe_inj</code>, the disadvantage is that for your use case the names of the lemmas in this API are a bit strange</p>",
        "id": 422626824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708524912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> I just tried <code>fun_prop</code> for the first time on a problem I encountered in the wild, that wasn't very easy but very much in the scope of <code>fun_prop</code>. Some of the error messages were very helpful, but I also found some behavior that maybe can be improved.</p>\n<p>Here is an annotated sequence of attempts that I tried:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.ContDiff.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.BorelSpace.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecialFunctions.Pow.Continuity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">ENNReal</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">ℝ</span> <span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- This was the result I needed in a larger proof. I started with a manual proof</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ENNReal.continuous_rpow_const.comp</span>\n    <span class=\"o\">(</span><span class=\"n\">ENNReal.continuous_coe.comp</span> <span class=\"n\">hu.continuous.nnnorm</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">aemeasurable</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.fun_prop</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- fails, it would be nice if `fun_prop` tells me that `AEMeasurable` hasn't been tagged with `@[fun_prop]`. (I learned this when tagging `Continuous.aemeasurable`)</span>\n\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">Continuous.aemeasurable</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- I'm not sure why `Continuous.aemeasurable` isn't even tried here</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Continuous.aemeasurable</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- Ok, this is promising, it is trying lemmas. It makes sense that not all lemmas are tagged yet</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span> <span class=\"n\">ENNReal.continuous_coe</span> <span class=\"n\">ENNReal.continuous_rpow_const</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Continuous.aemeasurable</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- Helpful error message! It apparently doesn't know `ContDiff.continuous`</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span> <span class=\"n\">ContDiff.continuous</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Continuous.aemeasurable</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- I hope that `fun_prop` will be able to use `ContDiff.continuous` at some point, although it might be tricky to work with a field that is a metavariable...</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Continuous.aemeasurable</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hu.continuous</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- success!</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hu.continuous</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- It would still be nice if `fun_prop` tries `Continuous.aemeasurable` first. Is it currently only trying these conversion lemmas at leaves? Maybe we can say that some conversion rules should be tried eagerly and not just at leaves?</span>\n</code></pre></div>",
        "id": 423621727,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709044944
    },
    {
        "content": "<p>I very much like that I can tag anything with <code>fun_prop</code>, and it figures out itself what kind of thing this is: whether it is a class of functions, a transition rule, a composition rule, ....</p>",
        "id": 423623021,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709045294
    },
    {
        "content": "<p>Thank you!, this is super helpful! </p>\n<p>Right now, only <code>Continuous</code> is set up with <code>fun_prop</code> by default. To get other function properties you should import these files</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.AEMeasurable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.ContDiff</span>\n</code></pre></div>\n<p>But I'm happy you didn't do that because now I have much better idea how to improve error messages :)</p>",
        "id": 423629481,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709046948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/423623021\">said</a>:</p>\n<blockquote>\n<p>I very much like that I can tag anything with <code>fun_prop</code>, and it figures out itself what kind of thing this is: whether it is a class of functions, a transition rule, a composition rule, ....</p>\n</blockquote>\n<p>Yes, making it very easy to set up is very much high priority for me. Let me know if there is still something that feels clunky and should be streamlined.</p>",
        "id": 423629942,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709047070
    },
    {
        "content": "<p>Is there documentation somewhere (outside Zulip) for how to set up and use <code>fun_prop</code>?<br>\nFor example, typing <code>#help tactic fun_prop</code> in a lean file importing <code>Mathlib</code> only gives the rather unhelpful message \"syntax \"fun_prop\"... [Mathlib.Meta.FunProp.funPropTacStx]<br>\n  Tactic to prove function properties\".</p>",
        "id": 423630730,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709047282
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- fails, it would be nice if `fun_prop` tells me that `AEMeasurable` hasn't been tagged with `@[fun_prop]`. (I learned this when tagging `Continuous.aemeasurable`)</span>\n</code></pre></div>\n<p>This should be easy to fix.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span> <span class=\"n\">AEMeasurable</span> <span class=\"n\">Continuous.aemeasurable</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- I'm not sure why `Continuous.aemeasurable` isn't even tried here</span>\n</code></pre></div>\n<p>As you note later, transition rules are used only on \"leafs of the expression\". This is absolutely crucial for performance. What <code>fun_prop</code> is doing here is that it tries to decompose it as <code>(fun x ↦ x ^ r)∘(fun x ↦ ‖u x‖₊)</code> but there is no composition theorem registered for <code>AEMesurable</code> and <code>fun_prop</code> just silently gives up. I will fix that and report missing composition rule.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">]</span> <span class=\"n\">ContDiff.continuous</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Continuous.aemeasurable</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- I hope that `fun_prop` will be able to use `ContDiff.continuous` at some point, although it might be tricky to work with a field that is a metavariable...</span>\n</code></pre></div>\n<p>Yes, metavariable is indeed the problem. Turning on <code>Meta.Tactic.fun_prop.discharge</code> reveals</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>                <span class=\"o\">[</span><span class=\"n\">Meta.Tactic.fun_prop.discharge</span><span class=\"o\">]</span> <span class=\"bp\">@</span><span class=\"n\">ContDiff.continuous</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n                      <span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">?𝕜</span>\n</code></pre></div>\n<p>It can't infer the field <code>?𝕜</code>. I think I can fix this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AEMeasurable</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hu.continuous</span>\n  <span class=\"n\">fun_prop</span>\n<span class=\"c1\">-- It would still be nice if `fun_prop` tries `Continuous.aemeasurable` first. Is it currently only trying these conversion lemmas at leaves? Maybe we can say that some conversion rules should be tried eagerly and not just at leaves?</span>\n</code></pre></div>\n<p>From performance perspective applying any transition rules on an expression that can be decomposed is a bad idea. The strategy is to decompose the above function into <code>(fun x ↦ x ^ r)∘(fun x ↦ ‖x‖₊)∘u</code> and only then apply transition rules e.g. prove <code>AEMeasurable u μ</code> from <code>Continuous u</code> and that from <code> ContDiff ℝ 1 u</code>.</p>",
        "id": 423633855,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709048177
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/423630730\">said</a>:</p>\n<blockquote>\n<p>Is there documentation somewhere (outside Zulip) for how to set up and use <code>fun_prop</code>?<br>\nFor example, typing <code>#help tactic fun_prop</code> in a lean file importing <code>Mathlib</code> only gives the rather unhelpful message \"syntax \"fun_prop\"... [Mathlib.Meta.FunProp.funPropTacStx]<br>\n  Tactic to prove function properties\".</p>\n</blockquote>\n<p>There is this literate file <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/test/fun_prop.lean\">https://github.com/leanprover-community/mathlib4/blob/master/test/fun_prop.lean</a></p>",
        "id": 423634248,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709048245
    },
    {
        "content": "<p>Is there a way to link this file from the docstring?</p>",
        "id": 423639025,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709049023
    },
    {
        "content": "<p>Yes I can do that.</p>",
        "id": 423639930,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709049192
    },
    {
        "content": "<p>Maybe a compromise for performance is to apply a transition rule only when no decomposition rule successfully applied? This could have the unfortunate consequence that adding a decomposition rule could break proofs, but I think that will be very rare. <br>\nAnd I think if you want to deal with a property like <code>Integrable</code>, this will be very useful, since various operations don't respect integrability, but do respect continuity. For example, it would be nice if <code>fun_prop</code> could learn to prove this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.LocallyIntegrable</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2u</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasureOnCompacts</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Integrable</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">hu.mul</span> <span class=\"n\">hv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">integrable_of_hasCompactSupport</span> <span class=\"o\">(</span><span class=\"n\">h2u.mul_right</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423649172,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709051286
    },
    {
        "content": "<p>I also noticed this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.LocallyIntegrable</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">u</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">v</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span> <span class=\"c1\">-- succeeds</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">fun_prop</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>Is this something we can/want to teach <code>fun_prop</code>? Or should we prove two versions of all lemmas with the two different notations?</p>",
        "id": 423649627,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709051435
    },
    {
        "content": "<p>Yes I'm aware of the <code>fun x ↦ u x * v x</code> vs <code>u * v</code>(<code>=fun x ↦ (u * v) x</code>) issues but I'm not sure what to do about it other then hardcode it as a special cases. Right now, the solution is indeed to prove two version of the those lemmas.</p>",
        "id": 423651742,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709052103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/423649172\">said</a>:</p>\n<blockquote>\n<p>Maybe a compromise for performance is to apply a transition rule only when no decomposition rule successfully applied? This could have the unfortunate consequence that adding a decomposition rule could break proofs, but I think that will be very rare. <br>\nAnd I think if you want to deal with a property like <code>Integrable</code>, this will be very useful, since various operations don't respect integrability, but do respect continuity. For example, it would be nice if <code>fun_prop</code> could learn to prove this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.LocallyIntegrable</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2u</span> <span class=\"o\">:</span> <span class=\"n\">HasCompactSupport</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">IsFiniteMeasureOnCompacts</span> <span class=\"n\">μ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Integrable</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">hu.mul</span> <span class=\"n\">hv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">integrable_of_hasCompactSupport</span> <span class=\"o\">(</span><span class=\"n\">h2u.mul_right</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Nice! This is a good example. So far I haven't done any experiments with <code>Integrable</code> and I'm not sure how successful will <code>fun_prop</code> be as it behave very differently from <code>Continuous</code>, <code>Differentiable</code>, ... It would be great to collect bunch of example theorems for <code>Integralble</code> that <code>fun_prop</code> ought to prove. Then I can start thinking how to adapt <code>fun_prop</code> for it.</p>",
        "id": 423652642,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709052376
    },
    {
        "content": "<p>However, in the case of<code>AEMeasurable</code> I think the solution is really to just report missing composition rule instead of trying to apply some transition rule.</p>",
        "id": 423653505,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709052633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/423653505\">said</a>:</p>\n<blockquote>\n<p>However, in the case of<code>AEMeasurable</code> I think the solution is really to just report missing composition rule instead of trying to apply some transition rule.</p>\n</blockquote>\n<p>Yeah, that's fair. I didn't realize at first that the proof just works in that case when pushing the transitions to the leaves.</p>",
        "id": 423654566,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709052944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/423634248\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/423630730\">said</a>:</p>\n<blockquote>\n<p>Is there documentation somewhere (outside Zulip) for how to set up and use <code>fun_prop</code>?<br>\nFor example, typing <code>#help tactic fun_prop</code> in a lean file importing <code>Mathlib</code> only gives the rather unhelpful message \"syntax \"fun_prop\"... [Mathlib.Meta.FunProp.funPropTacStx]<br>\n  Tactic to prove function properties\".</p>\n</blockquote>\n<p>There is this literate file <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/test/fun_prop.lean\">https://github.com/leanprover-community/mathlib4/blob/master/test/fun_prop.lean</a></p>\n</blockquote>\n<p>The literate file is great, but it should not be a substitute for a good docstring. Tactic docstrings should describe all the main behaviors and features of the tactic, maybe in a more \"spec\" and less \"tutorial\" way than that file, but you can link to the tutorial at the end of the doc.</p>",
        "id": 423981138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1709199456
    },
    {
        "content": "<p>One bug: if I write <code>by fun_prop</code> in a term that does not otherwise elaborate well, then Lean panics.<br>\nsemi-minimal example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.FDeriv.Measurable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.Calculus</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.SpecialFunctions.Pow.Continuity</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.FunProp.Measurable</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">Measure</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">extracted_1</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BorelSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span> <span class=\"n\">ℝ</span> <span class=\"n\">F'</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">F'</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">F'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measurable</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">fderiv</span> <span class=\"n\">ℝ</span> <span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"bp\">‖₊</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Measurable.mul</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">fun_prop</span><span class=\"o\">)</span> <span class=\"c1\">-- Lean panics</span>\n</code></pre></div>",
        "id": 424054495,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709223075
    },
    {
        "content": "<p>I think I see the problem, this does not panic but sends lean to an infinite loop <code>#check ((by fun_prop) : ?m)</code></p>",
        "id": 424055692,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709223392
    },
    {
        "content": "<p>Oh ok, at least the server crashes</p>",
        "id": 424055785,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709223420
    },
    {
        "content": "<p>This should be easy to fix if it is the same problem.</p>",
        "id": 424055922,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709223460
    },
    {
        "content": "<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11092\">#11092</a> plus few other minor improvements</p>",
        "id": 424333048,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709330724
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/11153\">#11153</a> marks theorems about <code>Differentiable(At/On/Within)</code> and <code>HasFDeriv(Within)At</code> in <code>Mathlib.Analysis.Calculus.FDeriv....</code></p>",
        "id": 424715973,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1709575765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113488-general/topic/.60fun_prop.60.20new.20tactic.20for.20Differentiable.2C.20Continuous.2C.20.2E.2E.2E/near/424333048\">said</a>:</p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/11092\">#11092</a> plus few other minor improvements</p>\n</blockquote>\n<p>How do I get this merged? I'm still confused by the the way PRs are reviewed and merged. How long is reasonable to wait for a review? Who should I bug to get a PR merged? Should I assign someone as a review or should I wait for a maintainer to assign someone?</p>",
        "id": 426005084,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1710189699
    },
    {
        "content": "<p>I don't have the answers for you and have wondered the same myself.  Seems like the best way, at least from my experience, is to just keep asking here.</p>",
        "id": 426007973,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1710190892
    },
    {
        "content": "<p>This sentence from mathlib contribution guide</p>\n<blockquote>\n<p>someone will probably \"review\" it within a few days (depending on the size of the PR; smaller PRs will get quicker responses)</p>\n</blockquote>\n<p>needs some refinement <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 426008320,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1710191030
    },
    {
        "content": "<p>Tomas, the maintainers recognize that this is an issue (certain PRs languishing without review) and we're in the process of trying out some new organizational efforts amongst ourselves to alleviate this problem.</p>",
        "id": 426009529,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710191581
    },
    {
        "content": "<p>But for the moment, asking on Zulip doesn't hurt. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 426009691,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710191653
    },
    {
        "content": "<p>I'm in the process of looking at a big PR, but I will look at yours if I can scrounge some time.</p>",
        "id": 426009737,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710191679
    },
    {
        "content": "<p>Ok I will be loud on Zulip then :)  I was just wondering if there is some process I'm not aware of.</p>",
        "id": 426009802,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1710191722
    },
    {
        "content": "<p>I clearly am not in any position to give advice on Mathlib contributing but given experience with maintaining <em>other</em> projects, you might instead try bribery instead of pure nagging :) -- specifically you might try saying \"I will trade any maintainer a review on another similar sized PR for a review of mine\" rather than just pinging about yours.</p>",
        "id": 426011711,
        "sender_full_name": "Julian Berman",
        "timestamp": 1710192551
    },
    {
        "content": "<p>There is  a specific issue with meta-code that is a lot harder to review and has a lot less experts.</p>",
        "id": 426014106,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710193568
    },
    {
        "content": "<p>Also that people who can review meta code keep being hired elsewhere and given lots to do outside of Mathlib. :-)</p>",
        "id": 426028016,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710200184
    },
    {
        "content": "<p>In that case, I already commented on the PR that your meta code was deeply lacking comments. You asked me where exactly I wanted to see comments added, so TLDR: \"Everywhere\"</p>",
        "id": 426076328,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710232682
    },
    {
        "content": "<p>Yes this is a very common problem with meta-programming PRs, and one of the reasons we lost some tactics during the port.</p>",
        "id": 426128795,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1710251289
    },
    {
        "content": "<p>I do try to heavily comment my positivity extensions, but I don't know whether that's enough comments still</p>",
        "id": 426187810,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710267703
    }
]