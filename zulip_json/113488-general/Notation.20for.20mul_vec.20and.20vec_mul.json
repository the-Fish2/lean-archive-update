[
    {
        "content": "<p>What do you all think about introducing infix notations for <code>matrix.mul_vec</code> and <code>matrix.vec_mul</code>?</p>\n<p>I am currently working on this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">schur_complement_eq'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.is_symm</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">vec_mul</span> <span class=\"o\">(</span><span class=\"n\">sum.elim</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">from_blocks</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">B</span><span class=\"bp\">ᵀ</span> <span class=\"n\">D</span><span class=\"o\">))</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">sum.elim</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">vec_mul</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">mul_vec</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"n\">A</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">mul_vec</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">vec_mul</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">-</span> <span class=\"n\">B</span><span class=\"bp\">ᵀ</span> <span class=\"bp\">⬝</span> <span class=\"n\">A</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>It is really hard to read without infix notation. I would propose something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">localized</span> <span class=\"s2\">\"infix ` ⊕ᵥ `:65 := sum.elim\"</span> <span class=\"k\">in</span> <span class=\"n\">matrix</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"infix ` ᵛ⬝ `:73 := vec_mul\"</span> <span class=\"k\">in</span> <span class=\"n\">matrix</span>\n<span class=\"n\">localized</span> <span class=\"s2\">\"infix ` ⬝ᵛ `:74 := mul_vec\"</span> <span class=\"k\">in</span> <span class=\"n\">matrix</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">schur_complement_eq</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">n</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.is_symm</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">invertible</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊕ᵥ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">ᵛ⬝</span> <span class=\"n\">from_blocks</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">B</span><span class=\"bp\">ᵀ</span> <span class=\"n\">D</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">⊕ᵥ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">A</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span> <span class=\"bp\">⬝ᵛ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">ᵛ⬝</span> <span class=\"n\">A</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">A</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span> <span class=\"bp\">⬝ᵛ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">ᵛ⬝</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"bp\">-</span> <span class=\"n\">B</span><span class=\"bp\">ᵀ</span> <span class=\"bp\">⬝</span> <span class=\"n\">A</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">⬝</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 285641653,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1654847090
    },
    {
        "content": "<p>I feel like if we go down that route we should change <code>dot_product u v</code> to <code>u ᵛ⬝ᵛ v</code></p>",
        "id": 285642656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654847850
    },
    {
        "content": "<p>The other option would be a <code>has_mat_mul</code> class and use <code>⬝</code> for all four operations</p>",
        "id": 285642753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654847908
    },
    {
        "content": "<p><code>⬝</code> for all of them would be amazing. What would be the best way to approach such a big refactoring?</p>",
        "id": 285644465,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1654849157
    },
    {
        "content": "<p>I don't think the refactor will be all that big, although a danger with this change is that <code>![![1,2],![3,4]] ⬝ ![![1,2],![3,4]] = ![10, 20]</code></p>",
        "id": 285645722,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654849981
    },
    {
        "content": "<p>(because <code>![![...]]</code> creates a vector of vectors not a matrix)</p>",
        "id": 285645845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/285645722\">said</a>:</p>\n<blockquote>\n<p>I don't think the refactor will be all that big, although a danger with this change is that <code>![![1,2],![3,4]] ⬝ ![![1,2],![3,4]] = ![10, 20]</code></p>\n</blockquote>\n<p>I believe it would not be a problem since we can require that the entries of the vector are <code>non_unital_non_assoc_semiring</code>, and now we're applying <code>has_mat_mul</code> to the entries</p>",
        "id": 285646151,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1654850273
    },
    {
        "content": "<p>I don't understand that suggestion. The problem is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span> <span class=\"bp\">⬝</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span>\n  <span class=\"bp\">=</span> <span class=\"n\">dot_product</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span>\n  <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">*</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"bp\">*</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span>\n  <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">9</span><span class=\"o\">,</span><span class=\"mi\">16</span><span class=\"o\">]</span>\n  <span class=\"bp\">=</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">10</span><span class=\"o\">,</span> <span class=\"mi\">20</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 285646575,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850523
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.non_unital_non_assoc_semiring\">docs#pi.non_unital_non_assoc_semiring</a></p>",
        "id": 285646656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850559
    },
    {
        "content": "<p>Arguably the real problem here is that we don't have notation that actually produces a matrix</p>",
        "id": 285646727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850611
    },
    {
        "content": "<p><code>![![1,2],![3,4]] * ![![1,2],![3,4]]</code> already fails to perform matrix multiplication</p>",
        "id": 285646747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850628
    },
    {
        "content": "<p>This has come up before, but I think the lean3 <code>notation</code> command isn't powerful enough to allow a special <code>!![1, 2; 3, 4]</code> notation</p>",
        "id": 285646830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850674
    },
    {
        "content": "<p>We could use a <code>user_notation</code>, but then it would print as something like <code>to_matrix ![![1,2],![3,4]]</code>.</p>",
        "id": 285646900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850716
    },
    {
        "content": "<p>Maybe thats ok though</p>",
        "id": 285646907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654850721
    },
    {
        "content": "<p>Indeed, we can't put the notation on <code>matrix</code> currently, or the instance isn't picked up.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.matrix.notation</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_mat_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mat_mul</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">notation</span>\n<span class=\"kd\">infix</span> <span class=\"bp\">`⬝`</span><span class=\"o\">:</span><span class=\"mi\">75</span> <span class=\"o\">:=</span> <span class=\"n\">has_mat_mul.mat_mul</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">-- Notation not found</span>\n<span class=\"cm\">instance matrix.has_mat_mul [non_unital_non_assoc_semiring α] [fintype n] :</span>\n<span class=\"cm\">  has_mat_mul (matrix m n α) (matrix n o α) (matrix m o α) :=</span>\n<span class=\"cm\">⟨matrix.mul⟩</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">matrix.has_mat_mul</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_mat_mul</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">o</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">o</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">matrix.mul</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[priority 100]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">matrix.has_dot_product</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_mat_mul</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">matrix.dot_product</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">matrix.has_mat_mul_right</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_mat_mul</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">matrix.mul_vec</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">matrix.has_mat_mul_left</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_mat_mul</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">matrix.vec_mul</span><span class=\"o\">⟩</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]])</span> <span class=\"bp\">⬝</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]))</span>\n<span class=\"k\">#eval</span> <span class=\"o\">((</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">⬝</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 285647363,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1654851019
    },
    {
        "content": "<p><code>(x : A) * (x : A)</code> where <code>x : X</code> is not enough to tell lean to use the multiplication on <code>A</code></p>",
        "id": 285649709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654852416
    },
    {
        "content": "<p>Ok, but what's the problem with the instance on <code>m → n → α</code> as in Anne's code above?</p>",
        "id": 285649771,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1654852443
    },
    {
        "content": "<p>I think it's a bad idea to ever spell <code>matrix m n a</code> in that way</p>",
        "id": 285649933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654852526
    },
    {
        "content": "<p>It feels as bad as spelling <code>opposite a</code> as <code>a</code> or <code>multiplicative a</code> as <code>a</code></p>",
        "id": 285649979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654852554
    },
    {
        "content": "<p>This does the right thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]])</span>\n    <span class=\"bp\">⬝</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]])</span>\n</code></pre></div>",
        "id": 285650173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654852650
    },
    {
        "content": "<p><code>foo (x : A)</code> where <code>x : X</code> and <code>def A := X</code> means \"parse <code>x</code> as an <code>A</code>, but then call <code>foo</code> with <code>x</code> as an <code>X</code>\"</p>",
        "id": 285650266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654852693
    },
    {
        "content": "<p>Here's a nicer spelling:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_matrix</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_matrix_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">to_matrix</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_matrix_symm_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">to_matrix.symm</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`!ₘ</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">l</span><span class=\"o\">:(</span><span class=\"n\">foldr</span> <span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">matrix.vec_cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">matrix.vec_empty</span> <span class=\"bp\">`</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">to_matrix</span> <span class=\"n\">l</span>\n\n<span class=\"k\">#eval</span> <span class=\"bp\">!ₘ</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span> <span class=\"bp\">⬝</span> <span class=\"bp\">!ₘ</span><span class=\"o\">[</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">],</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]]</span>  <span class=\"c1\">-- does the right thing</span>\n</code></pre></div>",
        "id": 285650558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654852851
    },
    {
        "content": "<p>I implemented the <code>user_notation</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/14665\">#14665</a></p>",
        "id": 285653561,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1654854662
    },
    {
        "content": "<p>Now that <code>!![1, 2; 3, 4]</code> notation is merged, we could consider revisiting <code>class has_mat_mul </code></p>",
        "id": 289450600,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657715162
    },
    {
        "content": "<p>What are the operations it would apply to (and what is that symbol - is it different from the smul symbol?)</p>",
        "id": 289477359,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1657726628
    },
    {
        "content": "<p>The symbol is <code>\\cdot</code>. It's different from the smul symbol. The dot is a bit smaller.</p>",
        "id": 289567628,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1657789683
    },
    {
        "content": "<p>We could use it for <code>matrix.mul</code>, where it is used already, for <code>matrix.mul_vec</code>, <code>matrix.vec_mul</code>, and <code>matrix.dot_product</code>.</p>",
        "id": 289567696,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1657789734
    },
    {
        "content": "<p>And possibly <code>matrix.vec_mul_vec</code>?</p>",
        "id": 289707748,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1657879318
    },
    {
        "content": "<p>Though that may not work with <code>matrix.dot_product</code>.</p>",
        "id": 289707814,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1657879346
    },
    {
        "content": "<p>We don't need notation for that, you can spell it <code>col v ⬝ row w</code></p>",
        "id": 289717662,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657886581
    },
    {
        "content": "<p>You don't have that option for the others, because the result type ends up a matrix not a vector</p>",
        "id": 289717689,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657886599
    },
    {
        "content": "<p>Ah, so you can.</p>",
        "id": 289724057,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1657890531
    },
    {
        "content": "<p>I tried this in <a href=\"https://github.com/leanprover-community/mathlib/pull/15585\">#15585</a>, but it doesn't work as well as I'd hoped because lean's overloaded notations:</p>\n<ul>\n<li>Doesn't seem to work with <code>local</code> or <code>open_locale</code></li>\n<li>Unfolds type synonyms</li>\n</ul>",
        "id": 290360249,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658400992
    },
    {
        "content": "<p>I thought you planned to create a type class <code>has_mat_mul </code>. Why do you use overloaded notations now?</p>",
        "id": 290369449,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1658406941
    },
    {
        "content": "<p>The typeclass had its own problems:</p>\n<ul>\n<li>The <code>out_param</code> stuff doesn't always help, you still can't write things like <code>v ⬝ 0</code></li>\n<li>You now have to change everything to be stated about <code>has_mat_mul.mul</code> instead of <code>dot_product</code> etc. This is a lot more unwieldy if the notation is not enabled;</li>\n</ul>",
        "id": 290370445,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658407481
    },
    {
        "content": "<p>I see. But I feel that the type class approach works quite well for <code>+</code>, <code>*</code>, <code>•</code>, etc. The fact that we can't write <code>v ⋅ 0</code> doesn't shock me. Somehow we need to tell Lean what <code>0</code> we mean. You probably can't write <code>a • 0</code> either, right?</p>",
        "id": 290372989,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1658408930
    },
    {
        "content": "<p><code>a • 0</code> isn't quite as bad because lean knows the result type is the same type as the 0</p>",
        "id": 290374797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658409957
    },
    {
        "content": "<p>Ah, ok, right. <code>⋅</code> would be extremely ambiguous about what comes in and what comes out...</p>",
        "id": 290375965,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1658410554
    },
    {
        "content": "<p>How about this: we add a typeclass <code>has_mat_mul </code> using <code>⋅</code> and in addition localized notations <code>ᵥ⋅ₘ</code>, <code>ᵥ⋅ₘ</code>, <code>ₘ⋅ₘ</code>, <code>ᵥ⋅ᵥ</code> that abbreviate <code>has_mat_mul</code> with the appropriate type class instance specified. So in most cases, you'll be able to use <code>⋅</code>. Whenever Lean doesn't understand what's going on because it's not clear what types the arguments have, you can use the more specific notation.</p>\n<p>It would be nice if the output window would show <code>⋅</code> whenever possible, though.</p>",
        "id": 290377664,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1658411379
    },
    {
        "content": "<p>It is probably worth revisiting this thread now that <code>⬝</code> is no longer used for matrix multiplication (we use <code>*</code> instead)</p>",
        "id": 412825223,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705247263
    },
    {
        "content": "<p>I really wish we had infix operators for all those multiplications!</p>",
        "id": 412914416,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705310222
    },
    {
        "content": "<p>Hear me out!<br>\nMatrix times vector: <code>A ₘ⋅ v</code><br>\nVector times matrix: <code>v ⋅ₘ A</code><br>\nMatrix times matrix: <code>A * B</code><br>\nDot product: <code>u ⋅ᵥ v</code><br>\nCross product: <code>u ×₃ v</code><br>\nThe first two symbols are new (my suggestion).<br>\nWhat do you think?</p>",
        "id": 412983820,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705333197
    },
    {
        "content": "<p>Why can't <code>HMul</code> work for all of these?</p>",
        "id": 412984053,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705333258
    },
    {
        "content": "<p>(except maybe the cross product and dot product)</p>",
        "id": 412984135,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705333277
    },
    {
        "content": "<p>I would think the first two are good examples of left and right actions. So they could use <code>SMul</code>.</p>",
        "id": 412987005,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705334161
    },
    {
        "content": "<p>Both would use \\smul then?</p>",
        "id": 412987137,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334197
    },
    {
        "content": "<p>Well, there are variant notations of <code>SMul</code> that distinguish left and right actions.</p>",
        "id": 412987599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705334328
    },
    {
        "content": "<p>A right action is a left action, but acting via the multiplicative opposite.</p>",
        "id": 412987677,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1705334343
    },
    {
        "content": "<p>Ah, so in both cases, it would be a matrix having an action on vector?</p>",
        "id": 412987767,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705334374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/412987005\">said</a>:</p>\n<blockquote>\n<p>I would think the first two are good examples of left and right actions. So they could use <code>SMul</code>.</p>\n</blockquote>\n<p>They're not <del>heterogenous</del> homogenous, so they'd have to use <code>HSMul</code></p>",
        "id": 412991693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705335669
    },
    {
        "content": "<p>But this would then probably be fighting the elaborator changes that Kyle made which fixed <code>^</code>.</p>",
        "id": 412991792,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705335720
    },
    {
        "content": "<p>They <em>are</em> heterogeneous, so they need to use <code>HSMul</code>.</p>",
        "id": 413007021,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705340854
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 413007187,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1705340933
    },
    {
        "content": "<p>I just got my words muddled, edited above</p>",
        "id": 413007466,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705341073
    },
    {
        "content": "<p>Long term, there's still the possibility of tweaking the \"expression tree elaborator\" that all the basic operators use, including <code>\\smul</code>. It would be good to collect elaboration issues.</p>\n<p>This elaborator basically turns itself off if the expressions involved can't be coerced to one another. <code>\\smul</code> has the wrinkle that (1) it works best for left actions and (2) the RHS can't hint to the LHS what type it should have.</p>\n<p>I'm not sure how well known this is, but in mathlib we have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/FBinop.html\">similar elaborator</a> that tries to find a common \"functor\" to coerce everything to. I think it's just used for <code>Set.prod</code> at the moment.</p>",
        "id": 413010279,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705342405
    },
    {
        "content": "<p>It's perhaps also worth noting that we should be very careful with typeclass inheritance of heterogenous operators, as discussed in S1.1.8 of the attachment in <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/411183622\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/411183622</a></p>",
        "id": 413011005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705342822
    },
    {
        "content": "<p>Why not just add notation for <code>mul_vec</code> and <code>vec_mul</code> without typeclasses?</p>",
        "id": 416214108,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705520124
    },
    {
        "content": "<p>It would be nice if these matrix-vector products could be in the language of HSMul somehow, because they're actions (well, multi-sort actions, though definitely actions when the matrices are square).</p>\n<p>Using HSMul directly probably has some bad elaboration issues, since it won't be able to link up the dimensions. Though perhaps that's fixable with default instances?</p>\n<p>If that doesn't work, maybe we could make a <code>A ₘ• v</code> notation that elaborates to <code>A • v</code> while somehow unifying the dimensions. Maybe there could be a pretty printer that prints this as <code>A ₘ• v</code> so that there's any hope of round tripping (i.e., successfully pasting in and using something from the infoview).</p>",
        "id": 416215443,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705520699
    },
    {
        "content": "<p>That is getting into redesign though. I don't see any reason not to add in notation for <code>A ₘ• v</code> and <code>v •ₘ A</code> for the pre-existing <code>mul_vec</code> and <code>vec_mul</code>.</p>",
        "id": 416215494,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705520730
    },
    {
        "content": "<p>Or perhaps <code>ₘ•&gt;</code> and <code>&lt;•ₘ</code> for consistency with left and right actions</p>",
        "id": 416335144,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705525244
    },
    {
        "content": "<p>Can we draw a conclusion please? I would like to add it to Mathlib today.</p>",
        "id": 419807390,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707129271
    },
    {
        "content": "<p>Unclear to me</p>",
        "id": 419815064,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707131829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/416335144\">said</a>:</p>\n<blockquote>\n<p>Or perhaps <code>ₘ•&gt;</code> and <code>&lt;•ₘ</code> for consistency with left and right actions</p>\n</blockquote>\n<p>I'd rather not.<br>\nI find using the symbols <code>&lt;</code> and <code>&gt;</code> confusing when not in a syntax for binary relations. <br>\nAs far as GitHub show me, the operators<code>•&gt;</code> and <code>&lt;•</code> are used only in two files anyway.<br>\nI'd rather add <code>ₘ•</code> and <code>•ₘ</code> but anything will be better than the status quo.</p>",
        "id": 419897389,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707155856
    },
    {
        "content": "<p>It's unclear to me what the <code>ₘ</code> is supposed to mean in this notation. And I agree with Eric about consistency, so something involving <code>&lt;•</code> or <code>•&gt;</code> would be preferable. (Martin, I could turn the tables and complain that it's unclear whether <code>ₘ•</code> should be <code>A * v</code> or <code>v * A</code>, so I don't see your reasoning as a good argument.)</p>",
        "id": 419903463,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707158034
    },
    {
        "content": "<p>If we used <code>•ᵥ</code> and <code>ᵥ•</code>, for <code>mulVec</code> and <code>vecMul</code>, respectively, then at least the notation order would match the word order. Although I take it that <code>•ᵥ</code> is already taken for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dotProduct#doc\">docs#dotProduct</a>.</p>",
        "id": 419903955,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707158196
    },
    {
        "content": "<p>Thinking again, I think I'd prefer to avoid <code>•</code> in the notation, since I am wary of ending up with a future generalization of <code>vecMul</code> that performs <code>SMul</code> between the coefficients instead of <code>*</code> (due to a much higher risk of diamonds)</p>",
        "id": 419908554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707159811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span>, note that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.dotProduct#doc\">docs#Matrix.dotProduct</a> uses a different dot symbol, <code>⬝ᵥ</code></p>",
        "id": 419908693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707159857
    },
    {
        "content": "<p>Lol, <code>•</code> and <code>⬝</code> are nearly visually indistinguishable for me with my font and size.</p>",
        "id": 419918448,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707163316
    },
    {
        "content": "<p>So <code>A ₘ* v</code> and <code>v *ₘ A</code> or rather <code>A *ᵥ v</code> and <code>v ᵥ* A</code> will we declare?</p>",
        "id": 419921072,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707164300
    },
    {
        "content": "<p>Should we use the same notation for both?</p>",
        "id": 419921480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707164455
    },
    {
        "content": "<p>I'd say let's go with <code>A *ᵥ v</code> and <code>v ᵥ* A</code>, unless you have a tested design for how to get them to use the same notation, without any elaboration gotchas.</p>",
        "id": 419921789,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707164586
    },
    {
        "content": "<p>If we change this design later, we can easily search/replace when the notations are different.</p>",
        "id": 419921869,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707164616
    },
    {
        "content": "<p>I actually like having the different notations, because then I don't have to mentally juggle types, but this is not a major issue I suppose since I can hover.</p>",
        "id": 419922147,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707164721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/419897389\">said</a>:</p>\n<blockquote>\n<p>As far as GitHub show me, the operators<code>•&gt;</code> and <code>&lt;•</code> are used only in two files anyway.</p>\n</blockquote>\n<p>This is because the notation is really new and I haven't had time to refactor its potential use cases to use it.</p>",
        "id": 419922366,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1707164794
    },
    {
        "content": "<p>I might suggest <code>*&gt;</code> and <code>&lt;*</code> for this for parallelism, but these are already taken by applicative monads. Thanks Haskell!</p>",
        "id": 419923148,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707165079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/419921480\">said</a>:</p>\n<blockquote>\n<p>Should we use the same notation for both?</p>\n</blockquote>\n<p>Are you worried that <code>A *ᵥ v</code> and <code>v ᵥ* A</code> would make <code>v ⋅ᵥ w</code> look inadequate?</p>",
        "id": 419926116,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707166333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/419921789\">said</a>:</p>\n<blockquote>\n<p>I'd say let's go with <code>A *ᵥ v</code> and <code>v ᵥ* A</code>,</p>\n</blockquote>\n<p>Imma implement this right now.</p>",
        "id": 420010294,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707213172
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10297\">#10297</a></p>",
        "id": 420041997,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707224434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/419926116\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/419921480\">said</a>:</p>\n<blockquote>\n<p>Should we use the same notation for both?</p>\n</blockquote>\n<p>Are you worried that <code>A *ᵥ v</code> and <code>v ᵥ* A</code> would make <code>v ⋅ᵥ w</code> look inadequate?</p>\n</blockquote>\n<p>Yes, the lack of symmetry bugs me slightly, but I don't think it's worse than the status quo so I'm happy enough with this proposal</p>",
        "id": 420063457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707230898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113488-general/topic/Notation.20for.20mul_vec.20and.20vec_mul/near/420041997\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10297\">#10297</a></p>\n</blockquote>\n<p>Alright, ready for review!</p>",
        "id": 420099010,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707240665
    },
    {
        "content": "<p>Another potential refactoring is to write <code>⋅ᵥ</code> in place of <code>dotProduct</code> everywhere.</p>",
        "id": 420303506,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1707326415
    }
]