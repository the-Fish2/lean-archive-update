[
    {
        "content": "<p>Is there any any way to apply and expression (f : Expr) to an expression (e : Expr) while automatically infer all of the implicit arugments?</p>",
        "id": 435879870,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1714315394
    },
    {
        "content": "<p>If you're using Qq, then this is <code>q($f $e)</code></p>",
        "id": 435880636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714316021
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.mkAppM#doc\">docs#Lean.Meta.mkAppM</a></p>",
        "id": 435880926,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1714316180
    },
    {
        "content": "<p>another question, you can pretty print exprs using <code>Lean.Meta.ppExpr</code> but is there any way to make it take macros into account. For example right now it pretty prints as <code>Nat.add 10 15</code> can i make it pretty print as <code>10 + 15</code> instead?</p>",
        "id": 435882804,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1714317862
    },
    {
        "content": "<p>Do you have a mwe? Usually those are different expressions, so them printing differently is a feature</p>",
        "id": 435885410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1714319280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113488-general/topic/mkApp.20for.20implicit.20arguments/near/435885410\">said</a>:</p>\n<blockquote>\n<p>Do you have a mwe? Usually those are different expressions, so them printing differently is a feature</p>\n</blockquote>\n<p>Sorry for the late reply, I've been dreading trying to explain what I'm doing.</p>\n<p>So, I'm making a tactic called <code>cumulative</code> that basically adds together all functions with a particular labell attribute.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  `cumulative attr of x` exacts the sum of all functions with label attribute `attr` applied to `x`</span>\n\n<span class=\"sd\">  For instance suppose the only function with attr `tax_code` are:</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">    @[tax_code]</span>\n<span class=\"sd\">    def f₁ {α : Type*} [Semiring α] (a : α) : Nat := ...</span>\n\n<span class=\"sd\">    @[tax_code]</span>\n<span class=\"sd\">    def f₂ {α : Type*} [AddCommMonoid α] (a : α) : Nat := ...</span>\n<span class=\"sd\">  ```</span>\n<span class=\"sd\">  Then giving `α : Type*` satisfies enough typeclasses instances,</span>\n<span class=\"sd\">  for any `a : α`, `cumulative tax_code of a` is equivalent to `exact List.sum [f₁ a, f₂ a]`</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">syntax</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">cumulative</span><span class=\"o\">)</span> <span class=\"s2\">\"cumulative \"</span> <span class=\"n\">ident</span> <span class=\"s2\">\"of\"</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span>\n</code></pre></div>\n<p>Right now, I've switched to using List.sum, since <code>List.cons a (List.cons b List.nil)</code> automatically pretty prints as <code>[a, b]</code>. But I'm open to other options.</p>\n<p>If I use Qq, will the expression be pretty printed in it's un elaborated form <code>a  + b + c</code>, because for some reason even <code>Add.add a b</code> doesn't pretty print as <code>a + b</code></p>",
        "id": 436156244,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1714431614
    },
    {
        "content": "<p>Could you say more about what your concerns are regarding pretty printing? Is it that you want it to be in the right form inside the goal window?</p>",
        "id": 436159383,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714433081
    },
    {
        "content": "<p>yes in  the form a exact try this suggestion</p>",
        "id": 436161425,
        "sender_full_name": "Frederick Pu",
        "timestamp": 1714434272
    },
    {
        "content": "<p>If you want a <code>try this</code> suggestion, then you don't need to elaborate, you can use syntax quotations. Is the intent that you want this to <em>only</em> be for <code>try this</code>?</p>",
        "id": 436163423,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714435393
    },
    {
        "content": "<p>In <code>Mathlib/foo2.lean</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"sd\">/-- Some label attribute -/</span>\n<span class=\"n\">register_label_attr</span> <span class=\"n\">tax_code</span>\n</code></pre></div>\n<p>In <code>Mathlib/foo.lean</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.foo2</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tax_code</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₁</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">tax_code</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₂</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span>\n\n<span class=\"n\">elab</span> <span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"s2\">\"cumulative \"</span> <span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" of \"</span> <span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"bp\">←</span> <span class=\"n\">labelled</span> <span class=\"n\">id.getId</span>\n  <span class=\"k\">let</span> <span class=\"n\">applied</span> <span class=\"bp\">←</span> <span class=\"n\">names.mapM</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">Term</span> <span class=\"bp\">←</span>\n    <span class=\"k\">if</span> <span class=\"n\">applied.isEmpty</span> <span class=\"k\">then</span>\n      <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">applied.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">applied</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">app</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">stx</span> <span class=\"bp\">+</span> <span class=\"bp\">$</span><span class=\"n\">app</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">tac</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"k\">let</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"bp\">`</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">term</span><span class=\"o\">)</span>\n  <span class=\"n\">Tactic.evalTactic</span> <span class=\"n\">tac</span>\n  <span class=\"n\">Meta.Tactic.TryThis.addSuggestion</span> <span class=\"n\">tk</span> <span class=\"n\">tac</span> <span class=\"o\">(</span><span class=\"n\">origSpan</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"bp\">←</span> <span class=\"n\">getRef</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: let val := f₁ a + f₂ a</span>\n<span class=\"sd\">---</span>\n<span class=\"sd\">error: unsolved goals</span>\n<span class=\"sd\">a : ℝ</span>\n<span class=\"sd\">val : ℕ := f₁ a + f₂ a</span>\n<span class=\"sd\">⊢ False</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cumulative</span> <span class=\"n\">tax_code</span> <span class=\"n\">of</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 436164675,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714436124
    },
    {
        "content": "<blockquote>\n<p>for some reason even <code>Add.add a b</code> doesn't pretty print as <code>a + b</code></p>\n</blockquote>\n<p>Only <code>HAdd.hAdd</code> pretty prints as <code>a + b</code>.</p>",
        "id": 436164766,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1714436171
    }
]