[
    {
        "content": "<p>In the spirit of the <a href=\"https://leanprover-community.github.io/undergrad_todo.html\">Missing undergraduate mathematics in mathlib</a>, I was wondering what are some tactics that it would be nice to have, but for whatever reason never got implemented. I mean this in a fairly narrow sense, so  it could be either specific abstract algorithms and decision procedures, or specific tactics present in other proof assistants, that could  reasonably be adapted to lean. <br>\nAs a practical example, I'm thinking about things like Buchberger's algorithm (I remember a discussion about implementing it in lean) or the <code>omega</code> tactic (though that one is now available). </p>\n<p>So if there is anyone who would have really benefited if procedure X had been implemented, say Wu's algorithm for IMO-grand challenge people (?), they are welcome to chip in with their wishlist.</p>",
        "id": 420340234,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707338998
    },
    {
        "content": "<p>Somewhere else on this Zulip there's a discussion about how there should be a generic \"coerce the goal\" tactic, which takes a goal involving naturals resp integers and turns it into a goal about integers resp rationals, because we have <code>zify</code> and <code>qify</code> to do this but there are other instances (eg positive naturals to naturals, unleashing omega) where we don't have the appropriate tactic</p>",
        "id": 420347791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707342095
    },
    {
        "content": "<p>Generalized rewriting as in Coq</p>",
        "id": 420349175,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707342680
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/8167\">#8167</a></p>",
        "id": 420349651,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707342877
    },
    {
        "content": "<p>I actually have a tactic wishlist long like my arm that I pass around when people ask me. I will write a wiki page tomorrow with my ideas.</p>",
        "id": 420349881,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1707342976
    },
    {
        "content": "<p>Let me write about some tactics I miss</p>",
        "id": 420353467,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707344583
    },
    {
        "content": "<h3>Tendsto</h3>\n<ul>\n<li>Should find limits in \"simple\" cases (e.g., no <code>0/0</code> etc).</li>\n<li>Simplest version is <code>Continuous.tendsto' (by continuity) _ _ (by simp)</code>.</li>\n<li>More advanced version should know that <code>exp(-1/x)</code> tends to <code>ùìù[&gt;] 0</code> as <code>x</code> tends to <code>atTop</code>.</li>\n<li>Should know that <code>1/x</code> tends to <code>cobounded</code> as <code>x</code> tends to <code>ùìù[‚â†] 0</code> and vice versa (for any normed field, not only reals)</li>\n</ul>",
        "id": 420354653,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707345174
    },
    {
        "content": "<h3>Asymptotics</h3>\n<p>A version of <a href=\"https://dl.acm.org/doi/10.1145/3326229.3326240\">https://dl.acm.org/doi/10.1145/3326229.3326240</a> for Lean, should be able to deduce corollaries both from <code>f = g + o(h)</code> and <code>f = g + O(h)</code>. Should work at least for real and complex numbers.</p>",
        "id": 420354823,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707345265
    },
    {
        "content": "<p>For the limits in simple cases, might not <code>fun_prop</code> when adjusted for continuity be able to handle much of that? I haven't tried to use it yet but given how awesome the demo in <span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span>  presentation was I wouldn't be surprised by anything now.</p>",
        "id": 420355112,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707345420
    },
    {
        "content": "<h3>Exists positive from limit</h3>\n<p>Prove statements like <code>(Œ¥ : Real) (h : 0 &lt; Œ¥) ‚ä¢ ‚àÉ Œµ &gt; 0, Œµ ^ 2 + 5 * Œµ + sin Œµ &lt; Œ¥ ‚àß 3 * Œµ &lt; Œ¥</code> by proving <code>Tendsto (fun Œµ ‚Ü¶ Œµ ^ 2 + 5 * Œµ + sin Œµ) (nhds 0) (nhds 0)</code>, similarly for <code>3 * Œµ</code>, then using this fact to get a witness</p>",
        "id": 420356006,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707345897
    },
    {
        "content": "<p>(should work for <code>‚àÉ x &gt; a, _</code> too)</p>",
        "id": 420356042,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707345915
    },
    {
        "content": "<h3>Nonzero</h3>\n<p>A tactic that proves <code>expr ‚â† 0</code>.</p>\n<ul>\n<li>at least as powerful as whatever <code>field_simp</code> currently uses (it tries several tactics);</li>\n<li>knows lemmas like <code>a ‚â† 0 ‚Üí -a ‚â† 0</code>, <code>a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí a * b ‚â† 0</code> and <code>a ‚â† 0 ‚Üí a ^ n ‚â† 0</code>;</li>\n<li>fallbacks to <code>positivity</code> if it can't deal with the head symbol (e.g., <code>+</code>) and there is a <code>PartialOrder</code> instance</li>\n</ul>",
        "id": 420356408,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707346119
    },
    {
        "content": "<h3>Improved <code>positivity</code></h3>\n<ul>\n<li>more extensions<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.fract_nonneg#doc\">docs#Int.fract_nonneg</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.floor_nonneg#doc\">docs#Int.floor_nonneg</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.ceil_pos#doc\">docs#Int.ceil_pos</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.ceil_nonneg#doc\">docs#Int.ceil_nonneg</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.ceil_pos#doc\">docs#Nat.ceil_pos</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=neg_ne_zero#doc\">docs#neg_ne_zero</a></li>\n</ul>\n</li>\n<li>an attribute that automatically produces correct <code>positivity</code> extension in a simple case (e.g., we only know how to prove <code>0 ‚â§ f a</code>, never <code>0 &lt; f a</code>, or we always can prove <code>0 &lt; f a</code>)</li>\n<li>support for goals <code>expr &lt; 0</code>, so that it can prove <code>-3 * Œµ - Œ¥ &lt; 0</code></li>\n</ul>",
        "id": 420356921,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707346402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420355112\">said</a>:</p>\n<blockquote>\n<p>For the limits in simple cases, might not <code>fun_prop</code> when adjusted for continuity be able to handle much of that? I haven't tried to use it yet but given how awesome the demo in <span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span>  presentation was I wouldn't be surprised by anything now.</p>\n</blockquote>\n<p>I don't think <code>fun_prop</code> would work for that beyond suggested <code>Continuous.tendsto' (by fun_prop) _ _ (by simp)</code></p>\n<p>However, I have the other tactic <code>ftrans</code> for \"Function TRANSformation\" that might do be applicable. At some point I will port that to mathlib too.</p>",
        "id": 420357419,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707346661
    },
    {
        "content": "<h3>Linter for unneeded <code>by_cases</code></h3>\n<p>If you do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- the goal is a `Prop`</span>\n<span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span>\n<span class=\"bp\">¬∑</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- uses h</span>\n<span class=\"bp\">¬∑</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- ignores h</span>\n</code></pre></div>\n<p>then <code>h</code> is not an unused argument, because it is used in the first branch. However, this <code>by_cases</code> can be eliminated by using the second branch in all cases.<br>\nShould be easy to traverse the definition and look for the following anti-patterns for terms in <code>Prop</code>:</p>\n<ul>\n<li><code>ite _ _ _</code> is always bad, as either branch works;</li>\n<li><code>dite _ _ _</code> is bad, if one of the branches doesn't use the variable;</li>\n<li><code>Or.casesOn</code>: same as above;</li>\n<li>what else do commonly used tactics for case analysis produce?</li>\n</ul>",
        "id": 420357533,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707346719
    },
    {
        "content": "<h3>Linter for unnecessarily strong TC assumptions</h3>\n<p>Catch cases like \"we require <code>AddCommMonoid M</code>, then use only <code>AddZeroClass M</code>.<br>\n<a href=\"https://github.com/alexjbest/lean-generalisation\">Prior work exists</a> by <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>, in Lean 3</p>",
        "id": 420357756,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707346848
    },
    {
        "content": "<p>Can the l'hopital rule be a tactic?</p>",
        "id": 420358263,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707347137
    },
    {
        "content": "<p>And are there tactics that simplify working with indefinite integrals? For example variable substitution</p>",
        "id": 420358558,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707347307
    },
    {
        "content": "<p>I think that asymptotics as in Isabelle is the right way to go, because it supports more general asymptotic series (e.g., terms like <code>x ^ 2 exp(-2*x)</code>)</p>",
        "id": 420360075,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707348229
    },
    {
        "content": "<p>I have a few, but once I go through some of my course notes, I'll probably think of more.</p>",
        "id": 420366272,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1707351830
    },
    {
        "content": "<h3>Tactic that can compute things about polynomials</h3>\n<ul>\n<li>Polynomial equality</li>\n<li>Polynomial disequality</li>\n<li><code>n</code>-th coefficient, leading coefficient</li>\n<li><del>degree</del></li>\n<li><del>monicity (is that the word for the property of being monic?)</del></li>\n</ul>\n<p>The tactic should be able to work with polynomials over a commutative ring, at least when coefficients are explicitly given integers. Ideally there is some support for non-integer ring elements as well (perhaps just via <code>simp</code> being able to simplify expressions involving such elements). <br>\n<code>simp</code> can compute some of these things quite well (<code>n</code>-nth coefficient), but the other ones are quite painful</p>",
        "id": 420366276,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1707351833
    },
    {
        "content": "<h3>ring in characteristic <code>n</code></h3>\n<p>A tactic (perhaps <code>ring</code> itself) that is able to able to deal with the <code>CharP</code> predicate. Desired examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">R</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ring</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">R</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>Ideally same for <code>noncomm_ring</code></p>",
        "id": 420366748,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1707352157
    },
    {
        "content": "<p>I guess that polynomial disequality might be doable by adapting slim check.</p>",
        "id": 420367980,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707353010
    },
    {
        "content": "<p>Floris, for explicit polynomials, <code>compute_degree</code> and <code>monicity</code> should take care of some goals involving <code>degree/natDegree/Monic</code>.</p>\n<p>Do you have some examples where these tactics should work, but don't?</p>",
        "id": 420371874,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707355609
    },
    {
        "content": "<p>Very general, not sure if well-defined: tactic that takes a noncomputable formula, tries to lift it to the computable \"world\" and compute there.</p>",
        "id": 420378524,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707360209
    },
    {
        "content": "<p>E.g., it should replace classical <code>ite</code>s with computable, if it can synthesize an instance.</p>",
        "id": 420378734,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707360343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420378524\">said</a>:</p>\n<blockquote>\n<p>Very general, not sure if well-defined: tactic that takes a noncomputable formula, tries to lift it to the computable \"world\" and compute there.</p>\n</blockquote>\n<p>I have some <a href=\"https://github.com/lecopivo/SciLean/blob/master/test/realToFloat.lean\">experiments</a> in that direction with my <code>ftrans</code> tactic. You can define isomorphic types and functions that are preserved under this isomorphism.</p>\n<p>I used this to translate formulas on reals to floats under the inconsistent assumption that reals are isomorphic to float. It seems to work quite well. Of course you can use it for two types that are actually isomorphic and get a proper proof.</p>",
        "id": 420379020,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707360560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420366748\">said</a>:</p>\n<blockquote>\n<h3>ring in characteristic <code>n</code></h3>\n<p>A tactic (perhaps <code>ring</code> itself) that is able to able to deal with the <code>CharP</code> predicate. Desired examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">R</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ring</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">R</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ring</span>\n</code></pre></div>\n<p>Ideally same for <code>noncomm_ring</code></p>\n</blockquote>\n<p>I made a proof of concept of this for the Lean 3 ring tactic, it shouldn't be too hard to upgrade <code>ring</code> to do this. For now you could also do <code>repeat { ring; reduce_mod_char }</code>.</p>",
        "id": 420434500,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707390604
    },
    {
        "content": "<p>Analogs of <code>intro</code>/<code>revert</code> for the <code>exists</code> quantifier. More generally, there should be tactics that allow easy interactive (possibly irreversible) simplification of both goals and hypotheses that have nested <code>forall</code> and <code>exists</code> quantifiers. I brought this up in an <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/An.20.60exists_intro.60.20tactic.3F\">earlier thread</a>.</p>",
        "id": 420436966,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1707391587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420371874\">said</a>:</p>\n<blockquote>\n<p>Floris, for explicit polynomials, <code>compute_degree</code> and <code>monicity</code> should take care of some goals involving <code>degree/natDegree/Monic</code>.</p>\n<p>Do you have some examples where these tactics should work, but don't?</p>\n</blockquote>\n<p>Oops, I should have double checked, I wrote my previous message from memory.<br>\nI did indeed find <code>compute_degree</code> at some point. I was not aware that we had <code>monicity</code>. It is not mentioned in the module doc of the file where it is defined.</p>",
        "id": 420442132,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1707393729
    },
    {
        "content": "<p>I miss our nice list of tactics on the documentation page.</p>",
        "id": 420442158,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1707393739
    },
    {
        "content": "<p>I added <code>monicity</code> to the module-docs of <code>compute_degree</code>: <a href=\"https://github.com/leanprover-community/mathlib4/pull/10359\">#10359</a>.</p>",
        "id": 420453602,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707397738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420442158\">said</a>:</p>\n<blockquote>\n<p>I miss our nice list of tactics on the documentation page.</p>\n</blockquote>\n<p>The output of <code>#help tactic</code></p>\n<p>looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"mod_cases\"</span><span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">Mathlib.Tactic.ModCases.</span><span class=\"bp\">¬´</span><span class=\"n\">tacticMod_cases_</span><span class=\"o\">:</span><span class=\"n\">_</span><span class=\"bp\">%</span><span class=\"n\">_</span><span class=\"bp\">¬ª</span><span class=\"o\">]</span>\n  <span class=\"bp\">*</span> <span class=\"n\">The</span> <span class=\"n\">tactic</span> <span class=\"bp\">`</span><span class=\"n\">mod_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">%</span> <span class=\"mi\">3</span><span class=\"bp\">`</span> <span class=\"n\">will</span> <span class=\"n\">perform</span> <span class=\"n\">a</span> <span class=\"n\">case</span> <span class=\"n\">disjunction</span> <span class=\"n\">on</span> <span class=\"bp\">`</span><span class=\"n\">e</span><span class=\"bp\">`.</span>\n    <span class=\"n\">If</span> <span class=\"bp\">`</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"k\">then</span> <span class=\"n\">it</span> <span class=\"n\">will</span> <span class=\"n\">yield</span> <span class=\"n\">subgoals</span> <span class=\"n\">containing</span> <span class=\"n\">the</span> <span class=\"n\">assumptions</span>\n    <span class=\"bp\">`</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">‚â°</span> <span class=\"mi\">0</span> <span class=\"o\">[</span><span class=\"n\">ZMOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">‚â°</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"n\">ZMOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">‚â°</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"n\">ZMOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">`</span>\n    <span class=\"n\">respectively.</span> <span class=\"n\">If</span> <span class=\"bp\">`</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"bp\">`</span> <span class=\"n\">instead</span><span class=\"o\">,</span> <span class=\"k\">then</span> <span class=\"n\">it</span> <span class=\"n\">works</span> <span class=\"n\">similarly</span><span class=\"o\">,</span> <span class=\"n\">except</span> <span class=\"k\">with</span>\n    <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">MOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">`</span> <span class=\"n\">instead</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">ZMOD</span> <span class=\"mi\">3</span><span class=\"o\">]</span><span class=\"bp\">`.</span>\n  <span class=\"bp\">*</span> <span class=\"n\">In</span> <span class=\"n\">general</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">mod_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"bp\">`</span> <span class=\"n\">works</span>\n    <span class=\"n\">when</span> <span class=\"bp\">`</span><span class=\"n\">n</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">positive</span> <span class=\"n\">numeral</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"n\">e</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"n\">expression</span> <span class=\"n\">of</span> <span class=\"n\">type</span> <span class=\"bp\">`</span><span class=\"n\">‚Ñï</span><span class=\"bp\">`</span> <span class=\"n\">or</span> <span class=\"bp\">`</span><span class=\"n\">‚Ñ§</span><span class=\"bp\">`.</span>\n  <span class=\"bp\">*</span> <span class=\"n\">If</span> <span class=\"bp\">`</span><span class=\"n\">h</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">omitted</span> <span class=\"n\">as</span> <span class=\"k\">in</span> <span class=\"bp\">`</span><span class=\"n\">mod_cases</span> <span class=\"n\">e</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">will</span> <span class=\"n\">be</span> <span class=\"n\">default</span><span class=\"bp\">-</span><span class=\"n\">named</span> <span class=\"bp\">`</span><span class=\"n\">H</span><span class=\"bp\">`.</span>\n\n<span class=\"n\">syntax</span> <span class=\"s2\">\"monicity\"</span><span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">Mathlib.Tactic.ComputeDegree.monicityMacro</span><span class=\"o\">]</span>\n  <span class=\"bp\">`</span><span class=\"n\">monicity</span><span class=\"bp\">`</span> <span class=\"n\">tries</span> <span class=\"n\">to</span> <span class=\"n\">solve</span> <span class=\"n\">a</span> <span class=\"n\">goal</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"bp\">`</span><span class=\"n\">Monic</span> <span class=\"n\">f</span><span class=\"bp\">`.</span>\n  <span class=\"n\">It</span> <span class=\"n\">converts</span> <span class=\"n\">the</span> <span class=\"n\">goal</span> <span class=\"n\">into</span> <span class=\"n\">a</span> <span class=\"n\">goal</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"bp\">`</span><span class=\"n\">natDegree</span> <span class=\"n\">f</span> <span class=\"bp\">‚â§</span> <span class=\"n\">n</span><span class=\"bp\">`</span> <span class=\"n\">and</span> <span class=\"n\">one</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"bp\">`</span><span class=\"n\">f.coeff</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">`</span>\n  <span class=\"n\">and</span> <span class=\"n\">calls</span> <span class=\"bp\">`</span><span class=\"n\">compute_degree</span><span class=\"bp\">`</span> <span class=\"n\">on</span> <span class=\"n\">those</span> <span class=\"n\">two</span> <span class=\"n\">goals.</span>\n\n  <span class=\"n\">The</span> <span class=\"n\">variant</span> <span class=\"bp\">`</span><span class=\"n\">monicity</span><span class=\"bp\">!`</span> <span class=\"n\">starts</span> <span class=\"n\">like</span> <span class=\"bp\">`</span><span class=\"n\">monicity</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">but</span> <span class=\"n\">calls</span> <span class=\"bp\">`</span><span class=\"n\">compute_degree</span><span class=\"bp\">!`</span> <span class=\"n\">on</span> <span class=\"n\">the</span> <span class=\"n\">two</span> <span class=\"n\">side</span><span class=\"bp\">-</span><span class=\"n\">goals.</span>\n\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>It would probably be quite easy to make it produce an output that could be transferred to a markdown file.</p>\n<p>Would this be desirable?  I remember looking into this a while back: it seemed fairly straightforward, but I simply did not have the time to invest in this at the time.</p>",
        "id": 420490955,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707408600
    },
    {
        "content": "<p>With a little bit of extra effort, I guess that we could also introduce a <code>tactic_wanted</code> command that takes a name and a doc-string that could be automatically added to the page, as a way of keeping track of what automation is lacking.</p>\n<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">*  Should find limits in \"simple\" cases (e.g., no `0/0` etc).</span>\n<span class=\"sd\">*  Simplest version is `Continuous.tendsto' (by continuity) _ _ (by simp)`.</span>\n<span class=\"sd\">*  More advanced version should know that `exp(-1/x)` tends to `ùìù[&gt;] 0` as `x` tends to `atTop`.</span>\n<span class=\"sd\">*  Should know that `1/x` tends to cobounded as `x` tends to `ùìù[‚â†] 0` and vice versa (for any normed field, not only reals).</span>\n<span class=\"sd\">-/</span>\n<span class=\"n\">tactic_wanted</span> <span class=\"n\">Tendsto</span>\n</code></pre></div>",
        "id": 420492800,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707409070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420490955\">said</a>:</p>\n<blockquote>\n<p>It would probably be quite easy to make it produce an output that could be transferred to a markdown file.<br>\n</p>\n</blockquote>\n<p>This already exists elsewhere; the key missing piece is integration with doc-gen4</p>",
        "id": 420499564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707410990
    },
    {
        "content": "<p>Ah, I thought that the page would be on the community website, not on the documentation page!</p>",
        "id": 420500054,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707411124
    },
    {
        "content": "<p>I made a tracking issue for some of the things mentioned in this thread. <a href=\"https://github.com/leanprover-community/mathlib4/pull/10361\">#10361</a></p>",
        "id": 420530848,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707421930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420366276\">said</a>:</p>\n<blockquote>\n<h3>Tactic that can compute things about polynomials</h3>\n<ul>\n<li>Polynomial equality</li>\n<li>Polynomial disequality</li>\n<li><code>n</code>-th coefficient, leading coefficient</li>\n<li>degree</li>\n<li>monicity (is that the word for the property of being monic?)</li>\n</ul>\n<p>The tactic should be able to work with polynomials over a commutative ring, at least when coefficients are explicitly given integers. Ideally there is some support for non-integer ring elements as well (perhaps just via <code>simp</code> being able to simplify expressions involving such elements). <br>\n<code>simp</code> can compute some of these things quite well (<code>n</code>-nth coefficient), but the other ones are quite painful</p>\n</blockquote>\n<p>To the polynomial equality point, I would elaborate \"a tactic that can reduce a (mv)polynomial equality to equalities of the nonzero coefficients.\" This is basically what <a href=\"https://github.com/BoltonBailey/formal-snarks-project/blob/2fdc0c2ae0def3ea3e52a2c589337eb5ec5eaf78/FormalSnarksProject/SoundnessTactic/SoundnessProver.lean#L21\">this</a> is meant to do, but I still need to turn it into a proper tactic.</p>",
        "id": 420531222,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707422070
    },
    {
        "content": "<p>Another comment. I notice that a lot of the tactics here (<code>nonzero</code>, <code>tendsto</code>, <code>positivity</code>) as well as existing tactics like <code>continuity</code>,<code>push_neg</code> all seem to have the form of (apply lemmas where the conclusion/rewrite rule has a particular top level form recursively). Perhaps this framework can be generalized somehow?</p>",
        "id": 420532906,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707422677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420532906\">said</a>:</p>\n<blockquote>\n<p>Another comment. I notice that a lot of the tactics here (<code>nonzero</code>, <code>tendsto</code>, <code>positivity</code>) as well as existing tactics like <code>continuity</code>,<code>push_neg</code> all seem to have the form of (apply lemmas where the conclusion/rewrite rule has a particular top level form recursively). Perhaps this framework can be generalized somehow?</p>\n</blockquote>\n<p>This generalization exists and is called Aesop :) We should really make a concrete plan for how we want to use the full power of Aesop: IMO we should go beyond small rulesets and actually try larger-scale automation.</p>",
        "id": 420616028,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1707471741
    },
    {
        "content": "<p>It also exists as <code>apply_rules</code> and <code>fun_prop</code>, right?</p>",
        "id": 420616114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707471781
    },
    {
        "content": "<p>(and <code>solve_by_elim</code>?)</p>",
        "id": 420616146,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707471800
    },
    {
        "content": "<p>Not that it really matters, because it's unlikely that I'll ever write a tactic, but just to comment that I have a very hard time distinguishing between Aesop and the three tactics which Eric just mentioned. Are any of them subsumed by any of the others as far as an end user is concerned?</p>",
        "id": 420616505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707471957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> when you can find the time I would be interested in seeing the final boss of tactic wishlists</p>",
        "id": 420619992,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707473215
    },
    {
        "content": "<p>I can see that this can be quite confusing to the end user and I'm not really sure how to go about explaining the differences.</p>\n<p>For example, if you could magically solve higher order unification then <code>fun_prop</code> is obsolete and you can just use <code>apply_rules</code>. Unfortunately magic does not exist so you need a specialized <code>apply_rules</code> called <code>fun_prop</code> for propositions that have rules <code>*_id</code>, <code>*_const</code>, <code>*_comp</code>, <code>*_apply</code>, <code>*_pi</code>.</p>",
        "id": 420621020,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1707473599
    },
    {
        "content": "<p><code>nonzero</code> can be done by <code>aesop</code> (plus some special cases?) but <code>positivity</code> uses special tricks to avoid backtracking while proving, e.g., <code>0 &lt; a + b + c + d + e</code>.</p>",
        "id": 420653614,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707485772
    },
    {
        "content": "<p>And then the difference between <code>apply_rules</code> and <code>solve_by_elim</code> is that <code>apply_rules</code> doesn't backtrack, but <code>solve_by_elim</code> does (including across multiple related goals!)</p>",
        "id": 420654248,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707486003
    },
    {
        "content": "<p>and then the difference between solve_by_elim and aesop is that <code>solve_by_elim</code> only calls <code>apply</code> (modulo the existence of some hooks to call dischargers and other adhoc modifications), while <code>aesop</code> does everything, and is also lovely and usable.</p>",
        "id": 420654428,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707486065
    },
    {
        "content": "<p>So at least out of the 4 of those (<code>aesop</code> + <code>apply_rules</code> + <code>solve_by_elim</code> + <code>fun_prop</code>) all \"should exist\"? (Asking ignorant questions) <code>aesop</code> couldn't for instance take as input which tactics to apply at each step (and thereby support being given only <code>apply</code> to work with)?</p>",
        "id": 420659641,
        "sender_full_name": "Julian Berman",
        "timestamp": 1707487794
    },
    {
        "content": "<p>They each specialize in various ways. (well, not <code>apply_rules</code>: it really is just <code>solve_by_elim (config := {backtracking := false})</code>, or close enough).</p>",
        "id": 420660287,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488002
    },
    {
        "content": "<p>It's a very very large design space.</p>",
        "id": 420660336,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488023
    },
    {
        "content": "<p><code>fun_prop</code> specialises in reasoning about function, and not getting trapped by the infinite recursion that composition tempts the other backtracking tactics with.</p>",
        "id": 420660522,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488080
    },
    {
        "content": "<p><code>solve_by_elim</code> will work on multiple goals, backtracking across them, because it is used as the discharger for <code>exact?</code>. (Actually, maybe <code>aesop</code> copes just fine with multiple goals too, not sure.)</p>",
        "id": 420660697,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488141
    },
    {
        "content": "<p>It also has some custom machinery for applying terms, e.g. <code>solve_by_elim [my_fun x]</code>, where it is careful about not letting metavariables get stuck after one <code>apply</code>, so the term can be applied again with different arguments later in the search. I don't <em>think</em> this is a concern for <code>aesop</code>.</p>",
        "id": 420660971,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488232
    },
    {
        "content": "<p>Speaking as someone who doesn't understand any of the technicalities here, I was very surprised to see several people who do understand them get very excited by Tomas' <code>fun_prop</code> because I'd imagined we \"had everything we needed in this area\". This discussion is revealing that this seems to be far from the case!</p>",
        "id": 420661100,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707488276
    },
    {
        "content": "<p>I found it pretty interesting that when people were describing \"missing tactics\" above in this thread they were mostly describing the <em>problems</em> the tactic ought to be able to solve, rather than the algorithm by which is would do so!</p>",
        "id": 420661129,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488283
    },
    {
        "content": "<p>If that's a valid way to contribute then can I have a tactic which proves Fermat's Last Theorem?</p>",
        "id": 420661328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707488348
    },
    {
        "content": "<p>Oh, Kevin, you're aware that <code>continuity</code> has always been slow, despite changing implementations at least once (maybe twice now, once during mathlib3, again during the port).</p>",
        "id": 420661333,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488351
    },
    {
        "content": "<p>This is why people are excited about funprop. It properly solves the problems that <code>continuity</code> has always just been brute forcing (or failing).</p>",
        "id": 420661439,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1707488394
    },
    {
        "content": "<p>Given the popularity of this thread, I wonder if it is worth creating a new \"Feature request\" stream for this sort of thing (with missing tactics just being one of many possible topics for the stream).</p>",
        "id": 420690328,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707496920
    },
    {
        "content": "<p>feature request for whom?</p>",
        "id": 420690497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707496962
    },
    {
        "content": "<p>The <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a> <a class=\"stream\" data-stream-id=\"348111\" href=\"/#narrow/stream/348111-std4\">#std4</a> <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4\">#mathlib4</a> streams are often used for feature requests</p>",
        "id": 420690575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707496985
    },
    {
        "content": "<p>Yeah but it isn't easy to browse through them to get an idea of what new features the community would like to see the most.  This particular topic is the first time I've seen this sort of compilation and I think it has been educational.</p>",
        "id": 420690838,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707497059
    },
    {
        "content": "<p>I think the streams you mention are mostly dominated by quite narrowly focused questions on a very specific technical topic, whereas I am envisioning a stream devoted to broader perspective questions, or requests to compile diverse sets of narrow requests, such as the compilation of desired tactics seen here.</p>",
        "id": 420691507,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707497275
    },
    {
        "content": "<p>So maybe \"feature requests\" is the wrong name for what I am proposing.  Something like \"Big picture\" or \"Goals and perspectives\" or something... hmm, I'm struggling to find the right name, but basically the opposite of narrowly focused discussions.</p>",
        "id": 420692075,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707497455
    },
    {
        "content": "<p>To get the concentration you are talking about, I think you really do want a <em>topic</em> and not a <em>stream</em></p>",
        "id": 420692183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707497498
    },
    {
        "content": "<p>in which case this one will do fine</p>",
        "id": 420692203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707497506
    },
    {
        "content": "<p>the trouble is that we can't go in depth on any particular proposed tactic here without making it harder to see the big picture again</p>",
        "id": 420692378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707497555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420661129\">said</a>:</p>\n<blockquote>\n<p>I found it pretty interesting that when people were describing \"missing tactics\" above in this thread they were mostly describing the <em>problems</em> the tactic ought to be able to solve, rather than the algorithm by which is would do so!</p>\n</blockquote>\n<p>This has been a surprise to me too since I was rather selfishly fishing for something that could be more or less straightforwardly implemented, but I guess life if never easy. Thinking of my own wishlist, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what happened to implementing interval arithmetic in lean?</p>",
        "id": 420695531,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1707498526
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420692203\">said</a>:</p>\n<blockquote>\n<p>in which case this one will do fine</p>\n</blockquote>\n<p>Fair enough.  I've seen one or two other \"big picture\" topics recently (e.g., <a href=\"#narrow/stream/287929-mathlib4/topic/Mission.20of.20mathlib\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Mission.20of.20mathlib</a> ) but perhaps not enough volume as yet to warrant a separate stream.</p>",
        "id": 420698607,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707499645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420695531\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> what happened to implementing interval arithmetic in lean?</p>\n</blockquote>\n<p>Other people have been pushing this forward, see <a href=\"#narrow/stream/287929-mathlib4/topic/New.20.60by_approx.60.20tactic.20for.20proving.20real.20inequalities/near/407069390\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/New.20.60by_approx.60.20tactic.20for.20proving.20real.20inequalities/near/407069390</a> and <a href=\"#narrow/stream/113488-general/topic/Verified.20software.20floating.20point/near/419936247\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Verified.20software.20floating.20point/near/419936247</a></p>",
        "id": 420698925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707499745
    },
    {
        "content": "<p>Yep, I have working interval arithmetic (and some formalized Mandelbrot renders using it, including log and exp).</p>",
        "id": 420699798,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1707500042
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> 's request would be fulfilled if the community website had a list of such topics updated from time to time. Zulip is not ideal for this because nice and important discussions tend to get buried over time</p>",
        "id": 420706077,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707502474
    },
    {
        "content": "<p>Or some kind of a feed of zulip topics with a lot of activity from several active members</p>",
        "id": 420706199,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707502548
    },
    {
        "content": "<p>If further they could be tagged (such as feature requests, major bugs, announcements) then filtering them to get feature requests would also be easy</p>",
        "id": 420706360,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1707502606
    },
    {
        "content": "<p>One other way in which the community tracks features they would like is through the <a href=\"https://leanprover-community.github.io/undergrad_todo.html\">undergraduate todo page</a>, so maybe we could have more pages like that. I would also continue to advocate for the \"tracking issue\" approach, though. I think that issues like the <a href=\"https://github.com/leanprover-community/mathlib4/issues/7217\">linter wishlist</a> and this new <a href=\"https://github.com/leanprover-community/mathlib4/issues/10361\">tactic wishlist</a> are potentially the best in terms of simultaneous approachability and centrality.</p>",
        "id": 420710982,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707504475
    },
    {
        "content": "<p>(I would suggest that it might be nice to encourage adding content to the undergraduate todo page, I can probably think of a variety of computer science topics that could go there, but it seems like that page is perhaps specifically dedicated to this French mathematics curriculum. Maybe once everything on that page is complete we can transform it to can other undergrad topics?)</p>",
        "id": 420712244,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707504916
    },
    {
        "content": "<p>Maybe we need a meta-page tracking lists of goal theorems like <a href=\"https://github.com/leanprover-community/mathlib4/pull/6091\">#6091</a> so that we don't need a single mega-list where we need to get consensus on what should be eligible to be listed</p>",
        "id": 420713841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1707505508
    },
    {
        "content": "<p>To return to the topic of the thread, a more ambitious missing tactic would be </p>\n<h3>Tactic to resolve statements in the first-order theory of the reals.</h3>\n<p>It is a classical <a href=\"https://en.wikipedia.org/wiki/Tarski%E2%80%93Seidenberg_theorem\">theorem</a> that such decision procedures exist, and there is research on faster modern algorithms that I am unfamiliar with. I seem to recall watching a video of a talk someone gave about work formalizing CAD algorithms but I unfortunately am having trouble finding the link.</p>",
        "id": 420730316,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707512232
    },
    {
        "content": "<p>Another one:</p>\n<h3>Tactic for the convergence of logarithmico-exponential functions</h3>\n<p>These are functions that are composed from $+, -, *, exp, log$, the kind of functions one typically sees in big-O notation. It is a <a href=\"https://cs.stackexchange.com/a/127719/60324\">theorem</a> that all single-variable functions like this either approach a real limit or converge to infinity. It might be nice to be able to get a tactic that proves these limits / returns a point after which function A is greater than B, etc.</p>",
        "id": 420732671,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1707513228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420695531\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420661129\">said</a>:</p>\n<blockquote>\n<p>I found it pretty interesting that when people were describing \"missing tactics\" above in this thread they were mostly describing the <em>problems</em> the tactic ought to be able to solve, rather than the algorithm by which is would do so!</p>\n</blockquote>\n<p>This has been a surprise to me too since I was rather selfishly fishing for something that could be more or less straightforwardly implemented, but I guess life if never easy. Thinking of my own wishlist, <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> what happened to implementing interval arithmetic in lean?</p>\n</blockquote>\n<ul>\n<li><code>nonzero</code> can be implemented either using <code>aesop</code> with fallback to <code>positivity</code> if we have an order; see also what <code>field_simp</code> does;</li>\n<li>modifying <code>positivity</code> to support <code>-a &lt; 0</code> means adding <code>negative</code> to the list of possible outcomes and handling it here and there.</li>\n</ul>",
        "id": 420753412,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707524190
    },
    {
        "content": "<p>33 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Cylindrical.20Algebraic.20Decomposition.20tactic\">#general &gt; Cylindrical Algebraic Decomposition tactic</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span>.</p>",
        "id": 420771506,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707541457
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/.22Missing.20Tactics.22.20list/near/420732671\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Cylindrical.20Algebraic.20Decomposition.20tactic\">#general &gt; Cylindrical Algebraic Decomposition tactic</a> by <span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span>.</p>",
        "id": 420812340,
        "sender_full_name": "Notification Bot",
        "timestamp": 1707581780
    },
    {
        "content": "<p>A tactic that I often miss is a version of <code>simp_rw</code> that can create new goals for side-conditions. When rewriting under a binder and you need a side-condition, just universally quantify all local variables.<br>\nExample:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.SimpRw</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- desired new goal: ‚ä¢ ‚àÄ x, p x</span>\n</code></pre></div>",
        "id": 424085762,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709232510
    },
    {
        "content": "<p>But ideally it would be able to add even more local variables, using smart congr lemmas? Or is that too sophisticated?</p>",
        "id": 424086036,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709232609
    },
    {
        "content": "<p>E.g., add <code>x \\in s</code> when <code>simp_rw</code>ing inside a <code>Finset.sum</code>.</p>",
        "id": 424086080,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709232627
    },
    {
        "content": "<p>I guess by then we're stealing a lot of <code>conv</code> functionality.</p>",
        "id": 424086142,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1709232651
    },
    {
        "content": "<p>Ideally yes, it would use smart congr lemmas, and e.g. <code>‚àÄ·µê</code> when rewriting inside an integral.</p>",
        "id": 424086172,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1709232664
    },
    {
        "content": "<p><code>simp</code> uses those congr lemmas to navigate into terms already. (I think one could say that <code>conv</code> is stealing <code>simp</code> functionality to work.)</p>",
        "id": 424086357,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709232731
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/Help.20with.20.60nightly-testing.60/near/424206307\">Here</a> is me asking for a better <code>field_simp</code>. (In short: collect the <code>blah ‚â† 0</code> requirements and leave them as side goals.)</p>",
        "id": 424278786,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1709309660
    },
    {
        "content": "<p>There were several times when I wished we had a tactic to write <code>rw [h]; clear h</code> in short.</p>",
        "id": 424350218,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1709341501
    },
    {
        "content": "<p>If <code>h</code> is an equality where the left-hand side is a free variable, then that is exactly <code>subst h</code></p>",
        "id": 424350797,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709342095
    },
    {
        "content": "<p>Another possibility is that you never create <code>h</code> in the first place; if I want to change a subexpression using a rewrite which is an equality which can be proved with eg <code>ring</code> and which I never need again, then <code>rw [show x^2+3*x*y+2*y^2 = (x+y)*(x+2*y) by ring]</code> (or some minor syntactic variant of this, I'm not at lean right now) works and I never have to make the hypothesis at all.</p>",
        "id": 424371771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709362479
    },
    {
        "content": "<p>Beyond just a particular missing tactic, I wish the tactic mode itself did more to automate the use of tactics. I think it would be cool if there was some kind of <code>simp_by</code> or <code>tidy_by</code> that I could use instead of <code>by</code> to enter <code>simp</code>-trying tactic mode or <code>tidy</code>-trying tactic mode instead of regular tactic mode, where whenever I leave a proof <code>sorry</code>ed or unfinished, it automatically tries the tactic and inserts it if it closes the goal, and looks like normal tactic mode if that doesn't work.</p>",
        "id": 425319534,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1709822249
    },
    {
        "content": "<p>I thought that the dream was to be able to globally switch this mode on ...</p>",
        "id": 425398472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709847079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> sound's like what you want is <a href=\"#narrow/stream/270676-lean4/topic/Aesop.20etc.20in.20the.20background/near/378792005\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Aesop.20etc.20in.20the.20background/near/378792005</a> by <span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> and his group, I think</p>",
        "id": 425424297,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1709859127
    },
    {
        "content": "<p>Indeed the idea is to run tactics in the background, not just with a sorry but also when pausing for thought and working - taking off from all stages in case the user has taken a wrong turn. One can plug in <code>simp</code> or <code>aesop</code> or maybe one of the copilot tactics.</p>\n<p>This was a branch and PR that has rotted a bit, but I will bring it up to date. I am happy to work on UI and/or internal improvements.</p>",
        "id": 425428462,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1709862106
    },
    {
        "content": "<p>The pr <a href=\"https://github.com/leanprover-community/mathlib4/pull/6176\">https://github.com/leanprover-community/mathlib4/pull/6176</a> is now up to date. Anyone can try this by checking out (or using as dependency) the <code>aided_by</code> branch.</p>\n<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> Can you review this?<br>\n<span class=\"user-mention\" data-user-id=\"282271\">@Bolton Bailey</span> Does this look like what you wanted? I welcome suggestions on what would make things better.</p>",
        "id": 425449971,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1709875308
    },
    {
        "content": "<p>Yes, this looks like exactly what I wanted. Going over my most recent PRs it is able to conclude many of the lemmas. </p>\n<p>Frustrating to me that this PR wasn't approved months ago. Even if this weren't the \"right user interaction to drive tactics running automatically\" (which I'm not convinced it isn't), surely it would be fine to merge into mathlib and make it easier to experiment with?</p>",
        "id": 425517524,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1709904118
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 425518880,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1709904573
    },
    {
        "content": "<p>Another metaprogram that would be great: the <code>@[ext]</code> attribute should automatically generate the <code>ext_iff</code> lemma from a tagged <code>ext</code> lemma. Many <code>ext_iff</code> lemmas are currently missing in Mathlib, and I find it very annoying.</p>",
        "id": 446267660,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1719058808
    },
    {
        "content": "<p>Yes please, I will happily merge such a PR.</p>",
        "id": 446360006,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1719112464
    },
    {
        "content": "<p>5 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Generate.20ext_iff.20lemmas\">#lean4 &gt; Generate ext_iff lemmas</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 446519610,
        "sender_full_name": "Notification Bot",
        "timestamp": 1719206181
    }
]