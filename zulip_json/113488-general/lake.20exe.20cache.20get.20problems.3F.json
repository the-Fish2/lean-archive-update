[
    {
        "content": "<p>Has anyone had the following experience? I merged master with a branch, waited a while, opened VSCode, and refreshed dependencies. Lean says it's compiling starting with file [1800/2400]. I think, wait, that's going to take forever. So I close VSCode, and <code>lake exe cache get</code>. Then I open VSCode and refresh dependencies again. Now Lean says it's compiling starting with file [300/2400]. :( Did I do something wrong??</p>",
        "id": 431138465,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712163811
    },
    {
        "content": "<p>Assuming that the cache is remotely available, these issue typically get resolved after <code>lake exe cache clean</code> or, sometimes <code>rm -rf .lake</code> (think hard about issuing this last command!).</p>",
        "id": 431138990,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712164004
    },
    {
        "content": "<p>Of course, running <code>lake exe cache get</code> afterwards!</p>",
        "id": 431139065,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712164034
    },
    {
        "content": "<p>Got it, thanks!</p>",
        "id": 431140412,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1712164545
    },
    {
        "content": "<p>with this sort of situation, if my branch is just a few files changed from master and nothing too low-level, I checkout master, do <code>lake exe cache get</code> there, and then checkout the branch and then hopefully it just has to compile the files I changed.</p>",
        "id": 431162672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712173224
    },
    {
        "content": "<p>Kevin, this technique helped in Lean 3 where we didn't have a granular cache, but in Lean 4 this is exactly the same as running <code>lake exe cache get</code> on the branch</p>",
        "id": 431163016,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712173351
    },
    {
        "content": "<p>Even if the branch has just been merged with master locally and not pushed, using any one of the three ways that git can merge branches?</p>",
        "id": 431163998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712173716
    },
    {
        "content": "<p>Yes, because all that matters is the state of the files, not how you got there</p>",
        "id": 431164637,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712173935
    },
    {
        "content": "<p>cache is git-agnostic</p>",
        "id": 431164662,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712173948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113488-general/topic/lake.20exe.20cache.20get.20problems.3F/near/431163016\">said</a>:</p>\n<blockquote>\n<p>Kevin, this technique helped in Lean 3 where we didn't have a granular cache, but in Lean 4 this is exactly the same as running <code>lake exe cache get</code> on the branch</p>\n</blockquote>\n<p>While the end result is the same, Kevin's approach can be much faster; <code>lake exe cache get</code> is far slower on a missing cache than a present one.</p>",
        "id": 431258920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712220527
    },
    {
        "content": "<p>I wish I knew why :(</p>",
        "id": 431259438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712220708
    },
    {
        "content": "<p>It is literally the network request (i.e. azure) which takes longer to return 404 than 200</p>",
        "id": 431259551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712220744
    },
    {
        "content": "<p>Is it caching? The variation of failing requests is likely much higher than succeeding ones as any change results in completely different hashes downstream</p>",
        "id": 431262576,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1712221622
    },
    {
        "content": "<p>in that case, wouldn't you expect running it a second time to be fast?</p>",
        "id": 431265943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712222534
    },
    {
        "content": "<p>I mean, it shouldn't be a difficult test to run it in a loop and see if the server eventually decides it's worth caching</p>",
        "id": 431266153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712222579
    },
    {
        "content": "<p>I haven't tried. Maybe they just don't do negative caching</p>",
        "id": 431266177,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1712222590
    },
    {
        "content": "<p>I suppose that makes sense, you don't want to be on the hook as a caching service if you are serving cached 404s when the file is hot off the press</p>",
        "id": 431266435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712222676
    },
    {
        "content": "<p>Can we teach <code>cache</code> to create empty files or something for \"this file was unbuildable\", so that that information is cached positively?</p>",
        "id": 432086151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712620176
    },
    {
        "content": "<p>wouldn't it be <code>lake</code> creating those files?</p>",
        "id": 432170555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712652578
    },
    {
        "content": "<p>I think either would work, though maybe only lake has the info needed to create them</p>",
        "id": 432177673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712654596
    },
    {
        "content": "<p><code>cache</code> can't tell the difference between good files and bad, outdated files</p>",
        "id": 432178993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712654950
    }
]