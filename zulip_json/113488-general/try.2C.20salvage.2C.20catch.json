[
    {
        "content": "<p>Ever wanted to grab some data dependent (only) on the monad state <em>after</em> you've thrown an error in a <code>try</code> block? Well...probably not, actually. But if you ever find yourself in that specific predicament, here's some code that lets you write the following in most of Lean's major monads. :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">try</span>\n    <span class=\"bp\">...</span>\n  <span class=\"n\">salvage</span> <span class=\"n\">ex</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">...</span>\n    <span class=\"c1\">-- salvage `b : β` by working in the monad after `ex` has been thrown,</span>\n    <span class=\"c1\">-- but before restoring the state with `catch`</span>\n    <span class=\"n\">return</span> <span class=\"n\">b</span>\n  <span class=\"n\">catch</span> <span class=\"n\">ex</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"bp\">&lt;</span><span class=\"k\">do</span> <span class=\"n\">something</span> <span class=\"k\">with</span> <span class=\"n\">b</span><span class=\"bp\">!&gt;</span>\n    <span class=\"bp\">...</span>\n</code></pre></div>\n<p>(I'm not planning on PRing this—this is just for fun. Thought I'd share. :) )</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Lean\n\nsection\n\nset_option autoImplicit true\n\nopen Lean Elab Tactic\n\nsection instances\n\n/-!\nEverything is structurally exactly the same as for `tryCatch`.\nNote that we don&#39;t include `throw`—the `throw` in `MonadExcept` is enough.\n-/\n\nclass MonadSalvageOf.{u, v, w} (ε : semiOutParam (Type u)) (m : Type v → Type w) :\n    Type (max (max u (v + 1)) w) where\n  trySalvageCatch {α : Type v} (x : m α) {β : Type v} (salvage : ε → m β)\n      (handle : ε → β → m α) : m α\n\nclass MonadSalvage.{u, v, w} (ε : outParam (Type u)) (m : Type v → Type w) : Type (max (max u (v + 1)) w) where\n  trySalvageCatch {α : Type v} (x : m α) {β : Type v} (salvage : ε → m β)\n      (handle : ε → β → m α) : m α\n\nexport MonadSalvage (trySalvageCatch)\n\nabbrev trySalvageCatchThe (ε : Type u) {m : Type v → Type w} [MonadSalvageOf ε m]\n    {α : Type v} (x : m α) {β} (salvage : ε → m β) (handle : ε → β → m α) : m α :=\n  MonadSalvageOf.trySalvageCatch x salvage handle\n\ninstance (ε : outParam (Type u)) (m : Type v → Type w) [MonadSalvageOf ε m] : MonadSalvage ε m where\n  trySalvageCatch := trySalvageCatchThe ε\n\nnamespace EStateM\n\n@[always_inline, inline]\ndef trySalvageCatch {δ} [Backtrackable δ σ] {α} (x : EStateM ε σ α) {β} (salvage : ε → EStateM ε σ β) (handle : ε → β → EStateM ε σ α) : EStateM ε σ α := fun s =&gt;\n  let d := Backtrackable.save s\n  match x s with\n  | Result.error e s =&gt; match salvage e s with\n    | Result.ok b s&#39; =&gt; handle e b (Backtrackable.restore s&#39; d)\n    | Result.error e&#39; s&#39; =&gt; Result.error e&#39; s&#39; -- Errors in `salvage` are preserved and uncaught.\n  | ok               =&gt; ok\n\ninstance {δ} [Backtrackable δ σ] : MonadSalvageOf ε (EStateM ε σ) where\n  trySalvageCatch := trySalvageCatch\n\nend EStateM\n\ninstance : MonadSalvageOf ε (EIO ε) := inferInstanceAs (MonadSalvageOf ε (EStateM ε IO.RealWorld))\n\n@[always_inline]\ninstance (ε) [MonadSalvageOf ε m] : MonadSalvageOf ε (ReaderT ρ m) where\n  trySalvageCatch := fun x _ s c r =&gt;\n    trySalvageCatchThe ε (x r) (fun e =&gt; (s e) r) (fun e b =&gt; (c e b) r)\n\n@[always_inline]\ninstance (ε) [MonadSalvageOf ε m] : MonadSalvageOf ε (StateRefT&#39; ω σ m) where\n  trySalvageCatch := fun x _ s c t =&gt;\n    trySalvageCatchThe ε (x t) (fun e =&gt; (s e) t) (fun e b =&gt; (c e b) t)\n\n@[inline] protected def Core.trySalvageCatch (x : CoreM α) {β} (s : Exception → CoreM β) (h : Exception → β → CoreM α) : CoreM α := do\n  trySalvageCatch x s fun ex b =&gt; do\n    if ex.isRuntime &amp;&amp; !(← read).catchRuntimeEx then\n      throw ex\n    else\n      h ex b\n\ninstance : MonadSalvageOf Exception CoreM where\n  trySalvageCatch := Core.trySalvageCatch\n\nnamespace Tactic\n\n@[inline] protected def trySalvageCatch {α} (x : TacticM α) {β} (s : Exception → TacticM β)\n    (h : Exception → β → TacticM α) (restoreInfo := false): TacticM α := do\n  let t ← saveState\n  trySalvageCatch x s fun ex b =&gt; do t.restore restoreInfo; h ex b\n\ninstance : MonadSalvage Exception TacticM where\n  trySalvageCatch := fun x _ s h =&gt; Tactic.trySalvageCatch x s h (restoreInfo := false)\n\nend Tactic\n\nend instances\n\n/-- Example of a &#39;useful&#39; function built on `trySalvageCatch`. -/\ndef tryCatchSalvagingState {m : Type → Type} [Monad m] [MonadBacktrack σ m]\n    [MonadSalvage ε m] (x : m α) (h : ε → σ → m α) : m α :=\n  trySalvageCatch x (fun _ =&gt; saveState) h\n\nend\n\nsection parser\n\nopen Lean Meta Parser Term\n\ndef doSalvage := leading_parser\n  ppDedent ppLine &gt;&gt; atomic (&quot;salvage &quot; &gt;&gt; funBinder) &gt;&gt; optType &gt;&gt; darrow &gt;&gt; doSeq\n\ndef doCatchSalvage := leading_parser\n  ppDedent ppLine &gt;&gt; atomic (&quot;catch &quot; &gt;&gt; funBinder &gt;&gt; funBinder) &gt;&gt; darrow &gt;&gt; doSeq\n\n@[doElem_parser] def doTrySalvage := leading_parser\n  &quot;try &quot; &gt;&gt; doSeq &gt;&gt; doSalvage &gt;&gt; many (doCatchSalvage &lt;|&gt; doCatchMatch) &gt;&gt; Parser.optional doFinally\n\nmacro_rules\n| `(doTrySalvage| try $seq1 salvage $bi $[: $type]? =&gt; $seq2 catch $biex $bis =&gt; $seq3) =&gt;\n    `(doElem|trySalvageCatch\n      (do $seq1)\n      (fun $bi:funBinder $[: $type]? =&gt; do $seq2)\n      (fun $biex $bis =&gt; do $seq3))\n| `(doTrySalvage| try $seq1 salvage $bi $[: $type]? =&gt; $seq2 catch $alts:matchAlts) =&gt;\n    `(doElem|trySalvageCatch\n      (do $seq1)\n      (fun $bi:funBinder $[: $type]? =&gt; do $seq2)\n      (fun $alts:matchAlts))\n\nend parser\n\nsection\n\nopen Lean Meta\n\nelab &quot;test&quot; : tactic =&gt; do\n  try\n    let _ ← mkFreshExprMVar (Expr.const ``Nat []) (userName := `foo)\n    throwError &quot;error!&quot;\n  salvage _ =&gt; getMCtx\n  catch _ mctx =&gt;\n    if let .some foo := (← getMCtx).findUserName? `foo then\n      throwError &quot;somehow, {foo} survived&quot;\n    let .some foo := mctx.findUserName? `foo\n      | throwError &quot;could not find ?foo&quot;\n    let mvar := mctx.getDecl foo\n    logInfo m!&quot;found ?foo : {mvar.type}&quot;\n\nexample : True := by\n  test -- found ?foo : Nat\n  trivial\n\nend\n</code></pre></div>\n</div></div>",
        "id": 426464462,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1710387459
    }
]