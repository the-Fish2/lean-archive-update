[
    {
        "content": "<p>I would like to have a type for functions <code>f : R -&gt; R</code> satisfying <code>ContDiff R 2 f</code> and there are many ways to define this, what would be the better choice in practice / the most idiomatic between these two?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">CD_option_1</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span>\n  <span class=\"n\">smooth</span> <span class=\"o\">:</span> <span class=\"n\">ContDiff</span> <span class=\"n\">R</span> <span class=\"mi\">2</span> <span class=\"n\">toFun</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CD_option_2</span> <span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">ContDiff</span> <span class=\"n\">R</span> <span class=\"mi\">2</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n  <span class=\"c1\">-- whatever is needed to show that it is a subgroup</span>\n</code></pre></div>\n<p>The second one seems to do a lot of boilerplate things automatically, but the first one enables dot notation which I was not able to get with the second one. Or perhaps I am missing a third option?</p>",
        "id": 435798168,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1714261499
    },
    {
        "content": "<p>See the thread about <code>RingOfIntegers</code> for a third option:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">CD_Option_3</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">CD_Option_2</span>\n</code></pre></div>",
        "id": 435837516,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1714285180
    },
    {
        "content": "<p>Thanks for the suggestion! In the end I went with this,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">CD_</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Subspace</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">(</span><span class=\"n\">‚Ñù</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">ContDiff</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">change</span> <span class=\"n\">ContDiff</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">contDiff_const</span>\n  <span class=\"n\">add_mem'</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"n\">hf.add</span> <span class=\"n\">hg</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span> <span class=\"n\">hf.const_smul</span> <span class=\"n\">c</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">CD</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">CD_</span> <span class=\"n\">n</span> <span class=\"n\">E</span>\n</code></pre></div>\n<p>because <code>def</code> was hiding too much of the boilerplate that I was hoping to get (and the tradeoff is that it inherits the wrong topology).</p>",
        "id": 436049450,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1714398236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/113488-general/topic/Defining.20ContDiff.20functions/near/436049450\">said</a>:</p>\n<blockquote>\n<p>(and the tradeoff is that it inherits the wrong topology).</p>\n</blockquote>\n<p>Isn't this tradeoff too expensive? I mean, getting the wrong topology should be a no-go, because it's something you will never be able to fix (unless you hide your definition behind a type synonym, but then you will need to add back the boilerplate).</p>",
        "id": 436071878,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1714403462
    },
    {
        "content": "<p>After defining the semi norms I wanted I just provided instances for uniform space and topological space to override those found through the subtype path, and it seems to work for now. I agree that it feels rather brittle.</p>",
        "id": 436072931,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1714403725
    },
    {
        "content": "<p>And it does go against the principle of uniqueness of instances</p>",
        "id": 436073225,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1714403789
    },
    {
        "content": "<p>OK so the boilerplate to do is not that heavy, going from <code>abbrev</code> to <code>def</code> involves just this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">RCLike</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CD_</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Subspace</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">(</span><span class=\"n\">‚Ñù</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"bp\">|</span> <span class=\"n\">ContDiff</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">n</span> <span class=\"n\">f</span><span class=\"o\">}</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">change</span> <span class=\"n\">ContDiff</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">contDiff_const</span>\n  <span class=\"n\">add_mem'</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"n\">hf.add</span> <span class=\"n\">hg</span>\n  <span class=\"n\">smul_mem'</span> <span class=\"n\">c</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"o\">:=</span> <span class=\"n\">hf.const_smul</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CD</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">CD_</span> <span class=\"n\">n</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">CD</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">CD</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">‚Ñù</span> <span class=\"o\">(</span><span class=\"n\">CD</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">CD</span><span class=\"o\">]</span> <span class=\"bp\">;</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">CD.ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">CD</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.1</span> <span class=\"bp\">=</span> <span class=\"n\">g.1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span> <span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">g</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">CD.add_def</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">CD</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">f.1</span> <span class=\"bp\">+</span> <span class=\"n\">g.1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">lemma</span> <span class=\"n\">CD.smul_def</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">CD</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">R</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">f.1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 436144484,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1714426712
    },
    {
        "content": "<p>Nice! I would probably avoid <code>simp</code> in the instance definition, as you never know if it will do something complicated (although in this case apparently it doesn't), and use something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">CD</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">inferInstanceAs</span> <span class=\"o\">(</span><span class=\"n\">AddCommGroup</span> <span class=\"o\">(</span><span class=\"n\">CD_</span> <span class=\"n\">n</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Also, you should probably register a <code>FunLike</code> instance, a <code>ContinuousMapClass</code> instance, and do this for a general source space instead of the real line :-)</p>",
        "id": 436464402,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1714550064
    }
]