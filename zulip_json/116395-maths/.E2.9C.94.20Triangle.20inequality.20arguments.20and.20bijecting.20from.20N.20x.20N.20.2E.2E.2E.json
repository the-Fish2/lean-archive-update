[
    {
        "content": "<p>I'm currently trying to formalize the results in  <a href=\"/user_uploads/3121/7_3L36U34FHN50JGlI4Y0bl7/Lusin-Novikov.pdf\">Lusin-Novikov.pdf</a>, and at the moment am trying to formalize the first observation towards the top of page 2. I've made what I think is a fair amount of progress in <a href=\"/user_uploads/3121/Ag0EADwzrafogNsjOQ61VbIQ/MWE.lean\">MWE.lean</a> (albeit with horribly inefficient code, but I'll get to golfing once I have something that works), but there are a few sticking points.</p>\n<p>The first is at line 58, where I have managed to get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hcont3</span><span class=\"o\">:</span> <span class=\"n\">edist</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">edist</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">False</span>\n</code></pre></div>\n<p>I have a hypothesis that this distance is nonzero, and since it's in a metric space it's also not infinity (I was recommended to use an extended metric since it plays nicely with diameters and also another file I plan to use later on in the project uses emetrics), so <code>hcont3</code> should quickly yield a contradiction, but I don't actually know how to convince Lean of the latter (I'm also slightly concerned that the coercions are going to cause trouble, but I'm also not totally sure what to do about them and sometimes they work themselves out). Moreover,<code> linarith</code> is running into a strange issue if I try to use it right after line 58, giving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">neg_neg_of_pos</span> <span class=\"n\">εpos</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">εpos</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">ENNReal</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zero.toOfNat0</span> <span class=\"n\">ENNReal</span> <span class=\"n\">instENNRealZero</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">ENNReal</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Zero.toOfNat0</span> <span class=\"n\">ENNReal</span> <span class=\"n\">NegZeroClass.toZero</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">?</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>From what I can tell, it's getting mad about exactly which zero is being used, but I have no idea how to control that or even if that's something I want to attempt to control. Any suggestions for how to complete this part of the proof?</p>\n<p>Then there's the other containment, which is currently lines 61-65, and the key step is that I need to invoke density to pick points sufficiently close to <code>x.fst</code> and <code>x.snd</code>, and then I should be good to go with an argument similar to the other direction. A Moogle search yielded <a href=\"https://github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/Topology/MetricSpace/PseudoMetric.lean#L1833-L1834\">Docs#Metric.denseRange_iff</a>, which works in the metric context, but I couldn't find anything for the emetric case. I suppose worst case I can try to adapt this to the emetric case, but does there happen to exist anything already in the library to help that I'm just not seeing?</p>\n<p>And finally, there's the \"reindexing\" part, since the observation calls for a collection indexed by ℕ, where the one I'm directly constructing is indexed by ℕ x ℕ since it works better for the other details. Since ℕ and ℕ x ℕ are in bijection, it feels like it should be straightforward to do this reindexing; I would simply need an invertible function between them and access to its inverse. That being said, I'm not actually sure how to get such a function in Lean. Could I get some help?</p>",
        "id": 417542980,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706050285
    },
    {
        "content": "<p>For the first question, do you want to use something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=le_mul_iff_one_le_left#doc\">docs#le_mul_iff_one_le_left</a> and then prove 2/3 &lt; 1?</p>",
        "id": 417546805,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706052221
    },
    {
        "content": "<p>This may require moving to <code>dist</code> temporarily</p>",
        "id": 417546943,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706052282
    },
    {
        "content": "<p>I moved to dist as suggested, and now the coercions are causing trouble as I feared. In particular, I have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">hcont3</span><span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"bp\">↑</span><span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And would like to rewrite with <code>mul_le_iff_le_one_left</code>, but I'm getting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">rewrite'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">did</span> <span class=\"n\">not</span> <span class=\"n\">find</span> <span class=\"kd\">instance</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">pattern</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">target</span> <span class=\"n\">expression</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.9819</span> <span class=\"bp\">≤</span> <span class=\"bp\">?</span><span class=\"n\">m.9820</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">m.9819</span>\n</code></pre></div>\n<p>I attempted to hack in the equality of the coercions with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but Lean is resolving the coercions and storing the resulting hypothesis as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">this</span><span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">i.snd</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So somehow it's recognizing these things as the same while also not recognizing them as the same. Any suggestions?</p>",
        "id": 418131895,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706204394
    },
    {
        "content": "<p>The up arrow is output only; you should (almost) never write it yourself. You need to use the <code>(D i.fst: targettype)</code> syntax</p>",
        "id": 418135898,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706205708
    },
    {
        "content": "<p>Ah alright, that fixed it.</p>\n<p>I've now moved on to the \"using density to pick a close point\" condition. I've managed to get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">D_prop</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>And I would like to apply it to <code>x.fst</code> and a certain <code>r</code>, where I know <code>r&gt;0</code>. The current issue I have is that <code>x.fst</code> is of type <code>γ</code> and not of type <code>↑U</code>. I have a hypothesis <code>x.fst \\in U</code>, but I'm not sure how to use this to get the types I want.</p>",
        "id": 418139940,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706207164
    },
    {
        "content": "<p>Might be easier if you shared some code (<a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>), but perhaps <code>have := D_prop \\&lt;x.fst, by assumption\\&gt;</code></p>",
        "id": 418146123,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706209497
    },
    {
        "content": "<p>That worked! And with that, I've actually finished the triangle inequality part.</p>\n<p>Now all that's left is the \"reindexing\" part, as I initially defined V and W over N x N, but I ultimately need it over N. This seems like it should be simple, but I'm not really sure how to do it. Here's a more organized <a href=\"/user_uploads/3121/bWwZM4Y-5XdMG4ewXPewTHvB/MWE.lean\">MWE.lean</a>, where the main part is lines 31-39. The main bit I need is access to a function k and its inverse, as I know how to do the rest. Any ideas how to get a usable invertible function from N x N to N (or the reverse)?</p>",
        "id": 418318897,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706289731
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.natSumNatEquivNat#doc\">docs#Equiv.natSumNatEquivNat</a> what you're looking for?</p>",
        "id": 418327190,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706292710
    },
    {
        "content": "<p>Wait, no, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.prodEquivOfEquivNat#doc\">docs#Equiv.prodEquivOfEquivNat</a></p>",
        "id": 418327345,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706292755
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.pairEquiv#doc\">docs#Nat.pairEquiv</a></p>",
        "id": 418327403,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706292781
    },
    {
        "content": "<p>Pair worked wonderfully, thank you!</p>\n<p>I'm now down to genuinely the last step, proving that the <code>Emetric.diam</code> of the <code>V' n</code> and <code>W' n</code> sets I've constructed is sufficiently small. I have managed to get that their <code>Metric.diam</code> is the right size, but I'm not sure how to get from this to the Emetric case. Here's another <a href=\"/user_uploads/3121/40e3ApVfeackuH4FHqPYESuG/MWE.lean\">MWE.lean</a> for context.</p>",
        "id": 418336562,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706296372
    },
    {
        "content": "<p>Never mind, with some more playing around I got it, which means the proof is done! It's an absolute abomination at 320 lines and will definitely need golfing, but it's good enough for now</p>",
        "id": 418348222,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706301544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"530359\">Connor Gordon</span> has marked this topic as resolved.</p>",
        "id": 418696335,
        "sender_full_name": "Notification Bot",
        "timestamp": 1706553055
    }
]