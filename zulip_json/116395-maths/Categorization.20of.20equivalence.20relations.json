[
    {
        "content": "<p>Suppose I have an equivalence relation <code>eqv : α → α → Prop</code>. Does there necessarily exist an equivalent <code>EquivLike</code>, that is a way of representing that <code>eqv</code> as two antiparallel arrows that are inverses of each other?</p>\n<p>(I believe this is equivalent to asking: is there always a way to turn a type <code>α</code> and an equivalence relation on <code>α</code> into a category, such that two objects of the category are isomorphic iff they are equivalent under <code>eqv</code>. But I'm not sure.)</p>",
        "id": 433006950,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712974077
    },
    {
        "content": "<p>In mathlib, any preorder is equipped with a category structure: there is a (unique) map from <code>x</code> to <code>y</code> iff <code>x</code> is less than or equal <code>y</code>.</p>",
        "id": 433007697,
        "sender_full_name": "Joël Riou",
        "timestamp": 1712974828
    },
    {
        "content": "<p>Sure, but that preorder structure works up to equality -- the antisymmetry property specifically asks you to prove that <code>x ≥ y</code> and <code>y ≥ x</code> implies <code>x = y</code>. I'm asking if anything breaks if I weaken that requirement to some specific definition of isomorphism.</p>",
        "id": 433008284,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712975464
    },
    {
        "content": "<p>I can see that if I have a reflexive, transitive relation that is antisymmetric up to isomorphism, then I can certainly make a poset out of that. And I can define my arrows according to <code>r</code>. But that assumes some specific <code>r</code>, and the same equality can be implied by the antisymmetry of multiple relations.</p>",
        "id": 433008449,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712975628
    },
    {
        "content": "<p>For example, given <code>α := β × β</code> and <code>eqv a b := (a.1 = b.1) ∨ (a.2 = b2)</code>, both <code>le on .fst</code> and <code>le on .snd</code> are antisymmetric up to <code>eqv</code>, but they certainly aren't the same relation.</p>",
        "id": 433008642,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712975785
    },
    {
        "content": "<p>Well, that being said, that just means that there might different 'completions', different ways of defining the <em>non</em>-iso morphisms of the category, that have the same property that its isomorphisms are some specified equivalence....</p>",
        "id": 433008697,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712975853
    },
    {
        "content": "<p>... I guess what I want is a categorical limit on such categorical representations, or something. A limit in <strong>Cat</strong>, presumably?</p>",
        "id": 433008809,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712975943
    },
    {
        "content": "<p>You can take the preorder to be the equivalence relation itself</p>",
        "id": 433017004,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1712985275
    },
    {
        "content": "<p>Wouldn't that be minimal? ... I guess that would be the limit, but I guess I probably meant colimit then.</p>",
        "id": 433017268,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712985622
    },
    {
        "content": "<p>I might not be getting the point, but i think your example is not an equivalence relation? It's not transitive.</p>",
        "id": 433023773,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1712992590
    },
    {
        "content": "<p>(assuming that beta is not a subsingleton)</p>",
        "id": 433023809,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1712992646
    },
    {
        "content": "<p>Oops, yeah, I'm too used to tacking on <code>EqvGen</code> onto everything.</p>",
        "id": 433023822,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712992671
    },
    {
        "content": "<p>hmmm, better example...</p>",
        "id": 433023899,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712992744
    },
    {
        "content": "<p>Mm, there's a lot of psuedo-examples where the two \"different\" <code>r</code>s are obviously dual in some way -- <code>≤</code> and <code>≥</code> for <code>=</code>, <code>∃ f, Injective f</code> and <code>∃ f, Surjective f</code> for <code>≃</code> -- but I'm not sure that really \"counts\"...</p>",
        "id": 433023997,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712992844
    },
    {
        "content": "<p>... Hm. Actually, this feels like a theorem that might exist. Something like, if two relations are antisymmetric up to the same equivalence, then they define isomorphic lattices?</p>",
        "id": 433024149,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712992991
    },
    {
        "content": "<p>hmmm<br>\nactually, I can probably bypass much of this by just operating on <code>Quot eqv</code> instead</p>",
        "id": 433025438,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712994373
    },
    {
        "content": "<p>and then the relevant relations are antisymm up to actual equality on the quotient type, so I can use the existing preorder/poset API</p>",
        "id": 433025464,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712994410
    },
    {
        "content": "<p>-- Okay, better counterexample that's basically the same as my old one but actually valid this time. <code>α := Vector β n</code> for some fixed <code>n</code>, <code>β</code> itself has a total order, and equivalence is defined by permutation. Then any relation of the form \"sort the list, then sort by each element in turn\" will be antisymmetric up to permutation, but there are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">!</mo></mrow><annotation encoding=\"application/x-tex\">n!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!</span></span></span></span> such relations depending on the \"priority\" of each index, and they generate completely different orders on <code>Vector β n</code>.</p>",
        "id": 433026929,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1712995904
    }
]