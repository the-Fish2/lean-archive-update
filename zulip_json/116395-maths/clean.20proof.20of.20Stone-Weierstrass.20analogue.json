[
    {
        "content": "<p>We have the Stone-Weierstrass theorem for compact spaces in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=polynomialFunctions.topologicalClosure#doc\">docs#polynomialFunctions.topologicalClosure</a> (the real case) and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=polynomialFunctions.starClosure_topologicalClosure#doc\">docs#polynomialFunctions.starClosure_topologicalClosure</a> (the <code>IsROrC</code> case). At this point, we don't have the version for locally compact spaces.</p>\n<p>I need a similar statement, which is that for <code>s : Set 𝕜</code> with <code>s</code> compact and containing <code>0 : 𝕜</code>, then the topological closure of the non-unital star subalgebra generated by the polynomial <code>X : 𝕜[X]</code> (viewed a continuous map in <code>C(s, 𝕜)</code>) is dense in the subtype <code>C(s, R)₀ := { f : C(s, R) // f 0 = 0 }</code> (technically it's <code>f ⟨0, (h : 0 ∈ s)⟩ = 0</code>, but let's not muddy the waters). You may assume that I have all the relevant structure on this subtype (it's a non-unital commutative star ring, an ideal, etc.), I'm just trying to keep things simple.</p>\n<p>What's the best way to prove this? As I see it, there are a few options:</p>\n<ol>\n<li>Prove the Stone-Weierstrass theorem for locally compact spaces, identify <code>C(s, 𝕜)₀</code> with <code>C₀(s \\ {0}, 𝕜)</code> and go from there.</li>\n<li>Consider the map <code>C(s, 𝕜) → C(s, 𝕜)₀</code>given by <code>f ↦ f - (f 0)</code>which just subtracts off a constant function. This map is continuous and linear. Show that any element of the star-closure of the polynomial functions maps into the non-unital star subalgebra generated by <code>X : 𝕜[X]</code>.  This is messy because we don't have a nice induction principle to apply (if it were just polynomials it wouldn't be so bad), and also because this map is only linear. Then use continuity and the existing Stone-Weierstrass theorem to conclude the result.</li>\n</ol>\n<p>Am I missing some easier way? If not, which of the above do you think is a better approach?</p>",
        "id": 426000186,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710187674
    },
    {
        "content": "<p>I don’t see why 2 would be messy after turning the closure result into filter stuff</p>",
        "id": 426002890,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710188814
    },
    {
        "content": "<p>The closure bit is the easy part. (I've just edited to swap the last two sentences of (2) so that it's clearer.)</p>",
        "id": 426002945,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710188836
    },
    {
        "content": "<p>I can’t believe that is the issue…</p>",
        "id": 426004677,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710189516
    },
    {
        "content": "<p>I know. It feels incredibly stupid, which is why I'm asking here. <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> If you can do it easily I would be grateful!</p>",
        "id": 426004977,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710189649
    },
    {
        "content": "<p>Let me try</p>",
        "id": 426006114,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710190163
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> , who was interested in all this.</p>",
        "id": 426202134,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1710273383
    },
    {
        "content": "<p>Anatole and I have been discussing this privately. I think I see a path to make it work without too much hassle.</p>",
        "id": 426202196,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710273414
    },
    {
        "content": "<p>Oh, I see.</p>",
        "id": 426202226,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1710273424
    },
    {
        "content": "<p>That shouldn't preclude anyone from thinking about it if they want to though.</p>",
        "id": 426202261,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710273443
    },
    {
        "content": "<p>I had been thinking about this a while ago and came up with your strategy but did no even try to write something, postponing for better times.</p>",
        "id": 426202302,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1710273463
    },
    {
        "content": "<p>But nice that you came up with a solution!</p>",
        "id": 426202423,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1710273507
    },
    {
        "content": "<p>Sorry maybe we should have had some of our discussion in this stream. Basically the topological part is very easy and then I spent half of my day struggling with algebra <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>You can have a look at what I did <a href=\"https://github.com/leanprover-community/mathlib4/blob/AD_non_unital_StoneWeierstrass/Mathlib/Topology/ContinuousFunction/NonUnitalStoneWeierstrass.lean\">here</a>. Unless I'm missing something obvious, my first lemma contains absolutely all the mathematical content for the general case. The hard part then is showing that the intersection between the kernel of evaluation at zero and the unital star-subalgebra generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> is exactly the non-unital star subalgebra generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span>. I think most of the troubles come from API holes and this approach could be reasonable in theory, but Jireh wants to explore another direction as well.</p>",
        "id": 426207703,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710275638
    },
    {
        "content": "<p>Also my fault for taking the discussion private. I think, unless I'm missing something, that we can use Anatole's first lemma, along with the following approach. We <code>let S := NonUnitalStarSubalgebra.adjoin 𝕜 {(ContinuousMap.id 𝕜).restrict s} : NonUnitalStarSubalgebra C(s, 𝕜)</code>. Then we'll take the <code>T := StarSubalgebra.adjoin 𝕜 S</code>, which, after not much work given the API we already have, should be provably equal to <code>span {1, S}</code>. Now, it is clear that <code>S</code> separates points (because <code>(ContinousMap.id 𝕜).restrict s</code> itself does), and therefore so does <code>T</code>, so Stone-Weierstrass applies to <code>T</code>, and then we apply Anatole's lemma taking <code>φ</code> to be the evaluation map (at zero).</p>",
        "id": 426208901,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710276125
    },
    {
        "content": "<p>I think that should work and avoid a lot of the troubles so it sounds great. I think some of the holes I uncovered deserve to be filled though so I'll try to make my approach look kind of good.</p>",
        "id": 426210360,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710276749
    },
    {
        "content": "<p>Question for any lurking algebraist : do you expect these lemmas to be useful ? How would you have stated them ? The two use case in mind are <code>S = {Polynomial.X}</code> in <code>Polynomial K</code> and <code>S = range MvPolynomial.X</code> in <code>MvPolynomial σ K</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bar_key</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">MvPolynomial</span> <span class=\"n\">s</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">aeval</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">Algebra.adjoin_eq_range</span><span class=\"o\">,</span> <span class=\"n\">AlgHom.mem_range</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ha</span>\n  <span class=\"n\">refine</span> <span class=\"n\">P.induction_on</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">Q</span> <span class=\"bp\">↦</span> <span class=\"n\">aeval</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">Q</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"n\">hQ</span> <span class=\"n\">hR</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">Q</span> <span class=\"n\">x</span> <span class=\"n\">hQ</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">aeval_C</span><span class=\"o\">,</span> <span class=\"n\">algebraMap_smul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">SMulMemClass.smul_mem</span> <span class=\"n\">x</span> <span class=\"n\">hb</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">map_add</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">add_mem</span> <span class=\"n\">hQ</span> <span class=\"n\">hR</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">aeval_X</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n      <span class=\"n\">using</span> <span class=\"n\">mul_mem</span> <span class=\"o\">(</span><span class=\"n\">NonUnitalAlgebra.subset_adjoin</span> <span class=\"n\">K</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"n\">hQ</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bar</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">subset_antisymm</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Submodule.span_induction</span> <span class=\"n\">ha</span> <span class=\"o\">(</span><span class=\"n\">NonUnitalAlgebra.subset_adjoin</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_mem</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">add_mem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hc</span> <span class=\"bp\">↦</span> <span class=\"n\">bar_key</span> <span class=\"o\">(</span><span class=\"n\">H.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">trivial</span><span class=\"o\">)</span> <span class=\"n\">hc</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">NonUnitalAlgebra.adjoin_induction</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">∈</span> <span class=\"n\">Ideal.span</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">ha</span>\n      <span class=\"n\">Ideal.subset_span</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">add_mem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">zero_mem</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Ideal.mul_mem_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">Q</span> <span class=\"n\">hQ</span> <span class=\"bp\">↦</span> <span class=\"n\">Submodule.smul_of_tower_mem</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"n\">hQ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 426211663,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710277268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/clean.20proof.20of.20Stone-Weierstrass.20analogue/near/426211663\">said</a>:</p>\n<blockquote>\n<p>Question for any lurking algebraist : do you expect these lemmas to be useful ? How would you have stated them ? The two use case in mind are <code>S = {Polynomial.X}</code> in <code>Polynomial K</code> and <code>S = range MvPolynomial.X</code> in <code>MvPolynomial σ K</code>.</p>\n</blockquote>\n<p>I don't understand what the second one means, but the first one seems to say that <code>NonUnitalAlgebra.adjoin K s</code> is a module over <code>Algebra.adjoin K s</code>.<br>\n(By the way, both result seems to generalize to <code>CommSemiring K</code> and <code>Semiring A</code>.)</p>",
        "id": 426219143,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1710280578
    },
    {
        "content": "<p>If you prove the analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.adjoin_eq_span#doc\">docs#Algebra.adjoin_eq_span</a> for NonUnitalAlgebra (with Submonoid replaced by Subsemigroup) and that <code>Submonoid.closure s = {1} ∪ Subsemigroup.closure S</code>, it should then easily follow that <code>Subalgebra.toSubmodule (Algebra.adjoin K s) = Submodule.span K ({1} ∪ NonUnitalAlgebra.adjoin K s)</code>, even for not necessarily commutative A. It seems we are missing <code>(Algebra.adjoin K s).toNonUnitalSubalgebra = NonUnitalAlgebra.adjoin K ({1} ∪ s)</code> too.</p>\n<p>In the proof of <code>bar_key</code>, using MvPolynomial doesn't allow noncommutative A. You might try to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.adjoin_eq_range_freeAlgebra_lift#doc\">docs#Algebra.adjoin_eq_range_freeAlgebra_lift</a>, but I think using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.adjoin_induction#doc\">docs#Algebra.adjoin_induction</a> is easier than both. Regarding <code>bar</code>, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_smul_of_span_eq_top#doc\">docs#Submodule.span_smul_of_span_eq_top</a> and the <code>adjoin_eq_span</code> theorems you can reduce it to the statement that <code>(Submonoid.closure s) • s = Subsemigroup.closure s</code>.</p>",
        "id": 426220003,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1710280950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/116395-maths/topic/clean.20proof.20of.20Stone-Weierstrass.20analogue/near/426219143\">said</a>:</p>\n<blockquote>\n<p>I don't understand what the second one means, but the first one seems to say that <code>NonUnitalAlgebra.adjoin K s</code> is a module over <code>Algebra.adjoin K s</code>.<br>\n(By the way, both result seems to generalize to <code>CommSemiring K</code> and <code>Semiring A</code>.)</p>\n</blockquote>\n<p>I just needed that the non-unital subalgebra generated by all variables in a polynomial ring is actually an ideal, the goal being to prove that this subalgebra is precisely the kernel of evaluation at zero. I originally did a version just for polynomials but ended up writing it more generally (I didn't claim it was full generality!)</p>",
        "id": 426221736,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710281803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/clean.20proof.20of.20Stone-Weierstrass.20analogue/near/426220003\">said</a>:</p>\n<blockquote>\n<p>If you prove the analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.adjoin_eq_span#doc\">docs#Algebra.adjoin_eq_span</a> for NonUnitalAlgebra (with Submonoid replaced by Subsemigroup) and that <code>Submonoid.closure s = {1} ∪ Subsemigroup.closure S</code>, it should then easily follow that <code>Subalgebra.toSubmodule (Algebra.adjoin K s) = Submodule.span K ({1} ∪ NonUnitalAlgebra.adjoin K s)</code>, even for not necessarily commutative A. It seems we are missing <code>(Algebra.adjoin K s).toNonUnitalSubalgebra = NonUnitalAlgebra.adjoin K ({1} ∪ s)</code> too.</p>\n</blockquote>\n<p>Aha, this sounds like the right way to do it indeed. Thanks!</p>",
        "id": 426221957,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710281925
    },
    {
        "content": "<blockquote>\n<p>In the proof of <code>bar_key</code>, using MvPolynomial doesn't allow noncommutative A. You might try to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.adjoin_eq_range_freeAlgebra_lift#doc\">docs#Algebra.adjoin_eq_range_freeAlgebra_lift</a>, but I think using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.adjoin_induction#doc\">docs#Algebra.adjoin_induction</a> is easier than both. </p>\n</blockquote>\n<p>I think I had trouble doing the induction like that, let me check why.</p>\n<blockquote>\n<p>Regarding <code>bar</code>, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_smul_of_span_eq_top#doc\">docs#Submodule.span_smul_of_span_eq_top</a> and the <code>adjoin_eq_span</code> theorems you can reduce it to the statement that <code>(Submonoid.closure s) • s = Subsemigroup.closure s</code>.</p>\n</blockquote>\n<p>Nice, thanks!</p>",
        "id": 426222141,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710282028
    },
    {
        "content": "<p>The problem with <code>adjoin_induction</code> is I end up with this subgoal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>Which doesn't seem provable. I haven't thought more about the deep reasons for this, I also expected the two inductions to be equivalent.</p>",
        "id": 426225637,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710283987
    },
    {
        "content": "<p>I think you must have miscopied that sub goal because it's just <code>simpa [add_mul] using add_mem</code></p>",
        "id": 426240957,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710293274
    },
    {
        "content": "<p>Fixed, thanks!</p>",
        "id": 426280404,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710317663
    },
    {
        "content": "<p>I guess the more natural way to do it is non-unital <code>adjoin_eq_span</code> + <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_induction#doc\">docs#Submodule.span_induction</a> + <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subsemigroup.closure_induction#doc\">docs#Subsemigroup.closure_induction</a></p>",
        "id": 426288509,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710320679
    },
    {
        "content": "<p>I have the <code>adjoin_eq_span</code> and <code>Submonoid.closure s = {1} ∪ Subsemigroup.closure s</code> results locally now, so don't duplicate effort.</p>",
        "id": 426338232,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710336026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/clean.20proof.20of.20Stone-Weierstrass.20analogue/near/426000186\">said</a>:</p>\n<blockquote>\n<p>We have the Stone-Weierstrass theorem for compact spaces in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=polynomialFunctions.topologicalClosure#doc\">docs#polynomialFunctions.topologicalClosure</a> (the real case) and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=polynomialFunctions.starClosure_topologicalClosure#doc\">docs#polynomialFunctions.starClosure_topologicalClosure</a> (the <code>IsROrC</code> case). At this point, we don't have the version for locally compact spaces.</p>\n<p>I need a similar statement, which is that for <code>s : Set 𝕜</code> with <code>s</code> compact and containing <code>0 : 𝕜</code>, then the topological closure of the non-unital star subalgebra generated by the polynomial <code>X : 𝕜[X]</code> (viewed a continuous map in <code>C(s, 𝕜)</code>) is dense in the subtype <code>C(s, R)₀ := { f : C(s, R) // f 0 = 0 }</code> (technically it's <code>f ⟨0, (h : 0 ∈ s)⟩ = 0</code>, but let's not muddy the waters). You may assume that I have all the relevant structure on this subtype (it's a non-unital commutative star ring, an ideal, etc.), I'm just trying to keep things simple.</p>\n<p>What's the best way to prove this? As I see it, there are a few options:</p>\n<ol>\n<li>Prove the Stone-Weierstrass theorem for locally compact spaces, identify <code>C(s, 𝕜)₀</code> with <code>C₀(s \\ {0}, 𝕜)</code> and go from there.</li>\n<li>Consider the map <code>C(s, 𝕜) → C(s, 𝕜)₀</code>given by <code>f ↦ f - (f 0)</code>which just subtracts off a constant function. This map is continuous and linear. Show that any element of the star-closure of the polynomial functions maps into the non-unital star subalgebra generated by <code>X : 𝕜[X]</code>.  This is messy because we don't have a nice induction principle to apply (if it were just polynomials it wouldn't be so bad), and also because this map is only linear. Then use continuity and the existing Stone-Weierstrass theorem to conclude the result.</li>\n</ol>\n<p>Am I missing some easier way? If not, which of the above do you think is a better approach?</p>\n</blockquote>\n<p>I think 1. is more natural, as it goes along the more general unitization of a non-unital algebra.</p>",
        "id": 426360727,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1710342215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"382902\">@Yoh Tanimoto</span> see <a href=\"#narrow/stream/116395-maths/topic/clean.20proof.20of.20Stone-Weierstrass.20analogue/near/426208901\">this message</a> where I lay out the current plan.</p>",
        "id": 426360996,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710342278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> I don't have time to PR this right now, but you (or anyone else) is welcome to.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">NonUnitalAlgebra</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">IsScalarTower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SMulCommClass</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- This is the version we should actually have as `NonUnitalAlgebra.adjoin_induction'`, but</span>\n<span class=\"c1\">-- currently that is used for the subtype.</span>\n<span class=\"sd\">/-- A dependent version of `NonUnitalAlgebra.adjoin_induction`. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">adjoin_induction''</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">Hs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">subset_adjoin</span> <span class=\"n\">R</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">Hadd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">add_mem</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›))</span>\n    <span class=\"o\">(</span><span class=\"n\">H0</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">zero_mem</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">Hmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_mem</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›))</span>\n    <span class=\"o\">(</span><span class=\"n\">Hsmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">SMulMemClass.smul_mem</span> <span class=\"n\">_</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›))</span>\n    <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"o\">:=</span>\n  <span class=\"n\">adjoin_induction'</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"n\">Hs</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">Hadd</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span> <span class=\"n\">y.1</span> <span class=\"n\">y.2</span><span class=\"o\">)</span>\n    <span class=\"n\">H0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">Hmul</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span> <span class=\"n\">y.1</span> <span class=\"n\">y.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">Hsmul</span> <span class=\"n\">r</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adjoin_eq_span</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSubmodule</span> <span class=\"bp\">=</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Subsemigroup.closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hx</span> <span class=\"n\">using</span> <span class=\"n\">adjoin_induction''</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Hs</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">subset_span</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Subsemigroup.subset_closure</span> <span class=\"n\">hx</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Hadd</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"n\">hpx</span> <span class=\"n\">hpy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">add_mem</span> <span class=\"n\">hpx</span> <span class=\"n\">hpy</span>\n    <span class=\"bp\">|</span> <span class=\"n\">H0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">zero_mem</span> <span class=\"n\">_</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Hmul</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"n\">hpx</span> <span class=\"n\">hpy</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">span_induction₂</span> <span class=\"n\">hpx</span> <span class=\"n\">hpy</span> <span class=\"bp\">?</span><span class=\"n\">Hs</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">Hadd_l</span> <span class=\"bp\">?</span><span class=\"n\">Hadd_r</span> <span class=\"bp\">?</span><span class=\"n\">Hsmul_l</span> <span class=\"bp\">?</span><span class=\"n\">Hsmul_r</span>\n      <span class=\"n\">case</span> <span class=\"n\">Hs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"bp\">↦</span> <span class=\"n\">subset_span</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mul_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n      <span class=\"n\">case</span> <span class=\"n\">Hadd_l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hxz</span> <span class=\"n\">hyz</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">add_mem</span> <span class=\"n\">hxz</span> <span class=\"n\">hyz</span>\n      <span class=\"n\">case</span> <span class=\"n\">Hadd_r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hxz</span> <span class=\"n\">hyz</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">add_mem</span> <span class=\"n\">hxz</span> <span class=\"n\">hyz</span>\n      <span class=\"n\">case</span> <span class=\"n\">Hsmul_l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hxy</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">smul_mul_assoc</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">smul_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hxy</span>\n      <span class=\"n\">case</span> <span class=\"n\">Hsmul_r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hxy</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">mul_smul_comm</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">smul_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hxy</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Hsmul</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">hpx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">smul_mem</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hpx</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">span_le.2</span> <span class=\"n\">_</span>\n    <span class=\"k\">show</span> <span class=\"n\">Subsemigroup.closure</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNonUnitalSubsemiring.toSubsemigroup</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Subsemigroup.closure_le.2</span> <span class=\"o\">(</span><span class=\"n\">subset_adjoin</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">NonUnitalAlgebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">NonUnitalStarAlgebra</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NonUnitalSemiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">IsScalarTower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SMulCommClass</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StarRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StarRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">StarModule</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Pointwise</span>\n<span class=\"kn\">open</span> <span class=\"n\">Submodule</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adjoin_eq_span</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toSubmodule</span> <span class=\"bp\">=</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Subsemigroup.closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">star</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">adjoin_toNonUnitalSubalgebra</span><span class=\"o\">,</span> <span class=\"n\">NonUnitalAlgebra.adjoin_eq_span</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">NonUnitalStarAlgebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Submonoid</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The `Submonoid.closure` of a set is `1` union the its `Subsemigroup.closure`. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">closure_eq_one_union</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)}</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">Subsemigroup.closure</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"n\">induction</span> <span class=\"n\">hx</span> <span class=\"n\">using</span> <span class=\"n\">closure_induction'</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Hs</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Subsemigroup.subset_closure</span> <span class=\"n\">hx</span>\n    <span class=\"bp\">|</span> <span class=\"n\">H1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Hmul</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.singleton_union</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">SetLike.mem_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hy</span><span class=\"o\">)⟩</span> <span class=\"o\">:=</span> <span class=\"n\">And.intro</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n      <span class=\"n\">all_goals</span> <span class=\"n\">simp_all</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Or.inr</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mul_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"bp\">▸</span> <span class=\"n\">one_mem</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">induction</span> <span class=\"n\">hx</span> <span class=\"n\">using</span> <span class=\"n\">Subsemigroup.closure_induction'</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Hs</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">subset_closure</span> <span class=\"n\">hx</span>\n      <span class=\"bp\">|</span> <span class=\"n\">Hmul</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">mul_mem</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Submonoid</span>\n</code></pre></div>",
        "id": 426364576,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1710343188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/clean.20proof.20of.20Stone-Weierstrass.20analogue/near/426225637\">said</a>:</p>\n<blockquote>\n<p>The problem with <code>adjoin_induction</code> is I end up with this subgoal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span>\n</code></pre></div>\n<p>Which doesn't seem provable. I haven't thought more about the deep reasons for this, I also expected the two inductions to be equivalent.</p>\n</blockquote>\n<p>We just need to generalize the variable <code>b</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MvPolynomial</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bar_key</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">Algebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">NonUnitalAlgebra.adjoin</span> <span class=\"n\">K</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">b</span><span class=\"bp\">;</span> <span class=\"n\">change</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"c1\">-- makes b explicit, otherwise `refine` introduces it automatically and anonymously</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Algebra.adjoin_induction</span> <span class=\"n\">ha</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">hb</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mul_mem</span> <span class=\"o\">(</span><span class=\"n\">NonUnitalAlgebra.subset_adjoin</span> <span class=\"n\">_</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"n\">hx</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">k</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Algebra.smul_def</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">NonUnitalSubalgebra.smul_mem'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hx</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">add_mem</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hb</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 426369188,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1710344367
    }
]