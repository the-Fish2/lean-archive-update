[
    {
        "content": "<p>Is there a name for one the following properties?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Inseparable</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myProp</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">⤳</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myProp'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Inseparable</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>E.g., compacts in <code>R1Space</code>s and all closed sets in any topology satisfy these properties.<br>\nAlso, if <code>s</code> is a set in a complete space and it has this property (they're equivalent in R0 spaces), then it is complete.<br>\nThis can be used to show that some functional spaces like <code>ContinuousMap</code>, <code>ContinuousLinearMap</code>, <code>ContinuousMultilinearMap</code> are complete without separability of the codomain.</p>\n<p>More precisely, if the interiors of <code>s ∈ 𝔖</code> cover the whole space, then the set of continuous functions in <code>X →ᵤ[𝔖] Y</code> has <code>myProp</code>. This together with <a href=\"https://github.com/leanprover-community/mathlib4/pull/10844\">#10844</a> implies <code>CompleteSpace</code> for all the spaces above (assuming <code>[WeaklyLocallyCompact X]</code> for <code>ContinuousMap</code> and seminormable topology on the codomain for the rest).</p>",
        "id": 422961381,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708672607
    },
    {
        "content": "<p>It somehow feels almost opposite to being a sober space: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∃</mi><mi>y</mi><mo>∈</mo><mi>S</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>∈</mo><mover accent=\"true\"><mi>S</mi><mo>ˉ</mo></mover><mo separator=\"true\">,</mo><mi>y</mi><mo>⇝</mo><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">\\exists y \\in S, \\forall x \\in \\bar S, y \\leadsto x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0145em;vertical-align:-0.1944em;\"></span><span class=\"mord accent\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8201em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span><span style=\"top:-3.2523em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.1667em;\"><span class=\"mord\">ˉ</span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⇝</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> (holds for irreducible <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>).</p>",
        "id": 422963011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708673415
    },
    {
        "content": "<p>It's possible that I got the direction of the arrow wrong (it's past 1am here) but I definitely need <code>∀ x in closure s, ∃ y ∈ s, _</code></p>",
        "id": 422963490,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708673556
    },
    {
        "content": "<p>I can say <code>IsClosed (SeparationQuotient.mk '' s)</code></p>",
        "id": 422963520,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708673582
    },
    {
        "content": "<p>But this adds an unnecessary type to the soup (though we'll need it for <code>*linearMap</code>s anyway to preserve <code>*linear</code> part).</p>",
        "id": 422963644,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708673651
    },
    {
        "content": "<p>I may need different arrows for \"closure is a subset of any open that contains <code>s</code>\" and \"<code>s</code> is complete\", too sleepy to be sure.</p>",
        "id": 422964773,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708674417
    },
    {
        "content": "<p>Yury, I'm not answering your original question, but about completeness of <code>X →ᵤ[𝔖] Y</code> you may want to have a look at <a href=\"https://github.com/leanprover-community/mathlib/pull/18017\">mathlib#18017</a>, which proves it the Bourbaki way. The main thing blocking me from making it into a proper PR is that it's waiting on a proper theory of ideals of sets, the main point being that <code>X →ᵤ[𝔖] Y</code> doesn't change when you replace <code>𝔖</code> by the generated ideal (I used to say bornology but it doesn't match our definition of bornology so I'm sticking to ideal). This allows to avoid assuming directedness of <code>𝔖</code> is basically all of the statements (as you noticed, these are essentially never really needed).<br>\nNext, the gadget introduced by Bourbaki is <a href=\"https://github.com/leanprover-community/mathlib/blob/090c3f0a331c60d629319a10a0e6938a6b8d4c64/src/topology/uniform_space/cauchy.lean#L164\">UniformSpace.LEWithClosedBasis</a>, which allows deducing completeness from the completeness in product types. I quite like this approach from a moral point of view because it really separates the multiple parts of the proof (everything relies on <a href=\"https://github.com/leanprover-community/mathlib/blob/090c3f0a331c60d629319a10a0e6938a6b8d4c64/src/topology/uniform_space/cauchy.lean#L182\">this lemma</a>) but I understand it may be easier to give an ad hoc proof. What do you think?</p>",
        "id": 423017099,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708695285
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/422961381\">said</a>:</p>\n<blockquote>\n<p>This together with <a href=\"https://github.com/leanprover-community/mathlib4/pull/10844\">#10844</a> implies <code>CompleteSpace</code> for all the spaces above (assuming <code>[WeaklyLocallyCompact X]</code> for <code>ContinuousMap</code> and seminormable topology on the codomain for the rest).</p>\n</blockquote>\n<p>I don't understand why these extra assumptions are needed?</p>",
        "id": 423018161,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708695686
    },
    {
        "content": "<p>I think that we can give an ad hoc proof now, replace with a more integrated proof later.</p>",
        "id": 423044803,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708704022
    },
    {
        "content": "<p>Sure.</p>",
        "id": 423045516,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708704229
    },
    {
        "content": "<p>Note that my <code>uniformity_eq</code> lemmas can help with getting rid of <code>DirectedOn</code> assumptions too: instead of using <code>HasBasis</code>, you use <code>eq_biInf</code>.</p>",
        "id": 423045760,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708704299
    },
    {
        "content": "<p>About extra assumptions. To prove that <code>C(X, Y)</code> is complete you need to show that continuous functions are \"closed mod inseparable\" in <code>X →ᵤ[{K | IsCompact K}] Y</code>\". If you have a limit point of the set of continuous function, then it's continuous on all compacts (because of the uniform convergence). I can't glue it into <code>Continuous</code> without weak local compactness.</p>",
        "id": 423046283,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708704439
    },
    {
        "content": "<p>Ah yes, I completely missed the point. Note that Bourbaki assumes \"locally compact or metrizable\", which suggests that we should be using compactly generated spaces, but that can wait.</p>",
        "id": 423047645,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708704831
    },
    {
        "content": "<p>What are compactly generated spaces? How do you proceed if the domain is metrizable, not locally compact?</p>",
        "id": 423047866,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708704894
    },
    {
        "content": "<p>The key property is that testing convergence reduces to testing it on compact subspaces (there are subtleties in the non Hausdorff case, maybe you want to test on maps from compact Hausdorff spaces, but let's put that aside for now). This is obviously true for locally compact spaces, and for metrizable spaces you just have to see that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>u</mi><mi>n</mi></msub><mo>→</mo><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">u_n \\to l</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msub><mi>u</mi><mi>n</mi></msub><mi mathvariant=\"normal\">∣</mi><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">}</mo><mo>∪</mo><mo stretchy=\"false\">{</mo><mi>l</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{u_n | n\\in\\mathbb{N}\\} \\cup \\{l\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mclose\">}</span></span></span></span> is compact.</p>",
        "id": 423048940,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708705186
    },
    {
        "content": "<p>So, instead of \"metrizable\" you can say <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SequentialSpace#doc\">docs#SequentialSpace</a> ?</p>",
        "id": 423049303,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708705294
    },
    {
        "content": "<p>Yes sure</p>",
        "id": 423049341,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708705305
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 423049360,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708705313
    },
    {
        "content": "<p>About <code>LEWithClosedBalls</code> etc, in the file about Polish spaces <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> proves the following lemma (I extracted it from a longer proof):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">CompleteSpace.iInf</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">ht₀</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i₀</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">T0Space</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span> <span class=\"bp\">∧</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">CompleteSpace.mk</span> <span class=\"n\">X</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"n\">hf</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ht₀</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">i₀</span><span class=\"o\">,</span> <span class=\"n\">hsep₀</span><span class=\"o\">,</span> <span class=\"n\">hi₀</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">uniformSpace</span> <span class=\"o\">:=</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">hf.mono_uniformSpace</span> <span class=\"o\">(</span><span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">choose</span> <span class=\"n\">x</span> <span class=\"n\">hfx</span> <span class=\"n\">using</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"bp\">@</span><span class=\"n\">CompleteSpace.complete</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">i₀</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">u</span> <span class=\"n\">i₀</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hf.1</span>\n    <span class=\"n\">exact</span> <span class=\"n\">tendsto_nhds_unique</span> <span class=\"o\">((</span><span class=\"n\">hfx</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">nhds_mono</span> <span class=\"o\">(</span><span class=\"n\">hi₀</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hfx</span> <span class=\"n\">i₀</span><span class=\"o\">)</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span> <span class=\"n\">i₀</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace.toTopologicalSpace_iInf</span><span class=\"o\">,</span> <span class=\"n\">nhds_iInf</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_iInf</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hfx</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>Does it follow from some general theory?</p>",
        "id": 423050411,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708705606
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Compactly_generated_space\">The wikipedia page</a> actually does a good job at comparing possible definitions. The reason I wanted to be sure to pick \"the right one\" is that a lot of the theory about compact open topology can be done in this setup, but everyone treats only the T2 case so I want to see the proof to see which of the definition works in the non-T2 case.</p>",
        "id": 423050734,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708705696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/423050411\">said</a>:</p>\n<blockquote>\n<p>About <code>LEWithClosedBalls</code> etc, in the file about Polish spaces <span class=\"user-mention silent\" data-user-id=\"110050\">Sébastien Gouëzel</span> proves the following lemma (I extracted it from a longer proof):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">CompleteSpace.iInf</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">ht₀</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">i₀</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">T0Space</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span> <span class=\"bp\">∧</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toTopologicalSpace</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">CompleteSpace.mk</span> <span class=\"n\">X</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"n\">hf</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">ht₀</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">i₀</span><span class=\"o\">,</span> <span class=\"n\">hsep₀</span><span class=\"o\">,</span> <span class=\"n\">hi₀</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">uniformSpace</span> <span class=\"o\">:=</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">hf.mono_uniformSpace</span> <span class=\"o\">(</span><span class=\"n\">iInf_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">choose</span> <span class=\"n\">x</span> <span class=\"n\">hfx</span> <span class=\"n\">using</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"bp\">@</span><span class=\"n\">CompleteSpace.complete</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">i₀</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">u</span> <span class=\"n\">i₀</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hf.1</span>\n    <span class=\"n\">exact</span> <span class=\"n\">tendsto_nhds_unique</span> <span class=\"o\">((</span><span class=\"n\">hfx</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">nhds_mono</span> <span class=\"o\">(</span><span class=\"n\">hi₀</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hfx</span> <span class=\"n\">i₀</span><span class=\"o\">)</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span> <span class=\"n\">i₀</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace.toTopologicalSpace_iInf</span><span class=\"o\">,</span> <span class=\"n\">nhds_iInf</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_iInf</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hfx</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>Does it follow from some general theory?</p>\n</blockquote>\n<p>I don't <em>think</em> this is related to <code>LEWithClosedBasis</code>, but I want to think about it.</p>",
        "id": 423056039,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708707272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/423047866\">said</a>:</p>\n<blockquote>\n<p>What are compactly generated spaces? How do you proceed if the domain is metrizable, not locally compact?</p>\n</blockquote>\n<p>Compactly generated spaces are topological spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> such that a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mspace></mspace><mspace width=\"0.1111em\"/><mo lspace=\"0em\" rspace=\"0.17em\"></mo><mtext> ⁣</mtext><mo lspace=\"0em\" rspace=\"0em\">:</mo><mspace width=\"0.3333em\"/><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f\\colon X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace nobreak\"></span><span class=\"mspace\" style=\"margin-right:0.1111em;\"></span><span class=\"mpunct\"></span><span class=\"mspace\" style=\"margin-right:-0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mrel\">:</span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is continuous if and only if all its restrictions to compact subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> are continuous. (There are subtleties whether compact should mean Hausdorff here.)</p>",
        "id": 423078882,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1708715772
    },
    {
        "content": "<p>(And about wether you should take actual subspaces or maps from arbitrary compact spaces)</p>",
        "id": 423080202,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708716324
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10902\">#10902</a> for now</p>",
        "id": 423108768,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708729753
    },
    {
        "content": "<p>Should we have a name for <code>t ≤ ⨆ s ∈ 𝔖, .coinduced (Subtype.val : s → α) (.induced Subtype.val t)</code>?</p>",
        "id": 423108809,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708729798
    },
    {
        "content": "<p>With some obvious lemmas like <code>mono</code> (enlarge the set), <code>of_nhds</code> (assuming that each point has a nhd in <code>𝔖</code>), and <code>of_seq</code> (for sequential spaces).</p>",
        "id": 423108884,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708729831
    },
    {
        "content": "<p>Hmmm, so that compactly generated is just this for <code>𝔖</code> = compact subsets / T2 compact subsets ? There's still one of the three possible definition which isn't covered by this, but that sounds interesting. And I guess your hope is to generalize the proof of completeness for such a <code>𝔖</code>? I'll think about it.</p>",
        "id": 423112012,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708732009
    },
    {
        "content": "<p>We have completeness of <code>UniformOnFun</code> for any <code>𝔖</code>. If <code>t ≤ ⨆ (s) (hs : IsCompact s), .coinduced (Subtype.val : s → α) (.induced Subtype.val t)</code>, then we can get completeness of <code>ContinuousMap</code>.</p>",
        "id": 423112686,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708732533
    },
    {
        "content": "<p>Yes, that's what I meant.</p>",
        "id": 423112713,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708732562
    },
    {
        "content": "<p>Is it true with some weaker assumption?</p>",
        "id": 423112756,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708732582
    },
    {
        "content": "<p>I believe this would work for any <code>𝔖</code> satisfying the condition you wrote above (as in, if you equip <code>ContinuousMap</code> with the corresponding topology) ? Because then it's easy to see that testing continuity is the same as testing continuity in any <code>s ∈ 𝔖</code>, and continuity is a closed condition in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformFun#doc\">docs#UniformFun</a>.</p>",
        "id": 423113037,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708732813
    },
    {
        "content": "<p>This should rather be stated as a condition for the map from <code>ContinuousMap</code> to <code>UniformOnFun</code> having closed range, and we leave the completeness part to when it's also a uniform inducing (to avoid dealing with nonstandard topologies).</p>",
        "id": 423113258,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708732959
    },
    {
        "content": "<p>If we equip <code>ContinuousMap</code> with the compact-open topology, is there a better assumption than <code>t ≤ ⨆ (s) (hs : IsCompact s), .coinduced (Subtype.val : s → α) (.induced Subtype.val t)</code>?</p>",
        "id": 423113281,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708732986
    },
    {
        "content": "<p>No, I don't think so</p>",
        "id": 423113295,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708733001
    },
    {
        "content": "<p>I want to prove completeness of <code>ContinuousLinearMap</code>s and <code>ContinuousMultilinearMap</code>s in the same way, reusing <a href=\"https://github.com/leanprover-community/mathlib4/pull/10902\">#10902</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/10844\">#10844</a></p>",
        "id": 423113319,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708733024
    },
    {
        "content": "<p>Note that this is exactly compact generation (modulo the Hausdorff details)</p>",
        "id": 423113387,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708733058
    },
    {
        "content": "<p>Yes, I see. I don't know if assuming this for Hausdorff compact subsets is enough.</p>",
        "id": 423113422,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708733091
    },
    {
        "content": "<p>Proving completeness of <code>E  →L[K] F</code> without <code>[T2Space F]</code> will require a map <code>outCLM : SeparationQuotient F →L[K] F</code> and this will depend on <a href=\"https://github.com/leanprover-community/mathlib4/pull/10644\">#10644</a> to avoid choosing between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SeparationQuotient#doc\">docs#SeparationQuotient</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformSpace.SeparationQuotient#doc\">docs#UniformSpace.SeparationQuotient</a>.</p>",
        "id": 423113573,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708733210
    },
    {
        "content": "<p>BTW, for <code>E →L[K] F</code>, what's the right assumption on <code>E</code>? <code>SequentialSpace</code>? Something else?</p>",
        "id": 423113660,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708733272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/423113422\">said</a>:</p>\n<blockquote>\n<p>Yes, I see. I don't know if assuming this for Hausdorff compact subsets is enough.</p>\n</blockquote>\n<p>I think it's stronger to assume it for all Hausdorff compact subsets actually ? That's what Wikipedia says but I'm too tired to check why. So your lemma in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10902\">#10902</a> is surely as general as it could be. My worry was rather what to choose as a definition of <code>CompactGenerated</code>, since we would like to pick a definition that is powerfull enough to do the whole theory of the compact-open topology.</p>",
        "id": 423114049,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708733608
    },
    {
        "content": "<p>What other properties depend on this definition?</p>",
        "id": 423114131,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708733664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/423113660\">said</a>:</p>\n<blockquote>\n<p>BTW, for <code>E →L[K] F</code>, what's the right assumption on <code>E</code>? <code>SequentialSpace</code>? Something else?</p>\n</blockquote>\n<p>I don't remember and I really need to sleep, but there are a <em>lot</em> of results about this in the section of Bourbaki, Topological Vector Spaces where they define the topology on <code>E  →L[K] F</code>.</p>",
        "id": 423114191,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708733715
    },
    {
        "content": "<p>I don't have Bourbaki. Good night!</p>",
        "id": 423114209,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708733747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/423114131\">said</a>:</p>\n<blockquote>\n<p>What other properties depend on this definition?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Homeomorph.curry#doc\">docs#Homeomorph.curry</a> should work for compactly generated spaces IIUC</p>",
        "id": 423114286,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708733800
    },
    {
        "content": "<p>I can't prove <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap.continuous_eval#doc\">docs#ContinuousMap.continuous_eval</a> with these assumptions without assuming something about the codomain.</p>",
        "id": 423119507,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708738176
    }
]