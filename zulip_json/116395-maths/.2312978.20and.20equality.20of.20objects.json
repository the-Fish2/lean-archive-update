[
    {
        "content": "<p>This PR introduces a concept which I remember reading about in Deligne-Mumford years ago: given a functor <code>p : 𝒳 ⥤ 𝒮</code>, a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> upstairs and a morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> downstairs, it introduces the predicate saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">p(\\phi)=f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. This is an equality of morphisms, which seems fine, but underlying it (and indeed the reason the PR is made) is the idea that for this to make sense, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> must send the source of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> to the source of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and the target of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">ϕ</span></span></span></span> to the target of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, which is equality of objects in a category, which is \"evil\". </p>\n<p>My first instinct was that the \"correct\" way to do this should surely be to introduce isomorphisms between <code>p (dom φ)</code> and <code>dom f</code> and the same for the codomains, and to carry all these things around, but in practice (at least in the examples I know) <code>𝒳 </code> is a category whose objects are e.g. pairs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>E</mi><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(E,S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> an elliptic curve over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> (or whatever) and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> is just the functor which forgets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> and it's really convenient to talk about equality of objects here. I wanted to break this intuition by saying \"OK so the idea is that we should be allowed to replace <code>𝒮</code> by an equivalent category <code>𝒮'</code> and now everything will break\" but it doesn't break, at least naively, because a functor applied to equal objects gives equal objects. I'm beginning to conclude that somehow this concept is not evil, but basically I'm just confused. <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> can you enlighten me? There's more to come from <span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> regarding this stuff, and if I'm supposed to be reviewing it I'd better understand properly what's going on. <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> you might also understand this lifting property properly as well. What am I missing? Why is this PR not pure evil? Assuming it isn't, I'm happy to merge it!</p>",
        "id": 442468153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717488589
    },
    {
        "content": "<p>For the record I'm not opposed to rewriting this stuff to work with \"lifts up to isomorphism\" instead. I think at first we just found it less complicated to do it this way, and since I also only know examples of stacks/fibered categories of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mtext>Object over defined over S</mtext><mo separator=\"true\">,</mo><mi>S</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\text{Object over defined over S}, S)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord text\"><span class=\"mord\">Object over defined over S</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span></span></span></span> with the map to <code>𝒮</code> being by just forgetting the object I wasn't sure how much benefit would be gained by generalizing it in this way.</p>",
        "id": 442470372,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717489264
    },
    {
        "content": "<p>At least in the previous definition we had, it would be very easy to just replace the equalities with isomorphisms. I just wasn't sure if it was worth the hassle.</p>",
        "id": 442470605,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717489341
    },
    {
        "content": "<p>Something that could be an issue is that fibered categories, when defined using <code>IsHomLift</code> in this way, would not be stable under equivalence of categories (and some might consider this \"pure evil\").</p>",
        "id": 442471517,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717489627
    },
    {
        "content": "<p>But if you instead use the notion of equivalence of based categories, then (I think) that the notion will be stable under equivalence.</p>",
        "id": 442472619,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717489958
    },
    {
        "content": "<p>I'm not suggesting you rewrite the stuff at all, I'm basically just expressing surprise that Deligne and Mumford do something which looks on the face of it evil and I'm trying to understand better what's going on.</p>",
        "id": 442483871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717493345
    },
    {
        "content": "<p>It is a matter of compromise: I certainly do not consider the original definition of fibered categories by Grothendieck as evil (but some may disagree). In most mathematically relevant applications of fibered categories, the equalities of objects that are introduced here shall be definitional equalities (because an object \"upstairs\" shall be a dependent tuple like <code>(S, E)</code>, e.g. <code>S</code> a scheme and <code>E</code> an elliptic curve over <code>S</code>), and the new definition of <code>IsHomLift</code> will allow doing substitutions (which makes <code>eqToHom</code> disappear).</p>\n<p>(For fibered categories <code>p : 𝒳 ⥤ 𝒮</code>, one may replace <code>𝒮</code> by an equivalent category: more precisely, and more generally, if <code>𝒮 '⥤ 𝒮</code>is a functor, there is a \"fibre product\" <code>p' : 𝒳 '⥤ 𝒮'</code> that has the same fibres as <code>p</code>.)</p>",
        "id": 442495010,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717496588
    },
    {
        "content": "<p>Is there some kind of analogue/generalization of \"concrete category\" here? The idea is that objects of <code>𝒳</code> really should be thought of as \"objects of <code>𝒮</code> together with more stuff\" and that the theory should only be applied in situations where <code>p</code> is a \"forgetful functor\"?</p>",
        "id": 442497254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717497279
    },
    {
        "content": "<p>If we have a kind of \"pseudo-functor\" <code>F</code> which assigns a category to any object <code>S : 𝒮</code>with suitable extra data, we may define a (fibered) category <code>𝒳</code> over <code>𝒮</code> whose objects consists of tuples <code>(S, X)</code> with <code>S : 𝒮</code> and <code>X : F S</code>. All fibered categories should be equivalent in a suitable sense to fibered categories constructed in this way.</p>",
        "id": 442503652,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717499467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/.2312978.20and.20equality.20of.20objects/near/442503652\">said</a>:</p>\n<blockquote>\n<p>If we have a kind of \"pseudo-functor\" <code>F</code> which assigns a category to any object <code>S : 𝒮</code>with suitable extra data, we may define a (fibered) category <code>𝒳</code> over <code>𝒮</code> whose objects consists of tuples <code>(S, X)</code> with <code>S : 𝒮</code> and <code>X : F S</code>. All fibered categories should be equivalent in a suitable sense to fibered categories constructed in this way.</p>\n</blockquote>\n<p>We actually have this construction <a href=\"https://github.com/Paul-Lez/Stacks-project/blob/master/LS/FiberedCategories/Pseudofunctor.lean\">here</a>. Although not the converse, that every fibered category is equivalent to such a fibered category</p>",
        "id": 442504377,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717499689
    },
    {
        "content": "<p>This kind of stuff is discussed in the article by Ahrens and Lumsdaine introducing \"displayed categories\": <a href=\"https://arxiv.org/abs/1705.04296\">https://arxiv.org/abs/1705.04296</a></p>",
        "id": 442520058,
        "sender_full_name": "David Wärn",
        "timestamp": 1717504723
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/aNE-2FmIOhskveVLMKZEX1bU/ahrens.png\">ahrens.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/aNE-2FmIOhskveVLMKZEX1bU/ahrens.png\" title=\"ahrens.png\"><img src=\"/user_uploads/3121/aNE-2FmIOhskveVLMKZEX1bU/ahrens.png\"></a></div><p>Thanks David! The quote is from p1 of the paper. So are we doing it wrong?</p>",
        "id": 442532575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717508451
    },
    {
        "content": "<p>(a displayed category is just a family of categories indexed by objects of a category + ...,)</p>",
        "id": 442532753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717508513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398922581\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398875432\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398793015\">said</a>:</p>\n<blockquote>\n<p>Are you planning to use Grothendieck fibrations? I think they will not keep some of their advantages when formalized because they involve equalities of objects</p>\n</blockquote>\n<p>Calle and I have already had a few annoying encounters with equalities of objects actually so if there are ways to avoid those, I'd be quite interested!</p>\n</blockquote>\n<p>I guess options that come to mind are</p>\n<ol>\n<li>Grothendieck fibrations, and just live with <code>eqToHom</code> annoyances that arise from writing down the definition in intensional type theory.</li>\n<li><a href=\"https://ncatlab.org/nlab/show/Street+fibration\">Street fibrations</a>, which will have the same definition except that an <code>eqToHom</code> is replaced by an arbitrary isomorphism.</li>\n<li><a href=\"https://ncatlab.org/nlab/show/displayed+category\">Displayed categories</a>, which I am now realizing will probably also be inconvenient in Lean because they involve dependent equalities/\"pathovers\" in the axioms (e.g. associativity).</li>\n</ol>\n<p>The \"real\" definition is that a prestack is a pseudofunctor to the 2-category of groupoids (or of categories, or ...). I'm not sure why the definition in terms of fibrations stuck in algebraic geometry, but in any case, both will be needed at some point.</p>\n</blockquote>\n<p>Here are some thoughts from <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> on this, from the thread \"Formalizing stacks\".</p>",
        "id": 442554636,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717514127
    },
    {
        "content": "<p>I don't think I'm qualified enough to determine which approach would be best, but I do like their definition of displayed functors (definition 3.11). Something like that is probably the right way to define functors between fibered categories equipped with a <code>HasFibers</code> class as per <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> 's suggestion (see the discussion on the other thread for this class)</p>",
        "id": 442562118,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717515948
    },
    {
        "content": "<p>Well it seems to me that formalising these concepts in Lean's dependent type theory is an interesting open problem and now my instinct is to merge the PR and continue with the experiment of doing it this way. I think that we've thought hard about making the simplifier deal with <code>eqToHom</code> annoyances, so let's see what happens.</p>",
        "id": 442564868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717516595
    },
    {
        "content": "<p>If someone wants to formalize displayed categories, Jon Sterling and Carlo Angiuli's <a href=\"https://www.jonmsterling.com/frct-003I.xml\">notes</a> are an excellent and detailed reference. Also, I'd love to help!</p>",
        "id": 442680948,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717555617
    },
    {
        "content": "<p>My instinct is that if you want to go ahead and formalise a bunch of the abstract theory then an approach like this might be better (and in a system which has higher types like a HoTTsystem it might be the best idea) but if you're just interested in stacks because of their applications to moduli problems (like I am) then we'll be able to get away with the approach Calle is taking, because the equalities which show up really are going to be defeq in practice in those applications. I don't know enough about the general theory to know when the problems with this approach will start rearing their ugly head but that's why I think it's an interesting idea to push on with the approach in the PR. For me a target is the moduli stack of elliptic curves where the map from the top category to the base really is a forgetful functor.</p>",
        "id": 442695536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717563713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/116395-maths/topic/.2312978.20and.20equality.20of.20objects/near/442504377\">said</a>:</p>\n<blockquote>\n<p>We actually have this construction <a href=\"https://github.com/Paul-Lez/Stacks-project/blob/master/LS/FiberedCategories/Pseudofunctor.lean\">here</a>. Although not the converse, that every fibered category is equivalent to such a fibered category</p>\n</blockquote>\n<p>Given a pseudofunctor <code>F</code> and a Grothendieck topology on the source, have you defined the notion of (effective) descent? which can be stated in three steps:<br>\n0) if <code>M</code> and <code>N</code> are objects in<code>F.obj X</code>, then the presheaf of morphisms from <code>M</code> to <code>N</code> (on <code>Over X</code>) is separated presheaf (this is a kind of <code>ext</code> property).<br>\n1) this presheaf is a sheaf (this is descent of morphisms)<br>\n2) the descent is effective: 0) and 1) says that the functor from <code>F.obj X</code>to the category of objects equipped with a descent data relative to a covering of <code>X</code> is fully faithful, then we require this is an equivalence of categories.</p>\n<p>(These properties should first be defined for a family of maps to <code>X</code>, and then applied to covering families of a topology.) The numbering 0-1-2 is consistent with Giraud's notions of <code>i</code>-faithful functors.</p>\n<p>For the applications to algebraic geometry, I think it would be very convenient to have such definitions formulated in the language of pseudo-functors (and at some point also in the language of fibered categories). This should be very similar to some definitions in the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8661\">#8661</a></p>",
        "id": 442791744,
        "sender_full_name": "Joël Riou",
        "timestamp": 1717594939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/.2312978.20and.20equality.20of.20objects/near/442791744\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/116395-maths/topic/.2312978.20and.20equality.20of.20objects/near/442504377\">said</a>:</p>\n<blockquote>\n<p>We actually have this construction <a href=\"https://github.com/Paul-Lez/Stacks-project/blob/master/LS/FiberedCategories/Pseudofunctor.lean\">here</a>. Although not the converse, that every fibered category is equivalent to such a fibered category</p>\n</blockquote>\n<p>Given a pseudofunctor <code>F</code> and a Grothendieck topology on the source, have you defined the notion of (effective) descent? which can be stated in three steps:<br>\n0) if <code>M</code> and <code>N</code> are objects in<code>F.obj X</code>, then the presheaf of morphisms from <code>M</code> to <code>N</code> (on <code>Over X</code>) is separated presheaf (this is a kind of <code>ext</code> property).<br>\n1) this presheaf is a sheaf (this is descent of morphisms)<br>\n2) the descent is effective: 0) and 1) says that the functor from <code>F.obj X</code>to the category of objects equipped with a descent data relative to a covering of <code>X</code> is fully faithful, then we require this is an equivalence of categories.</p>\n<p>(These properties should first be defined for a family of maps to <code>X</code>, and then applied to covering families of a topology.) The numbering 0-1-2 is consistent with Giraud's notions of <code>i</code>-faithful functors.</p>\n<p>For the applications to algebraic geometry, I think it would be very convenient to have such definitions formulated in the language of pseudo-functors (and at some point also in the language of fibered categories). This should be very similar to some definitions in the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8661\">#8661</a></p>\n</blockquote>\n<p>This is definitely something we would want to do. One of our current targets is to reformulate our current definition of stacks using some notion of descent data (and enough API around it), so I think what you're suggesting would be highly relevant to that.</p>",
        "id": 442904043,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1717624285
    },
    {
        "content": "<p>(this sort of stuff is on my todo list but I've been quite busy with other things lately. I should hopefully be able to get back to working on it over the next couple of weeks)</p>",
        "id": 442904321,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1717624356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/.2312978.20and.20equality.20of.20objects/near/442791744\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/116395-maths/topic/.2312978.20and.20equality.20of.20objects/near/442504377\">said</a>:</p>\n<blockquote>\n<p>We actually have this construction <a href=\"https://github.com/Paul-Lez/Stacks-project/blob/master/LS/FiberedCategories/Pseudofunctor.lean\">here</a>. Although not the converse, that every fibered category is equivalent to such a fibered category</p>\n</blockquote>\n<p>Given a pseudofunctor <code>F</code> and a Grothendieck topology on the source, have you defined the notion of (effective) descent? which can be stated in three steps:<br>\n0) if <code>M</code> and <code>N</code> are objects in<code>F.obj X</code>, then the presheaf of morphisms from <code>M</code> to <code>N</code> (on <code>Over X</code>) is separated presheaf (this is a kind of <code>ext</code> property).<br>\n1) this presheaf is a sheaf (this is descent of morphisms)<br>\n2) the descent is effective: 0) and 1) says that the functor from <code>F.obj X</code>to the category of objects equipped with a descent data relative to a covering of <code>X</code> is fully faithful, then we require this is an equivalence of categories.</p>\n<p>(These properties should first be defined for a family of maps to <code>X</code>, and then applied to covering families of a topology.) The numbering 0-1-2 is consistent with Giraud's notions of <code>i</code>-faithful functors.</p>\n<p>For the applications to algebraic geometry, I think it would be very convenient to have such definitions formulated in the language of pseudo-functors (and at some point also in the language of fibered categories). This should be very similar to some definitions in the draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8661\">#8661</a></p>\n</blockquote>\n<p>Yes like Paul said this is something we definitely want to do soon! At the moment I wanted to get some PRs accepted before continuing to develop the theory, so that I knew what we were doing wasn't completely wrong.</p>\n<p>I think we are quite close to being able to state these for general fibered categories anyways, so shouldn't we get this statement you're suggesting on pseudofunctors by specialization? So a pseudofunctor satisfies effective descent := the associated fibered category satisfies effective descent. With the <code>HasFibers</code> class, the fibers are definitionally the same as the values of the pseudofunctor, so there should not be any problem in moving between the two.</p>",
        "id": 443001262,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717662475
    },
    {
        "content": "<p>Also, stackification can be defined as a composition of three functors <code>Pseduo =&gt; 0)</code>, <code>0) =&gt; 1)</code> and <code>1) =&gt; 2)</code>. It would be nice to argue that this makes the inclusions <code>2) ⊆ 1)</code>, <code>1) ⊆ 0)</code> and <code>0) ⊆ Pseudo</code> reflective in some 2-categorical sense. From that it would be very convenient to construct fibered products of stacks immediately from just knowing fibered products of pseudofunctors and/or fibered categories. I don't have so much experience with 2-categories though, so I do not know how much extra work it would be to develop a theory of reflective sub-2-categories.</p>",
        "id": 443002734,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1717662852
    }
]