[
    {
        "content": "<p>I'm trying to define Dedekind cuts as a way of formalizing the Reals, and it would be helpful for my proofs of addition if I could prove that starting from a value above the cut and going down towards the cut in equal-sized increments was well-founded. However, I'm not sure where to even start with this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- I've defined Dedekind Cuts like so...</span>\n<span class=\"kd\">structure</span> <span class=\"n\">DedekindCut</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"c1\">--- is a given rational below the cut</span>\n  <span class=\"n\">cut</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>\n  <span class=\"c1\">-- every Dedekind Cut partitions the rationals, so the proposition must be decidable, otherwise we may find</span>\n  <span class=\"c1\">-- rationals which aren't cut q or ¬cut q</span>\n  <span class=\"n\">decide</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">cut</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- each partition must be inhabited</span>\n  <span class=\"n\">has_lt_partition</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">cut</span> <span class=\"n\">q</span>\n  <span class=\"n\">has_ge_partition</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"n\">cut</span> <span class=\"n\">q</span>\n  <span class=\"c1\">-- cut must respect the &lt; operator on rationals</span>\n  <span class=\"n\">lower_cover</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;</span> <span class=\"n\">q</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">cut</span> <span class=\"n\">q</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">cut</span> <span class=\"n\">r</span>\n  <span class=\"c1\">-- cut must not have a maximum element (though it will have an upper bound)</span>\n  <span class=\"n\">no_max</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">cut</span> <span class=\"n\">q</span> <span class=\"bp\">-&gt;</span> <span class=\"bp\">∃</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"bp\">∧</span> <span class=\"n\">cut</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>Now I want to prove something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">CutInd</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">dedekind</span><span class=\"o\">:</span> <span class=\"n\">DedekindCut</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n  <span class=\"n\">value_not_cut</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">dedekind.cut</span> <span class=\"n\">value</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">CutInd.instLt</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">dedekind</span><span class=\"o\">:</span> <span class=\"n\">DedekindCut</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"o\">(</span><span class=\"n\">CutInd</span> <span class=\"n\">α</span> <span class=\"n\">dedekind</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">a.value</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.value</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">DedekindCut.step_down_with_accessible</span>\n  <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cut_wf</span><span class=\"o\">:</span> <span class=\"n\">DedekindCutWf</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">dedekind</span><span class=\"o\">:</span> <span class=\"n\">DedekindCut</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">step_size</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step_size_positive</span><span class=\"o\">:</span> <span class=\"n\">cut_wf.is_positive</span> <span class=\"n\">step_size</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">CutInd</span> <span class=\"n\">α</span> <span class=\"n\">dedekind</span><span class=\"o\">),</span> <span class=\"n\">Acc</span> <span class=\"n\">LT.lt</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"c1\">-- not sure how to start filling this in somehow</span>\n</code></pre></div>\n<p>where <code>DedekindCutWf</code> is any lemmas I need to make this work. I think I only need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">DedekindCutWf</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">is_positive</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span> <span class=\"c1\">-- there might be something in mathlib for this, but not a big deal for now</span>\n  <span class=\"n\">sub_decreasing</span><span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">is_positive</span> <span class=\"n\">b</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>Intuitively this should work, since if you step down <code>n</code> times (for some <code>n</code>), you will end up below the cut.<br>\nAnd all values below the cut are <code>&lt;</code> all values above the cut. Since the region below the cut is non-empty (by <code>has_lt_partition</code>), it shouldn't be possible to recurse infintely.<br>\nAnd it's not possible to construct <code>CutInd</code> for values below the cut.</p>\n<p>This is all I've got so far, but not sure where to go forward from here or if this is even the right approach. Do you guys have some hints on how to go about this or if my approach isn't workable in some way?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">DedekindCut.step_down_with_accessible</span>\n  <span class=\"o\">[</span><span class=\"n\">Sub</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cut_wf</span><span class=\"o\">:</span> <span class=\"n\">DedekindCutWf</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">dedekind</span><span class=\"o\">:</span> <span class=\"n\">DedekindCut</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">step_size</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">step_size_positive</span><span class=\"o\">:</span> <span class=\"n\">cut_wf.is_positive</span> <span class=\"n\">step_size</span><span class=\"o\">):</span>\n  <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">CutInd</span> <span class=\"n\">α</span> <span class=\"n\">dedekind</span><span class=\"o\">),</span> <span class=\"n\">Acc</span> <span class=\"n\">LT.lt</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">q_is_below_cut</span> <span class=\"o\">⟩</span>  <span class=\"o\">:=</span> <span class=\"n\">dedekind.has_lt_partition</span>\n  <span class=\"n\">cases</span> <span class=\"bp\">@</span><span class=\"n\">lt_or_ge</span> <span class=\"n\">α</span> <span class=\"n\">_</span> <span class=\"n\">x.value</span> <span class=\"n\">q</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">x.value_not_cut</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">dedekind.lower_cover</span> <span class=\"n\">h</span> <span class=\"n\">q_is_below_cut</span>\n    <span class=\"n\">contradiction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Acc.intro</span>\n      <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"n\">y_lt_x</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 437870980,
        "sender_full_name": "RustyYato",
        "timestamp": 1715281570
    },
    {
        "content": "<p>I'm aware that mathlib4 uses Cauchy sequences to define the reals, but I'm doing this as a way to learn lean4 and how to write proofs. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>, and I don't think I found anything on Dedekind cuts, so I thought I would try my hand at it.</p>",
        "id": 437873534,
        "sender_full_name": "RustyYato",
        "timestamp": 1715282754
    },
    {
        "content": "<p>i think first off you will want to be able to talk about the natural notion of integer multiplication given by repeated addition... secondly, you will want something saying that <code>∀ x y, ∃ z : y - z &lt; y</code> or in words \"any distance can be bridged by some number\". thirdly, the archimedian property will help. i think these three assumptions should be sufficient to prove this?</p>",
        "id": 437877794,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1715284773
    },
    {
        "content": "<p>for a bit more guidance on how to get the first, you may want to look into making your arbitrary <code>α</code> a(n additive) Group, to give it an appropriate instance of <code>Module ℕ α</code></p>",
        "id": 437878240,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1715284931
    },
    {
        "content": "<p>I see, that makes sense, I'll try that out. Thanks! </p>\n<p>For <code>∀ x y, ∃ z : y - z &lt; y</code> did you mean to use <code>x</code> in there somewhere?</p>",
        "id": 437878351,
        "sender_full_name": "RustyYato",
        "timestamp": 1715284983
    },
    {
        "content": "<p>ah yes. i meant <code>∀ x y, ∃ z : y - z &lt; x</code> (or <code>∀ x y, ∃ z : x - z &lt; y</code>, dealers choice)</p>",
        "id": 437878428,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1715285032
    },
    {
        "content": "<p>hmm, so I tried this out and wasn't able to make it work. But I also found out that it likely wouldn't have helped anyways :( </p>\n<p>The XY problem here is that I'm trying to define addition in terms on the cuts, but I am unable to prove the decidability of addition with the given proposition <code>add.cut := ∃q_a q_b, q_a + q_b = q ∧ a.cut q_a ∧ b.cut q_b</code>. NOTE: for this part I'm just working with the Rationals, not some generalized field. </p>\n<p>Of course I could use <code>Classical.decideProp</code>, but then the addition is non-computable. Which is super unfortunate.<br>\nI think there should be a constructive proof of this, but it eludes me.</p>\n<p>Maybe I can define a non-standard order for the rationals and just use induction to get a super slow implementation? (like inducting over the numerator and denominator, and checking all of them).</p>\n<p>Does it being non-computable matter if I only intend to use this type for proofs?</p>",
        "id": 437913359,
        "sender_full_name": "RustyYato",
        "timestamp": 1715306703
    },
    {
        "content": "<p>While its true that we don't have a lot of material on dedekind cuts, a lot of the things in this file in mathlib <a href=\"https://github.com/leanprover-community/mathlib4/blob/18a35ebb796ef104676edcf9d6f02880f4e6af6a/Mathlib/Algebra/Order/CompleteField.lean\">https://github.com/leanprover-community/mathlib4/blob/18a35ebb796ef104676edcf9d6f02880f4e6af6a/Mathlib/Algebra/Order/CompleteField.lean</a> make use of dedekind cuts implicitly to define maps between conditionally complete ordered fields (like the reals). Maybe you'll find some useful material there</p>",
        "id": 437939164,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1715327067
    }
]