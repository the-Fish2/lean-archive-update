[
    {
        "content": "<p>We have the type <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.AEEqFun#doc\">docs#MeasureTheory.AEEqFun</a> <code>α →ₘ[μ] β</code> of functions that are (strongly) measurable and are quotiented by a.e.-equality w.r.t. a measure <code>μ</code> on <code>α</code>. We have the coercion <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.AEEqFun.cast#doc\">docs#MeasureTheory.AEEqFun.cast</a> that picks an arbitrary representative from an equivalence class.<br>\nGiven a (strongly) measurable function <code>f : α → β</code> we of course cannot expect that <code>(mk f).out</code> is the same as <code>f</code>, and it will only be a.e.-equal. So for example, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.AEEqFun.coeFn_one#doc\">docs#MeasureTheory.AEEqFun.coeFn_one</a> that only states that <code>⇑(1 : α →ₘ[μ] β) =ᵐ[μ] 1</code>, but is not actually an equality of functions.</p>\n<p>We could do better: we could modify <code>AEEqFun.cast</code> so that it picks out the constant functions on the nose, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→ₘ</span><span class=\"o\">[</span><span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"n\">g</span> <span class=\"n\">μ</span><span class=\"o\">),</span>\n    <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">mk</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"bp\">∧</span> <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">Function.const</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n    <span class=\"n\">Classical.choose</span> <span class=\"n\">h</span> <span class=\"k\">else</span>\n    <span class=\"c1\">-- existing definition</span>\n</code></pre></div>\n<p>This is nice, because we can get a (non-definitional) equality of functions <code>⇑(1 : α →ₘ[μ] β) = 1</code>, not just a.e.-equality.</p>\n<p>Can we do better than this? I would like to do the same for any continuous function. The problem with this is that we are not assuming that <code>α</code> is a topological space, only a measurable space. I think that requiring a topological space on <code>α</code> is unacceptable. </p>\n<p>Now one thing we could do is to check \"if the σ-algebra is the Borel σ-algebra of a topological space, there exists a continuous representative <code>g</code> w.r.t. that topology, choose a continuous representative.\"<br>\nHowever, this doens't work, since many topologies give the same σ-algebra. E.g. on <code>ℝ</code> the coarsest topology that is finer than the usual topology but also makes <code>{0}</code> open should generate the same σ-algebra.</p>\n<p>So here is my mathematical question: given a σ-algebra, is there a \"nice\" condition <code>P</code> on topologies, such that for the common cases (Banach spaces, or at the very least, <code>ℝⁿ</code>)  there is at most one topology satisfying <code>P</code> that generates the usual σ-algebra on those spaces? (Or at least, the usual topology should be the finest such topology.)</p>",
        "id": 438958859,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1715845094
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/12949\">#12949</a> is the PR for the constant case. Unfortunately we need the condition <code>[NeZero μ]</code> to prove <code>⇑(1 : α →ₘ[μ] β) x = 1</code>, so we also need the unconditional a.e.-equality.</p>",
        "id": 438968079,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1715848566
    },
    {
        "content": "<p>The answer to your question (if I understand it correctly) is no: even on R, there are two arbitrarily nice topologies which are not the same but generate the Borel sigma algebra: take the usual topology, and the push-forward of this topology under a Borel-measurable non-continuous map.</p>",
        "id": 438981325,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1715853169
    },
    {
        "content": "<p>Oh, I think you are right... That is unfortunate.</p>",
        "id": 439041311,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1715871712
    },
    {
        "content": "<p>Also, take the discrete topology on <code>Bool</code> and the measure <code>dirac false</code>. Then the quotient space knows nothing about the value at <code>true</code> and has no way to recover it.</p>",
        "id": 439082393,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715885667
    },
    {
        "content": "<p>So, even if the output is continuous, it is not guaranteed to be the original function.</p>",
        "id": 439082444,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1715885685
    },
    {
        "content": "<p>But that is not a problem, since I'm fine with it only working in common analysis cases (e.g. with a Haar measure).</p>\n<p>But indeed, even for constant functions, I have to assume that the measure is not the zero measure.</p>",
        "id": 439161436,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1715928570
    }
]