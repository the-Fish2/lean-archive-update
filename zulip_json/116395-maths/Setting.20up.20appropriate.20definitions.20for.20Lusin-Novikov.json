[
    {
        "content": "<p>I am currently attempting to formalize a proof of the Lusin-Novikov theorem in descriptive set theory, namely the proof in the following paper: <a href=\"/user_uploads/3121/YgPuDT9DsFucyc50yoi1rqjq/Lusin-Novikov.pdf\">Lusin-Novikov.pdf</a></p>\n<p>So far I've set up the following for the spaces X and Y, and the function f between them.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tα</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pα</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tβ</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pβ</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fcont</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm new to topology in Lean, so I have a few questions regarding how to set up the appropriate definitions. </p>\n<ol>\n<li>While defining the notion of a partial section (or even a Borel partial section) is pretty straightforward, I'm not really sure how I might define the sigma ideal generated by such partial sections. Is there any machinery in Lean already to do this? I was thinking a subtype of <code>Set α</code> would make sense, but I'm not really sure how to encode the sigma ideal condition into such a subtype.</li>\n<li>Similarly, I'm not sure the best way to define ℙ. Again a subtype of <code>Set Set α</code> would make sense, and perhaps it wouldn't be too bad to encode the collection being disjoint and the sets being closed, but is there a better way to do it?</li>\n<li>At some point I need to define what the paper calls (U)^2, the product of U with itself minus its diagonal. I could do this as directly as possible via <code>def sq_minus_diag (U : Set α) := {x : α × α | x.1 ∈ U ∧ x.2 ∈ U ∧ x.1 ≠ x.2}</code>, but is there a better option?</li>\n</ol>",
        "id": 416823210,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1705683399
    },
    {
        "content": "<p>The first hint is that for finite sets you should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a>.</p>",
        "id": 416824061,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1705683609
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"464202\">@Felix Weilacher</span> has been formalizing DST recently, perhaps he is interested. I was, also, but I had to stop for a while.</p>",
        "id": 416824437,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1705683714
    },
    {
        "content": "<p>Is this how subtypes work, syntactically? I came up with these for now (with the definition of I being a placeholder until I figure out how to generate a sigma ideal).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> To be replaced with actual definition once I have it -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">C₁</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">C₂</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">C₁</span> <span class=\"bp\">∩</span> <span class=\"n\">C₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">IsClosed</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>However, when I attempt to define what it means for a family to be null using this type, I get an error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsNull</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">F</span><span class=\"bp\">=</span><span class=\"n\">F</span>\n\n<span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">TopologicalSpace</span> <span class=\"bp\">?</span><span class=\"n\">m.1010</span>\n</code></pre></div>\n<p>I'm assuming I have somehow screwed up the definition of a subtype, but I don't know how it works well enough to see what I did wrong.</p>",
        "id": 416834059,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1705686309
    },
    {
        "content": "<p>Is a subtype of a topological space always a topological space?</p>",
        "id": 416834370,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705686407
    },
    {
        "content": "<p>I think so? A subtype should correspond to some subset of the original space, which we can equip with the subspace topology.</p>",
        "id": 416845565,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1705690101
    },
    {
        "content": "<p>In the meantime, I've tried to write a statement for the first observation on the second page of the paper, and I'm getting a few errors. Here's what I wrote</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">obs1</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MetricSpace</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SeparableSpace</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">γ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Ucl</span> <span class=\"o\">:=</span> <span class=\"n\">IsClosed</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">εpos</span> <span class=\"o\">:</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sq_minus_diag</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">Metric.diam</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span> <span class=\"bp\">∧</span>\n  <span class=\"n\">Metric.diam</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The first thing it doesn't like is the <code>[SeparableSpace γ]</code>, for which I'm getting the following error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">binder</span> <span class=\"n\">annotation</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">a</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.1226</span>\n<span class=\"n\">use</span> <span class=\"n\">the</span> <span class=\"n\">command</span> <span class=\"bp\">`</span><span class=\"kd\">set_option</span> <span class=\"n\">checkBinderAnnotations</span> <span class=\"n\">false</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">disable</span> <span class=\"n\">the</span> <span class=\"n\">check</span>\n</code></pre></div>\n<p>It also doesn't like the <code>sq_minus_diag U = ⋃ n : ℕ, ((V n) × (W n))</code>, for which I'm getting the following error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_3</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u_3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Set</span> <span class=\"bp\">?</span><span class=\"n\">m.1493</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.1491</span>\n</code></pre></div>\n<p>Any ideas what I'm doing wrong here?</p>\n<p>(Also would this sort of discussion be better suited for <a class=\"stream\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4\">#lean4</a>? I'm not sure what the correct feed is for this.)</p>",
        "id": 416847316,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1705690712
    },
    {
        "content": "<p>I also have not been working on lean much lately, so some of my library knowledge may be out of date.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"530359\">Connor Gordon</span> <a href=\"#narrow/stream/116395-maths/topic/Setting.20up.20appropriate.20definitions.20for.20Lusin-Novikov/near/416823210\">said</a>:</p>\n<blockquote>\n<p>While defining the notion of a partial section (or even a Borel partial section) is pretty straightforward, I'm not really sure how I might define the sigma ideal generated by such partial sections. Is there any machinery in Lean already to do this? I was thinking a subtype of <code>Set α</code> would make sense, but I'm not really sure how to encode the sigma ideal condition into such a subtype.</p>\n</blockquote>\n<p>One quirk of mathlib is there is a lot of infrastructure set up for filters that is not there for ideals. Often, even if the ideal is a bit more intuitive to think about, it's better to just work with the dual filter. For generating a sigma filter, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.countableGenerate#doc\">docs#Filter.countableGenerate</a></p>",
        "id": 416853390,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705692931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"530359\">Connor Gordon</span> <a href=\"#narrow/stream/116395-maths/topic/Setting.20up.20appropriate.20definitions.20for.20Lusin-Novikov/near/416823210\">said</a>:</p>\n<blockquote>\n<p>At some point I need to define what the paper calls (U)^2, the product of U with itself minus its diagonal. I could do this as directly as possible via <code>def sq_minus_diag (U : Set α) := {x : α × α | x.1 ∈ U ∧ x.2 ∈ U ∧ x.1 ≠ x.2}</code>, but is there a better option?</p>\n</blockquote>\n<p>Maybe <code>U ×ˢ U \\ (diagonal  α)</code></p>",
        "id": 416854400,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705693303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"530359\">Connor Gordon</span> <a href=\"#narrow/stream/116395-maths/topic/Setting.20up.20appropriate.20definitions.20for.20Lusin-Novikov/near/416834059\">said</a>:</p>\n<blockquote>\n<p>Is this how subtypes work, syntactically? I came up with these for now (with the definition of I being a placeholder until I figure out how to generate a sigma ideal).</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> To be replaced with actual definition once I have it -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">C₁</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">C₂</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">C₁</span> <span class=\"bp\">∩</span> <span class=\"n\">C₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">IsClosed</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Why do you want <code>I</code> and <code>P</code> to be subtypes? It is probably better to just define sets (or ideals/filters) here.</p>",
        "id": 416855341,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705693614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"530359\">Connor Gordon</span> <a href=\"#narrow/stream/116395-maths/topic/Setting.20up.20appropriate.20definitions.20for.20Lusin-Novikov/near/416834059\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">IsNull</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">F</span><span class=\"bp\">=</span><span class=\"n\">F</span>\n\n\n<span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">TopologicalSpace</span> <span class=\"bp\">?</span><span class=\"n\">m.1010</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>In paper mathematics, people often say that they are making a definition only for certain types of objects, even when the definition is valid for a much broader class of objects, because the general definition is not very interesting and/or well behaved without some extra assumptions about the objects. </p>\n<p>In lean/mathlib, it is usually best to avoid this. For example, here, \"null\" makes sense for arbitrary elements of <code>Finset (Set α)</code>.</p>",
        "id": 416856519,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705694058
    },
    {
        "content": "<p>I can't tell what is causing your error message without seeing the whole code, but having this be a predicate on <code>Finset (Set α)</code> might help and is the right decision anyways.</p>",
        "id": 416856942,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705694218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"530359\">Connor Gordon</span> <a href=\"#narrow/stream/116395-maths/topic/Setting.20up.20appropriate.20definitions.20for.20Lusin-Novikov/near/416847316\">said</a>:</p>\n<blockquote>\n<p>It also doesn't like the <code>sq_minus_diag U = ⋃ n : ℕ, ((V n) × (W n))</code>, for which I'm getting the following error message:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_3</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u_3</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Set</span> <span class=\"bp\">?</span><span class=\"n\">m.1493</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.1491</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I'm pretty sure it's that you need to use <code>Set.prod</code>, written <code>×ˢ</code>. Right now it is taking the subtypes induced by <code>V n</code> and <code>W n</code> and taking the product of those types.</p>",
        "id": 416857692,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705694495
    },
    {
        "content": "<p>Another word of warning: <code>Metric.diam</code> will return 0 for sets with infinite diameter. When I've done things similar to this, I've usually found <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EMetric.diam#doc\">docs#EMetric.diam</a> to be better to use.</p>",
        "id": 416858537,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1705694795
    },
    {
        "content": "<p>Thanks for all the tips! After taking a break to formalize the two \"observations\" in the paper, I'm back to trying to get these definitions working. Towards using the dual filter idea, I attempted to define the set of complements of Borel partial sections as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BorelPartialSection</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">MeasurableSet</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">y</span>\n<span class=\"kd\">def</span> <span class=\"n\">I₀</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">BorelPartialSection</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>However, when I do this, I get the error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">occurrence</span> <span class=\"n\">of</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span> <span class=\"bp\">'</span><span class=\"n\">u_3'</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">I₀'</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">occur</span> <span class=\"n\">at</span> <span class=\"n\">the</span> <span class=\"n\">declaration</span> <span class=\"n\">type</span><span class=\"o\">,</span> <span class=\"n\">nor</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">explicit</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span> <span class=\"n\">provided</span> <span class=\"kd\">by</span> <span class=\"n\">the</span> <span class=\"n\">user</span><span class=\"o\">,</span> <span class=\"n\">occurring</span> <span class=\"n\">at</span> <span class=\"n\">expression</span>\n  <span class=\"n\">BorelPartialSection.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">,</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">compl.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"n\">at</span> <span class=\"n\">declaration</span> <span class=\"n\">body</span>\n  <span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">BorelPartialSection</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm assuming this is a classic instance of me not knowing how set builder notation works in Lean, but could I get some help defining what I actually want this to be?</p>",
        "id": 418700182,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706554574
    },
    {
        "content": "<p>I think I've only seen that if there's another error elsewhere, though I'm not sure what it would be here. Maybe try giving I0 an explicit type?</p>",
        "id": 418705179,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706556499
    },
    {
        "content": "<p><code>BorelPartialSection</code> has an extra <code>f</code> argument, right? You should provide it in the set builder notation</p>",
        "id": 418705622,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706556658
    },
    {
        "content": "<p>It would be easier for me to check whether my hunch is correct if you gave us a mwe though</p>",
        "id": 418705793,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706556719
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 418705907,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706556743
    },
    {
        "content": "<p><code>f</code> is declared as a global variable. Where should it be in the set builder notation? <br>\n<a href=\"/user_uploads/3121/iIa6rsroX9NCCSTFbspWn9Hm/MWE.lean\">MWE.lean</a></p>",
        "id": 418707963,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706557531
    },
    {
        "content": "<p>There's no such thing as a \"global variable\" in Lean 4 (it was a thing in Lean 3, and it was pretty buggy)</p>",
        "id": 418721796,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706562927
    },
    {
        "content": "<p>Here's something that should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.Polish</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.Polish</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tα</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">pα</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tβ</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mβ</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">pβ</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fcont</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">BorelPartialSection</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">MeasurableSet</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">A.InjOn</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">I₀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">BorelPartialSection</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 418722010,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706563004
    },
    {
        "content": "<p>I took the freedom to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.InjOn#doc\">docs#Set.InjOn</a> since it will make your life easier down the line</p>",
        "id": 418722054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706563030
    },
    {
        "content": "<p>That worked, thanks so much! I went ahead and did the rest of the relevant definitions as well, as shown here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tα</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">pα</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tβ</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mβ</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">pβ</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fcont</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">Fdisj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">C₁</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">C₂</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">C₁</span> <span class=\"bp\">∩</span> <span class=\"n\">C₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Fclosed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">IsClosed</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">BorelPartialSection</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">MeasurableSet</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">A.InjOn</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">IDual₀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">BorelPartialSection</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">IDual</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">countableGenerate</span> <span class=\"o\">(</span><span class=\"n\">IDual₀</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">IDual</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">FBorelCover</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⋃</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"n\">Set.univ</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">BorelCover</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⋃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Set.univ</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsNull</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">FBorelCover</span> <span class=\"n\">B</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">sq_minus_diag</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">x.1</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x.2</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x.1</span> <span class=\"bp\">≠</span> <span class=\"n\">x.2</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>(If you think I could improve any of these definitions, please let me know.)</p>\n<p>I'm now attempting to formulate the statements of Lemmas 1 and 2 in the paper, and I'm running into a few issues. The first one I'm going for is Lemma 2, for which I want to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lem2</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ABC</span> <span class=\"o\">:</span> <span class=\"n\">BorelCover</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Lean is not liking the <code>{C ∩ f⁻¹' (A n) | C ∈ F}</code>, as it wants a <code>Finset α</code> but is getting a <code>Set α</code>. Is there a way for me to write this set as a finset?</p>\n<p>For Lemma 1, this is somewhat silly, but I'm not actually sure how to write the doubleton set <code>{V n, W n}</code> as a <code>Finset α</code> rather than a <code>Set α</code>. How would I do this?</p>",
        "id": 418756537,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706581476
    },
    {
        "content": "<p>I'm also trying to prove a convenience lemma that members of a non-null family of sets are nonempty. I've started the proof below, where the key idea is that if we did have an empty set, then we could pick our Borel cover to assign all of Y to the empty set and have everything else be empty.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">aux2</span> <span class=\"o\">(</span><span class=\"n\">Fnonnull</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">≠</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">C</span> <span class=\"n\">hC</span> <span class=\"n\">hcont</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">IsNull</span><span class=\"o\">]</span>\n    <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"k\">then</span> <span class=\"n\">Set.univ</span> <span class=\"k\">else</span> <span class=\"bp\">∅</span> <span class=\"k\">with</span> <span class=\"n\">B_def</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>However, this is raising the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there any way to get around this issue?</p>",
        "id": 418757119,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706581949
    },
    {
        "content": "<p>re: decidability, you can <code>open Classical</code> in the file to make all Props decidable (assuming you don't care about constructivity/computability)</p>",
        "id": 418759638,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706584020
    },
    {
        "content": "<p>for your lemma 1 question, Lean should be able to create a Finset literal if it knows what the expected type is... for example, <code>({1, 2} : Finset ℕ)</code> type-checks perfectly well</p>",
        "id": 418760179,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706584560
    },
    {
        "content": "<p>Just use the <code>classical</code> tactic at the beginning of the proof, that's much better than opening it for all the file</p>",
        "id": 418795574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706606326
    },
    {
        "content": "<p>The <code>classical</code> tactic worked, thanks!</p>\n<p>I'm still having trouble on the two lemmas, though. For the first, I've written the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lem1</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Udecomp</span> <span class=\"o\">:</span> <span class=\"n\">sq_minus_diag</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">n</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">VWnull</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">∪</span> <span class=\"o\">({</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The second line is giving me these errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Insert</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Union</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>And the third is giving me this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">Union</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>For the second, I've written</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lem2</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ABC</span> <span class=\"o\">:</span> <span class=\"n\">BorelCover</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But am getting the error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span> <span class=\"bp\">∧</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"n\">argument</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span> <span class=\"bp\">∧</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n</code></pre></div>\n<p>Any ideas how to fix these?</p>",
        "id": 418866096,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706629420
    },
    {
        "content": "<p>Not enough code for us to see the error for ourselves</p>",
        "id": 418867281,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706629707
    },
    {
        "content": "<p>Apologies, here's a MWE</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.Polish</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.Polish</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.CantorScheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Bases</span>\n\n\n<span class=\"c1\">-- Set variables:</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tα</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">pα</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">tβ</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mβ</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">pβ</span> <span class=\"o\">:</span> <span class=\"n\">PolishSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fcont</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">Fdisj</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">C₁</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">C₂</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">C₁</span> <span class=\"bp\">∩</span> <span class=\"n\">C₂</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Fclosed</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">IsClosed</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span>\n\n<span class=\"c1\">-- Important definitions:</span>\n<span class=\"kd\">def</span> <span class=\"n\">BorelPartialSection</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">MeasurableSet</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">A.InjOn</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">IDual₀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">BorelPartialSection</span> <span class=\"n\">f</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">IDual</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">countableGenerate</span> <span class=\"o\">(</span><span class=\"n\">IDual₀</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">IDual</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sets</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">FBorelCover</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⋃</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"n\">Set.univ</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">BorelCover</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">⋃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">Set.univ</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsNull</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">FBorelCover</span> <span class=\"n\">B</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"n\">f</span>\n<span class=\"kd\">def</span> <span class=\"n\">sq_minus_diag</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">x.1</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x.2</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x.1</span> <span class=\"bp\">≠</span> <span class=\"n\">x.2</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lem1</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Udecomp</span> <span class=\"o\">:</span> <span class=\"n\">sq_minus_diag</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">n</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">VWnull</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">∪</span> <span class=\"o\">({</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lem2</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ABC</span> <span class=\"o\">:</span> <span class=\"n\">BorelCover</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 418868511,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706630040
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lem1</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Udecomp</span> <span class=\"o\">:</span> <span class=\"n\">sq_minus_diag</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">n</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">VWnull</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">∪</span> <span class=\"o\">({</span><span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">W</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>For technical reasons, we need to be able to tell whether <code>V n = W n</code> in a decidable way</p>",
        "id": 418873359,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706631406
    },
    {
        "content": "<p>For <code>lem2</code>, that set builder notation only works for <code>Set</code>, not <code>Finset</code></p>",
        "id": 418873472,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706631445
    },
    {
        "content": "<p>Alternative:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Classical</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lem2</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ABC</span> <span class=\"o\">:</span> <span class=\"n\">BorelCover</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F.image</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 418874380,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706631708
    },
    {
        "content": "<p>That works, thank you!</p>\n<p>In the meantime, I've been trying to prove that I is closed under countable unions, as we would expect of a sigma ideal. The only issue is that I need Lean to recognize <code>IDual</code> as a <code>CountableInterFilter</code>, which it should be by definition of <code>countableGenerate</code> in <a href=\"https://www.github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/Order/Filter/CountableInter.lean#L215-L217\">docs#Filter.countableGenerate</a>, but I'm not sure how to actually get Lean to realize it.</p>\n<p>Also, for the proof of Lemma 2, part of the proof is extracting relevant Borel covers based on the fact that each of the families are null. In particular, I need a Borel cover for each <code>n : ℕ</code>.  I suppose I could do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lem2</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ABC</span> <span class=\"o\">:</span> <span class=\"n\">BorelCover</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">F.image</span> <span class=\"k\">fun</span> <span class=\"n\">C</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">IsNull</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">IsNull</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">IsNull._eq_1</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_image</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">,</span>\n      <span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">forall_apply_eq_imp_iff₂</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hA</span>\n    <span class=\"n\">set</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">choose</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">B_def</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but this seems absolutely awful to work with. Is there something better I can do?</p>",
        "id": 418886114,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706635295
    },
    {
        "content": "<p>I've been working on the proof of Lemma 1 (after the simplifying reductions have been made) in in <a href=\"/user_uploads/3121/ntvPPXRUrPxRRjGM3hfoRafN/MWE.lean\">MWE.lean</a>, so in particular I've defined the set <code>B U</code> as written in the paper and am currently trying to show that the resulting cover is indeed a Borel cover. I have shown it's a cover, and all that remains is to show that <code>B U</code>, which is defined to be <code>Y</code> minus the union of the other <code>B C</code>s for all <code>C</code> in <code>F</code>. I know that <code>Y</code> and all of the <code>B C</code>s are Borel, so I would like to apply <code>MeasurableSet.iInter</code> to finish, but it's not recognizing that the intersection in question is actually finite. Any ideas how I could address this?</p>",
        "id": 419095157,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706723874
    },
    {
        "content": "<p>is <code>F</code> a <code>Finset</code>? Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.measurableSet_biInter#doc\">docs#Finset.measurableSet_biInter</a></p>",
        "id": 419107255,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1706728269
    },
    {
        "content": "<p>Yep, that worked!</p>",
        "id": 419111999,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706730076
    },
    {
        "content": "<p>Did you figure out the <code>CountableInterFilter</code> instance issue or are you still looking for a solution to that?</p>",
        "id": 419116374,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706732088
    },
    {
        "content": "<p>I am still looking for a solution to that as well as advice for the picking Borel covers for lemma 2 part, I've just been working on some other stuff in the meantime.</p>",
        "id": 419116976,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706732380
    },
    {
        "content": "<p>Actually never mind on the <code>CountableInterFilter</code> one, I just needed to unfold the definition of Idual and it figured it out!</p>",
        "id": 419118088,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1706732915
    },
    {
        "content": "<p>That works! I was just going to suggest marking the definition as <code>@[reducible]</code> but I wasn't sure if that would cause other problems</p>",
        "id": 419129452,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1706737909
    },
    {
        "content": "<p>I've been continuing to work on Lemma 2 in <a href=\"/user_uploads/3121/jP1zmIZ7yAzZZ6i5qD5oN01U/MWE.lean\">MWE.lean</a>. I've now managed to reduce the problem to proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">Bcover</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">FBorelCover</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">∧</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">∩</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>This should follow pretty quickly from the definitions of <code>B</code> and <code>B'</code>, but getting anything out of <code>Classical.choose</code> can be a hassle. Does anyone have any idea how I could do this or how to better define <code>B</code> and <code>B'</code> to avoid this issue?</p>",
        "id": 419917160,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1707162839
    },
    {
        "content": "<p>Never mind, <code>aesop</code> saved the day! (As a stylistic note, what are the guidelines behind using <code>aesop</code> or <code>simp</code> in proofs? Should I always use <code>aesop?</code> or <code>simp?</code> and put the replacements, or is it sometimes fine to leave them as-is?)</p>",
        "id": 419926914,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1707166652
    },
    {
        "content": "<p>At least for <code>simp</code>, it's fine, as long as it proves the (sub)goal. We don't like proofs that do <code>simp; some more work that depends on the exact goal that simp left</code></p>",
        "id": 419934579,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1707169911
    },
    {
        "content": "<p>I just finished the proof of Lemma 1 after the reductions at the beginning, so now it's time to actually implement those reductions! Getting to the single cover by taking unions seems simple enough, so I'm mainly wondering how to do the disjointifying part. I found <a href=\"https://github.com/leanprover-community/mathlib4/blob/8666bd82efec40b8b3a5abca02dc9b24bbdf2652/Mathlib/Order/Disjointed.lean#L49-L51\">Docs#Disjointed</a>, but this seems to be collections of set indexed by the naturals, where I would want a collection of sets indexed by a Finset. Does there exist infrastructure to do this already in Mathlib, or should I attempt to do that myself (if it's the latter, is there a way to get an ordering on a Finset?)</p>",
        "id": 420338080,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1707338142
    },
    {
        "content": "<p>Alright, I have implemented the taking unions step, <a href=\"#narrow/stream/270676-lean4/topic/simp.20without.20unpacking.20my.20own.20definitions\">barring some difficulties in proving that the unions do what I want</a>. I now have a Borel cover for each natural number such that all of them agree on the sets indexed by <code>F</code>. I would like to disjointify them in some coherent way such that the disjointified versions also agree on the sets indexed by <code>F</code>. Any ideas on how to do this?</p>",
        "id": 420674592,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1707492405
    },
    {
        "content": "<p>After some more thought, I think I know what I would like to do for the structure of the disjointifying, I just need some help on one step. I would like to place a linear ordering on <code>F</code>, perhaps by using `Finset.toList, and then define the Borel cover via the same method as is done is the Disjointed file. Is there a canonical way to put an ordering on a Finset in a way that's usable? I might also need to induct on it to prove the sets are Borel, so if that's possible that would be fantastic.</p>",
        "id": 421068561,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1707753451
    },
    {
        "content": "<p>I don't understand why you want to disjointify in this proof</p>",
        "id": 421665835,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1708007452
    },
    {
        "content": "<p>You know, now that you mention it, you're right. I never stopped to think whether that partition statement was necessary. All I needed was that the sets for <code>V n</code> and <code>W n</code> were disjoint from the sets for all the <code>C</code>s, and that's much easier to work with (and I just finished doing it). Thank you for the sanity check!</p>",
        "id": 421710454,
        "sender_full_name": "Connor Gordon",
        "timestamp": 1708019807
    }
]