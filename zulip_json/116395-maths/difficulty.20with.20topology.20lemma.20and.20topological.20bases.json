[
    {
        "content": "<p>I am trying to prove a little lemma: If X is a compact-open of a quasi-separated space Y and the set of compact-opens (in Y) forms a basis of Y, then the set of compact-opens (in X) forms a basis of X. Here is my code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.QuasiSeparated</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Compactness.Compact</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.ContinuousOn</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">topology_lemma</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">QuasiSeparatedSpace</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">OpenEmbedding</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hYb</span><span class=\"o\">:</span> <span class=\"n\">TopologicalSpace.IsTopologicalBasis</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"n\">IsOpen</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">S</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">TopologicalSpace.IsTopologicalBasis</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">IsOpen</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">S</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"gr\">sorry</span>\n    <span class=\"gr\">sorry</span>\n    <span class=\"n\">ext</span> <span class=\"n\">U</span>\n    <span class=\"n\">constructor</span>\n</code></pre></div>\n<p>The first constructor turns my goal TopologicalSpace.IsTopologicalBasis {S | IsOpen S ∧ IsCompact S} into three different subgoals exists_subset_inter, sUnion_eq, and eq_generateFrom, as per the definition of IsTopologicalBasis. I can prove the first two subgoals, so I've put in sorrys just to get rid of extraneous information. </p>\n<p>The third subgoal turns out to be <code>inst✝¹ = TopologicalSpace.generateFrom {S | IsOpen S ∧ IsCompact S}</code> which as far as I know means I am in serious trouble because \\textdied kills Lean. However, I tried ext U and got a goal of the form IsOpen U ↔ IsOpen U, which seems promising, but both implications seem to lead to dead ends. (You can't tell here, but these IsOpens refer to different topologies, and this is only made clear when you mouse over them in the tactics panel).</p>\n<p>Anyway, is there something I can do with the subgoal <code>inst✝¹ = TopologicalSpace.generateFrom {S | IsOpen S ∧ IsCompact S}</code> that isn't ext? Or is it over once I have a \\textdied in the goal? I've tried a few things and didn't manage to get them to work. If it helps, here's the definition of TopologicalSpace.generateFrom:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The open sets of the least topology containing a collection of basic sets. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">GenerateOpen</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">basic</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"n\">s</span>\n  <span class=\"bp\">|</span> <span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"n\">univ</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inter</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sUnion</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"bp\">⋃₀</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">topological_space.generate_open</span> <span class=\"n\">TopologicalSpace.GenerateOpen</span>\n\n<span class=\"sd\">/-- The smallest topological space containing the collection `g` of basic sets -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">generateFrom</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">IsOpen</span> <span class=\"o\">:=</span> <span class=\"n\">GenerateOpen</span> <span class=\"n\">g</span>\n  <span class=\"n\">isOpen_univ</span> <span class=\"o\">:=</span> <span class=\"n\">GenerateOpen.univ</span>\n  <span class=\"n\">isOpen_inter</span> <span class=\"o\">:=</span> <span class=\"n\">GenerateOpen.inter</span>\n  <span class=\"n\">isOpen_sUnion</span> <span class=\"o\">:=</span> <span class=\"n\">GenerateOpen.sUnion</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">topological_space.generate_from</span> <span class=\"n\">TopologicalSpace.generateFrom</span>\n</code></pre></div>",
        "id": 424155839,
        "sender_full_name": "Panagiotis Angelinos",
        "timestamp": 1709264686
    },
    {
        "content": "<p>Some comments: first, it is nice (both for the style and because it simplifies the infoview) to split your subgoals using dots, obtained by typing <code>\\.</code>. So you would get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">topology_lemma</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">QuasiSeparatedSpace</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">OpenEmbedding</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hYb</span><span class=\"o\">:</span> <span class=\"n\">TopologicalSpace.IsTopologicalBasis</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"n\">IsOpen</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">S</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">TopologicalSpace.IsTopologicalBasis</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">IsOpen</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">S</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In this way, each time you try to solve one goal, you also see this one (and local hypothesis get discharged once this is closed). Secondly, it is often a good idea to avoid using definitions directly: athough this is a normal mathematicians' habit, the way mathlib is constructed is to provide a bunch of theorems that allow to interact with definitions, rather than going back to the basic one. For instance, you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">topology_lemma</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">QuasiSeparatedSpace</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">OpenEmbedding</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hYb</span><span class=\"o\">:</span> <span class=\"n\">TopologicalSpace.IsTopologicalBasis</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"n\">IsOpen</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">S</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">TopologicalSpace.IsTopologicalBasis</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">IsOpen</span> <span class=\"n\">S</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">S</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">TopologicalSpace.isTopologicalBasis_of_isOpen_of_nhds</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">U</span> <span class=\"n\">hU</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">S</span> <span class=\"n\">hx</span> <span class=\"n\">hS</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Finally, going back to your original question (which, as explained above, I would discourage to follow) you should first think at what the pen-and-paper proof would be: the <code> isOpen U &lt;-&gt; isOpen U</code> suggests that you need to show that something that was open in <code>Y</code> stays open in <code>X</code>...</p>",
        "id": 424185931,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1709283846
    },
    {
        "content": "<p>Thanks for the help, I've managed to get this to work. And I've removed some unnecessary assumptions!</p>",
        "id": 424270073,
        "sender_full_name": "Panagiotis Angelinos",
        "timestamp": 1709307590
    }
]