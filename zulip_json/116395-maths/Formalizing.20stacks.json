[
    {
        "content": "<p>Me and <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> are going to try to formalize stacks. We are wondering in what generality to write things. Is there any point in proving things about fibered categories in general? Or can we just immediately prove things (like 2-Yoneda lemma) about categories fibered in groupoids. I don't have too much experience with these things, but I have only ever seen fibered categories being used to talk about stacks, and then one only needs categories fibered in groupoids anyways. If anyone has more experience with these things, it would be great to hear your opinion.</p>\n<p>For example, in these notes: <a href=\"http://url\">https://sites.math.washington.edu/~jarod/moduli.pdf</a> they never introduces fibered categories, and instead only works with categories fibered in groupoids (which are called prestacks there).</p>",
        "id": 398735113,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1698341348
    },
    {
        "content": "<p>Adding something to mathlib often teaches you generalisations you might never have heard of otherwise :)</p>",
        "id": 398736408,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698341912
    },
    {
        "content": "<p>I think it is important to formalize fibered categories in general! The notions of descent of morphisms (for a covering family for a certain topology) and effectiveness of descent make sense in this context, and having this in general would be very useful eventually (e.g. in order to formulate and obtain faithfully flat descent).</p>",
        "id": 398738889,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698342953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> what level of generality are you aiming for? What sort of stacks are you planning on constructing? Will you try to construct any examples?</p>",
        "id": 398746199,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698345537
    },
    {
        "content": "<p>For example, do you want to go down the following rabbit hole? <a href=\"https://ncatlab.org/nlab/show/stack\">https://ncatlab.org/nlab/show/stack</a></p>",
        "id": 398746251,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698345561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398746199\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> what level of generality are you aiming for? What sort of stacks are you planning on constructing? Will you try to construct any examples?</p>\n</blockquote>\n<p>I don't really plan to do any higher categorical stuff (because I don't know so much about it), so only 1-stacks. I also haven't thought of any good examples yet, since they are all feel quite complicated to formalize, apart from the empty stack.</p>",
        "id": 398766271,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1698353876
    },
    {
        "content": "<p>Are you planning to use Grothendieck fibrations? I think they will not keep some of their advantages when formalized because they involve equalities of objects</p>",
        "id": 398793015,
        "sender_full_name": "Reid Barton",
        "timestamp": 1698368625
    },
    {
        "content": "<p>There's also the notion of \"displayed category\" that would be appropriate here, but I don't think mathlib has it<br>\n<a href=\"https://ncatlab.org/nlab/show/displayed+category\">https://ncatlab.org/nlab/show/displayed+category</a></p>",
        "id": 398794280,
        "sender_full_name": "Reid Barton",
        "timestamp": 1698369220
    },
    {
        "content": "<p>I thought someone was working on displayed categories... Maybe <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> ?</p>",
        "id": 398795661,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1698369866
    },
    {
        "content": "<p>Mathlib currently has <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.OplaxFunctor#doc\">docs#CategoryTheory.OplaxFunctor</a> because I <a href=\"#narrow/stream/113489-new-members/topic/bicategory/near/266573274\">urged</a> <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span> to generalize pseudofunctors that he already had. My <a href=\"#narrow/stream/113488-general/topic/Status.20of.20algebraic.20geometry/near/262764463\">original motivation</a> to work on the Grothendieck construction is to show the category of schemes has all small limits, and I later <a href=\"#narrow/stream/113488-general/topic/GLn.20functor/near/294983118\">thought about</a> connections with \"dependent functors\" (which sheaves of modules are). I was able to <a href=\"#narrow/stream/144837-PR-reviews/topic/.2311147.20function.20field/near/266572252\">show</a> the existence of colimits in the total category from the existence in the base and fiber categories, but I haven't touched these for a long time, and there are only various abandoned mathlib3 <a href=\"#narrow/stream/113489-new-members/topic/Tobias.20Schmude/near/287752772\">branches</a> that haven't been ported to Lean 4. I know near to nothing about stacks, so these are probably all that I can help for now!</p>",
        "id": 398810374,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1698376893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398793015\">said</a>:</p>\n<blockquote>\n<p>Are you planning to use Grothendieck fibrations? I think they will not keep some of their advantages when formalized because they involve equalities of objects</p>\n</blockquote>\n<p>Calle and I have already had a few annoying encounters with equalities of objects actually so if there are ways to avoid those, I'd be quite interested!</p>",
        "id": 398875432,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1698404486
    },
    {
        "content": "<p>In order to formalize fibered categories, I think that part of the API should be focused on functors <code>F : E ⥤ B</code> and properties of morphisms (cartesian maps, etc.), and some <code>Prop</code> typeclasses could be introduced like <code>F.IsPrefibered</code>, <code>F.IsFibered</code>, etc.</p>",
        "id": 398890941,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698410405
    },
    {
        "content": "<p>Then, when we want to introduce the \"fibres\" of <code>F</code>, instead of relying only on equalities, I think that we should allow the user to provide a bunch of categories <code>Fib b</code> for all <code>b : B</code> equipped with functors <code>Fib b ⥤ E</code> satisfying suitable conditions (we may not necessarily require that the composition <code>Fib b ⥤ E ⥤ B</code> is equal to the constant functor, but we may instead require that there is an iso, etc.). This could be part of a type class <code>[F.HasFibres]</code>, for which the API should also provide a constructor which would just take the inverse image by <code>F</code> of the identity of <code>b</code>.</p>",
        "id": 398890962,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698410411
    },
    {
        "content": "<p>Assuming <code>[F.HasFibres]</code>, one may introduce a typeclass containing the data of the inverse image functors <code>Fib b ⥤ Fib b'</code> and the data of the composition morphisms satisfying the expected cocycle conditions: this would be <code>[F.HasClivage]</code>. Then, one may show <code>F.IsFibered</code> iff the composition morphisms are isos. (Here again, given a prefibered category such that <code>[F.HasFibres]</code>, we should provide a constructor for <code>F.HasClivage</code>.)</p>",
        "id": 398890979,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698410418
    },
    {
        "content": "<p>Then, for the applications, e. g., the fibered category of modules over various commutative rings, we could declare an instance of <code>HasFibres</code> for which, by definition, the fibres would be the category of <code>R</code>-modules for a given commutative ring <code>R</code>. The base change functors that we already have for the categories of <code>R</code>-modules could be made part of a <code>HasClivage</code> instance, etc. Doing so, we could easily relate the abstract results and their more concrete applications. Otherwise, transfering properties via equivalence of categories could be painful...</p>",
        "id": 398891004,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698410424
    },
    {
        "content": "<p>(Similarly, in my formalization of <code>t</code>-structures on triangulated categories, I have defined a type class <code>t.HasHeart</code> where the user may provide a category and an embedding into the triangulated category. Doing so, I may ensure that the heart of the derived category of an abelian category <code>A</code> is the category <code>A</code>, by definition! Otherwise, I would have to compose with equivalences of categories... I think we could do similar things for fibered categories.)</p>",
        "id": 398891020,
        "sender_full_name": "Joël Riou",
        "timestamp": 1698410430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"376152\">Paul Lezeau</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398875432\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398793015\">said</a>:</p>\n<blockquote>\n<p>Are you planning to use Grothendieck fibrations? I think they will not keep some of their advantages when formalized because they involve equalities of objects</p>\n</blockquote>\n<p>Calle and I have already had a few annoying encounters with equalities of objects actually so if there are ways to avoid those, I'd be quite interested!</p>\n</blockquote>\n<p>I guess options that come to mind are</p>\n<ol>\n<li>Grothendieck fibrations, and just live with <code>eqToHom</code> annoyances that arise from writing down the definition in intensional type theory.</li>\n<li><a href=\"https://ncatlab.org/nlab/show/Street+fibration\">Street fibrations</a>, which will have the same definition except that an <code>eqToHom</code> is replaced by an arbitrary isomorphism.</li>\n<li><a href=\"https://ncatlab.org/nlab/show/displayed+category\">Displayed categories</a>, which I am now realizing will probably also be inconvenient in Lean because they involve dependent equalities/\"pathovers\" in the axioms (e.g. associativity).</li>\n</ol>\n<p>The \"real\" definition is that a prestack is a pseudofunctor to the 2-category of groupoids (or of categories, or ...). I'm not sure why the definition in terms of fibrations stuck in algebraic geometry, but in any case, both will be needed at some point.</p>",
        "id": 398922581,
        "sender_full_name": "Reid Barton",
        "timestamp": 1698421094
    },
    {
        "content": "<p>I feel like the Street fibration approach shouldn't be too bad, even though the nLab describes them as \"fairly cumbersome\", and it seems strictly(?) better than using Grothendieck fibrations, in the context of Lean.</p>",
        "id": 398923206,
        "sender_full_name": "Reid Barton",
        "timestamp": 1698421328
    },
    {
        "content": "<p>Fair enough! I think what we've done so far falls under the 1st option - we've managed to figure out how to deal with some of the <code>eqToHom</code> annoyance - but later something else would be better</p>",
        "id": 398931205,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1698424127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398890962\">said</a>:</p>\n<blockquote>\n<p>Then, when we want to introduce the \"fibres\" of <code>F</code>, instead of relying only on equalities, I think that we should allow the user to provide a bunch of categories <code>Fib b</code> for all <code>b : B</code> equipped with functors <code>Fib b ⥤ E</code> satisfying suitable conditions (we may not necessarily require that the composition <code>Fib b ⥤ E ⥤ B</code> is equal to the constant functor, but we may instead require that there is an iso, etc.). This could be part of a type class <code>[F.HasFibres]</code>, for which the API should also provide a constructor which would just take the inverse image by <code>F</code> of the identity of <code>b</code>.</p>\n</blockquote>\n<p>Thanks a lot for these replies!! I'm still quite new to making APIs in lean, so these suggestions really help. If I understand correctly,  <code>HasFibers</code> should essentially substitute fibered categories? So I state most of my theorems in terms of <code>HasFibers</code> instead ?</p>",
        "id": 402857536,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1700301381
    },
    {
        "content": "<p>I am not so sure this is what I meant. If <code>F : E ⥤ B</code>, we may be tempted to define for each <code>b : B</code> a category <code>F.fibre' b</code> by taking those object <code>X : E</code> such that <code>F.obj X = b</code> (or with the data of an iso, whichever design choice you prefer), and then formalise the definition of functors <code>F.fibre' b ⥤ F.fibre' b'</code> when <code>F</code> is a fibered category. I am suggesting a different design where the user may provide the data of such fiber categories <code>F.fibre b</code> for a given functor <code>F</code>, and would be the <code>[F.HasFibers]</code> typeclass. (Of course, we should have equivalences between <code>F.fibre b</code> and <code>F.fibre' b</code>.</p>\n<p>My concern is that if we take typical examples: <code>B</code> the category of rings (or its opposite category) and <code>E</code> the category of modules over rings, as a category over <code>B</code>, then we already have natural candidates for the \"fiber\" categories: for each ring <code>R</code>, this is the category <code>ModuleCat R</code>. Then, the fibered category should be able to work directly with these <code>ModuleCat R</code> without the mediation of an equivalence of categories.</p>\n<p>What I suggest is to define a typeclass <code>Is(Pre)FiberedCategory</code>, construct a <code>HasFibers</code> as a definition (not an instance), and for the subsequent constructions, add an <code>[F.HasFibers]</code>, provide a <code>HasClivage</code> definition, and subsequently add the <code>[F.HasClivage]</code> assumption.</p>",
        "id": 402867770,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700307136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/402867770\">said</a>:</p>\n<blockquote>\n<p>I am not so sure this is what I meant. If <code>F : E ⥤ B</code>, we may be tempted to define for each <code>b : B</code> a category <code>F.fibre' b</code> by taking those object <code>X : E</code> such that <code>F.obj X = b</code> (or with the data of an iso, whichever design choice you prefer), and then formalise the definition of functors <code>F.fibre' b ⥤ F.fibre' b'</code> when <code>F</code> is a fibered category. I am suggesting a different design where the user may provide the data of such fiber categories <code>F.fibre b</code> for a given functor <code>F</code>, and would be the <code>[F.HasFibers]</code> typeclass. (Of course, we should have equivalences between <code>F.fibre b</code> and <code>F.fibre' b</code>.</p>\n<p>My concern is that if we take typical examples: <code>B</code> the category of rings (or its opposite category) and <code>E</code> the category of modules over rings, as a category over <code>B</code>, then we already have natural candidates for the \"fiber\" categories: for each ring <code>R</code>, this is the category <code>ModuleCat R</code>. Then, the fibered category should be able to work directly with these <code>ModuleCat R</code> without the mediation of an equivalence of categories.</p>\n<p>What I suggest is to define a typeclass <code>Is(Pre)FiberedCategory</code>, construct a <code>HasFibers</code> as a definition (not an instance), and for the subsequent constructions, add an <code>[F.HasFibers]</code>, provide a <code>HasClivage</code> definition, and subsequently add the <code>[F.HasClivage]</code> assumption.</p>\n</blockquote>\n<p>Oh okay, but in such examples wouldn't one want to consider the pseudo-functor instead?</p>",
        "id": 402883025,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1700319058
    },
    {
        "content": "<p>I think we would like to be able to relate fibered categories and clivages.</p>",
        "id": 402883456,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700319446
    },
    {
        "content": "<p>Yeah but shouldn't I then prove some theorems about relating fibered category + clivage to a pseudo-functor?</p>",
        "id": 402885519,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1700320847
    },
    {
        "content": "<p>Absolutely. Results which can be phrased purely in terms of the fibered category <code>F</code> can be stated and proved this way, and statement involving the inverse image functor for this fibered category should be phrased under <code>F.HasFibers</code> or <code>F.HasClivage</code>.</p>",
        "id": 402918110,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700344864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/402918110\">said</a>:</p>\n<blockquote>\n<p>Absolutely. Results which can be phrased purely in terms of the fibered category <code>F</code> can be stated and proved this way, and statement involving the inverse image functor for this fibered category should be phrased under <code>F.HasFibers</code> or <code>F.HasClivage</code>.</p>\n</blockquote>\n<p>Oh okay I might understand more what you're saying now. So F.HasFibers should basically be a category <code>F.fiber b</code> for every <code>b</code>,  and these should come with equivalences to <code>F.preimagefiber b</code>? And basically I just need to prove all my statements about the inverse image functor pass through equivalences, so the user doesn't have to do that each time. Or is the equivalence with the preimage fiber already too cumbersome somehow? And I should phrase it some other way?</p>",
        "id": 403002085,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1700393321
    },
    {
        "content": "<p>That is essentially what I suggest. Instead of the data of an equivalence of categories, the data for each <code>F.fiber b</code> might be implemented as the data of a functor <code>i b : F.fiber b ⥤ E</code> with an isomophism <code>i b ⋙ F</code> with the constant functor <code>b</code>, and the property that the induced functor to <code>F.preimagefiber b</code> is an equivalence. Then, all you subsequent constructions could be done as much directly with <code>F.fiber b</code> rather than <code>F.preimagefiber b</code> so that you would not even need to pass through equivalences!</p>",
        "id": 403004523,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700395517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/403004523\">said</a>:</p>\n<blockquote>\n<p>That is essentially what I suggest. Instead of the data of an equivalence of categories, the data for each <code>F.fiber b</code> might be implemented as the data of a functor <code>i b : F.fiber b ⥤ E</code> with an isomophism <code>i b ⋙ F</code> with the constant functor <code>b</code>, and the property that the induced functor to <code>F.preimagefiber b</code> is an equivalence. Then, all you subsequent constructions could be done as much directly with <code>F.fiber b</code> rather than <code>F.preimagefiber b</code> so that you would not even need to pass through equivalences!</p>\n</blockquote>\n<p>Ohhhh okay. Thank you so much! I will try to implement this :)</p>",
        "id": 403261771,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1700522145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/403004523\">said</a>:</p>\n<blockquote>\n<p>That is essentially what I suggest. Instead of the data of an equivalence of categories, the data for each <code>F.fiber b</code> might be implemented as the data of a functor <code>i b : F.fiber b ⥤ E</code> with an isomophism <code>i b ⋙ F</code> with the constant functor <code>b</code>, and the property that the induced functor to <code>F.preimagefiber b</code> is an equivalence. Then, all you subsequent constructions could be done as much directly with <code>F.fiber b</code> rather than <code>F.preimagefiber b</code> so that you would not even need to pass through equivalences!</p>\n</blockquote>\n<p>Sorry, I actually still don't understand this. What is this induced morphism to <code>F.preimagefiber b</code> you are thinking of? I see a non-canonical morphism given by taking pullbacks over the natural isomorphism to the constant functor, but this involves a lot of choices. Also, wouldn't requiring the user to show that this induced morphism is an equivalence also just be the same amount of work as forcing the user to supply an equivalence with <code>F.preimagefiber b</code> in the first place?</p>\n<p>Maybe I should try to \"axiomatize\" the properties that a <code>Fib b</code> should satisfy without mentioning the preimage fiber. So for example, as you suggested it would be the data of a functor <code>i b : Fib b ⥤ E</code> with an isomorphism <code>i b ⋙ F</code> to the constant functor <code>b</code>. I would then also demand that one can choose pullbacks compatible with <code>Fib</code> in a suitable way, that the functors are faithful, jointly surjective and possible some more axioms as I need them. But again I don't know how much less work this would be than just forcing the user to just supply the equivalence in the first place.</p>",
        "id": 403820234,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1700757212
    },
    {
        "content": "<p>If <code>F.preimagefiber b</code> consists of <code>X : E</code> equipped with an iso between <code>F.obj X</code> and <code>b</code>, then with the data I suggest, we have a canonical functor <code>Fib b ⥤ F.preimagefiber b</code>.</p>",
        "id": 403845504,
        "sender_full_name": "Joël Riou",
        "timestamp": 1700766759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132603\">@Calle Sönne</span> and now have set up a basic theory of fibered categories and we now have <a href=\"https://github.com/Paul-Lez/Stacks-project\">a definition of Stacks here</a> if anyone is interested in having a look!</p>\n<p>We're hoping to eventually PR some of this stuff to mathlib so any feedback would be more than welcome!</p>\n<p>At the moment, stating the stack condition is quite cumbersome (notably because of a lot of canonical isomorphism having to be used to identify various objects), so there's probably a lot of room for improvement. One idea Calle and I have been discussing is defining a data type <code>descent data</code> and constructing some API about it.</p>",
        "id": 406570739,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1701964106
    },
    {
        "content": "<p>For instance we could have a predicate saying when the descent data is effective, which would correspond to the <code>objects_glue</code> condition in our definition</p>",
        "id": 406571120,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1701964242
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/leanprover-community/mathlib4/pull/8661\">#8661</a> introduces <a href=\"https://github.com/leanprover-community/mathlib4/blob/descent/Mathlib/CategoryTheory/Sites/Descent.lean#L74-L95\">SheafDescentData</a><br>\nand there are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicGeometry.SheafedSpace.GlueData#doc\">docs#AlgebraicGeometry.SheafedSpace.GlueData</a> etc. too, which might be unified under the same framework.</p>",
        "id": 406574427,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1701965068
    },
    {
        "content": "<p>About descent data, in a draft PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/8661\">#8661</a> I formalize the fact that sheaves can be glued: if <code>(C, J)</code> is a site and <code>Y : I → C</code> are objects which \"cover the final object\", then there is an equivalence of categories between the category of sheaves over <code>C</code> and a category <code>SheafDescentData</code> whose objects consists of families of sheaves over each of the sites <code>Over (Y i)</code> equipped with a descent data (i.e. isomorphisms which satisfy some compatibilites...), see <a href=\"https://github.com/leanprover-community/mathlib4/pull/8661/files#diff-fdd776e556488ad2ff22be948bb4fbccc55fbb4c7871ba7be6f82eab205f3a4aR74-R94\">https://github.com/leanprover-community/mathlib4/pull/8661/files#diff-fdd776e556488ad2ff22be948bb4fbccc55fbb4c7871ba7be6f82eab205f3a4aR74-R94</a> . With some modifications, similar definitions could be done for general fibered categories.</p>",
        "id": 406574610,
        "sender_full_name": "Joël Riou",
        "timestamp": 1701965117
    },
    {
        "content": "<p>Oh that sounds great! I was hoping someone had come up with a neater way to package this type of information!</p>",
        "id": 406575028,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1701965223
    },
    {
        "content": "<p>Calle and I will try and adapt our stuff to the framework you've set up</p>",
        "id": 406575653,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1701965413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398890979\">said</a>:</p>\n<blockquote>\n<p>Assuming <code>[F.HasFibres]</code>, one may introduce a typeclass containing the data of the inverse image functors <code>Fib b ⥤ Fib b'</code> and the data of the composition morphisms satisfying the expected cocycle conditions: this would be <code>[F.HasClivage]</code>. Then, one may show <code>F.IsFibered</code> iff the composition morphisms are isos. (Here again, given a prefibered category such that <code>[F.HasFibres]</code>, we should provide a constructor for <code>F.HasClivage</code>.)</p>\n</blockquote>\n<p>How would one show that the category is fibered here, given that there is a clivage such that the composition morphisms are isos? I don't see how this notion of <code>HasClivage</code> contains any information about morphisms between different fibers.</p>\n<p>Also, thank you so much for the help with this so far! Me and <span class=\"user-mention\" data-user-id=\"376152\">@Paul Lezeau</span> have now got a working notion of <code>HasFibers</code> like you suggested :)</p>",
        "id": 431748270,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1712481809
    },
    {
        "content": "<p>Let me give more details. According to SGA I VI 6.1, a functor is a \"catégorie préfibrée\" if the pullback functor exists for all morphisms in the base category. This can be formulated as a property of <code>F</code> (this could be phrased as a typeclass <code>F.IsPrefibered : Prop</code>).</p>\n<p>Then, assuming <code>F.IsPrefibered</code>, one may extend <code>[F.HasFibers]</code> to define <code>[F.HasClivage]</code>, which would be the data of such functors <code>pullback f : Fib b ⥤ Fib b'</code> for all morphisms <code>f</code>. Then, the pullback by an identity morphism is isomorphic to the identity functor, and the pullback functor by a composition of morphisms has a natural transformation from the composition of the pullback functors. These natural transformations satisfy certain coherence properties.</p>\n<p>Then, one may define <code>F.IsFibered : Prop</code> by extending <code>F.IsPrefibered</code> and requesting that the composition of two cartesian morphisms is cartesian. Finally, one may prove that if we have <code>F.HasClivage</code>, then <code>F.IsFibered</code> iff the natural transformations which relate the composition of two pullback functors and the pullback by the composition for the given clivage are isomorphisms (this is SGA I VI 7.2).</p>",
        "id": 431794019,
        "sender_full_name": "Joël Riou",
        "timestamp": 1712508638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/431794019\">said</a>:</p>\n<blockquote>\n<p>Let me give more details. According to SGA I VI 6.1, a functor is a \"catégorie préfibrée\" if the pullback functor exists for all morphisms in the base category. This can be formulated as a property of <code>F</code> (this could be phrased as a typeclass <code>F.IsPrefibered : Prop</code>).</p>\n<p>Then, assuming <code>F.IsPrefibered</code>, one may extend <code>[F.HasFibers]</code> to define <code>[F.HasClivage]</code>, which would be the data of such functors <code>pullback f : Fib b ⥤ Fib b'</code> for all morphisms <code>f</code>. Then, the pullback by an identity morphism is isomorphic to the identity functor, and the pullback functor by a composition of morphisms has a natural transformation from the composition of the pullback functors. These natural transformations satisfy certain coherence properties.</p>\n<p>Then, one may define <code>F.IsFibered : Prop</code> by extending <code>F.IsPrefibered</code> and requesting that the composition of two cartesian morphisms is cartesian. Finally, one may prove that if we have <code>F.HasClivage</code>, then <code>F.IsFibered</code> iff the natural transformations which relate the composition of two pullback functors and the pullback by the composition for the given clivage are isomorphisms (this is SGA I VI 7.2).</p>\n</blockquote>\n<p>Oh this is perfect, thanks a lot! I seem to have had the wrong impression of what <code>IsPrefibered</code> should mean, now it all makes sense.</p>",
        "id": 431804588,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1712514975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398891020\">said</a>:</p>\n<blockquote>\n<p>(Similarly, in my formalization of <code>t</code>-structures on triangulated categories, I have defined a type class <code>t.HasHeart</code> where the user may provide a category and an embedding into the triangulated category. Doing so, I may ensure that the heart of the derived category of an abelian category <code>A</code> is the category <code>A</code>, by definition! Otherwise, I would have to compose with equivalences of categories... I think we could do similar things for fibered categories.)</p>\n</blockquote>\n<p>How did you deal with functoriality for <code>t.HasHeart</code>? Did you additionally require your functors to preserve the <code>HasHeart</code> structure, or was there some way to get around that? I looked around in mathlib for t-structures but I couldn't seem to find it, I guess you have the code in some separate repository somewhere?</p>",
        "id": 432548379,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1712768390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132603\">Calle Sönne</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/432548379\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/398891020\">said</a>:</p>\n<blockquote>\n<p>(Similarly, in my formalization of <code>t</code>-structures on triangulated categories, I have defined a type class <code>t.HasHeart</code> where the user may provide a category and an embedding into the triangulated category. Doing so, I may ensure that the heart of the derived category of an abelian category <code>A</code> is the category <code>A</code>, by definition! Otherwise, I would have to compose with equivalences of categories... I think we could do similar things for fibered categories.)</p>\n</blockquote>\n<p>How did you deal with functoriality for <code>t.HasHeart</code>? Did you additionally require your functors to preserve the <code>HasHeart</code> structure, or was there some way to get around that? I looked around in mathlib for t-structures but I couldn't seem to find it, I guess you have the code in some separate repository somewhere?</p>\n</blockquote>\n<p>(I should add that I know very little about <code>t</code>-structures, so maybe what I am saying about functoriality makes no sense.)</p>",
        "id": 432548792,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1712768518
    },
    {
        "content": "<p>I plan to PR <code>t</code>-structures to mathlib, but it will take a certain time... My draft code is in a mathlib branch <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Triangulated/TStructure/Basic.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Triangulated/TStructure/Basic.lean</a><br>\n(In general, triangulated functors do not respect the heart of t-structures.)</p>",
        "id": 432619147,
        "sender_full_name": "Joël Riou",
        "timestamp": 1712803766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/432619147\">said</a>:</p>\n<blockquote>\n<p>I plan to PR <code>t</code>-structures to mathlib, but it will take a certain time... My draft code is in a mathlib branch <a href=\"https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Triangulated/TStructure/Basic.lean\">https://github.com/leanprover-community/mathlib4/blob/jriou_localization/Mathlib/CategoryTheory/Triangulated/TStructure/Basic.lean</a><br>\n(In general, triangulated functors do not respect the heart of t-structures.)</p>\n</blockquote>\n<p>Thanks a lot!</p>",
        "id": 432669573,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1712829707
    },
    {
        "content": "<p>Do anyone have any advice on how to define functoriality for this <code>HasFibers</code> class? </p>\n<p>To recap what was said before, if we have a fibered category <code>p : X ⥤ S</code> (or just a functor) then <code>p.HasFibers</code> is defined as a collection of categories <code>Fib s</code> for each <code>s : S</code> equiped with functors <code>ι s : Fib s ⥤ X</code>  such that the composition <code>ι s ⋙ p</code> is the constant functor mapping to <code>S</code> +  the induced map to the normal fibers is an equivalence. So the point is that often there is a natural choice of fiber categories, e.g. for the fibered category of modules over the category of rings we would like the fiber over a ring <code>R</code> to be the category <code>Mod R</code>.</p>\n<p>So far I have defined functors between different fibered categories <code>p, q</code> with <code>p.HasFibers</code> and <code>q.HasFibers</code> as a normal functor of fibered categories + functors between all the fiber categories <code>p.Fib S</code> and <code>q.Fib S</code> such that these are compatible with the functor on underlying fibered categories. Now this works decently, and I've managed to show that a functor is full resp. faithful iff all the functors between the fiber categories are. I've almost showed that this is true for equivalences of fibered categories as well. </p>\n<p>The problem is that I feel its a bit annoying to have to define the functors on the fibers, as these are completely determined by the underlying functor on the fibered category anyways. Another alternative would be to define functors between <code>p</code> and <code>q</code> to be a functor of fibered categories + the condition that any element in the image of some <code>p.Fib s</code> gets mapped to something in the image of <code>q.Fib s</code>. From this one could reconstruct the functors on the fibers. This feels more convenient to verify when defining the functors, but I guess then the problem would be that the functor on the fiber categories would be quite inexplicit.</p>\n<p>Does anyone have any ideas one what would be a good approach here? I think my problem is that I don't have enough experience with lean to tell if what I'm doing is unnecessarily complicated or not.</p>",
        "id": 434386167,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713540574
    },
    {
        "content": "<p>I would imagine you could phrase something in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Pseudofunctor#doc\">docs#CategoryTheory.Pseudofunctor</a> and morphisms of pseudofunctors. I don't really know much about the API for the (bi)category of pseudofunctors, assuming it even exists! I think <span class=\"user-mention\" data-user-id=\"438192\">@Yuma Mizuno</span> is the correct person to ask.</p>",
        "id": 434386463,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713540677
    },
    {
        "content": "<p>Yeah, I feel <code>HasFibers</code> is really something in between fibered categories and pseudofunctors.</p>",
        "id": 434386593,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713540721
    },
    {
        "content": "<p>So maybe I should not define functors for the <code>HasFibers</code> class, but wait until I have <code>HasClivage</code> as well and in that setting associate a pseudofunctor for which its a lot more convenient to define functors in terms of the fibers</p>",
        "id": 434386942,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713540820
    },
    {
        "content": "<p>Can you define a pseudofunctor associated to an instance of <code>HasFibers</code>?</p>",
        "id": 434387418,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713540970
    },
    {
        "content": "<p>I my understanding the data of a \"functor\" between two fibered categories (over the same base category) should not involve the data of <code>HasFibers</code>. But, when the source and target categories both have a clivage, it should make sense to state that the \"global\" functor is compatible with the extra data of a bunch of functors on the fibers (+ many compatibilities).</p>",
        "id": 434387570,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713541028
    },
    {
        "content": "<p>Oh I see, yeah I agree.</p>",
        "id": 434388246,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713541252
    },
    {
        "content": "<p>I honestly wasn’t sure what Calle meant about “functoriality” until I saw Joël’s message</p>",
        "id": 434388538,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713541333
    },
    {
        "content": "<p>BTW, it’s not clear to me that we should use the type class system for things like HasFibers. Why not just make a structure that bundles all the stuff for a fibred category over a given category C?</p>",
        "id": 434392233,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713542513
    },
    {
        "content": "<p>Usually, we do not introduce two different cleavages for the same fibered category, so that using a class makes sense. Using structures would presumably be equally ok.</p>",
        "id": 434392736,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713542655
    },
    {
        "content": "<p>IIUC, a cleavage still contains data, and presumably one could talk about isomorphisms of such data, which could still be useful to talk about in the context of formalization.</p>",
        "id": 434394093,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1713543054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"420917\">@Sina 𓃵</span> You probably are interested in this thread</p>",
        "id": 434397017,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1713544026
    },
    {
        "content": "<p>Sure, but in a similar situation (actually a special case), a category <code>C</code> may be equipped with a shift by a monoid <code>[HasShift C M]</code> (the data of the shift functors can be understood as the cleavage for a fibered category), but we have not defined the notion of isomorphism between two shifts on the same category.</p>\n<p>However, when we have a functor <code>F : C ⥤ D</code> between two categories equipped with a shift by <code>M</code>, I have formalized the type class <code>F.CommShift M</code> which expresses that <code>F</code> \"commutes\" with the shift (data of isomorphisms + compatibilites). This is an important notion (and what I suggest is a kind of generalization of this). Still, if we absolutely need to do that, we may say that two <code>HasShift C M</code> are isomorphic by constructing a <code>F.CommShift M</code> term for <code>F</code> the identity functor (with different shifts on the source and target).</p>",
        "id": 434397489,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713544194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/116395-maths/topic/Formalizing.20stacks/near/434387570\">said</a>:</p>\n<blockquote>\n<p>I my understanding the data of a \"functor\" between two fibered categories (over the same base category) should not involve the data of <code>HasFibers</code>. But, when the source and target categories both have a clivage, it should make sense to state that the \"global\" functor is compatible with the extra data of a bunch of functors on the fibers (+ many compatibilities).</p>\n</blockquote>\n<p>Okay I agree that this would make more sense, but wouldnt you still want theorems about these global functors that says that its faithfull/full/an equivalence iff it is so on all the fibers? I guess maybe then I should just prove these statements in terms of the \"canonical\" fibers, and leave the <code>HasFibers</code> stuff for whenever I have a clivage also.</p>",
        "id": 434399745,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713545086
    },
    {
        "content": "<p>Because I guess its unnecessary to fix a clivage in order to prove these statements.</p>",
        "id": 434399958,
        "sender_full_name": "Calle Sönne",
        "timestamp": 1713545171
    },
    {
        "content": "<p>Ok, there are three layers: 1) the fibered categories (as a functor), 2) the data of categories which are the fibers, 3) cleavages (the additional data of functors between the fibers).<br>\nThe notion of functor <code>F</code> between two fibered categories (over the same base category) makes sense without any reference to 2) or 3), but when we have 2) + a compatibility of <code>F</code> and 2) [indeed 3) should not be necessary here], then there should be theorems like you mention.</p>",
        "id": 434404641,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713547047
    },
    {
        "content": "<p>Re clivages, I will hopefully start working on these soon so we can start incorporating them in this stuff</p>",
        "id": 434410623,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1713549779
    },
    {
        "content": "<p>BTW, I've seen the phrase \"cleaving\" in place of the older \"cleavage\", which to my mind us a better term to use, for hopefully obvious reasons.</p>",
        "id": 434580734,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1713697651
    },
    {
        "content": "<p>They are only obvious to people who are enough fluent in non-mathematical English.</p>",
        "id": 434592947,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713709888
    },
    {
        "content": "<p>And they are not present at all in the French word \"clivage\".</p>",
        "id": 434593027,
        "sender_full_name": "Joël Riou",
        "timestamp": 1713709935
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 434610246,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713725047
    },
    {
        "content": "<p>This is true, and yet the word 'cleavage' is a word for a part of female anatomy. Like the conference NeurIPS is no longer called NIPS, it is possible to change our terms of art.</p>\n<p>Cleaving is a perfectly good synomym to my mind that carries no baggage whatsoever. :-)</p>",
        "id": 434910236,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1713853269
    },
    {
        "content": "<p>The Coq/Rocq change is another example of such a desirable move.</p>",
        "id": 434924482,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1713858546
    },
    {
        "content": "<p>I'd like to post here about a few questions I have about stacks, maybe ones that can be answered from the work here:</p>\n<ul>\n<li>Bhatt-Scholze established a \"pro-étale\" site, but is there a \"pro-flat\" site? Is there a unification of the two different flat sites via the notion of pro (finite - presentation)?</li>\n<li>Faithfully flat maps are effective descent morphisms. Faithfully flat is equivalent to flat and flat-locally surjective. Do we have proofs of these?</li>\n</ul>",
        "id": 446194562,
        "sender_full_name": "E. Dean Young",
        "timestamp": 1719012831
    },
    {
        "content": "<p>On the level of affine schemes, what ring-theoretic morphisms would a pro-flat site have that faithfully flat does not have?  I would naively guess that flat is the same as pro-flat.</p>",
        "id": 446228113,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1719036576
    },
    {
        "content": "<p>The covers in the pro-étale site of <code>X</code> are defined as fpqc covers (involving weakly-étale schemes over <code>X</code>). Then, I do not think that there is a thing called \"pro-flat\".</p>",
        "id": 446273447,
        "sender_full_name": "Joël Riou",
        "timestamp": 1719063447
    }
]