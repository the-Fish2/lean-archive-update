[
    {
        "content": "<p>is this <code>sorry</code> below fillable without assuming <code>Classical.choice</code>? The <code>axiom</code> being assumed is a reasonable-looking version of the statement that every set has a well order. In set theory, this obviously implies choice, since 'minimum wrt a well-ordering on an appropriate sigma-type' works as a choice function. </p>\n<p>But it seems there is a nuance with the type theory version; since 'min' is defined as an existential and not a function, the existence of a <code>WellOrder</code> for every type doesn't give a choice function. So I'm guessing the answer is no. </p>\n<p>Thinking in the other direction : presumably <code>wellOrderingPrinciple</code> as below still can't be proven without assuming choice. So how powerful is the world I'm in if <code>wellOrderingPrinciple</code> is an axiom? </p>\n<p>Can someone fill in this picture for me? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">WellOrder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">antisymm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_min</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">S.Nonempty</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">wellOrderingPrinciple</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">WellOrder</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Classical.axiomOfChoice'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 437745221,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1715210017
    },
    {
        "content": "<p>I guess it is not. Without any additional choice besides yours, one can obtain a subset <code>σ</code> of  <code>Σ (x : α), β x</code> and a map <code>p : σ → α</code> which is bijective,  but its inverse map is not deducible without choice (contrary to what is possible in set theory). </p>\n<p>The code below proves that (presumably without choice) but the end of it (that takes the inverse) uses <code>Classical.choice</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">WellOrder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">antisymm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">exists_min</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">S.Nonempty</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">wellOrderingPrinciple</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">WellOrder</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Classical.axiomOfChoice'</span>\n    <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">θ</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">x</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">wO</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">wellOrderingPrinciple</span> <span class=\"n\">θ</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">wO</span>\n  <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">θ</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">u</span> <span class=\"bp\">∧</span> <span class=\"n\">r</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">}</span>\n  <span class=\"k\">have</span> <span class=\"n\">S_ne</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Nonempty</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">x</span>\n    <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hy</span>\n  <span class=\"k\">let</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">θ</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"n\">wO.le</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">z</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span>\n  <span class=\"k\">have</span> <span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Function.Bijective</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩,</span> <span class=\"n\">hxy</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟨</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span><span class=\"o\">⟩,</span> <span class=\"n\">hxy'</span><span class=\"o\">⟩</span> <span class=\"n\">h</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hxy</span> <span class=\"n\">hxy'</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">wO.antisymm</span>\n      <span class=\"bp\">·</span> <span class=\"n\">subst</span> <span class=\"n\">h</span>\n        <span class=\"n\">apply</span> <span class=\"n\">hxy.2</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hxy'.1</span>\n      <span class=\"bp\">·</span> <span class=\"n\">subst</span> <span class=\"n\">h</span>\n        <span class=\"n\">apply</span> <span class=\"n\">hxy'.2</span>\n        <span class=\"n\">exact</span> <span class=\"n\">hxy.1</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">⟩,</span> <span class=\"n\">hb_mem</span><span class=\"o\">,</span> <span class=\"n\">hb_le</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">wO.exists_min</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S_ne</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hb_mem</span>\n      <span class=\"n\">use</span> <span class=\"o\">⟨⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hb_mem.1</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">hb_mem.2</span>\n      <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">z</span> <span class=\"n\">hz</span>\n        <span class=\"n\">apply</span> <span class=\"n\">hb_le</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span>\n        <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hb_mem.1</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Function.bijective_iff_has_inverse.mp</span> <span class=\"n\">hp</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Function.LeftInverse</span><span class=\"o\">,</span> <span class=\"n\">Function.RightInverse</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hl</span> <span class=\"n\">hr</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">hg</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prop</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">x</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val.snd</span><span class=\"o\">)</span>\n  <span class=\"n\">use</span> <span class=\"n\">f</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hr</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">Classical.axiomOfChoice'</span>\n</code></pre></div>",
        "id": 437851332,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715273192
    },
    {
        "content": "<p>The point, AFAIR, is that in type theory, a map <code>f : α → Set β</code> such that <code>∀ a, Singleton (f a)</code> cannot be refined into a map <code>φ : α → β</code> such that <code>∀ a, f a = { φ a }</code>. (From a constructive point of view, this is clear, knowing that a unique solution exists doesn't give you any information about how to get it.)</p>",
        "id": 437851681,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715273351
    },
    {
        "content": "<p>Thank you! It seems funny having a intermediate 'weak well-ordering principle' that is weaker than choice, even if it feels very strong.</p>",
        "id": 437907720,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1715301633
    },
    {
        "content": "<p>Well, this is one point where type theory and set theory differ. I remember that the HOTT book has a discussion about that. There, there are 3 “obvious” choice principles, one is true, the other is an axiom, and the last one is false.</p>",
        "id": 438057092,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715381276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/116395-maths/topic/Choice.20and.20well-ordering/near/437851681\">said</a>:</p>\n<blockquote>\n<p>The point, AFAIR, is that in type theory, a map <code>f : α → Set β</code> such that <code>∀ a, Singleton (f a)</code> cannot be refined into a map <code>φ : α → β</code> such that <code>∀ a, f a = { φ a }</code>. (From a constructive point of view, this is clear, knowing that a unique solution exists doesn't give you any information about how to get it.)</p>\n</blockquote>\n<p>Just want to point out that this is a feature of Lean's type theory in particular, and is not the case in univalent type theories (edit: possibly you need to assume <code>β</code> is 0-truncated, which is true by default in lean) or in the internal logic of a topos (these both satisfy the \"axiom of unique choice\")</p>",
        "id": 440197381,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1716417770
    }
]