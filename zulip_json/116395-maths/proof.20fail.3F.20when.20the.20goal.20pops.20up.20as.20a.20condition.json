[
    {
        "content": "<p>Something funny happened in my formalization of the infinitude of primes by Euler (proof 4 in chapter 1 of Aigner &amp; Ziegler's \"Proofs from THE BOOK\", 6th ed.): <strong><em>The infinitude itself is needed by the proof</em></strong>. Before jumping to the conclusion that the proof is defect, I'll assume that my formalization is incorrect.</p>\n<p><a href=\"/user_uploads/3121/HjpC0D77CScwU4OlfhAgqYzW/image.png\">image.png</a><br>\nThe appended page from the book is marked at the critical point, where it says \"Now clearly, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>≥</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\"> p_k \\ge k+1 </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>\". Yes, clearly this holds for all primes, but to show it, have a look at what's needed to prove it in Lean:</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/HjpC0D77CScwU4OlfhAgqYzW/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/HjpC0D77CScwU4OlfhAgqYzW/image.png\"></a></div><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">autoImplicit</span> <span class=\"n\">false</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Finset</span> <span class=\"n\">Nat</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Filter</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zeroth_prime_eq_two</span> <span class=\"o\">:</span> <span class=\"n\">nth</span> <span class=\"n\">Nat.Prime</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">nth_count</span> <span class=\"n\">prime_two</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">nth_prime_ge_add_two</span> <span class=\"o\">:</span> <span class=\"n\">nth</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span>\n  <span class=\"bp\">.</span> <span class=\"n\">norm_num</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">le_iff_eq_or_lt</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Or.inl</span> <span class=\"n\">zeroth_prime_eq_two.symm</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">succ_eq_add_one</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">add_le_add_iff_right</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ih</span>\n    <span class=\"n\">norm_num</span> <span class=\"n\">at</span> <span class=\"n\">ih</span>\n    <span class=\"n\">simp_arith</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">nth</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">nth</span> <span class=\"n\">Nat.Prime</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">succ_le_iff</span><span class=\"o\">,</span> <span class=\"n\">nth_lt_nth</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">lt_add_one</span> <span class=\"n\">n</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"n\">exact</span> <span class=\"n\">LE.le.trans</span> <span class=\"n\">ih</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>The state at the <code>sorry</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"n\">case</span> <span class=\"n\">hf</span>\n      <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">n</span><span class=\"bp\">✝</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n      <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"bp\">≤</span> <span class=\"n\">nth</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n      <span class=\"bp\">⊢</span> <span class=\"n\">Set.Infinite</span> <span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"n\">Nat.Prime</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The only idea I have is that, in the proof, the statement can be constructed to not be about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>p</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">p_k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in general, but those with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>π</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k \\le \\pi(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>, but then, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> is not bounded, either. What is my misconception here?</p>",
        "id": 437428550,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715079893
    },
    {
        "content": "<p>Isn't <code>exact infinite_setOf_prime</code> what you need to fill the sorry here?</p>",
        "id": 437429711,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1715080400
    },
    {
        "content": "<p>A workaround seems possible if there was a version of <code>nth_lt_nth</code> that does not depend on <code>Set.Infinite</code>?</p>",
        "id": 437429762,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715080425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"313038\">Moritz Firsching</span> <a href=\"#narrow/stream/116395-maths/topic/proof.20fail.3F.20when.20the.20goal.20pops.20up.20as.20a.20condition/near/437429711\">said</a>:</p>\n<blockquote>\n<p>Isn't <code>exact infinite_setOf_prime</code> what you need to fill the sorry here?</p>\n</blockquote>\n<p>Yeah but use the fact to prove it---wouldn't that be cheating?</p>",
        "id": 437429923,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715080479
    },
    {
        "content": "<p>Ah, I see the problem now.</p>",
        "id": 437430527,
        "sender_full_name": "Moritz Firsching",
        "timestamp": 1715080702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"707242\">Ralf Stephan</span> <a href=\"#narrow/stream/116395-maths/topic/proof.20fail.3F.20when.20the.20goal.20pops.20up.20as.20a.20condition/near/437428550\">said</a>:</p>\n<blockquote>\n<p>The only idea I have is that, in the proof, the statement can be constructed to not be about pk​ in general, but those with k≤π(x), but then, x is not bounded, either. What is my misconception here?</p>\n</blockquote>\n<p>You will have introduced <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>, so you will be in a context where it is a constant.</p>",
        "id": 437434078,
        "sender_full_name": "Richard Copley",
        "timestamp": 1715082131
    },
    {
        "content": "<p>I think the problem here is with your use of Nat.nth</p>",
        "id": 437434371,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1715082236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"707242\">Ralf Stephan</span> <a href=\"#narrow/stream/116395-maths/topic/proof.20fail.3F.20when.20the.20goal.20pops.20up.20as.20a.20condition/near/437429762\">said</a>:</p>\n<blockquote>\n<p>A workaround seems possible if there was a version of <code>nth_lt_nth</code> that does not depend on <code>Set.Infinite</code>?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">Nat.nth_lt_nth'</span>\n\n<span class=\"n\">Nat.nth_lt_nth'</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hlt</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">setOf</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">hf.toFinset.card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nth</span> <span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">nth</span> <span class=\"n\">p</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 437443813,
        "sender_full_name": "A.",
        "timestamp": 1715085521
    },
    {
        "content": "<p>Thanks. I think now, it should work to assume a finite set of primes of suitable cardinality and work with that.</p>",
        "id": 437463521,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715091199
    },
    {
        "content": "<p>And probably it's time to start a blueprint of that proof  <span aria-label=\"working on it\" class=\"emoji emoji-1f6e0\" role=\"img\" title=\"working on it\">:working_on_it:</span> , even if it's trivial for most of you.</p>",
        "id": 437471808,
        "sender_full_name": "Ralf Stephan",
        "timestamp": 1715093800
    }
]