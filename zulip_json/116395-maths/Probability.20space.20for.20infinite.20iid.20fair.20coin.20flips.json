[
    {
        "content": "<p>I am interested in learning about the different ways one can construct a probability space for infinite iid fair coin flips in lean4 and potentially using mathlib4. </p>\n<p>I am currently doing it using a pre-existing <a href=\"https://github.com/RemyDegenne/kolmogorov_extension4/blob/183d5b2dfa9ab01c5b22d7ebf69112aa73df2727/KolmogorovExtension4/CaratheodoryExtension.lean#L309\">formalization of the Caratheodory extension theorem</a> and adapting from the algebra of sets described in <a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-566.pdf\">Joe Hurd's dissertation on verification of randomized algorithms</a>.</p>\n<p>While it seems to me like a reasonable construction, I am wondering if perhaps this has already been done, or if there is a simpler way to do it. What made me wonder is <a href=\"https://github.com/leanprover-community/mathlib4/blob/9d8e1c0bf00abbaab69ed8397d6b4fea3e7f5c84/Mathlib/MeasureTheory/MeasurableSpace/Basic.lean#L1203\">a comment in mathlib4</a> just before an instance of a relevant measurable space. </p>\n<p>Thank you.</p>",
        "id": 417455940,
        "sender_full_name": "John Tristan",
        "timestamp": 1706019714
    },
    {
        "content": "<p>This has not been done, and the way you linked to would indeed be the easiest way to do it as of now (I think). I think the primary reason it is not done is that we want arbitrary (not just countable) products of probability spaces in full generality (see <a href=\"https://math.stackexchange.com/questions/1797899/infinite-product-probability-spaces\">this</a>).</p>",
        "id": 420519105,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1707417436
    },
    {
        "content": "<p>admittedly this is an overkill for countable iid Bernoulli which is easy from Caratheodory extension or Kolmogorov extension.</p>",
        "id": 420519518,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1707417586
    },
    {
        "content": "<p>The comment refers to the MeasurableSpace structure on Pi types Set a, i.e. a -&gt; Prop (in your application Nat -&gt; Bool), but no Measure is defined on this space yet</p>",
        "id": 420520761,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1707418073
    },
    {
        "content": "<p>fwiw, iirc there is also a result that says something along the lines of that a space admits an infinite iid sequence of coin flips iff it admits a continuous random variable. Not sure what the result is called though</p>",
        "id": 420521669,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1707418389
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/Probability.20projects/near/403677790\">related previous discussion</a></p>",
        "id": 420521966,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1707418504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673728\">Josha Dekker</span> <a href=\"#narrow/stream/116395-maths/topic/Probability.20space.20for.20infinite.20iid.20fair.20coin.20flips/near/420521669\">said</a>:</p>\n<blockquote>\n<p>fwiw, iirc there is also a result that says something along the lines of that a space admits an infinite iid sequence of coin flips iff it admits a continuous random variable. Not sure what the result is called though</p>\n</blockquote>\n<p>I think that is just relating X ~ U([0,1]) to its binary expansion sequences (modulo cases of 0111... = 1000... which are only countably many hence null)</p>",
        "id": 420522720,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1707418749
    },
    {
        "content": "<p>Ah, maybe then a temporary workaround is you can define countable iid coin flips as pushforward of U([0,1]) through binary expansion. I'm not sure how easy it would be to prove properties of it</p>",
        "id": 420523167,
        "sender_full_name": "Thomas Zhu",
        "timestamp": 1707418898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"631691\">Thomas Zhu</span> <a href=\"#narrow/stream/116395-maths/topic/Probability.20space.20for.20infinite.20iid.20fair.20coin.20flips/near/420523167\">said</a>:</p>\n<blockquote>\n<p>Ah, maybe then a temporary workaround is you can define countable iid coin flips as pushforward of U([0,1]) through binary expansion. I'm not sure how easy it would be to prove properties of it</p>\n</blockquote>\n<p>Yes, that is what I thought, so you don’t need to worry about products of probability spaces.</p>",
        "id": 420524295,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1707419319
    },
    {
        "content": "<p>I had a private discussion with John about this (I did not see this message when it was first posted). Let me repeat the main message of the discussion here: the repository he linked to contains a full proof of the Kolmogorov extension theorem, from which one can very easily get a measure for infinitely many coin flips. Here is some code to do that (with coin flips taking values in the reals):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">KolmogorovExtension4.independentFamily</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">NNReal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Nonempty</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">TopologicalSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">PolishSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">BorelSpace</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">independentFamily'</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">projectiveLimit</span> <span class=\"o\">(</span><span class=\"n\">Measure.subset_pi</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">product_isProjective</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsProbabilityMeasure</span> <span class=\"o\">(</span><span class=\"n\">independentFamily'</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">independentFamily'</span><span class=\"o\">]</span>\n  <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">Bernoulli_half</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">Measure.dirac</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">Measure.dirac</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">Bernoulli_half</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Bernoulli_half</span><span class=\"o\">,</span> <span class=\"n\">Measure.add_toOuterMeasure</span><span class=\"o\">,</span> <span class=\"n\">Measure.smul_toOuterMeasure</span><span class=\"o\">,</span>\n    <span class=\"n\">OuterMeasure.coe_add</span><span class=\"o\">,</span> <span class=\"n\">OuterMeasure.coe_smul</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">add_apply</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">smul_apply</span><span class=\"o\">,</span> <span class=\"n\">MeasurableSet.univ</span><span class=\"o\">,</span>\n    <span class=\"n\">Measure.dirac_apply'</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">Set.indicator_of_mem</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">one_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ENNReal.smul_def</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">OfNat.ofNat_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">not_false_eq_true</span><span class=\"o\">,</span>\n    <span class=\"n\">ENNReal.coe_div</span><span class=\"o\">,</span> <span class=\"n\">ENNReal.coe_ofNat</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ENNReal.add_halves</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ENNReal.coe_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">NBernoulli_half</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">independentFamily'</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Bernoulli_half</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">IsProbabilityMeasure</span> <span class=\"n\">NBernoulli_half</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">NBernoulli_half</span><span class=\"o\">]</span>\n  <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>I am very slowly merging the code of the repository into Mathlib. It's slow because I am refactoring it as I go and because I don't have much time for lean now.</p>",
        "id": 420525615,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1707419806
    }
]