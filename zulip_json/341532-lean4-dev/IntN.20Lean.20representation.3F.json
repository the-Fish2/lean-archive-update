[
    {
        "content": "<p>I'm starting to tinker with how signed fixed-width integer types <code>IntN</code> (similar to Lean's <code>UIntN</code> types) could be efficiently represented.</p>\n<p>Any knee-jerk thoughts on how the underlying Lean representation (i.e., non-C definitions)  might be best modeled?</p>\n<p>At the moment I'm playing around with a type <code>Fin2C n</code> that is a sort of play on <code>Fin</code> but focused on supporting two's complement arithmetic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`Fin2C n` is an integer `i` with the constraint that `-n ≤ i &lt; n`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Fin2C</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"n\">where</span>\n  <span class=\"sd\">/-- If `i : Fin2C n`, then `i.val : ℤ` is the described number. It can also be</span>\n<span class=\"sd\">  written as `i.1` or just `i` when the target type is known. -/</span>\n  <span class=\"n\">val</span>  <span class=\"o\">:</span> <span class=\"n\">Int</span>\n  <span class=\"sd\">/-- If `i : Fin2C n`, then `i.2` is a proof that `-n ≥ i.1`. -/</span>\n  <span class=\"n\">isGe</span> <span class=\"o\">:</span> <span class=\"n\">LE.le</span> <span class=\"o\">(</span><span class=\"bp\">-↑</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">val</span>\n  <span class=\"sd\">/-- If `i : Fin2C n`, then `i.3` is a proof that `i.1 &lt; n`. -/</span>\n  <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">LT.lt</span> <span class=\"n\">val</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>from which you would define <code>Int64</code> as <code>Fin2C 2^63</code>.</p>\n<p>But a more generic, arbitrary finite interval over ℤ could also work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`FinZ n m` is an integer `i` with the constraint that `n ≤ i &lt; n + m`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">FinZ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- If `i : FinZ n m`, then `i.val : ℤ` is the described number. It can also be</span>\n<span class=\"sd\">  written as `i.1` or just `i` when the target type is known. -/</span>\n  <span class=\"n\">val</span>  <span class=\"o\">:</span> <span class=\"n\">Int</span>\n  <span class=\"sd\">/-- If `i : FinZ n m`, then `i.2` is a proof that `n ≤ i.1`. -/</span>\n  <span class=\"n\">isGe</span> <span class=\"o\">:</span> <span class=\"n\">LE.le</span> <span class=\"n\">n</span> <span class=\"n\">val</span>\n  <span class=\"sd\">/-- If `i : FinZ n m`, then `i.3` is a proof that `i.1 &lt; n + m`. -/</span>\n  <span class=\"n\">isLt</span> <span class=\"o\">:</span> <span class=\"n\">LT.lt</span> <span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>from which you would define <code>Int64</code> as <code>FinZ -2^63 2^64</code>.</p>\n<p>Anyway, it's been a while since I've hacked at length in Lean and I'm not far enough along to have strong opinions about which approach is best... any experience-informed biases you have I'd love to hear =)</p>\n<p>(I am just starting to define various <code>Fin2C n</code> defs/lemmas by translating corresponding <code>Fin n</code> definitions at the moment... hoping that trying both approaches will prove to be elucidating.)</p>",
        "id": 410214406,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1703720934
    },
    {
        "content": "<p>my recommendation would be to just have <code>IntN := UIntN</code> with different instances</p>",
        "id": 410214579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703721076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/IntN.20Lean.20representation.3F/near/410214579\">said</a>:</p>\n<blockquote>\n<p>my recommendation would be to just have <code>IntN := UIntN</code> with different instances</p>\n</blockquote>\n<p>Ah, that would gives us some nice representation properties \"for free\" (e.g., we immediately get the compiler using the correct size bitvectors I suspect).</p>\n<p>Is that the right long term representation, though? I.e., would that make some proofs involving <code>IntN</code> values potentially more painful? I.e., since there's no trivial projection to either <code>Nat</code> or <code>Int</code> from an underlying <code>UIntN</code>/<code>Fin</code> representation of an <code>IntN</code>. </p>\n<p>(Ah... but perhaps the last point is less of a concern since most proofs about <code>IntN</code> can't rely on <code>Int</code> theories/lemmas/etc? I haven't done tons of complex proofs over <code>IntN</code> types in practice... so I'm speculating a little here...)</p>",
        "id": 410218863,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1703723677
    },
    {
        "content": "<p>There is a natural map from <code>UIntN</code> to <code>IntN</code> which just wraps</p>",
        "id": 410218932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703723717
    },
    {
        "content": "<p>and this map is the identity function which is even nicer</p>",
        "id": 410218964,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703723740
    },
    {
        "content": "<p>so the only thing that <code>IntN</code> really adds is the <code>toInt</code> function</p>",
        "id": 410219039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703723774
    },
    {
        "content": "<p>Ah, yah so using <code>UIntN</code> under the hood for <code>IntN</code> means sign insensitive operations can just re-use UIntN logic:</p>\n<ul>\n<li>addition</li>\n<li>subtraction</li>\n<li>multiplication</li>\n<li>negation</li>\n<li>bitwise AND</li>\n<li>bitwise OR</li>\n<li>bitwise XOR</li>\n<li>bitwise NOT</li>\n<li>left shift</li>\n</ul>\n<p>and for sign sensitive operations, we would leverage <code>IntN.toInt</code> and <code>IntN.ofInt</code> definitions and then define those operations in whatever terms are most convenient, e.g.:</p>\n<ul>\n<li>division  <code>:= fun (n m : IntN) : IntN := IntN.ofInt (n.toInt / m.toInt)</code></li>\n<li>modulo <code>:= fun (n m : IntN) : IntN := IntN.ofInt (n.toInt % m.toInt)</code></li>\n<li>right shift ...</li>\n<li>comparisons (except equality) ...</li>\n</ul>\n<p>Is reasoning about those projections toInt/ofInt or how the UIntN operation semantics correspond to IntN values going to be too frustrating for lemmas about <code>IntN</code> types? Or is that a reasonable pill to have to swallow once so-to-speak (i.e., for each primitive IntN operations' lemmas) and then it's no longer an issue anyone has to worry about?</p>",
        "id": 410222743,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1703726258
    },
    {
        "content": "<p>I'm not sure how else you would do it. The bigger annoyance is that signed div/mod have really mathematically ugly semantics, which makes it a pain to spec.</p>",
        "id": 410254365,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1703747676
    },
    {
        "content": "<p>I did a quick test and it looks like a structure lets you reuse the compiler representation, but more safety on the operation.  e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Int8</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofUInt</span> <span class=\"o\">::</span>\n  <span class=\"n\">toUInt</span> <span class=\"o\">:</span> <span class=\"n\">UInt8</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Int8.add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int8</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int8</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x.asUInt</span> <span class=\"bp\">+</span> <span class=\"n\">y.asUInt</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 410254945,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1703748064
    },
    {
        "content": "<p>Don't forget comparison functions, which are also sign sensitive.</p>",
        "id": 410264386,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703754456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/IntN.20Lean.20representation.3F/near/410254945\">said</a>:</p>\n<blockquote>\n<p>I did a quick test and it looks like a structure lets you reuse the compiler representation, but more safety on the operation.  e.g.,</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Int8</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofUInt</span> <span class=\"o\">::</span>\n  <span class=\"n\">toUInt</span> <span class=\"o\">:</span> <span class=\"n\">UInt8</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">Int8.add</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Int8</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int8</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x.asUInt</span> <span class=\"bp\">+</span> <span class=\"n\">y.asUInt</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes, in general if your struct has one runtime relevant field and any number of irrelevant fields (such as types, proofs etc.) it will be represented as just the runtime relvant field without any wrapping.</p>",
        "id": 410300404,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1703773215
    },
    {
        "content": "<p>You can also avoid some indirection using <code>structure Int8 extends UInt8</code> but there isn't much to gain in this case.</p>",
        "id": 410302975,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1703774488
    },
    {
        "content": "<p>I have an <a href=\"https://github.com/lecopivo/SciLean/blob/master/SciLean/Data/Int64.lean\">implementation</a> of Int64 but without a spec. (... I should have used UInt64 instead of USize)</p>",
        "id": 410811832,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704184474
    },
    {
        "content": "<p>maybe rename it to <code>ISize</code>?</p>",
        "id": 410811888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704184530
    },
    {
        "content": "<p>Sure if you really care to have the same size as <code>USize</code> but I would rather use the familiar <code>Int64</code> and use <code>UInt64</code> for the internal representation.</p>",
        "id": 410812045,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1704184658
    },
    {
        "content": "<p>Anyone know off the top of their head how to safely cast an <code>int8_t</code> to a bitwise-identical <code>uint8_t</code>?</p>\n<p>I was wondering how one nicely uses these these sorts of representations that use the unsigned ints under the hood (e.g., <a href=\"https://github.com/pnwamk/lean4-int-type-tinkering/blob/main/IntTypeTinkering/IntN/Basic.lean\">here</a>) with native C/C++ code  that uses actual signed integers explicitly... and at least this morning all I'm coming up with are various expressions that I think end up including undefined behavior, lol: <code>reinterpret_cast&lt;uint8_t&amp;&gt;((int8_t&amp;)i8)</code>, <code>*reinterpret_cast&lt;uint8_t*&gt;((int8_t*)&amp;i8)</code>.</p>\n<p>I'll have to look at this more tonight...</p>",
        "id": 410867960,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1704211544
    },
    {
        "content": "<p>I think in C at least, <code>int8_t x = ...; uint8_t y = (uint8_t) x;</code> is not UB? I have no familiarity with C++ though.</p>",
        "id": 410880457,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1704216843
    },
    {
        "content": "<p>It's a shame I can't find an official C++ standard to link to, but the unofficial standards seem to define casts to unsigned as using modulo arithmetic to preserve the expected bit pattern, <code>(uint8_t)</code> should always be correct.</p>",
        "id": 410897592,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704225265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/IntN.20Lean.20representation.3F/near/410897592\">said</a>:</p>\n<blockquote>\n<p>It's a shame I can't find an official C++ standard to link to, but the unofficial standards seem to define casts to unsigned as using modulo arithmetic to preserve the expected bit pattern, <code>(uint8_t)</code> should always be correct.</p>\n</blockquote>\n<p>Ah, okay. I may have read something that got me a little paranoid here. The C-style casts do seem to work in practice… wish it was easier to find a confident/official answer.</p>",
        "id": 410914005,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1704234126
    },
    {
        "content": "<p>I believe that's just standard conversion? <a href=\"https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_conversions\">https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_conversions</a></p>",
        "id": 410914989,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1704234737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/IntN.20Lean.20representation.3F/near/410914989\">said</a>:</p>\n<blockquote>\n<p>I believe that's just standard conversion? <a href=\"https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_conversions\">https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_conversions</a></p>\n</blockquote>\n<p>Ah, thanks for the reference link. I think you're right.</p>\n<p>According to that ref (and experiments seem to confirm):</p>\n<ul>\n<li><code>intN_t</code> =&gt; <code>uintN_t</code> is what we'd intuitively think/expect</li>\n<li><code>uintN_t</code> =&gt; <code>intN_t</code> is technically implementation defined pre C++20 but specified to be what we'd expect C++20 and beyond</li>\n</ul>\n<p>Sounds like a non-issue then <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span> (And perhaps you'd want some tests to confirm the compiler implementation does the latter case as expected if we're not using -std=c++20 or more recent...?)</p>",
        "id": 410921190,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1704238911
    },
    {
        "content": "<p>I did not look up references, but AFAIR the only way that always works is to cast to an array of chars, which alias which everything and then do a memcpy. A good compiler should optimize this away.</p>",
        "id": 410948031,
        "sender_full_name": "Tobias Grosser",
        "timestamp": 1704251345
    },
    {
        "content": "<p>RFC Github issue is up: <a href=\"https://github.com/leanprover/lean4/issues/3162\">https://github.com/leanprover/lean4/issues/3162</a></p>",
        "id": 412175042,
        "sender_full_name": "Andrew Kent",
        "timestamp": 1704903226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"601254\">@Thea Brick</span> said she has an implementation generic across the bit count (originally for wasm) that might be useful here as a model for the <code>IntX</code>s</p>",
        "id": 413077770,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1705378770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/341532-lean4-dev/topic/IntN.20Lean.20representation.3F/near/413077770\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"601254\">Thea Brick</span> said she has an implementation generic across the bit count (originally for wasm) that might be useful here as a model for the <code>IntX</code>s</p>\n</blockquote>\n<p>link: <a href=\"https://github.com/T-Brick/Numbers\">https://github.com/T-Brick/Numbers</a></p>",
        "id": 413078238,
        "sender_full_name": "Thea Brick",
        "timestamp": 1705379094
    }
]