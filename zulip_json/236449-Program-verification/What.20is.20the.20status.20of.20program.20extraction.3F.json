[
    {
        "content": "<p><a href=\"https://groups.google.com/forum/#!topic/lean-user/6eb8DZTqqOI\">From a quick google search</a>, I hear that there is some plan of supporting extracting Lean to C++ some day. What is the current status of this?</p>",
        "id": 201559977,
        "sender_full_name": "Agnishom Chattopadhyay",
        "timestamp": 1592786613
    },
    {
        "content": "<p>This is a major component of the Lean 4 architecture</p>",
        "id": 201560253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592787182
    },
    {
        "content": "<p>It's not likely to happen in lean 3 as it seems lean 4 is imminent</p>",
        "id": 201560260,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592787231
    },
    {
        "content": "<p>In lean 3, we have the VM instead, which is an interpreter for lean programs. I think lean 4 will also have an interpreter, but at the end of a file it transpiles to C and then compiles using clang (?) to produce machine code that can be run in the next file</p>",
        "id": 201560308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1592787317
    },
    {
        "content": "<p>Great, thanks! Rooting for Lean 4</p>",
        "id": 201560790,
        "sender_full_name": "Agnishom Chattopadhyay",
        "timestamp": 1592788215
    },
    {
        "content": "<p>Reviving this old thread. What's the current status of program extraction in Lean 4?</p>",
        "id": 417977904,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706136903
    },
    {
        "content": "<p>Lean 4 is a self hosted programming language that can compile to both C and LLVM.</p>",
        "id": 417982714,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1706139729
    },
    {
        "content": "<p>traditionally, extraction implies preservation of meaning (in some sense). What semantics of C and LLVM does Lean (currently) use?</p>",
        "id": 418022473,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1706168119
    },
    {
        "content": "<p>There are no formal semantics, its just a normal compiler like you would see in other programming languages.</p>",
        "id": 418024772,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1706169354
    },
    {
        "content": "<p>What would be the workflow if one wants to write formally verified code? Write the code in Lean in one file,  prove correctness in Lean in a separate file, then compile the former into LLVM?</p>",
        "id": 418275074,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1706275564
    },
    {
        "content": "<p>You can just put them into the same file it doesn't matter. But yes that works.</p>",
        "id": 418275325,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1706275658
    },
    {
        "content": "<p>Pragmatically, just getting started is as simple as running <code>lake init</code>, <code>lake build</code> and then your executable will be in <code>.lake/build/bin</code>.</p>\n<p>Lean does have very little support for verification of code in the <code>IO</code> monad though, so the verified parts will almost certainly need to be pure at least for the time being.</p>",
        "id": 418325513,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1706292109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397075\">Kevin Cheung</span> <a href=\"#narrow/stream/236449-Program-verification/topic/What.20is.20the.20status.20of.20program.20extraction.3F/near/418275074\">said</a>:</p>\n<blockquote>\n<p>What would be the workflow if one wants to write formally verified code? Write the code in Lean in one file,  prove correctness in Lean in a separate file, then compile the former into LLVM?</p>\n</blockquote>\n<p>Do I need to write a formal semantics of Lean in itself to prove the correctness of my Lean code in Lean? I don't know much about formal verification, so forgive me if my question is unclear.</p>",
        "id": 443597604,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1717941656
    },
    {
        "content": "<p>It highly depends on what kind of verification you are after and what trusted code base you are willing to accept. If you do proves about the behavior of Lean code in Lean you have effectively shown that the view which the kernel has on your code does have property X while only trusting the Kernel.</p>\n<p>However the view which the kernel has on your code is not the view which gets executed, Lean's compiler splits apart from the elaborator quite a bit before we ever end up reaching the kernel. So now you have basically two choices:</p>\n<ol>\n<li>Just trust the Lean compiler and the transitions it makes, this is pretty much what everyone does and it is perfectly reasonable. It is also the trust model that basically every other language in this world has.</li>\n<li>Think about precise semantics for the various IRs used by the compiler and formally verify all compiler passes. Note that core currently has no interest in doing this at all so if we end up changing a part of the compiler it would be the job of whoever wishes to verify it to fix their proofs. In general I'm rather confident that a verification of the compiler is close to impossible without the authors of the compiler specifically designing it such that it is possible. This is simply because we have <code>partial</code> functions around already so someone who verifies stuff already can't look into those and would have to change compiler code.</li>\n</ol>",
        "id": 443598364,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1717942288
    },
    {
        "content": "<p>Thanks for your detailed explanation.</p>",
        "id": 443600588,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1717943927
    },
    {
        "content": "<p>Just for completeness (although I think that <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> is right that 1. is perfectly reasonable), there is a third option: write your own (less optimized) verified or a verifying (in the sense of translation validation) compiler. Probably a lot of effort for little gain, but still probably more feasible than keeping up with core on the regular compiler</p>",
        "id": 443771349,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1718026095
    },
    {
        "content": "<p>For the record:</p>\n<blockquote>\n<p>write your own (less optimized) verified or a verifying (in the sense of translation validation) compiler</p>\n</blockquote>\n<p>is (vaguely) what I aim to do in my PhD, but it's pretty unclear how far we will get.</p>",
        "id": 445139859,
        "sender_full_name": "Siddharth Bhat",
        "timestamp": 1718632997
    }
]