[
    {
        "content": "<p>Hi <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Another example of 'how would an expert do this'... I have a very simple lemma the type of which a serious program verification effort would likely encounter hundreds or thousands. Therefore, I am interested in a short proof which requires as little human intervention as possible. Also, I think the lemma is so trivial that no specialized tactics should be required -- ideally, I'd like to stay in the core lib.</p>\n<p>The lemma is <code>x.length = 4 --&gt; x = [x[0], x[1], x[2], x[3]]</code> and here are my clumsy attempts. You will find numerous <code>QUESTION</code>s where I'm not sure what's going on, and I'd be grateful about clarification on any of them.</p>\n<p>I am particularly interested in knowing how the core tactics would allow me to repeatedly and anonymously (without naming hypotheses explicitly) split _any_ disjunction in the set of hypotheses, which is one stumbling block below.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Lemmas</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab.Tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lt_succ_iff_lt_or_eq</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">or_forall</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">&lt;-&gt;</span> <span class=\"o\">((</span><span class=\"bp\">∀</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"n\">h</span><span class=\"o\">)))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">destruct_length4_list_0</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x.length</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- Not idiomatic -- why not call `ext`? See below...</span>\n  <span class=\"n\">apply</span> <span class=\"n\">List.ext_get</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">lt_succ_iff_lt_or_eq</span><span class=\"o\">,</span> <span class=\"n\">Nat.not_lt_zero</span><span class=\"o\">,</span> <span class=\"n\">or_forall</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">destruct_length4_list'</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x.length</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- `ext` leads to a formulation with `get?` which does not seem easy to handle automatically?</span>\n  <span class=\"c1\">-- If `List.get_ext` was the `ext`-rule for lists... then we would end up with this (?)</span>\n  <span class=\"n\">apply</span> <span class=\"n\">List.ext_get</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">hi'</span>\n    <span class=\"c1\">-- Get `i &lt; 4` by simplifying `h: List.length x = 4`</span>\n    <span class=\"c1\">-- QUESTION: Why do neither `simp_all` nor `simp [h] at *` do this?</span>\n    <span class=\"c1\">-- Doesn't work: simp [h] at *</span>\n    <span class=\"c1\">-- Doesn't work: simp_all</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hi</span>\n    <span class=\"c1\">-- QUESTION: Now we need to split `i &lt; 4` into cases. `interval_cases` from mathlib does this, but how</span>\n    <span class=\"c1\">-- can this be done on the basis of core tactics? It seems like a common thing to do.</span>\n    <span class=\"c1\">-- QUESTION: Why _does_ `simp ... at *` work here, i.e. hi does not have to be named explicitly?</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">lt_succ_iff_lt_or_eq</span><span class=\"o\">,</span> <span class=\"n\">Nat.not_lt_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"c1\">-- QUESTION: `cases_type* Or` does the case splitting here, but this should be something</span>\n    <span class=\"c1\">-- the core lib should be able to do, ideally without having to name hypotheses explicitly?</span>\n    <span class=\"c1\">--</span>\n    <span class=\"c1\">-- Can be done with general-purpose `elim`, see below, but that does not exist.</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">----------------------------- custom elim -----------------------------------------------------</span>\n\n<span class=\"sd\">/-- Try to close goal by assumption. Upon succes, return fvar id of</span>\n<span class=\"sd\">  matching assumption. Otherwise, return none. --/</span>\n<span class=\"kd\">def</span> <span class=\"n\">assumptionCore'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">FVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">findLocalDeclWithType</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">fvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.assign</span> <span class=\"o\">(</span><span class=\"n\">mkFVar</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Close goal `mvarId` using an assumption. Throw error message if failed. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">assumption'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">FVarId</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">assumptionCore'</span> <span class=\"n\">mvarId</span>\n  <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"assumption' tactic failed\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">fvarid</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">fvarid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">erule</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvid</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">with_intro</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">saveState</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvids</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.apply</span> <span class=\"n\">e</span>\n    <span class=\"k\">match</span> <span class=\"n\">mvids</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"ill-formed elimination rule {e}\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">main</span> <span class=\"o\">::</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"c1\">-- Try to solve main goal by assumption, remember fvar of hypothesis</span>\n      <span class=\"k\">let</span> <span class=\"n\">fvid</span> <span class=\"bp\">←</span> <span class=\"n\">assumption'</span> <span class=\"n\">main</span>\n      <span class=\"c1\">-- Remove hypothesis from all other goals</span>\n      <span class=\"k\">let</span> <span class=\"n\">other'</span> <span class=\"bp\">←</span> <span class=\"n\">other.mapM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">mvid</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvid.isAssignedOrDelayedAssigned</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvid</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.clear</span> <span class=\"n\">fvid</span>\n        <span class=\"k\">if</span> <span class=\"n\">with_intro</span> <span class=\"k\">then</span>\n          <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvid</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.intros</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n      <span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"n\">other'</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">restoreState</span> <span class=\"n\">s</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"erule_tac failed\"</span>\n\n<span class=\"c1\">-- Run erule repeatedly</span>\n<span class=\"kd\">def</span> <span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvid</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"n\">Meta.repeat1'</span> <span class=\"o\">(</span><span class=\"n\">erule</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mvid</span><span class=\"o\">]</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"erule\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermForApply</span> <span class=\"n\">e</span>\n   <span class=\"n\">Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">erule</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"elim\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermForApply</span> <span class=\"n\">e</span>\n   <span class=\"n\">Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">elim</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--------------------------------- end custom elim -------------------------------------------------------</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">destruct_length4_list''</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x.length</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">x</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- `ext` leads to a formulation with get? which does not seem easy to handle automatically.</span>\n  <span class=\"c1\">-- Let's pretend `List.get_ext` was the `ext`-rule for lists... then we would end up with this:</span>\n  <span class=\"n\">apply</span> <span class=\"n\">List.ext_get</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">hi</span> <span class=\"n\">hi'</span>\n    <span class=\"c1\">-- Get `i &lt; 4` by simplifying `h: List.length x = 4`</span>\n    <span class=\"c1\">-- QUESTION: Why do neither `simp_all` nor `simp [h] at *` do this?</span>\n    <span class=\"c1\">-- Doesn't work: simp [h] at *</span>\n    <span class=\"c1\">-- Doesn't work: simp_all</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hi</span>\n    <span class=\"c1\">-- QUESTION: Now we need to split `i &lt; 4` into cases. `interval_cases` from mathlib does this, but how</span>\n    <span class=\"c1\">-- can this be done on the basis of core tactics? It seems like a common thing to do.</span>\n    <span class=\"c1\">-- QUESTION: Why _does_ `simp ... at *` work here, i.e. hi does not have to be named explicitly?</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">lt_succ_iff_lt_or_eq</span><span class=\"o\">,</span> <span class=\"n\">Nat.not_lt_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"c1\">-- QUESTION: `cases_type* Or` does the case splitting here, but this should be something</span>\n    <span class=\"c1\">-- the core lib should be able to do, ideally without having to name hypotheses explicitly?</span>\n    <span class=\"c1\">--</span>\n    <span class=\"c1\">-- Can be done with general-purpose `elim`:</span>\n    <span class=\"n\">elim</span> <span class=\"n\">Or.elim</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp_all</span>\n    <span class=\"n\">done</span>\n</code></pre></div>",
        "id": 434943330,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713864785
    },
    {
        "content": "<p>This doesn't answer any of your questions, and you might already be aware of this, but just for completeness I should mention that the specific lemma you're trying to prove can be proved by pattern matching:</p>\n<div class=\"codehilite\" data-code-language=\"lean4\"><pre><span></span><code>theorem destruct_length4_list'' : ∀ {x : List α} (h : x.length = 4), x = [x[0], x[1], x[2], x[3]]\n  | [_, _, _, _], _ =&gt; rfl\n</code></pre></div>",
        "id": 434944699,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1713865256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> No, I wasn't aware -- thank you very much, that's useful to know. Can one reformulate this so it is generic in the length, though?</p>",
        "id": 434945700,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713865580
    },
    {
        "content": "<p>I'm not sure, but since we're relying on the equation compiler to perform the case analysis here my guess would be that making that approach generic in the length will require metaprogramming of some kind.</p>",
        "id": 434946445,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1713865820
    },
    {
        "content": "<p>I would guess you can copy the approach of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinVec.etaExpand_eq#doc\">docs#FinVec.etaExpand_eq</a></p>",
        "id": 434956636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713869569
    },
    {
        "content": "<p>It depends on how you want to state the variable length version, but one version of this theorem is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.ofFn_get#doc\">docs#List.ofFn_get</a></p>",
        "id": 435008336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713885371
    }
]