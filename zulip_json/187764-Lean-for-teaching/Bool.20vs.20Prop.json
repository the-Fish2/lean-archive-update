[
    {
        "content": "<p>How would you explain the difference between <code>Bool</code> and <code>Prop</code> to (smart) highschoolers?</p>",
        "id": 408424274,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1702802992
    },
    {
        "content": "<p>They're the same thing, but at different levels in the hierarchy: one is a type and one is a universe. I usually explain universes, types and terms on day 1</p>",
        "id": 408433654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702811330
    },
    {
        "content": "<p>That said, why do you want to explain that to highschoolers? If you are just teaching them a bit about formalizing maths and not about computation it seems an unnecessary confusion to even introduce Bool at all</p>",
        "id": 408444385,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1702821960
    },
    {
        "content": "<p>Actually, I first taught them about computation, during which <code>Bool</code> appeared. Now I teach them about proving.</p>",
        "id": 408445231,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1702822686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/408433654\">said</a>:</p>\n<blockquote>\n<p>They're the same thing, but at different levels in the hierarchy: one is a type and one is a universe. I usually explain universes, types and terms on day 1</p>\n</blockquote>\n<p>D-D-D-Day 1? I hoped I could avoid talking about universes altogether!</p>",
        "id": 408445323,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1702822786
    },
    {
        "content": "<p>well, once you say \"everything has a type\" it's a pretty natural question to ask what the type of <code>Type</code> is, even at a high school level. For extra fun you can climb the universe hierarchy using lean's nested hovers</p>",
        "id": 408445629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1702823042
    },
    {
        "content": "<p>I say x : Real : Type and proof : statement : Prop and that's about it as far as type theory is concerned, so Prop is explained on day 1 yes. I never talk about bool because I'm talking to mathematicians</p>",
        "id": 408446576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702823851
    },
    {
        "content": "<p>There are quite a few open questions that can be explained to high schoolers. E.g., \"every triangle admits a periodic billiard trajectory\". That's a <code>Prop</code> that you don't know how to convert to <code>Bool</code>.</p>",
        "id": 408447743,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1702824829
    },
    {
        "content": "<p>A <code>Bool</code> is either true or false, and if you let Lean run for long enough it will tell you which it is. A <code>Prop</code> is either True or False, but you can't depend on Lean to tell you -- but you can try to write a proof.</p>\n<p>You need some passing familiarity with incompleteness to appreciate that there really is a distinction. Otherwise, I guess you could say something like what Yury is suggesting, that <code>Prop</code> is like <code>Bool</code> but it doesn't come with any algorithms to evaluate the statements. (How would you evaluate a universal quantifier over Nat? That's like an infinite <code>for</code> loop.)</p>",
        "id": 408451151,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702827690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/408445231\">said</a>:</p>\n<blockquote>\n<p>Actually, I first taught them about computation, during which <code>Bool</code> appeared. Now I teach them about proving.</p>\n</blockquote>\n<p>How about giving them some intuition of what a decidable proposition is, and then say that a decidable proposition can be converted into a boolean value?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testAge</span> <span class=\"o\">(</span><span class=\"n\">age</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">age</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">40</span>\n<span class=\"k\">#check</span> <span class=\"n\">testAge</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- testAge 21 : Prop</span>\n<span class=\"k\">#eval</span> <span class=\"n\">testAge</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- failed to synthesize  Decidable (testAge 21)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testAgeBool</span> <span class=\"o\">(</span><span class=\"n\">age</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">age</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">40</span>\n<span class=\"k\">#check</span> <span class=\"n\">testAgeBool</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- testAgeBool 21 : Bool</span>\n<span class=\"k\">#eval</span> <span class=\"n\">testAgeBool</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- false</span>\n</code></pre></div>\n<p>Conversely, a term <code>b : Bool</code> can be converted into the proposition <code>P := Eq b true </code> and we see that <code>P</code> has a proof if <code>b = true </code> and that <code>¬P</code> has a proof if <code>b = false</code>.</p>\n<p>Surely, somebody will ask if every proposition is decidable <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 408460820,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1702834100
    },
    {
        "content": "<p>That looks like a lousy pedagogical example, because it leaves the reader baffled over whether <code>age &gt; 40</code> is decidable or not</p>",
        "id": 408583307,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702896632
    },
    {
        "content": "<p>Yes, that's the whole point.</p>",
        "id": 408586622,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1702897778
    },
    {
        "content": "<p>So is the point in that example to teach the reader about reducibility?</p>",
        "id": 408595951,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702900806
    },
    {
        "content": "<p>Because certainly that seems to be what this extended example shows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testAge</span> <span class=\"o\">(</span><span class=\"n\">age</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">age</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">40</span>\n<span class=\"k\">#check</span> <span class=\"n\">testAge</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- testAge 21 : Prop</span>\n<span class=\"k\">#eval</span> <span class=\"n\">testAge</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- failed to synthesize  Decidable (testAge 21)</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">testAgeAbbrev</span> <span class=\"o\">(</span><span class=\"n\">age</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">age</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">40</span>\n<span class=\"k\">#check</span> <span class=\"n\">testAgeAbbrev</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- testAgeAbbrev 21 : Prop</span>\n<span class=\"k\">#eval</span> <span class=\"n\">testAgeAbbrev</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testAgeBool</span> <span class=\"o\">(</span><span class=\"n\">age</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">age</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">40</span>\n<span class=\"k\">#check</span> <span class=\"n\">testAgeBool</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- testAgeBool 21 : Bool</span>\n<span class=\"k\">#eval</span> <span class=\"n\">testAgeBool</span> <span class=\"mi\">21</span>  <span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 408596207,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702900888
    },
    {
        "content": "<p>Oh, I see. </p>\n<p>But no, I was hoping it would trigger questions surrounding decidability instead, in relation with <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Coe.html#decPropToBool\">#decPropToBool</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">decPropToBool</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">CoeDep</span> <span class=\"kt\">Prop</span> <span class=\"n\">p</span> <span class=\"n\">Bool</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">decide</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>So, to sum up, two (hoped for) points:</p>\n<ol>\n<li>Show that a decidable proposition can be converted into a boolean value.</li>\n<li>Discuss non-decidable propositions (informally).</li>\n</ol>",
        "id": 408604922,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1702904082
    },
    {
        "content": "<p>As a beginner, I find the foundational system very confusing.</p>\n<p>Referring to <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a> and <a href=\"https://lakesare.brick.do/on-universes-in-lean-vByqZWpNnrEJ\">https://lakesare.brick.do/on-universes-in-lean-vByqZWpNnrEJ</a>, I came up with this:</p>\n<p><a href=\"/user_uploads/3121/CzENYHNDeSePn8u-RGvGUi09/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/CzENYHNDeSePn8u-RGvGUi09/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/CzENYHNDeSePn8u-RGvGUi09/image.png\"></a></div><p>Green boxes are Types, non-green are Universes/Sorts.<br>\nIn this sense, Bool and Prop are similar because both are contained in Type 0, but different because Prop is a universe whereas Bool just a Type.</p>\n<p>Is my understanding correct?</p>",
        "id": 411611240,
        "sender_full_name": "Nilesh",
        "timestamp": 1704643875
    },
    {
        "content": "<p>The picture is not correct.</p>\n<p>There is a difference between: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Boo.true#doc\">docs#Boo.true</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Bool.false#doc\">docs#Bool.false</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=True#doc\">docs#True</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=False#doc\">docs#False</a></p>\n<p>Bool is a type with two <em>values</em> that happen to be called true or false, it is basically isomorphic to any set with two elements. It is interesting for programming or well, any case where you need something that behaves like a set with two elements.</p>\n<p><code>True</code> and <code>False</code> on the other hand are <em>properties</em> (not values) (hence why they live in <code>Prop</code>), <code>True</code>is a property that you can always prove because it requires no assumptions (<code>True</code> is not really an interesting or useful property most of the time) and <code>False</code> is a property that can never be proven, unless you have some contradiction at your hand.</p>",
        "id": 411611725,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704644376
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> I've updated the picture:</p>\n<p><a href=\"/user_uploads/3121/d4T1DSFD-I0KrzMx3pbsQd4q/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/d4T1DSFD-I0KrzMx3pbsQd4q/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/d4T1DSFD-I0KrzMx3pbsQd4q/image.png\"></a></div>",
        "id": 411612434,
        "sender_full_name": "Nilesh",
        "timestamp": 1704645074
    },
    {
        "content": "<p>I think that <code>Prop : Type</code> is misleading (or at least it misled me when I was trying to make sense of all this nonsense). For me it's worth just focusing on the fact that everything is at one of three levels: a universe, a type and a term.</p>",
        "id": 411612436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704645077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"509007\">Nilesh</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/411612434\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> I've updated the picture:</p>\n<p><a href=\"/user_uploads/3121/d4T1DSFD-I0KrzMx3pbsQd4q/image.png\">image.png</a></p>\n</blockquote>\n<p>that looks more correct yes</p>",
        "id": 411612499,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704645138
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"509007\">@Nilesh</span> </p>\n<p>I like your picture <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>I don’t know if I would say that they are similar, but  <code>Bool</code> and <code>Prop</code> are indeed both terms of type <code>Type 0</code> (or <code>Sort 1</code>, or just <code>Type</code>). So they are both types (by definition).  </p>\n<p>But the type <code>Bool</code> has just two terms, one called  <code>true</code> and the other one called <code>false</code>, while <code>Prop</code> can be considered as having many more (all the formulas  from first order logic).</p>\n<p>And as Henrik pointed out, there are terms of type <code>Prop</code> (or <code>Sort 0</code>) called <code>True</code> and <code>False</code>, but they are spelled differently (capitalized). These can be thought of as truth values for decidable propositions. </p>\n<p>Finally, your are right, <code>Prop</code> is a universe (in the sense that its terms are themselves types), while <code>Bool</code> is not.</p>",
        "id": 411612502,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1704645143
    },
    {
        "content": "<p>You might want to also capitalize <code>True -&gt; False</code> in the new picture <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 411612554,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1704645212
    },
    {
        "content": "<p>I could imagine some other type theory where universes don't have types and then the two blue boxes would just sit next to each other instead of one arbitrarily being inside the other</p>",
        "id": 411612659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704645279
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513540\">@Flo (Florent Schaffhauser)</span> Right. <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> </p>\n<p><code>#check True -&gt; False</code> indeed shows <code>True -&gt; False : Prop</code>.<br>\nBut <code>#check true -&gt; false</code> shows <code>true = true → false = true : Prop</code> which I don't understand at all. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 411612726,
        "sender_full_name": "Nilesh",
        "timestamp": 1704645356
    },
    {
        "content": "<p>-&gt; takes two types, <code>true</code> is a term not a type, but there's a coercion from Bool to Prop sending b to <code>b = true</code>.</p>",
        "id": 411612829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704645432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Ah, that makes sense.</p>\n<p>Updated the picture.<br>\n<a href=\"/user_uploads/3121/OG-xSy1WUz-VL88YgMeLzmUx/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/OG-xSy1WUz-VL88YgMeLzmUx/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/OG-xSy1WUz-VL88YgMeLzmUx/image.png\"></a></div>",
        "id": 411612939,
        "sender_full_name": "Nilesh",
        "timestamp": 1704645496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/411612659\">said</a>:</p>\n<blockquote>\n<p>I could imagine some other type theory where universes don't have types and then the two blue boxes would just sit next to each other instead of one arbitrarily being inside the other</p>\n</blockquote>\n<p>But then we wouldn’t be able to use types like <code>Nat</code> in the first order formulas of type <code>Prop</code>, would we?</p>\n<p>EDIT: Although for that it is (probably) sufficient to have the two blue boxes seating inside one same box, so I get your point now.</p>",
        "id": 411612974,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1704645539
    },
    {
        "content": "<p>If you want to get even closer to the way it is actually implemented you would find that R x R -&gt; R is usually written R -&gt; R -&gt; R because we are in a functional programming language (they are equivalent)</p>",
        "id": 411612997,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704645566
    },
    {
        "content": "<p>So, if <code>True</code> and <code>False</code> are separate from <code>true</code> and <code>false</code>, I may be able to create a different variant of <code>Bool</code> using  <code>Sum True False</code>?</p>",
        "id": 411614151,
        "sender_full_name": "Nilesh",
        "timestamp": 1704646358
    },
    {
        "content": "<p>No, that type would need to have a proof of False on the right values which is not possible. But for example <code>Sum Unit Unit</code> would indeed be the same as <code>Bool</code></p>",
        "id": 411614183,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704646405
    },
    {
        "content": "<p>A comment on the latest image: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Empty#doc\">docs#Empty</a> is a Type, not a Prop</p>",
        "id": 411615852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704647563
    },
    {
        "content": "<p>Oh, right! The empty proposition is called <code>False</code>, indeed <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span></p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#False\">docs#False</a></p>",
        "id": 411616233,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1704647845
    },
    {
        "content": "<p>Or <code>PEmpty.{0}</code></p>",
        "id": 411618363,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704649378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/411614183\">said</a>:</p>\n<blockquote>\n<p>No, that type would need to have a proof of False on the right values which is not possible. But for example <code>Sum Unit Unit</code> would indeed be the same as <code>Bool</code></p>\n</blockquote>\n<p>Nice. One question, though: how would you formalize the fact they are the same here? By setting up a bijection between the two? Or more categorically?</p>",
        "id": 411618866,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1704649745
    },
    {
        "content": "<p>Lean does have a notion of type equality (like literally via =) but its not very nice to use. Generally speaking I would say formalize it how you need it in your bigger theory. Idk if mathlib has a stance on how to do this type of stuff canonically?</p>",
        "id": 411618991,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1704649829
    },
    {
        "content": "<p>Yes, I don’t know either, but I’m interested to find out <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>I guess one could try to prove the universal property of <code>Sum Unit Unit</code> for <code>Bool</code>, but it’s not clear if it would be useful (I agree that the statement to formalize depends on what you need it for).</p>\n<p>And I thought that type equality would simply not work here, but maybe I’m wrong.</p>",
        "id": 411619338,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1704650105
    },
    {
        "content": "<p>Mathlib uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv#doc\">docs#Equiv</a></p>",
        "id": 411620745,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704651088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"509007\">Nilesh</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/411611240\">said</a>:</p>\n<blockquote>\n<p>As a beginner, I find the foundational system very confusing.</p>\n</blockquote>\n<p>The good news is you can go very far with a very limited understanding of foundations. In particular the difference between Bool and Prop is 99% irrelevant if you are interested in formalized mathematics in Lean.</p>",
        "id": 411660418,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704682623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/411612659\">said</a>:</p>\n<blockquote>\n<p>I could imagine some other type theory where universes don't have types and then the two blue boxes would just sit next to each other instead of one arbitrarily being inside the other</p>\n</blockquote>\n<p>I thought some more about your remark: one of the advantages of having the box <code>Prop</code> inside the box <code>Type</code> and not next to it is that terms such as <code>Nat → Prop</code> are also in <code>Type</code>, without having to go to <code>Type 1</code> to be able to write that <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 412690064,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705136210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"509007\">Nilesh</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/411612939\">said</a>:</p>\n<blockquote>\n<p>Updated the picture.<br>\n<a href=\"/user_uploads/3121/OG-xSy1WUz-VL88YgMeLzmUx/image.png\">image.png</a></p>\n</blockquote>\n<p>Out of curiosity, what tool do you use to produce this picture? <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 412690183,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705136295
    },
    {
        "content": "<p>I think the fact that <code>Nat -&gt; Prop</code>  doesn't have a higher type is a hack in the way the type theory works rather than the fact that <code>Prop : Type</code>. See <code>imax</code>, specifically designed to make this hack work.  What I'm saying is that it's all hacks and there could have been other hacks instead. I'm arguing that <code>Prop : Type</code> is just one of these hacks and is not something that one has to take on board and understand in order to get a feeling for the type theory. But this is just my personal interpretation of what is going on. I teach students what (I think) they need to know about the type system (namely element : type, type : <code>Type</code>, proof : statement and statement : <code>Prop</code>) and no more, because I've decided that these are the important statements and everything else that goes on under the hood is confusing and irrelevant. But I'm not teaching a type theory course. I tell them <code>Set X</code> is the type of subsets of <code>X</code> and they don't ask themselves \"how does this work internally in the type theory\" for the same reason that they've never queried why the set of subsets of a set is a valid mathematical object in the informal set theory that they see used in other classes.</p>",
        "id": 412692665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705138394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513540\">@Flo (Florent Schaffhauser)</span> I used <a href=\"http://tldraw.com\">tldraw.com</a> for this.</p>",
        "id": 412694141,
        "sender_full_name": "Nilesh",
        "timestamp": 1705139689
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yeah, a lot of truth in that. I've occasionally been nerd-sniped into looking for \"the absolute minimal\" foundations of types or computing or mathematics, but been learning recently that it's not a fruitful pursuit. Came across this bit from John McCarthy when reading about <a href=\"https://esolangs.org/wiki/Turing_tarpit\">Turing Tarpit</a>:</p>\n<blockquote>\n<p>We thought if we were to find the smallest universal machine then we could learn a great deal about computability -- of course that wouldn't be so!</p>\n</blockquote>\n<p>Another quote I liked:</p>\n<blockquote>\n<p>Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.</p>\n</blockquote>",
        "id": 412694481,
        "sender_full_name": "Nilesh",
        "timestamp": 1705139974
    },
    {
        "content": "<p>Here is the corrected image after fixing the error <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> pointed out.</p>\n<p><a href=\"/user_uploads/3121/qwHwfaVeIWHedIzunxmNmHwk/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/qwHwfaVeIWHedIzunxmNmHwk/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/qwHwfaVeIWHedIzunxmNmHwk/image.png\"></a></div>",
        "id": 412695012,
        "sender_full_name": "Nilesh",
        "timestamp": 1705140377
    },
    {
        "content": "<p>There's also a way of defining group theory by using only one (very long) universally quantified equation which happens to be equivalent to the usual associativity, 1 and inverse axioms, and it doesn't tell you anything about group theory other than the fact that this axiom is hell to work with. </p>\n<p>One of the first exercises that John Thompson set us in my basic group theory undergrad class was to show that of the five usual group theory axioms (associativity, left and right inverse, left and right identity) you can delete two of them (but you have to be careful about which two). At the time I found this intriguing but now I realise that really this is just a gimmick in some sense; I've never seen a practical use for \"we have left inverses and left and right identity and associativity so now we don't have to check right inverses\" for example, and if we really did drop one of these axioms and then there was some situation where one was easier to check than the other one then there would be a 50% chance that we dropped the wrong one anyway</p>",
        "id": 412695751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705141030
    },
    {
        "content": "<p>Yes, I agree that looking for the minimal set of rules is not always the way to go! Both for transmission of ideas and for practical efficiency. Anyway, it's cool to be able to discuss this here (viz. should <code>Nat → Prop</code> be of type <code>Sort 1</code> or higher?).  As <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> made it clear, making <code>Nat → Prop</code> of type <code>Sort 1</code> or <code>Sort 2</code> is a choice (that we can picture with the boxes <code>Sort 0</code> and <code>Sort 1</code> being either imbricated or next to each other) and it's fun to think what would be the advantages of each choice <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span></p>",
        "id": 412698316,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705143491
    },
    {
        "content": "<p>The way I would explain this to my class would be to say that Fermat's Last Theorem (for all naturals a b c n, some inequalities imply some other inequality) is clearly a true-false statement.</p>",
        "id": 412698519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705143659
    },
    {
        "content": "<p>What if somebody then asks you for an example of a statement that is not a true-false statement?</p>",
        "id": 412699602,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705143937
    },
    {
        "content": "<p>Oops, I forgot the <a href=\"#narrow/stream/113488-general/topic/logo/near/412313149\">JOKE</a> tag <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 412701624,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705144936
    },
    {
        "content": "<p>I find the nesting of boxes in this diagram misleading, because the type hierarchy is not cumulative.  <code>2 + 2 = 5</code> is inside <code>Prop</code> because it has type <code>Prop</code>, and <code>Prop</code> is inside <code>Type</code> because it has type <code>Type</code>.  But because of the nesting, <code>2 + 2 = 5</code> is also inside <code>Type</code>, even though it does not have type <code>Type</code>.</p>\n<p>I prefer to think of the collection of all expressions as a directed graph, with an edge from each expression to its type.  Here's how I would draw it:<br>\n<a href=\"/user_uploads/3121/NIYfsnfKjwL8w9GFMPJpGOKS/Types.png\">Types.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/NIYfsnfKjwL8w9GFMPJpGOKS/Types.png\" title=\"Types.png\"><img src=\"/user_uploads/3121/NIYfsnfKjwL8w9GFMPJpGOKS/Types.png\"></a></div>",
        "id": 412720793,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1705161825
    },
    {
        "content": "<p>Note that <code>intro</code> is not the name of the inhabitant of <code>True</code>, it's <code>trivial</code> (this is wrong in the other diagram too)</p>",
        "id": 412720904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705161929
    },
    {
        "content": "<p>Yeah this is how I draw it in my (maths) class (except rotated 90 degrees, and I only draw the line from Prop to Type and add the other Type n at the very end in a \"this is how it actually works but don't worry, this has nothing you do with maths\" comment)</p>",
        "id": 412721055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705162055
    },
    {
        "content": "<p>The directed graph is very nice, indeed!</p>\n<p>What I find difficult to explain to students is why the presence of terms such as <code>Nat</code> in terms of type <code>Prop</code> is licit, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>+</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\"> \\forall x : \\mathbb{N}, x + 0 = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;vertical-align:-0.1944em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. Any suggestion?</p>\n<p>If I understand Kevin’s rotation of 90 degrees correctly, I get a picture that is similar to the box diagram, but with directed  arrows instead of boxes, and terms such as <code>Nat</code> and <code>Prop</code> are at the same level of the resulting tree.</p>",
        "id": 412721751,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705162728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/412720904\">said</a>:</p>\n<blockquote>\n<p>Note that <code>intro</code> is not the name of the inhabitant of <code>True</code>, it's <code>trivial</code> (this is wrong in the other diagram too)</p>\n</blockquote>\n<p>Or <code>True.intro</code>.  But you're right, just <code>intro</code> isn't right.</p>",
        "id": 412721919,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1705162923
    },
    {
        "content": "<p>My picture: take the diagram above, remove all vertical arrows and all Type n for n&gt;=1, rotate 90 degrees if you like, and then claim that what you have left is all you need for undergraduate mathematics.</p>",
        "id": 412722288,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705163277
    },
    {
        "content": "<p>But if you want to understand type theory then that's a different question.</p>",
        "id": 412722344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705163306
    },
    {
        "content": "<p>Huh, I didn't know about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=True.intro#doc\">docs#True.intro</a>. I guess <code>.intro</code> would be sufficiently correct</p>",
        "id": 412722364,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705163336
    },
    {
        "content": "<p>You thought there wasn't a constructor? ;-)</p>",
        "id": 412722405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705163387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"513540\">Flo (Florent Schaffhauser)</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/412721751\">said</a>:</p>\n<blockquote>\n<p>What I find difficult to explain to students is why the presence of terms such as <code>Nat</code> in terms of type <code>Prop</code> is licit, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo separator=\"true\">,</mo><mi>x</mi><mo>+</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\"> \\forall x : \\mathbb{N}, x + 0 = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8833em;vertical-align:-0.1944em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. Any suggestion?</p>\n</blockquote>\n<p>Lots of expressions of one type contain within them subexpressions of other types.  If <code>x</code> has type <code>Nat</code>, then <code>Vector Nat x</code> has type <code>Type</code>.  Is that different from the occurrence of <code>Nat</code> and natural numbers in propositions?</p>",
        "id": 412722460,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1705163412
    },
    {
        "content": "<p>Indeed, it’s <del>not</del> different <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 412722607,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705163624
    },
    {
        "content": "<p>That Vector example is a bit different though since Nat is a Type and the Vector is a Type. With the forall something special is happening, where the result is in a smaller universe, Prop. I believe that this is Prop being what's called an \"impredicative universe\".</p>",
        "id": 412725285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705165918
    },
    {
        "content": "<p>In particular, quantification/functions usually gives you something at least as big as the domain and codomain, unless the codomain is a proposition, in which case you get a proposition. That's necessary for foralls to all be propositions.</p>",
        "id": 412725656,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705166116
    },
    {
        "content": "<p>Yes, you're right.  This is something special about Prop.</p>",
        "id": 412725671,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1705166136
    },
    {
        "content": "<p>I remember in Automath that some quantifications are \"too big\" and you don't get propositions, so this must not be a necessary part of type theory.</p>",
        "id": 412726131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705166363
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> talks about it here <a href=\"https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html?highlight=imax#the-universal-quantifier\">https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html?highlight=imax#the-universal-quantifier</a> (start at \"The idea is as follows\")</p>",
        "id": 412726165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705166379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/412725285\">said</a>:</p>\n<blockquote>\n<p>That Vector example is a bit different though since Nat is a Type and the Vector is a Type. With the forall something special is happening, where the result is in a smaller universe, Prop. I believe that this is Prop being what's called an \"impredicative universe\".</p>\n</blockquote>\n<p>Thanks for pointing that out <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> ! Here is how I think about what is similar and what is not in the two examples that we have been discussing. </p>\n<p>In <a href=\"https://leanprover-community.github.io/mathlib4_docs/foundational_types.html\">docs#foundational_types</a>, it says that, when <code>β :  α → Prop</code>, the type of dependent functions <code>(a : α) → β a</code> is denoted by <code>∀ a : α, β a</code>. </p>\n<p>So the type <code>∀ n : Nat, n + 0 = n</code> is the type of dependent functions <code>(n : Nat) → (n + 0 = n) </code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>  <span class=\"c1\">-- ∀ n : Nat, n + 0 = n</span>\n</code></pre></div>\n<p>And indeed if we declare</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">γ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.add_zero</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>then we get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">γ</span>  <span class=\"c1\">-- γ : ∀ (n : Nat), β n</span>\n<span class=\"k\">#check</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">β</span> <span class=\"n\">n</span>  <span class=\"c1\">-- ∀ (n : Nat), β n : Prop</span>\n</code></pre></div>\n<p>We can partly reproduce this type of behavior at every universe level <code>k</code>, not just <code>k = 0</code>. I say 'partly' because the last <code>#check</code> will give something different if <code>k &gt; 0</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean.Level</span>\n<span class=\"kd\">universe</span> <span class=\"n\">k</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">l</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">G</span> <span class=\"n\">L</span>  <span class=\"c1\">-- G : (x : L) → F x</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F.</span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"n\">x</span>  <span class=\"c1\">-- (x : L) → F x : Sort (imax l k)</span>\n</code></pre></div>\n<p>Or with an explicit, albeit slightly artificial, example of a term <code>L'</code> of type  <code>Sort l</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">L'</span> <span class=\"o\">:=</span> <span class=\"n\">PUnit.</span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">F'</span> <span class=\"o\">:</span> <span class=\"n\">L'</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">L'</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PUnit.</span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">G'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F'</span> <span class=\"n\">x</span>  <span class=\"o\">:=</span> <span class=\"n\">PUnit.unit.</span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">G'</span>  <span class=\"c1\">-- G' : (x : L') → F' x</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L'.</span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">})</span> <span class=\"bp\">→</span> <span class=\"n\">F'.</span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"n\">x</span>  <span class=\"c1\">-- (x : L') → F' x : Sort (imax l k)</span>\n</code></pre></div>\n<p>where <code>Nat.imax l k</code> is equal to <code>0</code> if <code>k = 0</code> and to <code>max l k</code> if <code>k &gt; 0</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Level.html#Nat.imax\">docs#Nat.imax</a>).</p>\n<p>So, <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/412725656\">as you were saying</a>, what is special about <code>Sort 0</code>, is that, given a function <code>β :  α → Sort k</code>, where <code>α</code> is a term of type <code>Sort l</code>, the type of dependent functions <code>(a : α) → β a</code> is a term of type <code>Sort (max l k)</code> if <code>k &gt; 0</code> and of type <code>Sort 0</code> if <code>k = 0</code>.</p>\n<p>It looks to me that we should perhaps view this as the type-theoretic way to define a proposition starting with the universal quantifier: to prove it means to define a dependent function of the appropriate type (and this type is by definition a term of type <code>Sort 0</code>).</p>\n<p>However, I don't know where in Lean the type of dependent functions <code>(a : α) → β a</code> is defined, as a term of type <code>Sort (imax l k)</code>. I guess that is why it is one of the foundational types.</p>",
        "id": 412737983,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1705176823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"513540\">Flo (Florent Schaffhauser)</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Bool.20vs.20Prop/near/412737983\">said</a>:</p>\n<blockquote>\n<p>However, I don't know where in Lean the type of dependent functions <code>(a : α) → β a</code> is defined, as a term of type <code>Sort (imax l k)</code>. I guess that is why it is one of the foundational types.</p>\n</blockquote>\n<p>Yeah, dependent function types are foundational. They are one of the core types of expressions, and they appear as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Expr.forallE#doc\">docs#Lean.Expr.forallE</a> in the implementation of Lean. The rule about what its type is is explicitly encoded in the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.inferType#doc\">docs#Lean.Meta.inferType</a> function. (We're well into the meta-level now!) <em>Note: that's the elaborator's implementation. The kernel has its own independent implementation too.</em></p>",
        "id": 412738371,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705177191
    },
    {
        "content": "<p>Here's the implementation: <a href=\"https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Meta/InferType.lean#L139-L146\">https://github.com/leanprover/lean4/blob/b614ff1d12bc38f39077f9ce9f2d48b42c003ad0/src/Lean/Meta/InferType.lean#L139-L146</a></p>\n<p>If you look carefully, you can see \"imax\" in <code>mkLevelIMax'</code>.</p>",
        "id": 412738552,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705177355
    },
    {
        "content": "<p>This function is a bit more complicated than you might expect since it handles arbitrarily nested dependent function types and calculates the <code>Sort (imax u1 (imax u2 ... (imax un v) ...))</code> all at once, I assume as an optimization.</p>",
        "id": 412738707,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705177515
    }
]