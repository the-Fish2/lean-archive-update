[
    {
        "content": "<p>What's the general version of this statement, and do we have it in mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.PiL2</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">det</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">q</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">r</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- alternative definition of det:</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">det_eq_matrixDet</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">det</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">Matrix.det</span> <span class=\"bp\">!!</span><span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"mi\">0</span><span class=\"bp\">;</span> <span class=\"n\">a</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"mi\">1</span><span class=\"bp\">;</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- already proved</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">det</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>A related missing theorem is that <code>det p q r != 0</code> iff <code>affineSpan ℝ {p, q, r} = ⊤</code>.</p>",
        "id": 422765243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708588985
    },
    {
        "content": "<p>The way to get to this result is to show that <code>det a b c = 0</code> implies <code>Collinear ℝ {a, b, c}</code>. Then apply <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Collinear.wbtw_or_wbtw_or_wbtw#doc\">docs#Collinear.wbtw_or_wbtw_or_wbtw</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mem_segment_iff_wbtw#doc\">docs#mem_segment_iff_wbtw</a></p>",
        "id": 422769797,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708591025
    },
    {
        "content": "<p>You should be able to do that first <code>det a b c = 0 → Collinear ℝ {a, b, c}</code> step by directly manipulating the linear equation obtained from <code>Matrix.det !![a 0, b 0, c 0; a 1, b 1, c 1; 1, 1, 1] = 0</code>, but I'm not completely sure...</p>",
        "id": 422770103,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708591141
    },
    {
        "content": "<p>Aha, I see that <code>Collinear</code> is defined in terms of matrix ranks, any idea how to connect <code>det</code> to a useful matrix determinant?</p>",
        "id": 422770173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708591177
    },
    {
        "content": "<p>the issue with the <code>Matrix.det</code> equation I have here is that the matrix itself isn't connected to anything mathlib-wise</p>",
        "id": 422770304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708591217
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.range_lt_top_of_det_eq_zero#doc\">docs#LinearMap.range_lt_top_of_det_eq_zero</a> which seems to go in the right direction, but I don't really know anything about matrix determinants in mathlib</p>",
        "id": 422771458,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708591713
    },
    {
        "content": "<p>It seems this is the only lemma linking rank and determinant, actually</p>",
        "id": 422771606,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708591789
    },
    {
        "content": "<p>I think that from a theoretic point of view we have everything (for linear maps maybe), but you surely need some glue to connect to your definition.</p>",
        "id": 422771785,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708591873
    },
    {
        "content": "<p>certainly, I'm just not sure what kind of statement is closest to what mathlib wants in this case (e.g. what would be the natural n-dimensional generalization)</p>",
        "id": 422771941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708591937
    },
    {
        "content": "<p>Maybe something related to the dimension of the span?</p>",
        "id": 422771983,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708591956
    },
    {
        "content": "<p>I think that's basically what <code>Collinear</code> gets you</p>",
        "id": 422772033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708591977
    },
    {
        "content": "<p>I think if it was a linear span we would be able to connect it to determinants of linear maps, but for affine spaces I don't see as many useful things</p>",
        "id": 422772239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708592052
    },
    {
        "content": "<p>Ah, for affine spaces I don't know.</p>",
        "id": 422773694,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708592561
    },
    {
        "content": "<p>I don't think we have a matrix constructor that has the 1's at the bottom like this one</p>",
        "id": 422773778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708592590
    },
    {
        "content": "<p>No I haven't seen that anywhere indeed</p>",
        "id": 422775088,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708593003
    },
    {
        "content": "<p>There's a more general statement we're missing here: that under suitable assumptions, an alternating map is zero only when its arguments are linearly dependent (we only have the reverse statement)</p>",
        "id": 422775987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708593353
    },
    {
        "content": "<p>Here's the proof I ended up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Point.ext</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">i</span>\n  <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">assumption</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">dotProduct_self_eq_zero</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">add_eq_zero_iff'</span> <span class=\"o\">(</span><span class=\"n\">mul_self_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul_self_nonneg</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_self_eq_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">collinear_iff</span> <span class=\"o\">:</span> <span class=\"n\">det</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">_root_.Collinear</span> <span class=\"n\">ℝ</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">H</span>\n  <span class=\"bp\">·</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"k\">then</span> <span class=\"n\">subst</span> <span class=\"n\">r</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">collinear_pair</span><span class=\"o\">]</span> <span class=\"k\">else</span>\n    <span class=\"n\">apply</span> <span class=\"n\">collinear_insert_of_mem_affineSpan_pair</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">mt</span> <span class=\"n\">dotProduct_self_eq_zero.1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">sub_ne_zero.2</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Ne.symm</span> <span class=\"n\">h</span>\n    <span class=\"n\">convert</span> <span class=\"n\">AffineMap.lineMap_mem_affineSpan_pair</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n      <span class=\"o\">((</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">using</span> <span class=\"mi\">1</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AffineMap.lineMap_apply_module'</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">det</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">sub_eq_zero</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">smul_eq_zero_iff_right</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">smul_sub</span><span class=\"o\">,</span> <span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_div_cancel'</span> <span class=\"n\">_</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">norm_sq_eq_inner</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">linear_combination</span> <span class=\"n\">H</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">r</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">linear_combination</span> <span class=\"n\">H</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">q</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">collinear_iff_of_mem</span> <span class=\"o\">(</span><span class=\"n\">p₀</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">H</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">H</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">det</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">det</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span>\n    <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">collinear_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.wbtw_or_wbtw_or_wbtw</span>\n  <span class=\"bp\">·</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mem_segment_iff_wbtw.2</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mem_segment_iff_wbtw.2</span> <span class=\"n\">h.symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mem_segment_iff_wbtw.2</span> <span class=\"n\">h.symm</span>\n</code></pre></div>",
        "id": 422799754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708602485
    },
    {
        "content": "<p>I was surprised to find that <code>‖p‖^2</code> was more difficult to use in this proof than <code>p ⬝ᵥ p</code>; I can prove the former is nonzero but there is no simp lemma that works out what it is in terms of coordinates in this case</p>",
        "id": 422800019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708602604
    },
    {
        "content": "<p>proving the latter is nonzero required filling a hole in the library</p>",
        "id": 422800061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708602624
    },
    {
        "content": "<p>I find it strange to use a three dimensional determinant here. Why not use the 2d one? Is it for symmetry reasons?</p>",
        "id": 422814672,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708607931
    },
    {
        "content": "<p><code>p ⬝ᵥ p</code> is not well-typed for <code>EuclideanSpace ℝ (Fin 2)</code>, you should be inserting some <code>withLp.equiv</code>s</p>",
        "id": 422818380,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708609213
    },
    {
        "content": "<p>(this is how <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EuclideanSpace.inner_eq_star_dotProduct#doc\">docs#EuclideanSpace.inner_eq_star_dotProduct</a>  is stated)</p>",
        "id": 422818593,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708609309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422814672\">said</a>:</p>\n<blockquote>\n<p>I find it strange to use a three dimensional determinant here. Why not use the 2d one? Is it for symmetry reasons?</p>\n</blockquote>\n<p>As far as I know this is the only way to write that as a determinant. It's a 3D determinant because affine transformations in 2D are represented using linear transformations in 3D where the z coordinate is fixed to 1</p>",
        "id": 422916688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708641506
    },
    {
        "content": "<p>I suppose you could use cofactor expansion on the last row to turn it into 3 2D determinants but that's hardly better</p>",
        "id": 422916905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708641608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422818380\">said</a>:</p>\n<blockquote>\n<p><code>p ⬝ᵥ p</code> is not well-typed for <code>EuclideanSpace ℝ (Fin 2)</code>, you should be inserting some <code>withLp.equiv</code>s</p>\n</blockquote>\n<p>That's weird, it works for me although I am on a slightly old mathlib e64d0a16</p>",
        "id": 422917193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708641775
    },
    {
        "content": "<p>By \"not well-typed\" I mean \"that's defeq abuse\" not \"Lean rejects it\"</p>",
        "id": 422918038,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708642267
    },
    {
        "content": "<p>sure, but I don't see that helping anything here</p>",
        "id": 422924320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708645628
    },
    {
        "content": "<p>this isn't mathlib code anyway</p>",
        "id": 422924357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708645653
    },
    {
        "content": "<p>I guess my main point is that it guarantees that there will be no lemmas that exist about it, in the same way that things go wrong if you end up with <code>s x</code> in your goal when <code>s</code> is a set</p>",
        "id": 422926176,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708646686
    },
    {
        "content": "<p>I agree if that were the case, but I don't think it is in this case</p>",
        "id": 422926221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708646717
    },
    {
        "content": "<p>there are actually just no relevant lemmas</p>",
        "id": 422926234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708646728
    },
    {
        "content": "<p>I also contest to some extent that this is/should be considered as defeq abuse. It is reasonable to want <code>![x, y]</code> to be usable to construct elements of R^2</p>",
        "id": 422926549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708646894
    },
    {
        "content": "<p>I think it's reasonable to want notation to exist, but it's unreasonable for it to be that notation  (at least as currently implemented)</p>",
        "id": 422926777,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708647028
    },
    {
        "content": "<p>You're setting yourself up for a headache if you write <code>norm ![x, y]</code></p>",
        "id": 422926790,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708647043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422916688\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422814672\">said</a>:</p>\n<blockquote>\n<p>I find it strange to use a three dimensional determinant here. Why not use the 2d one? Is it for symmetry reasons?</p>\n</blockquote>\n<p>As far as I know this is the only way to write that as a determinant. It's a 3D determinant because affine transformations in 2D are represented using linear transformations in 3D where the z coordinate is fixed to 1</p>\n</blockquote>\n<p>Given three points in an affine plane, the natural thing to do is <em>not</em> to artificially embed the affine plane into a 3d vector space.  It to form two vectors using point subtraction. Your three points form an actual triangle if and only if the two vectors you get form a basis. Then you project this basis to the relevant quotient to get the triangle orientation. Of course if you have a favorite basis for the vector space then you can compute a determinant.</p>",
        "id": 422926936,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647128
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  well as mentioned above <code>‖p‖^2</code> was even less useful than <code>p ⬝ᵥ p</code>, even though it's the less abusive one</p>",
        "id": 422926960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647156
    },
    {
        "content": "<p>Sorry I have no idea what you are talking about.</p>",
        "id": 422927057,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> This isn't about embedding, I'd prefer it if the determinant was defined directly over R^2 affine maps. It's just that when you write it in terms of matrices that's what you get</p>",
        "id": 422927129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647273
    },
    {
        "content": "<p>but yes, you can map this to two vectors and take a regular determinant there, if you break the symmetry</p>",
        "id": 422927189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647312
    },
    {
        "content": "<p>You are already breaking the symmetry by ordering the points.</p>",
        "id": 422927229,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647349
    },
    {
        "content": "<p>there are three ways to do that though and you need some symmetry property about swapping them</p>",
        "id": 422927295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647376
    },
    {
        "content": "<p>with the matrix det definition it follows from column swaps in the matrix determinant</p>",
        "id": 422927343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647438
    },
    {
        "content": "<p>if you subtract points the algebra is not very obvious and I would just expand everything and use <code>ring</code> to prove it</p>",
        "id": 422927392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647476
    },
    {
        "content": "<p>With the mathematically natural one it would follow from linearity of determinant.</p>",
        "id": 422927464,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647504
    },
    {
        "content": "<p>I don't know what you mean by that</p>",
        "id": 422927495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647533
    },
    {
        "content": "<p>I take it you are talking about <code>Matrix.det ![q - p, r - p]</code> as the definition?</p>",
        "id": 422927536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647564
    },
    {
        "content": "<p>Yes.</p>",
        "id": 422927669,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647645
    },
    {
        "content": "<p>I don't see swapping <code>p</code> and <code>q</code> here being an easy proof given a reasonable library on linear and affine maps</p>",
        "id": 422927716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422926221\">said</a>:</p>\n<blockquote>\n<p>I agree if that were the case, but I don't think it is in this case</p>\n</blockquote>\n<p>I note you rewrote <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.dotProduct_self_eq_zero#doc\">docs#Matrix.dotProduct_self_eq_zero</a> from scratch; maybe this (<code>exact?</code> being confused by the defeq) is why</p>",
        "id": 422927724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708647675
    },
    {
        "content": "<p>no, I wrote it from scratch because that theorem didn't exist when I looked</p>",
        "id": 422927843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647741
    },
    {
        "content": "<p>Then the proof you want relies on things like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>−</mo><mi>q</mi><mo>=</mo><mi>p</mi><mo>−</mo><mi>r</mi><mo>+</mo><mi>r</mi><mo>−</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">p - q = p - r + r - q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> and multilinearity.</p>",
        "id": 422927856,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647748
    },
    {
        "content": "<p>and antisymmetry of course, but no row expansion or other ugly computation.</p>",
        "id": 422927924,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647794
    },
    {
        "content": "<p>yes, I can see how to do it with elementary column operations, but that still looks a bit like an ugly computation</p>",
        "id": 422927943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422927843\">said</a>:</p>\n<blockquote>\n<p>no, I wrote it from scratch because that theorem didn't exist when I looked</p>\n</blockquote>\n<p>(it came in in <a href=\"https://github.com/leanprover-community/mathlib/pull/18783\">!3#18783</a> in April; I guess you're porting old lean3 code?)</p>",
        "id": 422927947,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708647819
    },
    {
        "content": "<p><code>det ![q - p, r - p] = det ![q - r + r - p, r - p] =  det ![q - r, r - p] +  det ![r - p, r - p] = det ![q - r, r - p]</code></p>",
        "id": 422928026,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647866
    },
    {
        "content": "<p>no, seems it wasn't imported</p>",
        "id": 422928041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647878
    },
    {
        "content": "<p>But it’s dinner time here so I need to go.</p>",
        "id": 422928056,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708647898
    },
    {
        "content": "<p>Note that in the same vein there will be exactly no lemmas about <code>det ![x, ...]</code> because that is also defeq abuse without a <code>Matrix.of</code></p>",
        "id": 422928098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708647934
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Are you saying that this is the right way to do affine points in n dimensions too? I really want that whole business to be a definition with general properties, not something in user code</p>",
        "id": 422928101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647936
    },
    {
        "content": "<p>Though probably there are no lemmas with the <code>of</code> either...</p>",
        "id": 422928108,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708647944
    },
    {
        "content": "<p>sure, this needs some <code>ofColumns</code> or <code>ofRows</code> function</p>",
        "id": 422928194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708647990
    },
    {
        "content": "<p>I have to say, the many defeq variations here do not spark joy</p>",
        "id": 422928251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648033
    },
    {
        "content": "<p>Well, <code>ofRows</code> would be identical to <code>of</code></p>",
        "id": 422928350,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648086
    },
    {
        "content": "<p>true</p>",
        "id": 422928365,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422928251\">said</a>:</p>\n<blockquote>\n<p>I have to say, the many defeq variations here do not spark joy</p>\n</blockquote>\n<p>Making <code>Matrix</code> and <code>EuclideanSpace</code> structures would maybe make this more predictable</p>",
        "id": 422928386,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648122
    },
    {
        "content": "<p>I don't think it would make things easier though, given how loosely connected they currently are in terms of lemmas</p>",
        "id": 422928421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648149
    },
    {
        "content": "<p>What's the mathlib approved operation for taking the dot product of elements of R^2?</p>",
        "id": 422928565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648252
    },
    {
        "content": "<p>I looked at innerProduct briefly but it has a weird type</p>",
        "id": 422928596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648278
    },
    {
        "content": "<p>It's surely <code>inner</code></p>",
        "id": 422928786,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648412
    },
    {
        "content": "<p>What's weird about the type?</p>",
        "id": 422928804,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648424
    },
    {
        "content": "<p>it's in some star ring and there are conjugations all over it</p>",
        "id": 422928828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648443
    },
    {
        "content": "<p>maybe there is a scope I can open to say I'm in R^2 and don't bother me with complex numbers</p>",
        "id": 422928889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648477
    },
    {
        "content": "<p>Sure, but that's an implementation detail; just write <code>⟪x, y⟫_ℝ</code></p>",
        "id": 422928898,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648484
    },
    {
        "content": "<p>There might be a scope that saves you from the <code>_ℝ</code>, or maybe it's even the default</p>",
        "id": 422928979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648554
    },
    {
        "content": "<p>my proof looks like this now, although I think it's probably even more abusing defeq now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Matrix.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.InnerProductSpace.PiL2</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.DotProduct</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Convex.Between</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Point</span> <span class=\"o\">:=</span> <span class=\"n\">EuclideanSpace</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">det</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">q</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">q</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">r</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">p</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- alternative definition of det:</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">det_eq_matrixDet'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">det</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">Matrix.det</span> <span class=\"o\">(</span><span class=\"n\">Matrix.of</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">b</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">-</span> <span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- already proved</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Point.ext</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">i</span>\n  <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">assumption</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">collinear_iff</span> <span class=\"o\">:</span> <span class=\"n\">det</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">_root_.Collinear</span> <span class=\"n\">ℝ</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">H</span>\n  <span class=\"bp\">·</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"k\">then</span> <span class=\"n\">subst</span> <span class=\"n\">r</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">collinear_pair</span><span class=\"o\">]</span> <span class=\"k\">else</span>\n    <span class=\"n\">apply</span> <span class=\"n\">collinear_insert_of_mem_affineSpan_pair</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">⟪</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n      <span class=\"n\">mt</span> <span class=\"n\">Matrix.dotProduct_self_eq_zero.1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">sub_ne_zero.2</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Ne.symm</span> <span class=\"n\">h</span>\n    <span class=\"n\">convert</span> <span class=\"n\">AffineMap.lineMap_mem_affineSpan_pair</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">⟪</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span> <span class=\"bp\">/</span> <span class=\"bp\">⟪</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">q</span><span class=\"bp\">⟫</span><span class=\"n\">_ℝ</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">using</span> <span class=\"mi\">1</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AffineMap.lineMap_apply_module'</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">det</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">sub_eq_zero</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">smul_eq_zero_iff_right</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">smul_sub</span><span class=\"o\">,</span> <span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_div_cancel'</span> <span class=\"n\">_</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">norm_sq_eq_inner</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">linear_combination</span> <span class=\"n\">H</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">r</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">linear_combination</span> <span class=\"n\">H</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"mi\">0</span> <span class=\"bp\">-</span> <span class=\"n\">q</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">collinear_iff_of_mem</span> <span class=\"o\">(</span><span class=\"n\">p₀</span> <span class=\"o\">:=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">H</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"bp\">;</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">H</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">det</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ring</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">det</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span>\n    <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">p</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">segment</span> <span class=\"n\">ℝ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">collinear_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h.wbtw_or_wbtw_or_wbtw</span>\n  <span class=\"bp\">·</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mem_segment_iff_wbtw.2</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">right</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mem_segment_iff_wbtw.2</span> <span class=\"n\">h.symm</span>\n  <span class=\"bp\">·</span> <span class=\"n\">left</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">mem_segment_iff_wbtw.2</span> <span class=\"n\">h.symm</span>\n</code></pre></div>",
        "id": 422929377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648842
    },
    {
        "content": "<p><code>have : ⟪r - q, r - q⟫_ℝ ≠ 0 := inner_self_ne_zero.2 &lt;| sub_ne_zero.2 &lt;| Ne.symm h</code> saves you a line</p>",
        "id": 422929521,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708648927
    },
    {
        "content": "<p>and an import</p>",
        "id": 422929533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708648940
    },
    {
        "content": "<p>Does this approach help at all?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">vectorSpan_insert</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Point</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">vectorSpan</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">ℝ</span> <span class=\"o\">((</span><span class=\"bp\">·</span> <span class=\"bp\">-ᵥ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">collinear_iff</span> <span class=\"o\">:</span> <span class=\"n\">det</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">_root_.Collinear</span> <span class=\"n\">ℝ</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Collinear</span><span class=\"o\">,</span> <span class=\"n\">vectorSpan_insert</span><span class=\"o\">,</span> <span class=\"n\">Set.image_insert_eq</span><span class=\"o\">,</span> <span class=\"n\">Set.image_singleton</span><span class=\"o\">,</span> <span class=\"n\">vsub_eq_sub</span>\n    <span class=\"n\">det_eq_matrixDet'</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 422930165,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649437
    },
    {
        "content": "<p>the main goal there looks a bit weird, it's asking for <code>q - p = r - p</code>?</p>",
        "id": 422930354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708649543
    },
    {
        "content": "<p>I think the hard part with this approach is proving <code>LinearIndependent</code>, there are also other routes that connect to <code>AffineIndependent</code> of the three points but I don't really see where to go from there</p>",
        "id": 422930480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708649638
    },
    {
        "content": "<p>My mistake, edited</p>",
        "id": 422930593,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649707
    },
    {
        "content": "<p>actually maybe it's a bit better with <code>LinearIndependent ℝ fun (x : ↑{q -ᵥ p, r -ᵥ p}) ↦ ↑x</code> since it seems plausible that one can reduce this to invertibility of <code>![q - p, r - p]</code> and thence to the determinant</p>",
        "id": 422930621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708649732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422775987\">said</a>:</p>\n<blockquote>\n<p>There's a more general statement we're missing here: that under suitable assumptions, an alternating map is zero only when its arguments are linearly dependent (we only have the reverse statement)</p>\n</blockquote>\n<p>I think we probably want this still</p>",
        "id": 422930800,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> has asked for this in the past</p>",
        "id": 422930821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649878
    },
    {
        "content": "<p>do we have the \"alternating map\" used in this theorem though? I couldn't find any form of it in mathlib, which is why it's defined in the MWE</p>",
        "id": 422930890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708649899
    },
    {
        "content": "<p><code>rw [Matrix.det]</code></p>",
        "id": 422930979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649969
    },
    {
        "content": "<p>Then an alternating map appears</p>",
        "id": 422930985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649973
    },
    {
        "content": "<p>There's probably an API lemma somewhere</p>",
        "id": 422930997,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708649986
    },
    {
        "content": "<p>Unfortunately I think <code>det</code> isn't an alternating map by that definition, because it's an affine multilinear (multiaffine?) map</p>",
        "id": 422931311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708650206
    },
    {
        "content": "<p>Dumb rewrites get me to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Matrix.detRowAlternating</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">q</span> <span class=\"bp\">-</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span>\n      <span class=\"bp\">¬∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Cardinal.mk</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">∧</span> <span class=\"n\">LinearIndependent</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"o\">})</span> <span class=\"n\">ℝ</span> <span class=\"n\">Subtype.val</span>\n</code></pre></div>",
        "id": 422931819,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708650513
    },
    {
        "content": "<p>I think there are alternative lemmas that avoid the need to unfold the rank &lt;= 1 stuff</p>",
        "id": 422931887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708650571
    },
    {
        "content": "<p>Yeah, hence \"dumb\"</p>",
        "id": 422932241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708650801
    },
    {
        "content": "<p>Though it exposed that we're missing <code>(Order.succ (Nat.cast n) : Cardinal) = Nat.cast (n + 1)</code></p>",
        "id": 422932342,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708650864
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>)</p>",
        "id": 422932355,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708650873
    },
    {
        "content": "<p>the part that I'm still not sure about in this route is how to connect <code>LinearIndependent</code> to either invertibility of a matrix or some kind of determinant</p>",
        "id": 422932410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708650916
    },
    {
        "content": "<p>Since I didn't link it above, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlternatingMap.map_linearDependent#doc\">docs#AlternatingMap.map_linearDependent</a> is the (easy) direction that we do have</p>",
        "id": 422932690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708651175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422775987\">said</a>:</p>\n<blockquote>\n<p>There's a more general statement we're missing here: that under suitable assumptions, an alternating map is zero only when its arguments are linearly dependent (we only have the reverse statement)</p>\n</blockquote>\n<p>The assumptions need to rule out the extreme case of the zero map. It would be useful to have that <code>ExteriorAlgebra.ιMulti R k w = 0</code> only if <code>¬LinearIndependent R w</code>, since ιMulti is in some sense universal for alternating maps (on finite index types). (I hope I've got that right.) (Edit: <code>¬</code>!)</p>",
        "id": 422937702,
        "sender_full_name": "Richard Copley",
        "timestamp": 1708654370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422928101\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> Are you saying that this is the right way to do affine points in n dimensions too? I really want that whole business to be a definition with general properties, not something in user code</p>\n</blockquote>\n<p>Sure, this is completely general. See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=affineIndependent_iff_linearIndependent_vsub#doc\">docs#affineIndependent_iff_linearIndependent_vsub</a> for instance.</p>",
        "id": 422942696,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708657716
    },
    {
        "content": "<p>okay, but I want a notion of <code>det</code> here that does not choose a base point explicitly (it may do so internally as part of the definition)</p>",
        "id": 422946803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708661018
    },
    {
        "content": "<p>e.g. the LHS of that theorem</p>",
        "id": 422946828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1708661036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Circularity.20of.20betweenness.20in.20R.5E2/near/422932342\">said</a>:</p>\n<blockquote>\n<p>Though it exposed that we're missing <code>(Order.succ (Nat.cast n) : Cardinal) = Nat.cast (n + 1)</code></p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.nat_succ#doc\">docs#Cardinal.nat_succ</a> ?</p>",
        "id": 422971998,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708678002
    }
]