[
    {
        "content": "<p>Informally: a cardinal number is at least <code>n+1</code> iff it is greater than <code>n</code>.<br>\nLean MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"c1\">-- most general version</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">leq_iff_le_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span>  <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- sufficient for my application</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Cardinal.leq_two_iff_le_one</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- I can prove; that doesn't suffice for me as I need a cardinal `c` and not `mk α`</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">α</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Cardinal.one_lt_iff_nontrivial</span><span class=\"o\">,</span> <span class=\"n\">nontrivial_iff</span><span class=\"o\">,</span> <span class=\"n\">Cardinal.two_le_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>To un-#xy, I'd like to translate between two statements about the rank of modules.</p>\n<p>(If these lemmas should be named differently, I don't mind feedback about this either.)</p>",
        "id": 428007726,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1710965317
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- I can prove; that doesn't suffice for me as I need a cardinal `c` and not `mk α`</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">α</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Cardinal.mk</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Cardinal.one_lt_iff_nontrivial</span><span class=\"o\">,</span> <span class=\"n\">nontrivial_iff</span><span class=\"o\">,</span> <span class=\"n\">Cardinal.two_le_iff</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- but every cardinal is of the form `mk α`</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Cardinal.leq_two_iff_le_one</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Quotient.inductionOn</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">α</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">apply</span> <span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 428008491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710965681
    },
    {
        "content": "<p>for naming feedback, <code>Cardinal.two_le_iff_one_lt</code> is perhaps the name for it, and <code>two_le_mk_iff_one_lt</code> for <code>foo</code>.</p>",
        "id": 428008671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710965762
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"c1\">-- most general version</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">leq_iff_le_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span>  <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Nat.cast_one</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.cast_add</span><span class=\"o\">]</span>\n  <span class=\"n\">cases</span> <span class=\"n\">lt_or_le</span> <span class=\"n\">c</span> <span class=\"n\">Cardinal.aleph0</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Cardinal.lt_aleph0.mp</span> <span class=\"n\">h</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.cast_le</span><span class=\"o\">,</span> <span class=\"n\">Nat.cast_lt</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_le</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">apply</span> <span class=\"n\">iff_of_true</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">lt_of_lt_of_le</span> <span class=\"o\">(</span><span class=\"n\">Cardinal.nat_lt_aleph0</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">Cardinal.nat_lt_aleph0</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 428009063,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1710965954
    },
    {
        "content": "<p>Thank you, <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> and <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>.<br>\nI'll need this for <a href=\"https://github.com/leanprover-community/mathlib4/pull/11337\">#11337</a>, and have PRed these lemmas separately as <a href=\"https://github.com/leanprover-community/mathlib4/pull/11544\">#11544</a>.</p>",
        "id": 428010652,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1710966610
    },
    {
        "content": "<p>We almost have this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.SetTheory.Cardinal.Basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Cardinal.succ_natCast</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Order.succ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Cardinal.nat_succ</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_cast</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">leq_iff_le_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Cardinal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Order.succ_le_iff</span><span class=\"o\">,</span> <span class=\"n\">Cardinal.succ_natCast</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 428021219,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710971392
    },
    {
        "content": "<p>Yes, this is the purpose of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SuccOrder#doc\">docs#SuccOrder</a></p>",
        "id": 428021304,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710971428
    },
    {
        "content": "<p>I think both these lemmas are valuable to add. For <code>leq_iff_le_succ</code> I would reverse the <code>iff</code> and rename to <code>Cardinal.natCast_add_one_le_iff</code>.</p>",
        "id": 428021318,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710971437
    },
    {
        "content": "<p>In fact, I had originally designed <code>SuccOrder</code> with <code>succ n</code> hardcoded as <code>n + 1</code>. I still think it's worth having as it will give more rewrite-friendly lemmas</p>",
        "id": 428021443,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710971507
    },
    {
        "content": "<p>Certainly, it shouldn't be restricted to <code>Cardinal</code></p>",
        "id": 428021557,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710971542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20n.2C.20relating.20leq.20and.20le/near/428021443\">said</a>:</p>\n<blockquote>\n<p>In fact, I had originally designed <code>SuccOrder</code> with <code>succ n</code> hardcoded as <code>n + 1</code>. I still think it's worth having as it will give more rewrite-friendly lemmas</p>\n</blockquote>\n<p>For <code>Cardinal</code> that doesn't work. From the docstring:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Note</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">successor</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">c</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">the</span> <span class=\"n\">same</span> <span class=\"n\">as</span> <span class=\"bp\">`</span><span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">`</span> <span class=\"n\">except</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">case</span> <span class=\"n\">of</span> <span class=\"n\">finite</span> <span class=\"bp\">`</span><span class=\"n\">c</span><span class=\"bp\">`.</span>\n</code></pre></div>",
        "id": 428021581,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710971557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20n.2C.20relating.20leq.20and.20le/near/428021557\">said</a>:</p>\n<blockquote>\n<p>Certainly, it shouldn't be restricted to <code>Cardinal</code></p>\n</blockquote>\n<p>You are thinking of a generalization that I'm not thinking of? The only generalization I can think of is to introduce an <code>AddOneClass</code> or something, which I'm not sure is worth it.</p>",
        "id": 428021688,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710971620
    },
    {
        "content": "<p>Ah right, it works for ordinals but not for cardinals <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 428021987,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710971768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20n.2C.20relating.20leq.20and.20le/near/428021688\">said</a>:</p>\n<blockquote>\n<p>The only generalization I can think of is to introduce an <code>AddOneClass</code> or something</p>\n</blockquote>\n<p>What I'm thinking of is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">AddSuccOrder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoidWithOne</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">SuccOrder</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">succ_eq_add_one</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 428022155,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710971876
    },
    {
        "content": "<p>Sure, that is a possible class to add, and maybe worth it</p>",
        "id": 428022284,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710971931
    },
    {
        "content": "<p>This would apply to <code>Int</code>, <code>Nat</code>, <code>Fin (n + 1)</code>, <code>ZMod n</code>, <code>Ordinal</code></p>",
        "id": 428022288,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710971937
    },
    {
        "content": "<p>Does it apply to <code>Fin</code> and <code>ZMod</code> (w.r.t. the largest element)?</p>",
        "id": 428022331,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710971968
    },
    {
        "content": "<p>Yes, because the way <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SuccOrder#doc\">docs#SuccOrder</a> is set up means that <code>succ a</code> needs to be the successor element only if <code>a</code> is not maximal</p>",
        "id": 428022471,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710972026
    },
    {
        "content": "<p>yes, but I thought for maximal elts <code>succ a = a</code>, and in at least one of <code>Fin</code> and <code>ZMod</code>, <code>a+1=0</code> for the maximal elt <code>a</code>.</p>",
        "id": 428022545,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710972064
    },
    {
        "content": "<p>Ah, I see what you mean. Make it <code>succ_eq_add_one (a) (ha : ¬ IsMax a) : succ a = a + 1 := by rfl</code></p>",
        "id": 428022558,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710972075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20n.2C.20relating.20leq.20and.20le/near/428022545\">said</a>:</p>\n<blockquote>\n<p>in at least one of <code>Fin</code> and <code>ZMod</code>, <code>a+1=0</code> for the maximal elt <code>a</code>.</p>\n</blockquote>\n<p>This holds for both of them, right?</p>",
        "id": 428022605,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710972107
    },
    {
        "content": "<p>(I am still in favor of equipping <code>Fin n</code> with saturating addition, btw...)</p>",
        "id": 428022615,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710972111
    },
    {
        "content": "<p>Yes, I can see that, I'm not sure.</p>",
        "id": 428022691,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710972139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20n.2C.20relating.20leq.20and.20le/near/428022558\">said</a>:</p>\n<blockquote>\n<p>Ah, I see what you mean. Make it <code>succ_eq_add_one (a) (ha : ¬ IsMax a) : succ a = a + 1 := by rfl</code></p>\n</blockquote>\n<p>That <code>by rfl</code> will certainly not work when <code>ha</code> is needed to prove it <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> But yeah, that could work. The lemma <code>n &lt; c ↔ n + 1 ≤ c</code> still wouldn't hold unconditionally in <code>Fin</code> and <code>ZMod</code>.</p>",
        "id": 428022785,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710972212
    },
    {
        "content": "<p>and for <code>Nat</code>/<code>Int</code>/<code>Ordinal</code> you would want an unconditional lemma (which I guess you get when assuming <code>NoMaxOrder</code>).</p>",
        "id": 428022903,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710972263
    },
    {
        "content": "<p>It's a minor duplication that could be removed. I would approve it if someone does it, but I don't think it's very high priority. <code>SuccOrder</code> itself is very nice though.</p>",
        "id": 428022940,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1710972296
    },
    {
        "content": "<p>I abandoned the idea of <code>AddSuccOrder</code> back in 2021 not because it was bad but because <strong>I</strong> was bad (at Lean) and struggled with more basic things. I think it's worth doing (maybe you can do it as an order theory exercise, <span class=\"user-mention\" data-user-id=\"634338\">@Michael Rothgang</span>?)</p>",
        "id": 428023157,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1710972410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20n.2C.20relating.20leq.20and.20le/near/428023157\">said</a>:</p>\n<blockquote>\n<p>I abandoned the idea of <code>AddSuccOrder</code> back in 2021 not because it was bad but because <strong>I</strong> was bad (at Lean) and struggled with more basic things. I think it's worth doing (maybe you can do it as an order theory exercise, <span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span>?)</p>\n</blockquote>\n<p>Sure, but not soon :-) I'm on the final stretches of my thesis; that's too large a task for me <em>right now</em>. I'll put that on my list for later; feel free to remind me in June!</p>",
        "id": 428025522,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1710973687
    }
]