[
    {
        "content": "<p>I'm finding that there is very little explicit API for pair sets <code>{a,b}</code>, but a lot of things can be done by <code>simp</code> plus maybe one more lemma.  For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">E</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">E</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.insert_subset_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">):</span> <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.pair_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Would it be worth making these basic lemmas more explicit in Mathlib (similar to how there is plenty of API for singletons <code>{a}</code>?  (I feel like the second example could also be a <code>simp</code> lemma.)</p>",
        "id": 418521695,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706464146
    },
    {
        "content": "<p>The reason for this situation is that all finite explicit sets are built out of three things:</p>\n<ul>\n<li><code>∅</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EmptyCollection#doc\">docs#EmptyCollection</a>)</li>\n<li><code>{a}</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Singleton#doc\">docs#Singleton</a></li>\n<li><code>insert a s</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Insert#doc\">docs#Insert</a>)</li>\n</ul>\n<p>along with a class stating that <code>insert a ∅ = {a}</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLawfulSingleton#doc\">docs#IsLawfulSingleton</a>)</p>",
        "id": 418522340,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706464775
    },
    {
        "content": "<p>Hence <code>{a}</code> is a primitive while <code>{a, b}</code> is derived as <code>insert a {b}</code></p>",
        "id": 418522407,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706464810
    },
    {
        "content": "<p>Maybe the first two could be simp lemmas and the third one should be stated the other way around and then made a simp lemma if you think that <code>{a,b}</code> is a good \"canonical form\" for {a} union {b}.</p>",
        "id": 418522411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706464815
    },
    {
        "content": "<p>At what level of reducibility is <code>{a,b}</code> equal to <code>insert a {b}</code>?</p>",
        "id": 418522455,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706464877
    },
    {
        "content": "<p>Isn't it insert a insert b empty?</p>",
        "id": 418522531,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706464931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418522455\">said</a>:</p>\n<blockquote>\n<p>At what level of reducibility is <code>{a,b}</code> equal to <code>insert a {b}</code>?</p>\n</blockquote>\n<p>Syntactic</p>",
        "id": 418522547,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706464956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418522531\">said</a>:</p>\n<blockquote>\n<p>Isn't it insert a insert b empty?</p>\n</blockquote>\n<p>Nope, that's the point of this setup.</p>",
        "id": 418522553,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706464968
    },
    {
        "content": "<p>You want <code>x ∈ {a, b}</code> to be defeq to <code>x = a ∨ x = b</code>. If <code>{a, b}</code> were notation for <code>insert a (insert b ∅)</code> then <code>x ∈ {a, b}</code> would instead be defeq to <code>x = a ∨ x = b ∨ False</code></p>",
        "id": 418522620,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465030
    },
    {
        "content": "<p>We avoid the junk \"or False\" which was being appended when the naive implication of set notation was used</p>",
        "id": 418522624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465034
    },
    {
        "content": "<p>Similarly <code>x \\in {a}</code> is presumably syntactic for <code>x = a</code>. For ages in lean 3 it was definitonally something else and it was really annoying :-)</p>",
        "id": 418522739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418522411\">said</a>:</p>\n<blockquote>\n<p>Maybe the first two could be simp lemmas and the third one should be stated the other way around and then made a simp lemma if you think that <code>{a,b}</code> is a good \"canonical form\" for {a} union {b}.</p>\n</blockquote>\n<p>The first one is already a <code>simp</code> lemma (or more precisely the composition of two existing <code>simp</code> lemmas, <code>Set.mem_insert_iff</code> and <code>Set.mem_singleton_iff</code>).  As for the third lemma, given the lack of API for pair sets currently, it doesn't seem like a great idea to <code>simp</code> into a pair set.</p>\n<p>The main issue from my viewpoint as a user is that these obvious lemmas were not picked up by the usual searches (library search, <code>exact?</code>, <code>apply?</code>, etc.).  If one isn't aware that <code>{a,b}</code> is syntactic sugar for <code>insert a {b}</code> (which, by the way, is not made very explicit in the current documentation), it actually becomes quite hard to manipulate pair sets with the current API, other than by hoping to get lucky with <code>simp</code>.</p>",
        "id": 418522744,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706465127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418522739\">said</a>:</p>\n<blockquote>\n<p>Similarly <code>x \\in {a}</code> is presumably syntactic for <code>x = a</code>. For ages in lean 3 it was definitonally something else and it was really annoying :-)</p>\n</blockquote>\n<p>No, <code>x \\in {a}</code> is syntactic for <code>Mem x (singleton a)</code>, it is (regular) defeq to <code>x = a</code> though</p>",
        "id": 418522877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465238
    },
    {
        "content": "<p>Then we should make the documentation clearer. This setup has been around for ages</p>",
        "id": 418522878,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465240
    },
    {
        "content": "<p>In my experience what happens when you start formalising interesting stuff is that you discover missing pieces of the API for the objects you're using, and then the best favour you can do to the community is to make a short PR adding them. PRs containing no new definitions and which fill in holes in the library are very easy to review and merge, and once they're in, you don't have to maintain them yourself.</p>",
        "id": 418522987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465322
    },
    {
        "content": "<p>Yes but here the situation is different, because the correct answer to \"We are missing API for pairs\" is \"Make more API for <code>insert</code> then\"</p>",
        "id": 418523014,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465364
    },
    {
        "content": "<p>Right but this can all be discussed on GitHub</p>",
        "id": 418523043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465391
    },
    {
        "content": "<p>Yael if you take one look at it and see a better abstraction then you just make a suggestion of eg a complete rewrite</p>",
        "id": 418523120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465438
    },
    {
        "content": "<p>It's ten lines of code</p>",
        "id": 418523127,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418523014\">said</a>:</p>\n<blockquote>\n<p>Yes but here the situation is different, because the correct answer to \"We are missing API for pairs\" is \"Make more API for <code>insert</code> then\"</p>\n</blockquote>\n<p>and no matter how many times we do that the problem of \"we <em>appear to be</em> missing API for pairs\" doesn't go away</p>",
        "id": 418523131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418522878\">said</a>:</p>\n<blockquote>\n<p>Then we should make the documentation clearer. This setup has been around for ages</p>\n</blockquote>\n<p>As far as I can tell the only documentation currently that states that pair sets <code>{a,b}</code> are defined as <code>insert a {b}</code> is a cryptic sentence in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Classes/SetNotation.html#%C2%ABterm{_}%C2%BB\">https://leanprover-community.github.io/mathlib4_docs/Std/Classes/SetNotation.html#%C2%ABterm{_}%C2%BB</a></p>",
        "id": 418523145,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706465468
    },
    {
        "content": "<p>the docs on that should definitely be improved to state the desugaring</p>",
        "id": 418523174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465513
    },
    {
        "content": "<p>does that docstring show up when you hover <code>{1, 2}</code>?</p>",
        "id": 418523242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465546
    },
    {
        "content": "<p>This subtlety is all due to the fact that for counting \"things\" (like elements of a set) it's sometimes better to start at 1</p>",
        "id": 418523244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465548
    },
    {
        "content": "<p>Yeah well first example is <code>by simp</code> (or even <code>rfl</code>), second example would be <code>by simp</code> if <code>Set.insert_subset_iff</code> were a simp lemma (which I personally think is reasonable, but possibly unforeseen drawbacks), and the third one is <code>rfl</code> again</p>",
        "id": 418523257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465573
    },
    {
        "content": "<p>Thanks for the review!</p>",
        "id": 418523271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418523242\">said</a>:</p>\n<blockquote>\n<p>does that docstring show up when you hover <code>{1, 2}</code>?</p>\n</blockquote>\n<p>Just to expand on that, many notations currently don't display <em>any</em> documentation on hovers, which is a very poor state of things. <a href=\"https://github.com/leanprover-community/mathlib4/pull/9942\">#9942</a> is a first attempt at improving this.</p>",
        "id": 418523376,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465676
    },
    {
        "content": "<p>This all comes from our Lean 3 habit of trusting notation to know what docstring it should display (which is usually obvious, but not always)</p>",
        "id": 418523414,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465723
    },
    {
        "content": "<p>Someone could now open a mathlib PR, tag it WIP, add <code>simp</code> to the lemma Yael suggests, and then use CI to see if mathlib compiles, and then run the benchmarker on the results to see if mathlib is now easier or harder to compile.</p>",
        "id": 418523519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706465825
    },
    {
        "content": "<p>I think the <code>inherit_doc</code> algorithm is a bit more conservative than lean 3, but the fact that the default is no docs is very ungreat</p>",
        "id": 418523528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465838
    },
    {
        "content": "<p>The immediate fix then is to expand on the docstring for <code>«term{_}»</code> to explicitly state that <code>{a,b}</code> is syntactically equal to <code>insert a {b}</code>, and maybe also that <code>{a,b,c}</code> is syntactically equal to <code>insert a {b,c}</code>.  Given that this docstring shows up on hover, that should be enough of a guide for a typical user to know where to look for API.</p>",
        "id": 418523551,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706465879
    },
    {
        "content": "<p>Re: <a href=\"https://github.com/leanprover-community/mathlib4/pull/9942\">#9942</a>, when adding explicit docs to a notation one thing I like to do is to make sure to actually mention the declaration name in the docstring, because it's not obvious or easy to get to this information otherwise</p>",
        "id": 418523609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418523528\">said</a>:</p>\n<blockquote>\n<p>I think the <code>inherit_doc</code> algorithm is a bit more conservative than lean 3, but the fact that the default is no docs is very ungreat</p>\n</blockquote>\n<p>Strong agreed. It has the advantage that we now have more opportunities to write better docstrings, though.</p>",
        "id": 418523612,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465911
    },
    {
        "content": "<p>Isn't the declaration name something that's accessible on hover?</p>",
        "id": 418523630,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465945
    },
    {
        "content": "<p>you see the docs on hover</p>",
        "id": 418523652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465959
    },
    {
        "content": "<p>Don't you see the expected type too?</p>",
        "id": 418523665,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706465975
    },
    {
        "content": "<p>yes</p>",
        "id": 418523674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706465987
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/hJBLsixUVAE_qQDFVcitFUsn/image.png\">image.png</a><br>\nThis is what one sees for instance in the playground.  No declaration name, just the docstring and type.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/hJBLsixUVAE_qQDFVcitFUsn/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/hJBLsixUVAE_qQDFVcitFUsn/image.png\"></a></div>",
        "id": 418523678,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706465994
    },
    {
        "content": "<p>but that doesn't tell you what function it is</p>",
        "id": 418523687,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466002
    },
    {
        "content": "<p>Expected type got a lot more confusing in Lean 4, though, because Lean 4 displays</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">very_long_expected_term</span>\n<span class=\"n\">_across_several_lines</span> <span class=\"o\">:</span> <span class=\"n\">ex</span>\n<span class=\"n\">pected_type</span>\n</code></pre></div>\n<p>where Lean 3 would just give</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">expected_type</span>\n</code></pre></div>\n<p>which I find more useful</p>",
        "id": 418523778,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466060
    },
    {
        "content": "<p>I don't think that's true?</p>",
        "id": 418523813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466095
    },
    {
        "content": "<p>hover on terms just shows the expected type</p>",
        "id": 418523820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466106
    },
    {
        "content": "<p>hover on constants shows the constant signature</p>",
        "id": 418523829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466119
    },
    {
        "content": "<p>...unless I'm blind<br>\n<a href=\"/user_uploads/3121/hOJjrK-1rNU5gw0Lnd94TM7x/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/hOJjrK-1rNU5gw0Lnd94TM7x/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/hOJjrK-1rNU5gw0Lnd94TM7x/image.png\"></a></div>",
        "id": 418523884,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466139
    },
    {
        "content": "<p>and I was just about to suggest that <code>@[inherit_doc]</code> and <code>@[inherit_doc foo]</code> should set things up so that you also see the constant hover for <code>foo</code>, instead of just the docstring for it</p>",
        "id": 418523913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466177
    },
    {
        "content": "<p>Ìs the thing in my image what you mean by \"constant signature\"?</p>",
        "id": 418523940,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466208
    },
    {
        "content": "<p>no</p>",
        "id": 418523945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466213
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/hG14WK2lodX2QGaZWTBkaFwP/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/hG14WK2lodX2QGaZWTBkaFwP/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/hG14WK2lodX2QGaZWTBkaFwP/image.png\"></a></div>",
        "id": 418524006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466259
    },
    {
        "content": "<p>This sounds useful, but should be displayed after the docstring</p>",
        "id": 418524041,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466305
    },
    {
        "content": "<p>isn't doc-gen the same way?</p>",
        "id": 418524080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466348
    },
    {
        "content": "<p>I also recommend adding text to the (currently quite pitiful) section on API on pair sets near <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.pair_eq_singleton#doc\">docs#Set.pair_eq_singleton</a> to the effect that one can prove many results about <code>{a,b}</code> by using that it is syntactically equal to <code>insert a {b}</code>.</p>",
        "id": 418524145,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706466382
    },
    {
        "content": "<p>Yeah, which is very confusing now that we have docstrings on structure fields.</p>",
        "id": 418524152,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466387
    },
    {
        "content": "<p>there was some hubbub about this because the docs were going before the declaration (\"to match the docstring syntax in the lean file\"), but it has since been changed to have the docs after the definition</p>",
        "id": 418524231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466465
    },
    {
        "content": "<p>which IMO makes more sense</p>",
        "id": 418524236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466471
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dvd#doc\">docs#Dvd</a> doesn't look that unreasonable to me</p>",
        "id": 418524309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706466507
    },
    {
        "content": "<p>I still think it's worth explicitly putting the second example into Mathlib though.  Right now it is not picked up by <code>exact?</code>, <code>hint</code>, <code>apply?</code>, or <code>simp</code>.</p>",
        "id": 418524343,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706466551
    },
    {
        "content": "<p>Yeah this should be fixed by making <code>Set.insert_subset_iff</code> a simp lemma.</p>",
        "id": 418524792,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418524309\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dvd#doc\">docs#Dvd</a> doesn't look that unreasonable to me</p>\n</blockquote>\n<p>Actually, this looks better than it used to. I was remembering the time where the structure docstring would come after the fields (and their docstrings).</p>",
        "id": 418524912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706466989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418523609\">said</a>:</p>\n<blockquote>\n<p>Re: <a href=\"https://github.com/leanprover-community/mathlib4/pull/9942\">#9942</a>, when adding explicit docs to a notation one thing I like to do is to make sure to actually mention the declaration name in the docstring, because it's not obvious or easy to get to this information otherwise</p>\n</blockquote>\n<p>Should I actually do this or should I assume that hovers will soon work differently and include the declaration name automatically?</p>",
        "id": 418525689,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706467662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/More.20API.20for.20pair.20sets.3F/near/418524792\">said</a>:</p>\n<blockquote>\n<p>Yeah this should be fixed by making <code>Set.insert_subset_iff</code> a simp lemma.</p>\n</blockquote>\n<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.insert_subset_iff#doc\">docs#Set.insert_subset_iff</a> a bad simp lemma because it duplicates <code>t</code>?</p>",
        "id": 418526913,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1706468689
    },
    {
        "content": "<p>so does <code>mem_insert</code> though</p>",
        "id": 418526940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706468716
    },
    {
        "content": "<p>I think it's a reasonable simp lemma exactly because it works nicely on <code>insert</code> chains</p>",
        "id": 418526960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706468739
    },
    {
        "content": "<p>then again, unlike <code>mem_insert</code>, with <code>insert_subset_iff</code> both sides of the subset can be pairs; we probably don't want <code>{a, b, c, d, e} ⊆ {x, y, z, u, v}</code> to explode into 25 cases</p>",
        "id": 418527325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706469007
    },
    {
        "content": "<p>Sometimes we might? So maybe that indicates it should be in a non-default simp set</p>",
        "id": 418527681,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706469288
    },
    {
        "content": "<p>I think that strengthens the case of making <code>{a,b} ⊆ E ↔ a ∈ E ∧ b ∈ E</code> a standalone lemma (and possibly also a <code>simp</code> lemma), for instance to be added to the small collection of \"Lemmas about pairs\" in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html</a></p>",
        "id": 418527759,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706469357
    },
    {
        "content": "<p>Actually, Ruben is right that even that would be a bad simp lemma since it duplicates <code>E</code>. If <code>E</code> is a huge expression, this might give exponential slowdown.</p>",
        "id": 418527879,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706469436
    },
    {
        "content": "<p>quadratic slowdown is more likely</p>",
        "id": 418527907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706469462
    },
    {
        "content": "<p>Probably something that could be fixed with pre vs post simp lemmas, even</p>",
        "id": 418528009,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706469530
    },
    {
        "content": "<blockquote>\n<p>it should be in a non-default simp set</p>\n</blockquote>\n<p>aka it should not be simp and people should just pass it to simp when they want it</p>",
        "id": 418528057,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706469575
    },
    {
        "content": "<p>That's one solution (status quo), but my hope is that we could make it more discoverable by having a simp set gathering a bunch of lemmas like this one which are not so easy to find</p>",
        "id": 418528303,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706469735
    },
    {
        "content": "<p>actually, just having a bunch more lemmas with the word <code>pair</code> in their name (<code>Set.mem_pair</code>, <code>Set.pair_subset_iff</code>, etc.), would make searching for lemmas involving pairs quite easy.</p>",
        "id": 418528517,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706469905
    },
    {
        "content": "<p>Do you envision some larger set of <code>simp</code> lemmas that a more desperate version <code>simp!</code> of <code>simp</code> would try using if <code>simp</code> itself was unsuccessful? [\"I really, really need this simplified, regardless of computational cost.\"]</p>",
        "id": 418528719,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706470058
    }
]