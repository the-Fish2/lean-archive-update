[
    {
        "content": "<p>Is this true for <code>IntermediateField</code>s? I know it's true for commutative <code>Subalgebra</code>s which are free as modules &lt;<a href=\"https://github.com/leanprover-community/mathlib4/blob/1e2a0aac32d0588b02af596df95840ac5cd33db3/Mathlib/RingTheory/LinearDisjoint.lean#L374-L380\">https://github.com/leanprover-community/mathlib4/blob/1e2a0aac32d0588b02af596df95840ac5cd33db3/Mathlib/RingTheory/LinearDisjoint.lean#L374-L380</a>&gt;. For fields, the remaining case is both <code>A/F</code> and <code>B/F</code> are not algebraic. In this case I suspect this holds as an equality of cardinality. But I have no idea how to prove it.</p>",
        "id": 437327931,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715025101
    },
    {
        "content": "<p>We only need to show when <code>A/F</code> and <code>B/F</code> are purely transcendental. Since in general case, there is <code>A/A'</code> algebraic, <code>A'/F</code>purely transcendental, <code>B/B'</code> algebraic, <code>B'/F</code>purely transcendental. By algebraicity we already have <code>[AB : A'B'] ≤ [AB' : A'B'] * [A'B : A'B'] ≤ [A : A'] * [B : B']</code>. If <code>[A'B' : F] ≤ [A' : F] * [B' : F]</code> then the desired result follows.</p>",
        "id": 437875713,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715283773
    },
    {
        "content": "<p>By the way, it's tempted to define <code>IntermediateField.inclRank (h : F ≤ E) := Module.rank F (IntermediateField.extendScalars h)</code>. Otherwise the above argument is tedious to write down in Lean; you need a lot of manual <code>Algebra</code> and <code>IsScalarTower</code> instances.</p>",
        "id": 437876248,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715284033
    },
    {
        "content": "<p>When <code>A/F</code> and <code>B/F</code> are purely transcendental, we may assume that they are isomorphic to <code>MvRatFunc</code> (which is not defined in mathlib yet, we only have <code>FractionRing</code> of <code>MvPolynomial</code>) <code>F(S)</code> and <code>F(T)</code>, respectively. Then there should be a surjective <code>F</code>-linear map from <code>F(S,T)</code> to <code>AB</code>. This should give the desired result, once we know how to compute <code>[F(S) : F]</code>.</p>",
        "id": 437880213,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715285794
    },
    {
        "content": "<p>When <code>S</code> is not empty, <code>[F(S) : F]</code> should be equal to <code>max(#S, #F, aleph0)</code>. The only (a little bit) nontrivial step is prove that <code>1 / (X_i - a)</code> for a fixed <code>i : S</code> and all <code>a : F</code> are <code>F</code>-linearly independent. All the remaining arguments are already in mathlib.</p>",
        "id": 437883616,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715287352
    },
    {
        "content": "<blockquote>\n<p>there should be a surjective <code>F</code>-linear map from <code>F(S,T)</code> to <code>AB</code></p>\n</blockquote>\n<p>This argument is not so good I think. The following is better: since <code>F(S)</code> and <code>F(T)</code> both embeds into <code>AB</code>, we have <code>[AB : F] ≥ max(#S, #T, #F, aleph0)</code>. On the other hand, <code>AB</code> is the fraction field of the image of <code>F[S,T]</code> in <code>E</code>, hence its cardinality is <code>≤ max(#S + #T, #F, aleph0) = max(#S, #T, #F, aleph0)</code>, so <code>[AB : F]</code> must also be smaller than or equal to this.</p>",
        "id": 437898602,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715294923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.5BAB.20.3A.20F.5D.20.E2.89.A4.20.5BA.20.3A.20F.5D.20*.20.5BB.20.3A.20F.5D.20for.20intermediate.20fields/near/437876248\">said</a>:</p>\n<blockquote>\n<p>By the way, it's tempted to define <code>IntermediateField.inclRank (h : F ≤ E) := Module.rank F (IntermediateField.extendScalars h)</code>. Otherwise the above argument is tedious to write down in Lean; you need a lot of manual <code>Algebra</code> and <code>IsScalarTower</code> instances.</p>\n</blockquote>\n<p>This reminds me of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.relindex#doc\">docs#Subgroup.relindex</a> which I found helpful for these sorts of relative rank/cardinality questions.</p>",
        "id": 437906310,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1715300439
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"366779\">@Jz Pan</span> for dealing with these thankless issues properly! Our library is the richer because of it.</p>",
        "id": 438051790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715378259
    },
    {
        "content": "<p>Oooooohhh we don't have transcendental basis yet :( We only have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_maximal_algebraicIndependent#doc\">docs#exists_maximal_algebraicIndependent</a> but I need the fact that the above field is algebraic over the intermediate field generated by a maximal algebraic independent family :( ... which is not in mathlib yet. That is also useful in the separable degree file (for transcendental extensions). I also need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO: move to suitable place</span>\n<span class=\"sd\">/-- Canonical isomorphism between rational functions and the</span>\n<span class=\"sd\">intermediate field generated by algebraically independent elements. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.AlgebraicIndependent.algEquivField</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">AlgebraicIndependent</span> <span class=\"n\">F</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">FractionRing</span> <span class=\"o\">(</span><span class=\"n\">MvPolynomial</span> <span class=\"n\">ι</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">IntermediateField.adjoin</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Set.range</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but so far we only have algebra version <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AlgebraicIndependent.aevalEquiv#doc\">docs#AlgebraicIndependent.aevalEquiv</a> ...</p>",
        "id": 438127204,
        "sender_full_name": "Jz Pan",
        "timestamp": 1715453375
    },
    {
        "content": "<p>I've defined <code>AlgebraicIndependent.algEquivField</code> and will open a PR soon.</p>",
        "id": 439894091,
        "sender_full_name": "Jz Pan",
        "timestamp": 1716321746
    },
    {
        "content": "<blockquote>\n<p>Oooooohhh we don't have transcendental basis yet :( We only have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_maximal_algebraicIndependent#doc\">docs#exists_maximal_algebraicIndependent</a> but I need the fact that the above field is algebraic over the intermediate field generated by a maximal algebraic independent family :( ... which is not in mathlib yet.</p>\n</blockquote>\n<p>That's not correct: we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_isTranscendenceBasis#doc\">docs#exists_isTranscendenceBasis</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsTranscendenceBasis.isAlgebraic#doc\">docs#IsTranscendenceBasis.isAlgebraic</a></p>",
        "id": 439894375,
        "sender_full_name": "Jz Pan",
        "timestamp": 1716321852
    }
]