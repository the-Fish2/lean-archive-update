[
    {
        "content": "<p>Do we have a Class for Uncountable (i.e. strictly larger cardinality than Countable), or should I just use \\neg (Countable ...) to encode this information?</p>",
        "id": 409713719,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703334490
    },
    {
        "content": "<p>We use <code>¬ Countable</code>, see for example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=not_countable_complex#doc\">docs#not_countable_complex</a>.</p>",
        "id": 409713916,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703334664
    },
    {
        "content": "<p>But this is not a crazy idea,  we have for example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Subsingleton#doc\">docs#Set.Subsingleton</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Nontrivial#doc\">docs#Set.Nontrivial</a></p>",
        "id": 409714014,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1703334738
    },
    {
        "content": "<p>IMHO, we should have a class for <code>Uncountable</code> and <code>Filter.cocountable</code>.</p>",
        "id": 409722608,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703342813
    },
    {
        "content": "<p>I’m working on Filter.cocountable, see my message earlier today: <a href=\"#narrow/stream/287929-mathlib4/topic/Cocountable.20filter/near/409699987\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Cocountable.20filter/near/409699987</a></p>",
        "id": 409723381,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703343519
    },
    {
        "content": "<p>Or do you mean that Filter.cocountable should make use of the class Uncountable explicitly?</p>",
        "id": 409723405,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703343557
    },
    {
        "content": "<p>It should use it for <code>instance [Uncountable α] : NeBot (cocountable α)</code></p>",
        "id": 409723706,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703343731
    },
    {
        "content": "<p>(or <code>cocountable : Filter α</code>, if you make <code>α</code> implicit)</p>",
        "id": 409723754,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703343752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Not.20countable/near/409723706\">said</a>:</p>\n<blockquote>\n<p>It should use it for <code>instance [Uncountable α] : NeBot (cocountable α)</code></p>\n</blockquote>\n<p>Yes, that’s where I have a little problem now, as I didn’t know how to write what would boil down to [\\neg Countable \\alpha]. I skipped that part for now, but I could make a class here that is defined similar to Countable, but with a negation and leave it in Filter.cocountable for now?</p>",
        "id": 409724328,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703344176
    },
    {
        "content": "<p>You should create a new file near the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Countable#doc\">docs#Countable</a> with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">mk_iff</span><span class=\"kd\">]</span>\n<span class=\"kd\">class</span> <span class=\"n\">Uncountable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"n\">not_countable</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">Countable</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>lemmas like <code>Function.Injective.uncountable</code>, <code>Function.Surjective.uncountable</code>, and instances like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Uncountable</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Uncountable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⊕</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Sum.inl_injective.uncountable</span>\n</code></pre></div>",
        "id": 409724816,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703344518
    },
    {
        "content": "<p>Probably, you should PR the <code>Uncountable</code> class first, then <code>Filter.cocountable</code>.</p>",
        "id": 409724961,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703344624
    },
    {
        "content": "<p>Or you can PR the <code>Filter.cocountable</code> without the <code>NeBot</code> instance, then PR the <code>Uncountable</code> class.</p>",
        "id": 409724978,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703344644
    },
    {
        "content": "<p>I need to keep the PR’s small anyway, I’ll see what I can do soon! Can I @ you as reviewer once I make the PR’s?</p>",
        "id": 409725086,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703344720
    },
    {
        "content": "<p>I think it should be in the same file as <code>Countable</code></p>",
        "id": 409725204,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703344806
    },
    {
        "content": "<p>We already have 3 files in <code>Data/Countable</code>.</p>",
        "id": 409725488,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703345004
    },
    {
        "content": "<p>I maintain. The negation of a property should be in the same file as that property.</p>",
        "id": 409725574,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703345050
    },
    {
        "content": "<p>Then a good way is to mirror each statement about <code>Countable</code> with a statement about <code>Uncountable</code>.</p>",
        "id": 409725691,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703345121
    },
    {
        "content": "<p>Okay, I'll work on a PR for a bit!</p>",
        "id": 409727152,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703346028
    },
    {
        "content": "<p>Just to make sure I get this right, I need to add it to Data/Countable/Defs.lean, right?</p>",
        "id": 409727639,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703346411
    },
    {
        "content": "<p>And possibly add some lemmas to <code>Data/Countable/Basic</code></p>",
        "id": 409727890,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703346644
    },
    {
        "content": "<p>This is now <a href=\"https://github.com/leanprover-community/mathlib4/pull/9254\">#9254</a>. It is very small at this point, I'd like to make sure I get it right before adding more API, so any feedback is welcome!</p>",
        "id": 409793415,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703402963
    },
    {
        "content": "<p>BTW, should we define <code>Uncountable</code> for <code>Sort*</code> or for <code>Type*</code>? All instances will be in <code>Type*</code> and assuming <code>Type*</code> can make it easier for Lean to unify universes (am I right?).</p>",
        "id": 409823614,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703432085
    },
    {
        "content": "<p>I just went for the same option as Countable to ensure consistency, I’m happy to change it though! Perhaps we should change both of them then?</p>",
        "id": 409824945,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703433530
    },
    {
        "content": "<p>No, <code>(p : Prop) : Countable p</code> is a valid instance.</p>",
        "id": 409825468,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703433866
    },
    {
        "content": "<p>But proofs of a proposition form a <code>Subsingleton</code>, hence finite, hence countable.</p>",
        "id": 409825490,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703433888
    },
    {
        "content": "<p>I pushed some changes to your branch.</p>",
        "id": 409825529,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703433926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Are there any reasons to use <code>Sort*</code> for <code>Uncountable</code>? If no, then should we change <code>Infinite</code> to <code>Type*</code> too?</p>",
        "id": 409826219,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703434604
    },
    {
        "content": "<p>Well they are propositions, you are allowed to negate them too</p>",
        "id": 409826304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703434705
    },
    {
        "content": "<p>But I agree it's not much use to have either <code>Countable</code> or <code>Uncountable</code> as working on <code>Sort*</code></p>",
        "id": 409826319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703434734
    },
    {
        "content": "<p>I would probably just put them in <code>Type*</code> until some use case actually needs them to be <code>Sort*</code></p>",
        "id": 409826335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703434758
    },
    {
        "content": "<p><code>Countable</code> is useful on <code>Sort*</code> because we can apply lemmas like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.measure_iUnion_null#doc\">docs#MeasureTheory.measure_iUnion_null</a> to a <code>Countable</code> <code>Sort*</code></p>",
        "id": 409826436,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703434845
    },
    {
        "content": "<p>(BTW, we should change this lemma to use <code>Sort*</code>)</p>",
        "id": 409826445,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703434857
    },
    {
        "content": "<p>Looking forward to <code>PUncountable</code> in the future :-)</p>",
        "id": 409826462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703434875
    },
    {
        "content": "<p>Why would you need this?</p>",
        "id": 409826477,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703434896
    },
    {
        "content": "<p>Well you just pointed out that <code>Countable</code> was useful on <code>Sort*</code>, so I'm just waiting for the future use case :-)</p>",
        "id": 409826533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703434926
    },
    {
        "content": "<p>Right back at you, given that the lemma doesn't actually work on <code>Sort*</code> today it doesn't seem to support your argument that we need it</p>",
        "id": 409826534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703434928
    },
    {
        "content": "<p>There is a TODO about it two lemmas down though</p>",
        "id": 409826601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703435032
    },
    {
        "content": "<p>but it seems that it was provable just the same, so it doesn't seem to be essential to unify them</p>",
        "id": 409826670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703435078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Not.20countable/near/409825529\">said</a>:</p>\n<blockquote>\n<p>I pushed some changes to your branch.</p>\n</blockquote>\n<p>Thanks, feel free to add more of course!</p>",
        "id": 409826676,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703435084
    },
    {
        "content": "<p>Right, we have separate lemmas for unions over <code>Type*</code>s and <code>Prop</code>s. When we introduced <code>Countable</code>, the plan was to unify them, but then we forgot.</p>",
        "id": 409826837,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703435248
    },
    {
        "content": "<p>We definitely use this trick for <code>Finite</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.eventually_all#doc\">docs#Filter.eventually_all</a></p>",
        "id": 409826909,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703435299
    },
    {
        "content": "<p>yes I remember, that was where one of the spurious universe bumps in mathlib came from</p>",
        "id": 409826949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703435346
    },
    {
        "content": "<p>How does this lead to a universe bump?</p>",
        "id": 409827502,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703435980
    },
    {
        "content": "<p>There was a bump when I made <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finprod#doc\">docs#finprod</a> work for <code>Sort*</code>s using <code>PLift</code>.</p>",
        "id": 409827569,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436038
    },
    {
        "content": "<p>I think the construction uses <code>PLift</code>, which lifts things in <code>Sort u</code> to <code>Type u</code></p>",
        "id": 409827580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703436055
    },
    {
        "content": "<p>Maybe some instances use <code>PLift</code> but not the definition.</p>",
        "id": 409827596,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436074
    },
    {
        "content": "<p>oh I see, I guess the definition is no longer <code>Nonempty (Fintype A)</code></p>",
        "id": 409827666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703436146
    },
    {
        "content": "<p>Yes, the definition is <code>∃ n, Nonempty (α ≃ Fin n)</code></p>",
        "id": 409827686,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436189
    },
    {
        "content": "<p>I don't really mind one way or another, do what you prefer</p>",
        "id": 409827744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703436248
    },
    {
        "content": "<p>I think that we'll go with <code>Sort*</code> in this PR, then I'll try to change <code>Infinite</code> and <code>Uncountable</code> to <code>Type*</code> in another PR.</p>",
        "id": 409827772,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436304
    },
    {
        "content": "<p>BTW, do we need <code>Classical.choice</code> for this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">Nontrivial</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">Countable</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">π</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 409827862,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436413
    },
    {
        "content": "<p>I guess, yes, because of the way we define <code>Infinite</code> (at least)</p>",
        "id": 409827889,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436475
    },
    {
        "content": "<p>is nontrivial constructive?</p>",
        "id": 409827936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703436488
    },
    {
        "content": "<p>No, it's a <code>Prop</code></p>",
        "id": 409827939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436496
    },
    {
        "content": "<p>And <code>Infinite</code> is very non-constructive: it's <code>Not (Finite α)</code>.</p>",
        "id": 409827946,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436519
    },
    {
        "content": "<p>in that case yes, it's equivalent to the axiom of choice</p>",
        "id": 409827947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703436524
    },
    {
        "content": "<p>So, the answer is \"not\" and I can use <code>choose</code> in the proof.</p>",
        "id": 409827948,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703436524
    },
    {
        "content": "<p>without choice you can't even prove that type is nonempty</p>",
        "id": 409827968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703436563
    },
    {
        "content": "<p>Shall I put <a href=\"https://github.com/leanprover-community/mathlib4/pull/9254\">#9254</a> out for review, or should something new be added there?</p>",
        "id": 411253490,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1704398696
    }
]