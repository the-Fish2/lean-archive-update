[
    {
        "content": "<p>Suppose I have some props <code>P Q : ‚Ñù ‚Üí Prop</code> and a hypothesis <code>h : ‚àÄ·∂† (c : ‚Ñù) in ùìù[&gt;]0, P c</code>, and I'm trying to prove the goal </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">‚ä¢</span> <span class=\"bp\">‚àÄ·∂†</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"bp\">ùìù</span><span class=\"o\">[</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Q</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>I can <code>filter_upwards [h]</code> and it will change the goal to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">‚ä¢</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">c</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Q</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>But I want it to change the goal to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">‚ä¢</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">),</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">P</span> <span class=\"n\">c</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Q</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>Is there a way to <code>filter_upwards</code> <em>within</em> a filter? Thanks!</p>",
        "id": 421533818,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1707945223
    },
    {
        "content": "<p>I think you need to use the right lemma for nhds_within, which will be the Eventually statement that 0 &lt; c for all c eventually in the nhds</p>",
        "id": 421534072,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707945328
    },
    {
        "content": "<p>but how do I filter_upwards with that at the same time?</p>",
        "id": 421534198,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1707945374
    },
    {
        "content": "<p>[h, that_lemma]</p>",
        "id": 421534281,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707945416
    },
    {
        "content": "<p>I think there's also some way to intro automatically too</p>",
        "id": 421534294,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707945423
    },
    {
        "content": "<p>Should be in the docs</p>",
        "id": 421534305,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707945429
    },
    {
        "content": "<p>Got it, thanks!</p>",
        "id": 421534478,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1707945488
    },
    {
        "content": "<p>This simple behaviour is how I came to love filter upwards, because it means you can do (for example) common epsilon delta arguments that require a <code>max</code> in a (to me) much more clear way</p>",
        "id": 421534734,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707945603
    },
    {
        "content": "<p>Anyways, I digress</p>",
        "id": 421534774,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707945611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/filter_upwards_within/near/421534734\">said</a>:</p>\n<blockquote>\n<p>This simple behaviour is how I came to love filter upwards, because it means you can do (for example) common epsilon delta arguments that require a <code>max</code> in a (to me) much more clear way</p>\n</blockquote>\n<p>Indeed this is the whole point!</p>",
        "id": 421542559,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707948995
    },
    {
        "content": "<p>The lemma is <code>self_mem_nhdsWithin</code></p>",
        "id": 421552830,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1707954080
    },
    {
        "content": "<p>I was trying to find a good example where stuff is written in a terrible <code>max</code> sort of way, but could be written in a better way if we had better-looking filter bases (<a href=\"https://github.com/leanprover-community/mathlib4/pull/9258\">#9258</a>). I am trying to do some thinking, because I think this could legitimately be a much better way to do these sorts of arguments (for teaching, even - we really can make \"choose N large such that P N , Q N and T N\" rigorous in such a better and more intuitive way!)</p>",
        "id": 421554673,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707955153
    },
    {
        "content": "<p>I don‚Äôt understand why you say this requires <a href=\"https://github.com/leanprover-community/mathlib4/pull/9258\">#9258</a>. This issue is very specific. We already have very usable filter bases. And really the reason why you will never convince anyone in the real world is that you are trying to replace non-proofs. There is nothing you can do to be more efficient than not proving something.</p>",
        "id": 421562757,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1707960454
    },
    {
        "content": "<p>How would you simulate this theorem? I do not know how using this is a non-proof - I think it's much much better than Metric.tendsto_nhds</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Metric.tendsto_nhds'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Œ≤</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"n\">u</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ·∂†</span> <span class=\"n\">Œµ</span> <span class=\"k\">in</span> <span class=\"bp\">ùìù</span><span class=\"o\">[</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ·∂†</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Œµ</span><span class=\"bp\">`</span>\n</code></pre></div>",
        "id": 421608713,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707987896
    },
    {
        "content": "<p>I don‚Äôt see <a href=\"https://github.com/leanprover-community/mathlib4/pull/9258\">#9258</a> as something that we need to be proficient with filter bases, the current situation is already very good. Typically, we have everything necessary for \"Choose N large enough such that‚Ä¶\". It‚Äôs more a potential exploration direction, in the same way that we came up (I think?) with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.smallSets#doc\">docs#Filter.smallSets</a></p>",
        "id": 421619413,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707991289
    },
    {
        "content": "<p>What's the issue/intuition behind smallSets?</p>",
        "id": 421624671,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707993183
    },
    {
        "content": "<p><code>‚àÄ·∂† s in (ùìù a).smallSets, p s</code> means that <code>p</code> is true for subsets of suffiiciently small nhds of <code>a</code>.</p>",
        "id": 421702928,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708017161
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.Tendsto.Icc#doc\">docs#Filter.Tendsto.Icc</a> that says (in one of the cases) that if <code>f ‚Üí a</code> and <code>g ‚Üí a</code>, then the whole interval <code>[f x, g x]</code> is contained in a small nhd of <code>a</code>, a.k.a. sandwich lemma.</p>",
        "id": 421703393,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1708017296
    }
]