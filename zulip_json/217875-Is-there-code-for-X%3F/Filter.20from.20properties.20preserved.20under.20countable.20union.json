[
    {
        "content": "<p>Suppose that  we have 'p : Set X -&gt; Prop' which carries over to subsets (hmono) and is preserved under countable unions (hcountable_union). The set of sets whose complement satisfy this property defines a Filter (with the countable intersection property); the finite union version of this is used in proving IsCompact.induction_on, and I'm using the countable union version of this to prove IsLindelof.induction_on. Are these results already added separately/is there interest in adding them separately? See the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Countable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Filter.CountableInter</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Compactness.Compact</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Topology</span> <span class=\"n\">TopologicalSpace</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hmono</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">⦄,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hcountable_union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)),</span> <span class=\"n\">S.Countable</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Filter</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"o\">}</span>\n      <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span>\n      <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ht₁</span> <span class=\"n\">ht</span> <span class=\"bp\">↦</span> <span class=\"n\">hmono</span> <span class=\"o\">(</span><span class=\"n\">compl_subset_compl.2</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"n\">ht₁</span>\n      <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"n\">ht₁</span> <span class=\"n\">ht₂</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">]</span>\n        <span class=\"n\">intro</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span>\n        <span class=\"k\">let</span> <span class=\"n\">Se</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">ht₁</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span> <span class=\"n\">ht₂</span><span class=\"bp\">ᶜ</span><span class=\"o\">}</span>\n        <span class=\"k\">have</span> <span class=\"n\">hSe</span> <span class=\"o\">:</span> <span class=\"n\">Se.Countable</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">Se</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n          <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n          <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">p₁</span>\n          <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">ht₂</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n              <span class=\"n\">assumption</span>\n            <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n            <span class=\"n\">exact</span> <span class=\"n\">p₂</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hcountable_union</span> <span class=\"n\">Se</span> <span class=\"n\">hSe</span> <span class=\"n\">this</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">⋃</span> <span class=\"n\">s</span><span class=\"bp\">∈</span> <span class=\"n\">Se</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">ht₁</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∪</span> <span class=\"n\">ht₂</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n        <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n        <span class=\"o\">}</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">CountableInterFilter</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">CountableInterFilter.mk</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Filter.mem_mk</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">compl_sInter</span><span class=\"o\">,</span> <span class=\"n\">sUnion_image</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">S</span> <span class=\"n\">hS</span> <span class=\"n\">hsp</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span><span class=\"bp\">ᶜ</span>\n    <span class=\"k\">let</span> <span class=\"n\">S'</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">S</span>\n    <span class=\"k\">have</span> <span class=\"n\">hsp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S'</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span>\n    <span class=\"k\">have</span> <span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S'.Countable</span> <span class=\"o\">:=</span> <span class=\"n\">Countable.image</span> <span class=\"n\">hS</span> <span class=\"n\">_</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">⋃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S'</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hcountable_union</span> <span class=\"n\">S'</span> <span class=\"n\">hS'</span> <span class=\"n\">hsp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 409559379,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703241220
    },
    {
        "content": "<p>This was suggested in the reviewing process of <a href=\"https://github.com/leanprover-community/mathlib4/pull/9107\">#9107</a></p>",
        "id": 409560381,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703241601
    },
    {
        "content": "<p>My gut feeling is that if this is useful for you in some project doing interesting mathematics then this is a good justification for adding them. If you're taking complements everywhere then maybe you're looking for ideals not filters though (do we have them?)</p>",
        "id": 409565649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703243886
    },
    {
        "content": "<p>In essence the complements are not necessary here, the more general set-up would I guess be that I can introduce 4 related results, which feel more intuitive in terms of Filters for me (also because the direct use-cases are for filters, that saves some intermediate results). </p>\n<p>A: CountableInterFilter from sets {t : p t} if p is stable under countable intersections<br>\nB: CountableInterFilter from sets {t : p tᶜ} if p is stable under countable unions, infer from A<br>\nC: filter from sets {t : p tᶜ} if p is stable under finite unions<br>\nD: filter from sets {t : p t} if p is stable under finite intersections, infer from C</p>\n<p>I think this should carry over to more general unions/intersections as well, but I'm not sure how useful that will be. </p>\n<p>Shall I add A and B to Filter/CountableInter.lean and C and D to Filter/Basic.lean?</p>",
        "id": 409566569,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703244344
    },
    {
        "content": "<p>My understanding of the mathlib way is that \"if you can generalise something at no cost (to e.g. the proofs), then do it\". (This may be different from writing textbooks or math papers.) In other words: this seems plausible to me.</p>",
        "id": 409568419,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1703245281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"673728\">@Josha Dekker</span> you could try making a PR with just C and D, and you might learn something from the reviews. Making a PR is usually the best way to get the experts to think about your ideas.</p>",
        "id": 409568858,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703245487
    },
    {
        "content": "<p>Okay, I'll do that! Thank you!</p>",
        "id": 409575484,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703248440
    },
    {
        "content": "<p>This is now <a href=\"https://github.com/leanprover-community/mathlib4/pull/9200\">#9200</a>, any remarks are welcome! I found that proving C and D separately was quicker than inferring either from the other.</p>",
        "id": 409583847,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703252088
    },
    {
        "content": "<p>I left some comments there.</p>",
        "id": 409732800,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703349959
    },
    {
        "content": "<p>Thanks, I’ll take a look soon!</p>",
        "id": 409746060,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703362492
    }
]