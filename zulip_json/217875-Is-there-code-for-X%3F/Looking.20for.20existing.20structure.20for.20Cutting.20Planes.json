[
    {
        "content": "<p>Hello Everyone! I am starting to model and develop proofs for <a href=\"https://jakobnordstrom.se/docs/presentations/TalkVeriPB_Dagstuhl23.pdf\">cutting planes and pseudo boolean equations</a> in lean. The notation looks like this:<br>\n<a href=\"/user_uploads/3121/pjprm1uKLoFZ_TxHCDh-d_m0/image.png\">image.png</a><br>\nWhere I am looking for a nice notation to model the Sum over ai*li and express the following rules:<br>\n<a href=\"/user_uploads/3121/StOBGNXYDoo1JmY2BP-F6XF1/image.png\">image.png</a><br>\nOf which I will prove the correctness of each using Lean as well. <br>\nNow I have approached modelling with <code>List Int</code>, where I keep the <code>as</code> and <code>ls</code> separate and unite them with the predicate:</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/pjprm1uKLoFZ_TxHCDh-d_m0/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/pjprm1uKLoFZ_TxHCDh-d_m0/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/StOBGNXYDoo1JmY2BP-F6XF1/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/StOBGNXYDoo1JmY2BP-F6XF1/image.png\"></a></div><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Σᵢ(aᵢ*lᵢ)</span>\n<span class=\"kd\">def</span> <span class=\"n\">pbSum</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ls</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">as.zipWith</span> <span class=\"o\">(</span><span class=\"bp\">·*·</span><span class=\"o\">)</span> <span class=\"n\">ls</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"bp\">·+·</span><span class=\"o\">)</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>And then the rules look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Σᵢ aᵢlᵢ ≥ A   Σᵢ bᵢlᵢ ≥ B</span>\n<span class=\"c1\">-- =&gt; Σ(aᵢ+bᵢ)lᵢ ≥ A + B</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">addition</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Int</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"n\">ls</span> <span class=\"n\">bs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Int</span><span class=\"o\">},</span>\n                      <span class=\"o\">(</span><span class=\"n\">pbSum</span> <span class=\"n\">as</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span> <span class=\"bp\">→</span>\n                      <span class=\"o\">(</span><span class=\"n\">pbSum</span> <span class=\"n\">bs</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">B</span> <span class=\"bp\">→</span>\n                      <span class=\"o\">(</span><span class=\"n\">pbSum</span> <span class=\"o\">(</span><span class=\"n\">as.zipWith</span> <span class=\"o\">(</span><span class=\"bp\">·+·</span><span class=\"o\">)</span> <span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"n\">ls</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>As a attempt, but i start to struggle when I want to represent the addition rule and the terms <code>li</code> are not the same. I have looked at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Basic.html#Finset\">Finite Sets</a> because the implement the <code>∑</code> but it's not the same semantics. </p>\n<p>Is there a structure (in mathlib4) that can better express these rules like adition of the pbSums and scalar multiplication? Any help and pointers is greatly appreciated!</p>",
        "id": 431333828,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712242775
    },
    {
        "content": "<p>I would rather use something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">pbSum</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">ls</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">:=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">as</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">ls</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>You will get more support from Mathlib when you want to prove properties about <code>pbSum</code>.</p>",
        "id": 431344167,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712245473
    },
    {
        "content": "<p>Your theorem, translated to my notation, can then be proved as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">pbSum</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"n\">i</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pbSum_addition</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">pbSum</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">pbSum</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">pbSum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">pbSum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">pbSum</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">pbSum</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n  <span class=\"bp\">·</span> <span class=\"n\">linarith</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Finset.sum_add_distrib</span><span class=\"o\">,</span> <span class=\"n\">add_mul</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 431349687,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712246693
    },
    {
        "content": "<p>Also see our recent discussion about whether using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.dotProduct#doc\">docs#Matrix.dotProduct</a> is a good idea:<br>\n<a href=\"#narrow/stream/116395-maths/topic/ERat.20as.20Semiring\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/ERat.20as.20Semiring</a></p>",
        "id": 431351289,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712247075
    },
    {
        "content": "<p>If you decide to use it, it will look as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pbSum_addition</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span>\n  <span class=\"bp\">·</span> <span class=\"n\">linarith</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 431353032,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712247550
    },
    {
        "content": "<p>Or even shorter proof (but slightly harder to find):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pbSum_addition</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"n\">z</span> <span class=\"bp\">≥</span> <span class=\"n\">A</span> <span class=\"bp\">+</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Matrix.add_dotProduct</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Int.add_le_add</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n</code></pre></div>",
        "id": 431353608,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712247662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671510\">Bernardo Borges</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Looking.20for.20existing.20structure.20for.20Cutting.20Planes/near/431333828\">said</a>:</p>\n<blockquote>\n<p><code>∑</code> but it's not the same semantics. </p>\n</blockquote>\n<p>Why don't you want to use it? Is it because <code>as</code> could have a different length from <code>ls</code> but you still want <code>pbSum as ls</code> to make sense?</p>",
        "id": 431354834,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712247901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Looking.20for.20existing.20structure.20for.20Cutting.20Planes/near/431354834\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"671510\">Bernardo Borges</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Looking.20for.20existing.20structure.20for.20Cutting.20Planes/near/431333828\">said</a>:</p>\n<blockquote>\n<p><code>∑</code> but it's not the same semantics. </p>\n</blockquote>\n<p>Why don't you want to use it? Is it because <code>as</code> could have a different length from <code>ls</code> but you still want <code>pbSum as ls</code> to make sense?</p>\n</blockquote>\n<p>I didn't think it was a good idea initially, because I saw its implementation of FinSet, but this data structure would not work as it enforces unique values.</p>\n<p>Also, another thing I'm trying to wrap my head around is how I will represent the negated coefficient, as in <code>x + !x = 1</code>, I might have a <code>3*!x</code> in my expressions, and it won't fit neatly into the FinVec</p>",
        "id": 431360282,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712249519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671510\">Bernardo Borges</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Looking.20for.20existing.20structure.20for.20Cutting.20Planes/near/431360282\">said</a>:</p>\n<blockquote>\n<p>I didn't think it was a good idea initially, because I saw its implementation of FinSet, but this data structure would not work as it enforces unique values.</p>\n</blockquote>\n<p>The indices have to be unique. Values at those indices don't have to be unique.</p>",
        "id": 431362443,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712250159
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FinVec#doc\">docs#FinVec</a></p>",
        "id": 431362677,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712250231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671510\">Bernardo Borges</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Looking.20for.20existing.20structure.20for.20Cutting.20Planes/near/431360282\">said</a>:</p>\n<blockquote>\n<p>Also, another thing I'm trying to wrap my head around is how I will represent the negated coefficient, as in <code>x + !x = 1</code>, I might have a <code>3*!x</code> in my expressions, and it won't fit neatly into the FinVec</p>\n</blockquote>\n<p>Can you elaborate?</p>",
        "id": 431362971,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712250316
    },
    {
        "content": "<p>Oh! If I understand the slides, you actually want this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">pbSum</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You have a vector <code>a</code> of weights, a vector <code>s</code> of signs, and a vector <code>x</code> representing a boolean solution.<br>\nAm I right?</p>",
        "id": 431367514,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712251785
    },
    {
        "content": "<p>Seems right, but I think I didnt get how it will be applied in the end. If I want to represent the proof in this image, do I write this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">pbSum</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pbSum_addition</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n\n<span class=\"c1\">-- t1 = 2w + 4x + 2y ≥ 4</span>\n<span class=\"kd\">def</span> <span class=\"n\">t1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">pbSum</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">])</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span>\n\n<span class=\"c1\">-- t2 = w + 2x + 4y + 2z ≥ 5</span>\n<span class=\"kd\">def</span> <span class=\"n\">t2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">pbSum</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">])</span> <span class=\"bp\">≥</span> <span class=\"mi\">5</span>\n\n<span class=\"c1\">-- t3 = 3w + 6x + 6y + 2z ≥ 9</span>\n<span class=\"kd\">def</span> <span class=\"n\">t3</span> <span class=\"o\">:=</span> <span class=\"n\">pbSum_addition</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/BzG-TNDF1F2HHDqZn7ofsb9n/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/BzG-TNDF1F2HHDqZn7ofsb9n/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/BzG-TNDF1F2HHDqZn7ofsb9n/image.png\"></a></div>",
        "id": 431375950,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712254216
    },
    {
        "content": "<p>No negations in your example?</p>",
        "id": 431376544,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712254474
    },
    {
        "content": "<p>Truly, If this is the intended interface, then when I add negations, I need to supply another vector of the signs, right</p>",
        "id": 431376988,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712254672
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/I3uHcrRTBSvzEP8TT6p9OajQ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/I3uHcrRTBSvzEP8TT6p9OajQ/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/I3uHcrRTBSvzEP8TT6p9OajQ/image.png\"></a></div>",
        "id": 431377106,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712254722
    },
    {
        "content": "<p>It seems that <code>pbSum_addition</code> will have to be a significantly different theorem than what it looked like originally. Can you <em>state</em> what you want to prove?</p>",
        "id": 431377366,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712254812
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 3w + 6x + 6y + 2z ≥ 9</span>\n<span class=\"kd\">def</span> <span class=\"n\">t3</span> <span class=\"o\">:=</span> <span class=\"n\">pbSum</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"bp\">≥</span> <span class=\"mi\">9</span>\n\n<span class=\"c1\">-- 2!z ≥ 0</span>\n<span class=\"kd\">def</span> <span class=\"n\">t4</span> <span class=\"o\">:=</span> <span class=\"n\">pbSum</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- 3w + 6x + 6y ≥ 7</span>\n<span class=\"kd\">def</span> <span class=\"n\">t5</span> <span class=\"o\">:=</span> <span class=\"n\">pbSum_addition</span> <span class=\"n\">t3</span> <span class=\"n\">t4</span>\n</code></pre></div>",
        "id": 431377710,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712254951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Looking.20for.20existing.20structure.20for.20Cutting.20Planes/near/431377366\">said</a>:</p>\n<blockquote>\n<p>It seems that <code>pbSum_addition</code> will have to be a significantly different theorem than what it looked like originally. Can you <em>state</em> what you want to prove?</p>\n</blockquote>\n<p>I agree that the slides are taking high level steps that should be broken down. Firstly, I need to address the possiblity of both 2z and 2!z appear in the expression. And then I can add another step that will equilibrate this, in this case the z term vanishes completely, but not without the effect of a constant <code>2</code> appearing in the lhs, which is also compensated to the rhs, by subtracting 2</p>",
        "id": 431378020,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712255073
    },
    {
        "content": "<p>It seems to me that you mixed up operations on data with theorems about those operations. However, I think I now understand what you want. Let me formalize it.</p>",
        "id": 431380343,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712256018
    },
    {
        "content": "<p>Unpolished sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.BigOperators.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pbSum</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Condition</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">weights</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span>\n  <span class=\"n\">rhs</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Condition.eval</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Condition</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">C.weights</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Condition.isSatisfied</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Condition</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"n\">C.eval</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">C.rhs</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">condition_of_signs</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Condition</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Condition.mk</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">-</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">w</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">condition_of_signs_eval_eq_pbSum_minus</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">condition_of_signs</span> <span class=\"n\">w</span> <span class=\"n\">s</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">pbSum</span> <span class=\"n\">w</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">condition_of_signs</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Condition.eval</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">pbSum</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq_sub_of_add_eq</span>\n  <span class=\"n\">apply</span> <span class=\"n\">eq_of_sub_eq_zero</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Finset.sum_add_distrib</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Finset.sum_sub_distrib</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.sum_eq_zero</span>\n  <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"n\">_</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">hsi</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hsi</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">condition_of_signs_isSatisfied_iff_pbSum_ge</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">condition_of_signs</span> <span class=\"n\">w</span> <span class=\"n\">s</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSatisfied</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">pbSum</span> <span class=\"n\">w</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"bp\">≥</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">Condition.isSatisfied</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">condition_of_signs_eval_eq_pbSum_minus</span><span class=\"o\">]</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">condition_of_signs</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addConditions</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Condition</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Condition</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Condition.mk</span> <span class=\"o\">(</span><span class=\"n\">a.weights</span> <span class=\"bp\">+</span> <span class=\"n\">b.weights</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a.rhs</span> <span class=\"bp\">+</span> <span class=\"n\">b.rhs</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">addConditions_isSatisfied</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Condition</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a.isSatisfied</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b.isSatisfied</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">addConditions</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSatisfied</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">addConditions</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Condition.isSatisfied</span><span class=\"o\">,</span> <span class=\"n\">Condition.eval</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">convert</span> <span class=\"n\">add_le_add</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Finset.sum_add_distrib</span><span class=\"o\">]</span>\n  <span class=\"n\">congr</span>\n  <span class=\"n\">ext</span> <span class=\"n\">i</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<ul>\n<li>The original formula (which works with weights and signs) is represented by <code>pbSum</code>.</li>\n<li>I convert the weights-and-signs representation to a structure <code>Condition</code> that has no negations.</li>\n<li><code>Condition.eval</code> evaluates the LHS of given condition for given vector <code>x</code>.</li>\n<li><code>Condition.isSatisfied</code> determines whether the vector <code>x</code> satisfies the condition.</li>\n<li>Theorem <code>condition_of_signs_isSatisfied_iff_pbSum_ge</code> provides an equivalence between <code>Condition.isSatisfied</code> and the original <code>pbSum</code> formulation.</li>\n<li>When we have conditions represented by the negation-free structure <code>Condition</code>, it is very easy to add two conditions together, which <code>addConditions</code> defines. Note that <code>(a.weights + b.weights)</code> is element-wise addition.</li>\n<li>Theorem <code>addConditions_isSatisfied</code> says that, if both conditions are satisfied by given vector <code>x</code>, their sum is also satisfied by <code>x</code>.</li>\n</ul>",
        "id": 431387391,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712258828
    },
    {
        "content": "<p>I am getting that the negation structure is conceptually irrelevant, and also we can map any of these negated values to another valid GE inequality without loss of information. So in <code>2!z &gt;= 0</code>, we want to transform it into a <code>Condition</code> that will not have such negation, and this will represent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">2</span> <span class=\"bp\">!</span><span class=\"n\">z</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span>            <span class=\"bp\">&lt;-</span> <span class=\"n\">rw</span> <span class=\"bp\">!</span><span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">z</span>\n<span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span>\n<span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span><span class=\"n\">z</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"n\">z</span> <span class=\"bp\">&gt;=</span> <span class=\"bp\">-</span><span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 431391305,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712260463
    },
    {
        "content": "<p>This is what I did above.</p>",
        "id": 431391364,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712260495
    },
    {
        "content": "<p>And then without negations the proofs follow smoothly, much like vector addition etc.<br>\n(I'm just typing this to wrap my head around it)</p>",
        "id": 431391403,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712260515
    },
    {
        "content": "<p>So then you followed proving that this conversion generates equivalent proof</p>",
        "id": 431391457,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712260541
    },
    {
        "content": "<p>Yes. I proved the equivalence between these two formulations above, so that you can trust me the much simpler definition of adding two condition together.</p>",
        "id": 431391536,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712260563
    },
    {
        "content": "<p>Bravo! It looks much simpler indeed after the inconvenience of !z's is gone</p>",
        "id": 431391621,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712260598
    },
    {
        "content": "<p>Thank you for the clarification!<br>\n I will read this calmly and try to better grasp the steps now!</p>",
        "id": 431391668,
        "sender_full_name": "Bernardo Borges",
        "timestamp": 1712260619
    },
    {
        "content": "<p>I don't know if the original formulation is useful later. Either way, the code above will need a lot of polishing. Also note that the definitions all use <code>(x : Fin n → Bool)</code> and so they are useless if you wanted to do e.g. linear relaxations of the problem.</p>",
        "id": 431391970,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712260715
    },
    {
        "content": "<p>Please, note the distinction between my definition <code>addConditions</code> (which says what adding two conditions together means) and my theorem <code>addConditions_isSatisfied</code> (which formalizes the \"obvious\" property of this operation).</p>",
        "id": 431392699,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1712260951
    }
]