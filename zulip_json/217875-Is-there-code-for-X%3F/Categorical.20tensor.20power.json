[
    {
        "content": "<p>Do we have the tensor power in a monoidal category defined anywhere? I can't find it at a glance.</p>",
        "id": 438650061,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715718374
    },
    {
        "content": "<p>Do you want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo>×</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">(M\\times M)\\times M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>×</mo><mo stretchy=\"false\">(</mo><mi>M</mi><mo>×</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M\\times (M\\times M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mn>3</mn></msup></mrow><annotation encoding=\"application/x-tex\">M^3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span></span></span>?</p>",
        "id": 438654709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715719978
    },
    {
        "content": "<p>I would associate everything to the right as usual (and even add a tensor product with the unit on the right!). Then use the <code>coherence</code> stuff to get isomorphisms to reassociate as needed.</p>",
        "id": 438656765,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1715720631
    },
    {
        "content": "<p>We don't have this.</p>\n<p>It may be worthwhile (eventually?) to have tensor products indexed by finite linearly ordered types (and then in a symmetric monoidal category, products indexed by finite types --- either by internally choosing an order, or defining the product as a section of the bundle of products over the space of choices).</p>",
        "id": 438661351,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1715722255
    },
    {
        "content": "<p>My motivation is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Monoidal.Braided.Basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">CategoryTheory</span> <span class=\"n\">MonoidalCategory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tensorPow</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">80</span> <span class=\"s2\">\" ^⊗ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">tensorPow</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tensorPow_add</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"n\">m</span> <span class=\"bp\">⊗</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">InducedPRO</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span> <span class=\"n\">ofExp</span> <span class=\"o\">::</span> <span class=\"n\">exp</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">InducedPRO</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">X₁</span> <span class=\"n\">X₂</span> <span class=\"n\">Y</span> <span class=\"n\">Y₁</span> <span class=\"n\">Y₂</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Hom</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofHom</span> <span class=\"o\">::</span> <span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"n\">X.exp</span> <span class=\"bp\">⟶</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"n\">Y.exp</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instCategory</span> <span class=\"o\">:</span> <span class=\"n\">Category</span> <span class=\"o\">(</span><span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Iso.ofEq</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X.exp</span> <span class=\"bp\">=</span> <span class=\"n\">Y.exp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Iso.mk</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"n\">X.exp</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span> <span class=\"bp\">^⊗</span> <span class=\"n\">Y.exp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instMonoidalCategoryStruct</span> <span class=\"o\">:</span> <span class=\"n\">MonoidalCategoryStruct</span> <span class=\"o\">(</span><span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instMonoidalCategory</span> <span class=\"o\">:</span> <span class=\"n\">MonoidalCategory</span> <span class=\"o\">(</span><span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">SymmetricCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instBraidedCategory</span> <span class=\"o\">:</span> <span class=\"n\">BraidedCategory</span> <span class=\"o\">(</span><span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instSymmetricCategory</span> <span class=\"o\">:</span> <span class=\"n\">SymmetricCategory</span> <span class=\"o\">(</span><span class=\"n\">InducedPRO</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 438726988,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715750999
    },
    {
        "content": "<p>What does PRO mean?</p>",
        "id": 438728570,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1715752085
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/PRO\">https://ncatlab.org/nlab/show/PRO</a> says that it stands for PROduct</p>",
        "id": 438733090,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715754471
    },
    {
        "content": "<p><span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span> There, <code>PROP</code>is the acronym for “products and permutations category”…</p>",
        "id": 438737497,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715756493
    },
    {
        "content": "<p>Yeah, it's not amazing terminology...</p>",
        "id": 438739203,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715757161
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Kim Morrison</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438661351\">said</a>:</p>\n<blockquote>\n<p>It may be worthwhile (eventually?) to have tensor products indexed by finite linearly ordered types (and then in a symmetric monoidal category, products indexed by finite types --- either by internally choosing an order, or defining the product as a section of the bundle of products over the space of choices).</p>\n</blockquote>\n<p>How does this compare to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiTensorProduct#doc\">docs#PiTensorProduct</a> (apart from that being only in the category of modules, of course)?</p>",
        "id": 438739289,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715757199
    },
    {
        "content": "<p>Most monoidal categories don't have arbitrary tensor products, but only finitely-indexed ones.</p>",
        "id": 438739451,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715757252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438726988\">said</a>:</p>\n<blockquote>\n<p>My motivation is the following:</p>\n</blockquote>\n<p>As it seems you do not need the action of the symmetric group on the powers of <code>A</code>, if may be possible to use the free monoidal category <code>F</code> on a singleton (<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Monoidal/Free/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Monoidal/Free/Basic.html</a>), there is a monoidal functor from this free category to <code>C</code> which sends the unique element of the singleton to <code>A</code>. It is know (to mathlib) that in this free category <code>F</code>, sets of morphisms are subsingletons, so that it should not be too hard to show that <code>F</code> is equivalent to the discrete category on <code>ℕ</code> (which may then be endowed with a monoidal category structure). Then, we get a monoidal functor <code>G : Discrete ℕ ⥤ C</code> which sends <code>n</code> to the nth power of <code>A</code>. Finally, if <code>G : D ⥤ C</code> is a monoidal functor, it may be possible to define a monoidal category structure on <code>Fullsubcategory G.obj</code>: if we apply this to <code>Discrete ℕ ⥤ C</code>, we would get a monoidal category whose type of objects would identify to <code>ℕ</code> and morphisms would identify to types of morphisms between powers of <code>A</code>. (I am not sure how to get the braided/symmetric structures though.)</p>",
        "id": 438741179,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715757948
    },
    {
        "content": "<p>(Update: <code>Discrete ℕ</code> is already known to be a monoidal category, but the free category could be used to show a certain universal property of it.)</p>",
        "id": 438741566,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715758086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438741179\">said</a>:</p>\n<blockquote>\n<p>we would get a monoidal category whose type of objects would identify to <code>ℕ</code> and morphisms would identify to types of morphisms between powers of <code>A</code>.</p>\n</blockquote>\n<p>I didn't dare to ask but yes a quick way to creating this category is exactly what I'm after!</p>",
        "id": 438741944,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715758226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438741179\">said</a>:</p>\n<blockquote>\n<p>if <code>G : D ⥤ C</code> is a monoidal functor, it may be possible to define a monoidal category structure on <code>Fullsubcategory G.obj</code></p>\n</blockquote>\n<p>I don't understand this, however. <code>G.obj : D → C</code>.</p>",
        "id": 438742029,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715758267
    },
    {
        "content": "<p>It seems that what I want is the pullback of a category along a plain function. Does this exist?</p>",
        "id": 438742213,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715758332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438739451\">said</a>:</p>\n<blockquote>\n<p>Most monoidal categories don't have arbitrary tensor products, but only finitely-indexed ones.</p>\n</blockquote>\n<p>I think we concluded that <code>PiTensorProduct</code> is effectively finitely-supported, even if not finitely-indexed</p>",
        "id": 438742297,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715758375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438742213\">said</a>:</p>\n<blockquote>\n<p>It seems that what I want is the pullback of a category along a plain function. Does this exist?</p>\n</blockquote>\n<p>Yes, that's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.InducedCategory#doc\">docs#CategoryTheory.InducedCategory</a></p>",
        "id": 438742541,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1715758461
    },
    {
        "content": "<p>Ahah! And is it customary to wrap a concrete <code>InducedCategory</code> in a type synonym?</p>",
        "id": 438742784,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715758551
    },
    {
        "content": "<p>And do we agree that nothing exists about the monoidal structure of an <code>InducedCategory</code>?</p>",
        "id": 438743103,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715758686
    },
    {
        "content": "<p><code>FullSubcategory</code> is a special case of <code>InducedCategory</code>, so it is possible that there is material on full subcategories that is easily generalized to induced categories.</p>",
        "id": 438743277,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1715758760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438743103\">said</a>:</p>\n<blockquote>\n<p>And do we agree that nothing exists about the monoidal structure of an <code>InducedCategory</code>?</p>\n</blockquote>\n<p>Yes, this is the reason why I have written <code>it may be possible</code>. I can try to do this part...</p>",
        "id": 438743495,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715758825
    },
    {
        "content": "<p>That would be great <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 438744020,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715759012
    },
    {
        "content": "<p>The greater context is that my computer science friend is writing a categorical interpretation of resource theory and I am trying to convince her to formalise it in Lean. For my (non-categorical) scheme to work, I need at least the basics to be there, and it seems that the PRO induced by an object in a monoidal category is the first missing piece</p>",
        "id": 438744444,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715759178
    },
    {
        "content": "<p>But exams are in three weeks, so I don't really have the luxury to do any more than toying around</p>",
        "id": 438744557,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715759230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438743103\">said</a>:</p>\n<blockquote>\n<p>And do we agree that nothing exists about the monoidal structure of an <code>InducedCategory</code>?</p>\n</blockquote>\n<p>I think the way to go to construct <code>MonoidalCategory (InducedCategory D F)</code> is to take, <code>tensorUnit</code>, a function <code>tensorObj : C → C → C</code> along with a family of isomorphisms <code>∀ X Y, F (tensorObj X Y) ≅ F X ⊗ F Y</code>. I don't think you need any more compatibility than that?</p>",
        "id": 438745721,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715759759
    },
    {
        "content": "<p>I think we already have that?</p>",
        "id": 438746652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715760097
    },
    {
        "content": "<p>I built this pullback stuff for when I build the monoidal category of algebras</p>",
        "id": 438746697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715760113
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Monoidal.induced#doc\">docs#CategoryTheory.Monoidal.induced</a></p>",
        "id": 438746904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715760182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438745721\">said</a>:</p>\n<blockquote>\n<p>I think the way to go to construct <code>MonoidalCategory (InducedCategory D F)</code> is to take, <code>tensorUnit</code>, a function <code>tensorObj : C → C → C</code> along with a family of isomorphisms <code>∀ X Y, F (tensorObj X Y) ≅ F X ⊗ F Y</code>. I don't think you need any more compatibility than that?</p>\n</blockquote>\n<p>This is actually more simple, because we already have a monoidal functor <code>C ⥤ D</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.CategoryTheory.Monoidal.Functor</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">CategoryTheory.MonoidalCategory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MonoidalCategory</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">MonoidalFunctor</span> <span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">MonoidalCategoryStruct</span> <span class=\"o\">(</span><span class=\"n\">InducedCategory</span> <span class=\"n\">D</span> <span class=\"n\">F.obj</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">tensorObj</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"n\">tensorUnit</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">tensorUnit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"n\">whiskerLeft</span> <span class=\"n\">X</span> <span class=\"o\">{</span><span class=\"n\">Y₁</span> <span class=\"n\">Y₂</span><span class=\"o\">}</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">F.μIso</span> <span class=\"n\">X</span> <span class=\"n\">Y₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span> <span class=\"bp\">≫</span> <span class=\"n\">_</span> <span class=\"bp\">◁</span> <span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">F.μIso</span> <span class=\"n\">X</span> <span class=\"n\">Y₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">F.obj</span> <span class=\"n\">_</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">whiskerRight</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">tensorHom</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">associator</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n      <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">associator</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span>\n      <span class=\"n\">hom_inv_id</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n      <span class=\"n\">inv_hom_id</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n  <span class=\"n\">leftUnitor</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">rightUnitor</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">CategoryTheory.MonoidalCategory</span>\n</code></pre></div>\n<p>(This construction is different from what <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> refers to also.)</p>",
        "id": 438748606,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715760773
    },
    {
        "content": "<p>Something I'm noticing with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.InducedCategory#doc\">docs#CategoryTheory.InducedCategory</a> is that it's a semireducible type synonym without explicit transport functions, making it very hard to get the types right. Any objection to turning it and its hom type into one-field structures?</p>",
        "id": 438750054,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715761275
    },
    {
        "content": "<p>Yes, I agree.</p>",
        "id": 438750586,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715761474
    },
    {
        "content": "<p>Where is the monoidal category structure on <code>ℕ</code> given by addition with only the trivial morphisms?</p>",
        "id": 438750858,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715761570
    },
    {
        "content": "<p><code>Monoidal/Discrete.lean</code></p>",
        "id": 438753253,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715762424
    },
    {
        "content": "<p>A very draft PR for the construction of the induced monoidal category structure <a href=\"https://github.com/leanprover-community/mathlib4/pull/12926\">#12926</a></p>",
        "id": 438758681,
        "sender_full_name": "Joël Riou",
        "timestamp": 1715764290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Categorical.20tensor.20power/near/438750054\">said</a>:</p>\n<blockquote>\n<p>Something I'm noticing with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.InducedCategory#doc\">docs#CategoryTheory.InducedCategory</a> is that it's a semireducible type synonym without explicit transport functions, making it very hard to get the types right. Any objection to turning it and its hom type into one-field structures?</p>\n</blockquote>\n<p>We have had some discussions about doing this a long time ago, and I am very much in favor.</p>",
        "id": 438788068,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1715775261
    },
    {
        "content": "<p>This reminds me that I should start PRing all that stuff about Lawvere theories...</p>",
        "id": 438790936,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1715776291
    }
]