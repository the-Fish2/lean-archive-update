[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- fibonacci sequence -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fibonacci</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fibonacci</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fibonacci</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- linear time fibonacci -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">loop</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">loop</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">loop</span> <span class=\"n\">n</span>\n      <span class=\"o\">(</span><span class=\"n\">p.2</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">fib_add</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fibonacci</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span>\n\n  <span class=\"c1\">-- strong induction on `n`</span>\n  <span class=\"c1\">-- I would like to know if it is possible to do strong induction, as used here, with `induction` instead of `induction'`.</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.strong_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">fibonacci</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 425491313,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1709894273
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">fib_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">fibonacci</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">fibonacci</span><span class=\"o\">,</span> <span class=\"n\">fib_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 425492368,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1709894610
    },
    {
        "content": "<p>wao!!!</p>",
        "id": 425493101,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1709894862
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> Thank you very much! This is surprising...</p>",
        "id": 425493262,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1709894891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as resolved.</p>",
        "id": 425493667,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709895034
    },
    {
        "content": "<p>What happens here is that you can use a theorem while you're proving that same theorem, as long as you finish in finitely many steps. Lean is often smart enough to figure out that termination proof for you, though</p>",
        "id": 425494845,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1709895465
    },
    {
        "content": "<p>In this case, is it possible to get out the inductive assumption without naming the theorem (i.e. with an example)?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Rat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">sum</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">sum_exp</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n\n  <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">ih</span> <span class=\"o\">:=</span> <span class=\"n\">sum_exp</span> <span class=\"n\">n</span>\n\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sum</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span>\n\n    <span class=\"n\">ring</span>\n</code></pre></div>",
        "id": 425498919,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1709896965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> has marked this topic as unresolved.</p>",
        "id": 425498956,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709896977
    },
    {
        "content": "<p>The answer to your original question is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.strong_induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>",
        "id": 425501514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709898064
    },
    {
        "content": "<p>Where <code>h</code> is the argument name in <code>Nat.strong_induction_on</code></p>",
        "id": 425501535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709898072
    },
    {
        "content": "<p>In the current dev version of Lean 4, there's now a way to do induction on the structure of the function itself, due to <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- fibonacci sequence -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fibonacci</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">fibonacci</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fibonacci</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">n</span> <span class=\"c1\">-- trick to get functional induction to work (causes it to be well-founded recursion)</span>\n\n<span class=\"c1\">-- In next Lean release. Creates `fibonacci.induct`</span>\n<span class=\"n\">derive_functional_induction</span> <span class=\"n\">fibonacci</span>\n\n<span class=\"sd\">/-- linear time fibonacci -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">loop</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">loop</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">loop</span> <span class=\"n\">n</span>\n      <span class=\"o\">(</span><span class=\"n\">p.2</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"n\">p.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">fib_add</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">fibonacci</span> <span class=\"bp\">=</span> <span class=\"n\">fib</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">fibonacci.induct</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ⊢ fibonacci 0 = fib 0</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  ⊢ fibonacci 1 = fib 1</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  n : Nat</span>\n<span class=\"cm\">  ih1 : fibonacci n = fib n</span>\n<span class=\"cm\">  ih2 : fibonacci (n + 1) = fib (n + 1)</span>\n<span class=\"cm\">  ⊢ fibonacci (Nat.succ (Nat.succ n)) = fib (Nat.succ (Nat.succ n))</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">next</span> <span class=\"n\">n</span> <span class=\"n\">ih1</span> <span class=\"n\">ih2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fibonacci</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 425549275,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709914660
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Will there be a way to derive functional induction for definitions that are defined with plain recursion? I worked around it here by using an artificial <code>termination_by</code>.)</p>",
        "id": 425549493,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1709914736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/strong.20induction.20without.20.60induction'.60/near/425501514\">said</a>:</p>\n<blockquote>\n<p>The answer to your original question is</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.strong_induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">h</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.strong_induction_on</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>if you don’t care, or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">Nat.strong_induction_on</span>\n  <span class=\"n\">next</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n</code></pre></div>\n<p>if you prefer <code>next</code>/<code>case</code> over the <code>with | … </code> syntax.</p>",
        "id": 425550669,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709915154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/strong.20induction.20without.20.60induction'.60/near/425549493\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> Will there be a way to derive functional induction for definitions that are defined with plain recursion? I worked around it here by using an artificial <code>termination_by</code>.)</p>\n</blockquote>\n<p>Yes! I experimented with that on monday, and it seems doable, and is somewhere on my roadmap not too far down, so it will work eventually.</p>",
        "id": 425550858,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709915218
    }
]