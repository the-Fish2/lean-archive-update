[
    {
        "content": "<p>Given a <code>Monoid</code>, how can one construct the <code>Submonoid</code> formed by the elements that have inverse? The <code>Units</code> are not a <code>Submonoid</code>, but something else...</p>",
        "id": 421846132,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708085200
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span></p>",
        "id": 421846784,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708085486
    },
    {
        "content": "<p>So I think this is (\\top : Submonoid M).units.ofUnits</p>",
        "id": 421847313,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708085714
    },
    {
        "content": "<p>Or equivalently, actually, (\\top : Subgroup M\\times).ofUnits</p>",
        "id": 421847461,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708085770
    },
    {
        "content": "<p>(not on pc, can't add proper symbols)</p>",
        "id": 421847486,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708085783
    },
    {
        "content": "<p>But given a subgroup of units, ofUnits gives you the corresponding submonoid, and you want the subgroup of <em>all</em> units.</p>",
        "id": 421847570,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708085826
    },
    {
        "content": "<p>If you want the subgroup of units corresponding to a given submonoid, that's what Submonoid.units is for</p>",
        "id": 421847669,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708085876
    },
    {
        "content": "<p>Is this also <code>Units.coeHom.mrange</code>?</p>",
        "id": 421853579,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708088472
    },
    {
        "content": "<p>Well that's as a set, but yeah I think so</p>",
        "id": 421853645,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708088500
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHom.mrange#doc\">docs#MonoidHom.mrange</a> disagrees with you</p>",
        "id": 421853781,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708088543
    },
    {
        "content": "<p>Oh lol</p>",
        "id": 421853819,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708088560
    },
    {
        "content": "<p>Then yes</p>",
        "id": 421853826,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708088562
    },
    {
        "content": "<p>Whoops, I meant <code>mrange</code></p>",
        "id": 421853841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708088568
    },
    {
        "content": "<p>Ahhhhh</p>",
        "id": 421853856,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708088576
    },
    {
        "content": "<p>Yeah</p>",
        "id": 421853872,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708088584
    },
    {
        "content": "<p>But <code>range</code> is a subgroup, not a set</p>",
        "id": 421853874,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708088584
    },
    {
        "content": "<p>Yeah ofUnits is essentially just the image of coeHom so that sounds correct</p>",
        "id": 421854072,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708088654
    },
    {
        "content": "<p>How do you feel about adding something like this in the <code>Mathlib.GroupTheory.Submonoid.Units</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Units</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_ofUnits_of_top_iff_isUnit</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Subgroup.ofUnits</span> <span class=\"bp\">⊤</span> <span class=\"bp\">↔</span> <span class=\"n\">IsUnit</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subgroup.mem_ofUnits_iff_exists_isUnit</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">exists_iff_of_forall</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 421945897,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708121077
    },
    {
        "content": "<p>Yeah we should probably have that.</p>",
        "id": 421945970,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121112
    },
    {
        "content": "<p>I'm wondering if there's any other analogous things that need adding</p>",
        "id": 421946012,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121134
    },
    {
        "content": "<p>We have one direction of it, it seems</p>",
        "id": 421946330,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121312
    },
    {
        "content": "<p>Subgroup.isUnit_of_mem_ofUnits</p>",
        "id": 421946361,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121336
    },
    {
        "content": "<p>Ah.</p>",
        "id": 421946471,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121399
    },
    {
        "content": "<p>And Subgroup.mem_ofUnits_of_isUnit_of_unit_mem is the other direction</p>",
        "id": 421946543,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121428
    },
    {
        "content": "<p>Or is once you consider everything is mem_top</p>",
        "id": 421946569,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121444
    },
    {
        "content": "<p>But your proof is also good</p>",
        "id": 421946663,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121492
    },
    {
        "content": "<p>Oh! Also, answering your original question again: it's also IsUnit.submonoid</p>",
        "id": 421947057,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121688
    },
    {
        "content": "<p>The table at the top of Submonoid/Units would say this, if it worked</p>",
        "id": 421947174,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121740
    },
    {
        "content": "<p>Yeah if you want the units as a submonoid of a monoid, use IsUnit.submonoid</p>",
        "id": 421947288,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708121766
    },
    {
        "content": "<p>If you want the units as a submonoid of the monoid in which a submonoid lies, then that is S.units.ofUnits</p>",
        "id": 421947994,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708122125
    },
    {
        "content": "<p>I guess Subgroup.ofUnits \\top = IsUnit.submonoid M might be useful to have!</p>",
        "id": 421948167,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708122224
    },
    {
        "content": "<p>Subgroup.ofUnits_top</p>",
        "id": 421948543,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708122425
    },
    {
        "content": "<p>Yes, I think that would be good to have. We could also have the lemma you mention, which is naturally a consequence</p>",
        "id": 421948866,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708122610
    },
    {
        "content": "<p>I don't like the proof, but something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Units</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Subgroup.ofUnits_top</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup.ofUnits</span> <span class=\"bp\">⊤</span> <span class=\"bp\">=</span> <span class=\"n\">IsUnit.submonoid</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">Submonoid.ext</span> <span class=\"bp\">?</span><span class=\"n\">h</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">IsUnit.mem_submonoid_iff</span><span class=\"o\">,</span><span class=\"n\">Subgroup.mem_ofUnits_iff_exists_isUnit</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exists_iff_of_forall</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 421949171,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708122765
    },
    {
        "content": "<p>Yes, precisely.</p>",
        "id": 421949224,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708122794
    },
    {
        "content": "<p>A shorter proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Units</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Units.mrange_coeHom</span> <span class=\"o\">:</span> <span class=\"n\">MonoidHom.mrange</span> <span class=\"o\">(</span><span class=\"n\">Units.coeHom</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">IsUnit.submonoid</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Subgroup.ofUnits_top</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup.ofUnits</span> <span class=\"bp\">⊤</span> <span class=\"bp\">=</span> <span class=\"n\">IsUnit.submonoid</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">MonoidHom.mrange_eq_map</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 421949763,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708123099
    },
    {
        "content": "<p>Very nice</p>",
        "id": 421950005,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708123248
    },
    {
        "content": "<p>Units.mrange_coeHom wants to be in a different file</p>",
        "id": 421950187,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708123352
    },
    {
        "content": "<p>I really don't get how can the proof be so shorter, and using a result that doesn't seem related...</p>",
        "id": 421952200,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708124599
    },
    {
        "content": "<p>Well, ofUnits is by definition (coeHom M).map</p>",
        "id": 421952247,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708124636
    },
    {
        "content": "<p>So the LHS is map, by definition. And it turns out in fact IsUnit.submonoid is defeq to mrange</p>",
        "id": 421952446,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708124755
    },
    {
        "content": "<p>That's more surprising maybe</p>",
        "id": 421952473,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708124763
    },
    {
        "content": "<p>Oh this does mean that Submonoid.units (IsUnit.submonoid M) = \\top as well</p>",
        "id": 421953148,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708125222
    },
    {
        "content": "<p>If we don't have that too, we should</p>",
        "id": 421953157,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708125230
    },
    {
        "content": "<p>call it Submonoid.units_isUnit_eq_top or something</p>",
        "id": 421953279,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708125299
    },
    {
        "content": "<p>(it's an immediate consequence of the above, given the Galois insertion)</p>",
        "id": 421953493,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708125451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> how do I say \"the lattice of subgroups of units is equivalent to the lattice of submonoids contained in IsUnit.subMonoid, with the units/ofUnits Galois Coinsertion defining the maps across\"?</p>",
        "id": 421955078,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708126516
    },
    {
        "content": "<p><code>Subgroup (Units M) o~= {s : Submonoid M // s &lt;= IsUnit.submonoid}</code>?</p>",
        "id": 421955396,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708126741
    },
    {
        "content": "<p>Cool! I don't know if we tend to have theorems like that.</p>",
        "id": 421956218,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708127329
    },
    {
        "content": "<p>Probably we have at least one direction</p>",
        "id": 421957286,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708128111
    },
    {
        "content": "<p>Isn't that just a special case of <code>Subgroup M o~= {s : Submonoid N // s &lt;= mrange f}</code> or similar?</p>",
        "id": 421958231,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708128688
    },
    {
        "content": "<p>Hmm, perhaps!</p>",
        "id": 421958365,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708128760
    },
    {
        "content": "<p>Is that true for arbitrary f?</p>",
        "id": 421958378,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708128773
    },
    {
        "content": "<p>ofUnits is just map, but units needed a little more to it, so it would seem surprising to me if it came out of that.</p>",
        "id": 421958425,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708128805
    },
    {
        "content": "<p>It seems that we don't have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Units</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">IsUnit.exists_inv</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">IsUnit</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hba</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isUnit_iff_exists</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">IsUnit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">IsUnit.exists_inv</span> <span class=\"n\">h</span> <span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hba</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hba</span><span class=\"o\">⟩</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 422090089,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708255297
    },
    {
        "content": "<p>I think that's probably because you never need those lemmas</p>",
        "id": 422090316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708255520
    },
    {
        "content": "<p>May be. Although I discovered because I need them...</p>",
        "id": 422090352,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708255561
    },
    {
        "content": "<p>It's usually more convenient to keep a <code>Unit</code> around than to unpack it into the val and inv</p>",
        "id": 422090395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708255570
    },
    {
        "content": "<p>In fact I need the other way: if I have such a <code>b</code>, then <code>a</code> is a Unit.</p>",
        "id": 422090465,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708255671
    },
    {
        "content": "<p>Can you share your context?</p>",
        "id": 422090533,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708255740
    },
    {
        "content": "<p>There are results around <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isUnit_iff_exists_inv#doc\">docs#isUnit_iff_exists_inv</a></p>",
        "id": 422090557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708255783
    },
    {
        "content": "<p>If you actually have a <code>b</code>, you can easily just build a term of <code>Units</code> directly, and even use the <code>lift</code> tactic to turn <code>a</code> itself into a unit.</p>",
        "id": 422103833,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708268329
    },
    {
        "content": "<p><code>IsUnit a ↔ (∃ b, a * b = 1) ∧ (∃ c, c * a = 1)</code> is probably more useful ...</p>",
        "id": 422107222,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708271317
    },
    {
        "content": "<p>Why?</p>",
        "id": 422107260,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708271373
    },
    {
        "content": "<p>It's not just a rephrasing of the definition (i.e. you can't get it by permuting arguments of the constructors), instead you need associativity to prove the reverse direction.</p>",
        "id": 422107379,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708271522
    },
    {
        "content": "<p>So, how do you feel about this result? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Units</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isUnit_iff_exists_both_units</span>  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">):</span> <span class=\"n\">IsUnit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):=</span> <span class=\"kd\">by</span>\n<span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n<span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hba</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Exists.intro</span> <span class=\"n\">b</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">b</span> <span class=\"n\">hba</span><span class=\"o\">⟩</span>\n<span class=\"bp\">·</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">hab</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.1</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">hca</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.2</span>\n  <span class=\"k\">have</span> <span class=\"n\">beqc</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">calc</span>\n      <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">HMul.hMul</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">hca.symm</span><span class=\"o\">))</span> <span class=\"n\">b</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"mi\">1</span><span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">hab</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span> <span class=\"n\">c</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">beqc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hca</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hca</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 422213927,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1708342228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Submonoid.20formed.20by.20the.20units/near/422107379\">said</a>:</p>\n<blockquote>\n<p>It's not just a rephrasing of the definition (i.e. you can't get it by permuting arguments of the constructors), instead you need associativity to prove the reverse direction.</p>\n</blockquote>\n<p>Hmm. Yeah I suppose it being both directions is the interesting bit.</p>",
        "id": 422214087,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708342295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315546\">Xavier Xarles</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Submonoid.20formed.20by.20the.20units/near/422213927\">said</a>:</p>\n<blockquote>\n<p>So, how do you feel about this result? </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Units</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isUnit_iff_exists_both_units</span>  <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">):</span> <span class=\"n\">IsUnit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):=</span> <span class=\"kd\">by</span>\n<span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n<span class=\"bp\">·</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hba</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Exists.intro</span> <span class=\"n\">b</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">b</span> <span class=\"n\">hba</span><span class=\"o\">⟩</span>\n<span class=\"bp\">·</span> <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">hab</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.1</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">hca</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.2</span>\n  <span class=\"k\">have</span> <span class=\"n\">beqc</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">calc</span>\n      <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">HMul.hMul</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"n\">hca.symm</span><span class=\"o\">))</span> <span class=\"n\">b</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"mi\">1</span><span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">HMul.hMul</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">hab</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span> <span class=\"n\">c</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">beqc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hca</span>\n  <span class=\"n\">use</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span><span class=\"n\">hca</span><span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It feels like in many ways we should have a defined predicate for \"IsLeftUnit\" but it's good.</p>",
        "id": 422214248,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1708342355
    },
    {
        "content": "<p>That golfs to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">isUnit_iff_exists_both_units</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsUnit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hca</span><span class=\"o\">⟩⟩</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"k\">from</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">hca</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"k\">calc</span>\n      <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">hca.symm</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">*</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"n\">hab</span>\n      <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span> <span class=\"n\">c</span>\n</code></pre></div>",
        "id": 422215814,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708342999
    },
    {
        "content": "<p>Or you could use <code>regular</code> elements:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">isUnit_iff_exists_both_units</span>  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsUnit</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">):=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hca</span><span class=\"o\">⟩⟩</span>\n    <span class=\"k\">suffices</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"k\">from</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">hca</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">IsRegular</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">isLeftRegular_of_mul_eq_one</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›,</span> <span class=\"n\">isRightRegular_of_mul_eq_one</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›⟩</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this.right</span> <span class=\"o\">(</span><span class=\"n\">this.left</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]))</span>\n</code></pre></div>",
        "id": 422222910,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708345727
    },
    {
        "content": "<p>You can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=left_inv_eq_right_inv#doc\">docs#left_inv_eq_right_inv</a></p>",
        "id": 422290573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708368666
    },
    {
        "content": "<p>This is the only interesting theorem I know about monoids :-)</p>",
        "id": 422297390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708372357
    }
]