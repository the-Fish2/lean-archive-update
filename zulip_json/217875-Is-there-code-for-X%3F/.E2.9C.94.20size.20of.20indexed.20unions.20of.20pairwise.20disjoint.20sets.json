[
    {
        "content": "<p>i'd like to prove that given a <code>MulAction G α</code>, the size of a Block <code>s</code> is given by the sum of the sizes of the orbits of elements of that block under the stabilizer of a single member <code>a ∈ s</code>. i already have proven that the block must be equal to the union of those orbits, but i can't seem to find decent way to even begin to state that the size is given by this sum.<br>\nto get a bit of a feeling what i'm talking about: i already have this, but i need a way to turn this statement into a statement about cardinalities</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">orbit_block_eq_union_stabilizer_orbits</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">IsBlock</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">orbit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">stabilizer</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_iUnion</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_prop</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulAction</span><span class=\"bp\">.</span><span class=\"n\">mem_orbit_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">and_true</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"bp\">⟨⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">hg</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Submonoid</span><span class=\"bp\">.</span><span class=\"n\">mk_smul</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hg</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">.</span><span class=\"n\">def_mem</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">smul_mem_smul_set_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hd</span>\n</code></pre></div>\n<p>my eventual end goal with this is that, since you can also prove that the size of a block must divide the size of the total space if the action is transitive, you will be able to prove that any block must have a certain size (i.e. the action must be primitive).</p>\n<p>a concrete example would be that given that the orbits under the stabilizer of some element <code>a</code> have sizes 1, 90, 240, 1440, and that the size of <code>α</code> is <code>1771</code>, any block must have either size 1 or 1771.</p>",
        "id": 442879550,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717617562
    },
    {
        "content": "<p>Can you already state the theorem about cardinalities (proof by sorry)?<br>\nI guess you'll also need an analogous statement saying that this union is disjoint.</p>",
        "id": 442980471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717656357
    },
    {
        "content": "<p>i'm having some trouble, i need to be able to sum over an arbitrary set rather than a finite one (which should be ok because i am summing values of ENat)</p>",
        "id": 442982321,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717657121
    },
    {
        "content": "<p>the api lemma i'd expect to use here would be this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">card_iunion_disjoint_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hdisjoint</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">))</span><span class=\"w\">  </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">encard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>but the statement doesn't typecheck because it wants a guarantee that we're not summing over an infinite set</p>",
        "id": 442983266,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717657430
    },
    {
        "content": "<p>the Finset version of this seems to be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.card_biUnion#doc\">docs#Finset.card_biUnion</a>, but i'd rather use <code>Set</code> here because that is what the current API of <code>MulAction.orbit</code> and <code>MulAction.IsBlock</code> work with</p>",
        "id": 442984417,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717657694
    },
    {
        "content": "<p>ok, i just found <code>HasSum</code>, but that would require a topology on <code>ENat</code>, which i can't seem to find? (the topology side of the library is new to me)</p>",
        "id": 442987510,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717658827
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsum#doc\">docs#finsum</a> for sums which the caller promises are finite.</p>",
        "id": 442988727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717659208
    },
    {
        "content": "<p>Probably we could argue all day about whether the \"correct\" topology on ENat has {infty} open or whether any open neighbourhood of infinity must also contain all sufficiently large positive integers.</p>",
        "id": 442988937,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717659278
    },
    {
        "content": "<p>If you want 1+1+1+...=infty then probably you just need to locally add the topology where the neighbourhoods of infinity are the ones containing all sufficiently large naturals (i.e. the one point compactification). Or just work in ENNReal instead.</p>",
        "id": 442989247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717659379
    },
    {
        "content": "<p>i guess for now i will assume a finite setting...</p>",
        "id": 442992206,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717660316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> has marked this topic as resolved.</p>",
        "id": 442992272,
        "sender_full_name": "Notification Bot",
        "timestamp": 1717660326
    }
]