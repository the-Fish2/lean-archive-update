[
    {
        "content": "<p>How hard would it be to generate a list of things (definitions, syntax, i.e. stuff that you can hover) that don't have a docstring, sorted by how often they appear in, say, all of mathlib?</p>",
        "id": 431459998,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712301069
    },
    {
        "content": "<p>That list (of <code>def</code>s) is <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/scripts/nolints.json\">https://github.com/leanprover-community/mathlib4/blob/master/scripts/nolints.json</a>, so you could iterate through it and count uses</p>",
        "id": 431460255,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712301156
    },
    {
        "content": "<p>It's all but the last two lines of that list.</p>\n<p>How has that lost got so big? I though we linted against that sort of thing.</p>",
        "id": 431469914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1712304589
    },
    {
        "content": "<p>Some definitions lost their docstring during the port, eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommRing#doc\">docs#CommRing</a></p>",
        "id": 431470093,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712304650
    },
    {
        "content": "<p>those were probably the pre-mathport definitions</p>",
        "id": 431470180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712304687
    },
    {
        "content": "<p>I think loogle already fetches docstrings. Is there a loogle query for \"fetch everything\"?</p>",
        "id": 431488042,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1712310401
    },
    {
        "content": "<p>Another (small) factor is a number of local notations which could have had <code>@[inherit_doc]</code> added. I believe Yael removed  ~115 of these at some point; there's an in-progress PR about the remaining ~50 instances.</p>",
        "id": 431493716,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1712312404
    },
    {
        "content": "<p>We should be careful with these; often the docstring needs editing at the same time</p>",
        "id": 431494051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712312557
    },
    {
        "content": "<p>eg</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Does the foo -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">notation</span> <span class=\"s2\">\"F\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>should become</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Does the foo, with notation `F` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">inherit_doc</span><span class=\"kd\">]</span>\n<span class=\"kd\">notation</span> <span class=\"s2\">\"F\"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foo</span>\n</code></pre></div>\n<p>or similar</p>",
        "id": 431494164,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1712312614
    },
    {
        "content": "<p>is this something that could be automatically handled by <code>@[inherit_doc]</code>?</p>",
        "id": 431499198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712314596
    },
    {
        "content": "<p>IIRC one issue with the current hover is that it doesn't actually show the constant's name</p>",
        "id": 431499279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712314638
    },
    {
        "content": "<p>Ah, I think I phrased my question badly. I guess I can figure out how to see if something has a docstring or not: But how do I got about finding out how often something appears in the mathlib core? (As a proxy for “most useful to document next”.)</p>",
        "id": 431502265,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712315978
    },
    {
        "content": "<p>Adam posted some code to answer a similar question by Kevin. Let me try to find it</p>",
        "id": 431630286,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712370370
    },
    {
        "content": "<p><a href=\"#narrow/stream/287929-mathlib4/topic/finding.20all.20uses.20of.20a.20theorem.20in.20mathlib\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/finding.20all.20uses.20of.20a.20theorem.20in.20mathlib</a></p>",
        "id": 431630305,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1712370415
    },
    {
        "content": "<p>Hmm, but that’s different: It goes through the definition’s values, i.e. the proof objects, to find constants used. This will find implicit things, and will not find, for example, tactics.</p>\n<p>I am more interested in what people actually wrote in the source. In that thread Damiano says</p>\n<blockquote>\n<p>if you get a hover information, then it is in the <code>ilean</code></p>\n</blockquote>\n<p>so I think that’s where I have to look, or near the implementation of the call hierarchy, once I am near a computer again.</p>",
        "id": 431666059,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712403838
    },
    {
        "content": "<p>Joachim, how would you like the information to be presented?</p>\n<p>Since I am in this \"linter phase\", I can offer a linter that checks whether a declaration has/does not have a doc-string.  Would that work for you?</p>",
        "id": 431695217,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712428498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> sounds like you need the info trees.</p>",
        "id": 431695322,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712428562
    },
    {
        "content": "<p>I am not sure that I understand what you are asking.  Is it \"if I were to document the most referenced declaration that does not have a docstring, which declaration would I chose?\"</p>",
        "id": 431695394,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712428620
    },
    {
        "content": "<p>And, following from your reference to tactics, those hovers do not come from the <code>ilean</code> but from the info trees, I think, as Adam said.</p>",
        "id": 431696869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712429606
    },
    {
        "content": "<p>(Incidentally, syntax linters do give you access to info trees...)</p>",
        "id": 431696968,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712429655
    },
    {
        "content": "<p>Ok, then info trees it is :-)</p>\n<blockquote>\n<p>Joachim, how would you like the information to be presented?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">#</span> <span class=\"n\">undocumented.csv</span>\n<span class=\"n\">name</span><span class=\"bp\">;</span><span class=\"n\">occurrences</span>\n<span class=\"n\">Lean.Parser.Command.def</span><span class=\"bp\">;</span><span class=\"mi\">14400</span>\n<span class=\"n\">Lean.Parser.Tactic.assumption</span><span class=\"bp\">;</span><span class=\"mi\">12312</span>\n<span class=\"n\">id</span><span class=\"bp\">;</span><span class=\"mi\">11231</span>\n<span class=\"n\">Nat.succ</span><span class=\"bp\">;</span><span class=\"mi\">10233</span>\n<span class=\"bp\">…</span>\n</code></pre></div>\n<p>(assuming these wouldn’t have a docstring, and numbers are made up of course. JSON fine too.)<br>\nBonus points for filtering by package, e.g. only show definitions from core.<br>\nBut of course I can do the let work if I can cargo cult “getting info trees for all modules in mathlib and traversing them” somewhere :-)</p>",
        "id": 431703273,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712435051
    },
    {
        "content": "<p>With this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">noDocs</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"bp\">∨</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">exact</span> <span class=\"n\">True.intro</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">intro</span>\n\n<span class=\"sd\">/-- I have a doc-string -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">withDocs</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"bp\">∨</span> <span class=\"n\">True</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">exact</span> <span class=\"n\">True.intro</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">.</span><span class=\"n\">intro</span>\n</code></pre></div>\n<p>is this a reasonable output for the \"tactic\" information?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">noDocs</span><span class=\"o\">]</span> <span class=\"c1\">-- no docs</span>\n<span class=\"o\">[(</span><span class=\"n\">Lean.Parser.Term.byTactic</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">753</span><span class=\"o\">,</span> <span class=\"mi\">811</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">753</span><span class=\"o\">,</span> <span class=\"mi\">755</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.cases</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">758</span><span class=\"o\">,</span> <span class=\"mi\">765</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">758</span><span class=\"o\">,</span> <span class=\"mi\">811</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.refine</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">768</span><span class=\"o\">,</span> <span class=\"mi\">777</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.exact</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">780</span><span class=\"o\">,</span> <span class=\"mi\">796</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.exact</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">799</span><span class=\"o\">,</span> <span class=\"mi\">811</span><span class=\"o\">))]</span>\n\n<span class=\"o\">[</span><span class=\"n\">withDocs</span><span class=\"o\">]</span>\n<span class=\"o\">[(</span><span class=\"n\">Lean.Parser.Term.byTactic</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">887</span><span class=\"o\">,</span> <span class=\"mi\">945</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">887</span><span class=\"o\">,</span> <span class=\"mi\">889</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.cases</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">892</span><span class=\"o\">,</span> <span class=\"mi\">899</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">892</span><span class=\"o\">,</span> <span class=\"mi\">945</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.refine</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">902</span><span class=\"o\">,</span> <span class=\"mi\">911</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.exact</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">914</span><span class=\"o\">,</span> <span class=\"mi\">930</span><span class=\"o\">)),</span>\n <span class=\"o\">(</span><span class=\"n\">Lean.Parser.Tactic.exact</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">933</span><span class=\"o\">,</span> <span class=\"mi\">945</span><span class=\"o\">))]</span>\n</code></pre></div>\n<p>I have not yet combined this with the <code>Expr</code> data, though.</p>",
        "id": 431737262,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712471216
    },
    {
        "content": "<p>Good! Can you also make it so that <code>True.intro</code> shows up?</p>",
        "id": 431783515,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712503654
    },
    {
        "content": "<p>I can get <code>True.intro</code> and <code>intro</code> easily, if you want <code>intro</code> (corresponding to <code>.intro</code>) to become, then I will have to do some elaboration.</p>",
        "id": 431784301,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712504061
    },
    {
        "content": "<p>If the proof uses <code>simp</code>, do you want to dig out the proof term or just the syntax information?  So, just <code>simp</code> or also the lemmas that <code>simp</code> used?</p>",
        "id": 431784347,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712504100
    },
    {
        "content": "<p>(Of course, of you use <code>simp [x]</code>, then <code>x</code> would appear.)</p>",
        "id": 431784384,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712504121
    },
    {
        "content": "<p>Also, after posting that, I realized that the data for doc-string may not be embedded in the syntax, because <code>add_decl_doc</code> (or something similar), may add doc-strings after the fact.</p>",
        "id": 431784504,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712504176
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/undocumented.20things/near/431784384\">said</a>:</p>\n<blockquote>\n<p>(Of course, of you use <code>simp [x]</code>, then <code>x</code> would appear.)</p>\n</blockquote>\n<p>That! Just all the explicitly mentioned tactics and lemmas, ideally resolved to their full <code>Name</code>.</p>",
        "id": 431784739,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712504319
    },
    {
        "content": "<p>Ok, I can probably do that, though I am not sure whether I will be able to do it today.</p>",
        "id": 431784791,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712504383
    },
    {
        "content": "<p>No expectations :-)</p>\n<p>Can you share the code that produced the output above?</p>",
        "id": 431784971,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712504499
    },
    {
        "content": "<p>I placed the code in a draft PR: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11991\">#11991</a>.</p>",
        "id": 431792644,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712507996
    },
    {
        "content": "<p>It is a linter, by default it is \"on\", but nothing imports it (except <code>Mathlib.lean</code> and <code>Mathlib/Tactic.lean</code>.  If you want to see the effect, simpy add <code>import Mathlib.Tactic.SyntaxDataLinter</code> to your file.</p>",
        "id": 431792883,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712508113
    },
    {
        "content": "<p>Thanks, that's already very helpful!</p>",
        "id": 431794746,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712508959
    },
    {
        "content": "<p>I am testing it out on Mathlib and there are quite a few exclusions that are probably helpful to make the output clearer.  Am I right that you do not care about these?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"n\">null</span>\n<span class=\"bp\">`</span><span class=\"kd\">by</span>\n<span class=\"bp\">`«;»</span>\n<span class=\"bp\">`«</span><span class=\"o\">]</span><span class=\"bp\">»</span>\n<span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq</span>\n<span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.paren</span>\n<span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq1Indented</span>\n<span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.byTactic</span>\n</code></pre></div>\n<p>(and possibly more, I am just skimming through some random files).</p>",
        "id": 431795196,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712509128
    },
    {
        "content": "<p>(In any case, I am adding some logic to exclude a list of <code>SyntaxNodeKind</code>s and you can then adapt as you want.)</p>",
        "id": 431795411,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712509187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> you should look at Scott’s lean training data repo. Specifically there’s a function there called <code>TacticInfo.isSubstantive</code> I think, and it probably does what you’re looking for</p>",
        "id": 431795944,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712509400
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">isSubstantive</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">TacticInfo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t.name</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">`</span><span class=\"n\">null</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">cdot</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">cdotTk</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Term.byTactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq1Indented</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.</span><span class=\"bp\">«</span><span class=\"n\">tactic_</span><span class=\"bp\">&lt;;&gt;</span><span class=\"n\">_</span><span class=\"bp\">»</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"bp\">``</span><span class=\"n\">Lean.Parser.Tactic.paren</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span>\n</code></pre></div>",
        "id": 431796755,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712509743
    },
    {
        "content": "<p>I think even that is missing whatever the name is associated to <code>have</code> and <code>let</code></p>",
        "id": 431798784,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712510613
    },
    {
        "content": "<p>Maybe others</p>",
        "id": 431798810,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712510625
    },
    {
        "content": "<p>Yes, I think that there are a few uncontroversial syntax nodes that you almost always want to exclude, but others that are more goal-specific.  I'll DM Joachim now, to avoid spamming the general thread.  If anyone wants in, simply let me know!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 431799137,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712510782
    },
    {
        "content": "<p>I think it would be useful for various things if we could have a complete list of “nonsubstantive” things</p>",
        "id": 431799380,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712510885
    },
    {
        "content": "<p>Ok, I can give an update, once I find more.  There are some nodes, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Lean.Parser.Tactic.withAnnotateState</span>\n<span class=\"bp\">`</span><span class=\"n\">Lean.Parser.Tactic.withReducible</span>\n</code></pre></div>\n<p>that <code>rw</code> brings in: do they count?</p>",
        "id": 431799531,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712510983
    },
    {
        "content": "<p><code>rw</code> also brings in <code>Lean.Parser.Tactic.rwRuleSeq</code> (inside a <code>Lean.Parser.Tactic.rwSeq</code> node).</p>",
        "id": 431799719,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712511057
    },
    {
        "content": "<p>You can also check is the syntax is original and I think that would take care of such things?</p>",
        "id": 431800000,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1712511247
    },
    {
        "content": "<p>Ah, I'll add that filter!</p>",
        "id": 431800035,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712511276
    },
    {
        "content": "<p>The <code>original</code> filter works very well!  On top of Scott's <code>isSubstantive</code>, I think that further additions may include</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">`</span><span class=\"kd\">by</span>\n<span class=\"bp\">`«;»</span>\n<span class=\"bp\">`«</span><span class=\"o\">]</span><span class=\"bp\">»</span>\n<span class=\"bp\">`«&lt;;&gt;»</span>\n</code></pre></div>\n<p>(and counting).</p>",
        "id": 431801512,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712512382
    },
    {
        "content": "<p>I don't think id exclude let and have. There is certainly something to be told to the hovering about them!</p>\n<p>Better err on the side of inclusion, it's better to skip documenting something trivial than to miss documenting something that's worth documenting (certainly I won't mind an explanation of <code>&lt;;&gt;</code> when I first see it.)</p>",
        "id": 431807524,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712517052
    },
    {
        "content": "<p>Here is my current attempt: It uses ileans, which is a very quick way to get references without having to re-elaborate the file, although it means we are missing out on tactics and other syntax elements. I assume that patching <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Server/References.html#Lean.Server.identOf\">Lean.Server.identOf</a> on <a href=\"https://github.com/leanprover/lean4/pull/3840\">a draft PR</a> to include <code>ofTacticInfo</code> and <code>ofCommandInfo</code>, letting CI create a test CI and then running this script will fix that. A bit ad-hoc, but a pragmatic way to get the data.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Lean.Server.References\nimport Lean.DocString\nimport Lean\nimport Std.Tactic.OpenPrivate\n\nopen private builtinDocStrings docStringExt from Lean.DocString\n\nopen Lean Elab PrettyPrinter\ndef failWith {α} (msg : String) (exitCode : UInt8 := 1) : IO α := do\n  (← IO.getStderr).putStrLn msg\n  IO.Process.exit exitCode\n\ndef modPrefixes : List Name := [`Init]\n\ndef act&#39; (fileNames : List String) : CoreM Unit := do\n  let env ← getEnv\n  let builtinDocStrings ← builtinDocStrings.get\n  let mut counts := HashMap.empty\n  for fileName in fileNames do\n    let ilean ← Lean.Server.Ilean.load fileName\n    counts := ilean.references.fold (init := counts)\n      fun counts refident info =&gt; Id.run do\n        let .const mod n := refident | return counts\n        unless modPrefixes.any (·.isPrefixOf mod) do return counts\n        if (docStringExt.find? env n).isSome then return counts\n        if (builtinDocStrings.find? n).isSome then return counts\n        return counts.insert n (counts.findD n 0 + info.usages.size)\n\n  counts.toArray.qsort (·.2 &gt; ·.2) |&gt;.forM fun (n, count) =&gt;\n    IO.println s!&quot;{n},{count}&quot;\n\ninstance : ToExpr System.FilePath where\n  toTypeExpr := Lean.mkConst ``System.FilePath\n  toExpr path := mkApp (Lean.mkConst ``System.FilePath.mk) (toExpr path.1)\n\nelab &quot;#compileTimeSearchPath&quot; : term =&gt; do\n  let path ← searchPathRef.get\n  return toExpr path\ndef compileTimeSearchPath : SearchPath := #compileTimeSearchPath\n\n\nunsafe def main (args : List String) : IO Unit := do\n  if args.isEmpty then failWith &quot;Usage: occCount [file.ilean ..]&quot;\n\n  initSearchPath (← findSysroot)\n  let imports := #[{module := `Mathlib}]\n  withImportModules imports {} 0 fun env =&gt; do\n    let ctx := {fileName := &quot;/&quot;, fileMap := Inhabited.default}\n    let state := {env}\n    Prod.fst &lt;$&gt; (act&#39; args).toIO ctx state\n</code></pre></div>\n</div></div>\n<p>I added this to mathlib’s <code>script</code> folder and am running it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">~/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span> <span class=\"bp\">$</span> <span class=\"n\">lake</span> <span class=\"n\">exe</span> <span class=\"n\">occCount</span> <span class=\"bp\">./.</span><span class=\"n\">lake</span><span class=\"bp\">/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lib</span><span class=\"bp\">/**/*.</span><span class=\"n\">ilean</span> <span class=\"bp\">|</span> <span class=\"n\">tee</span> <span class=\"n\">undocumented.csv</span>\n</code></pre></div>\n<p>which produces</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">~/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span> <span class=\"bp\">$</span> <span class=\"n\">head</span> <span class=\"bp\">-</span><span class=\"n\">n</span> <span class=\"mi\">20</span> <span class=\"n\">undocumented.csv</span>\n<span class=\"n\">Iff.trans</span><span class=\"o\">,</span><span class=\"mi\">1515</span>\n<span class=\"n\">Iff.rfl</span><span class=\"o\">,</span><span class=\"mi\">1435</span>\n<span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span><span class=\"mi\">993</span>\n<span class=\"n\">Ne.symm</span><span class=\"o\">,</span><span class=\"mi\">946</span>\n<span class=\"n\">eq_comm</span><span class=\"o\">,</span><span class=\"mi\">861</span>\n<span class=\"n\">Iff.symm</span><span class=\"o\">,</span><span class=\"mi\">856</span>\n<span class=\"n\">mt</span><span class=\"o\">,</span><span class=\"mi\">809</span>\n<span class=\"n\">if_neg</span><span class=\"o\">,</span><span class=\"mi\">744</span>\n<span class=\"n\">Subsingleton.elim</span><span class=\"o\">,</span><span class=\"mi\">598</span>\n<span class=\"n\">if_pos</span><span class=\"o\">,</span><span class=\"mi\">592</span>\n<span class=\"n\">exists_prop</span><span class=\"o\">,</span><span class=\"mi\">526</span>\n<span class=\"n\">dif_pos</span><span class=\"o\">,</span><span class=\"mi\">477</span>\n<span class=\"n\">dif_neg</span><span class=\"o\">,</span><span class=\"mi\">414</span>\n<span class=\"n\">Fin.succ</span><span class=\"o\">,</span><span class=\"mi\">385</span>\n<span class=\"n\">Classical.choose_spec</span><span class=\"o\">,</span><span class=\"mi\">346</span>\n<span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span><span class=\"mi\">346</span>\n<span class=\"n\">Or.resolve_left</span><span class=\"o\">,</span><span class=\"mi\">343</span>\n<span class=\"n\">ne_eq</span><span class=\"o\">,</span><span class=\"mi\">326</span>\n<span class=\"n\">and_imp</span><span class=\"o\">,</span><span class=\"mi\">288</span>\n<span class=\"n\">not_false_iff</span><span class=\"o\">,</span><span class=\"mi\">287</span>\n</code></pre></div>\n<p>which looks plausible. (Code also on branch <a href=\"https://github.com/leanprover-community/mathlib4/compare/nightly-testing...joachim/occCount\"><code>joachim/occCount</code></a>.)</p>",
        "id": 431893014,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712564997
    },
    {
        "content": "<p>There is hover information for tactics already in VSCode, so maybe the information about the location of tactics is also already stored somewhere...</p>",
        "id": 431895725,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712565684
    },
    {
        "content": "<p>It is in the info tree (and the environment)! But it’s thrown away when the info trees are “condensed” into the .ilean files. It would be straight-forward, but just very slow, to elaborate each file to get the info tree. But I am inpatient, so if possible I’d like to just read the .ilean files instead :)</p>",
        "id": 431896162,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712565776
    },
    {
        "content": "<p>Ok, you can also work on documenting the lemmas, while the linter produces the list of tactics and then extract the data from the tactics as well!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 431896436,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712565845
    },
    {
        "content": "<p>In any case, I think that for tactics, the biggest gap in tooling is making <code>doc-gen</code> aware of the output of <code>#help tactic</code>.</p>",
        "id": 431897014,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1712565968
    },
    {
        "content": "<p>It wasn’t too bad to hack lean to include syntax nodes in this report, now I get</p>\n<div class=\"codehilite\" data-code-language=\"csv\"><pre><span></span><code>~/build/lean/mathlib4 $ head -n 20 undocumented2.csv\nInit.NotationExtra,cdotTk,35292\nInit.Core,Iff.trans,1494\nInit.Core,Iff.rfl,1429\nInit.Conv,Lean.Parser.Tactic.Conv.convSeq,1344\nInit.Conv,Lean.Parser.Tactic.Conv.convSeq1Indented,1333\nInit.Core,Function.comp_apply,955\nInit.Core,Ne.symm,913\nInit.Core,Iff.symm,848\nInit.Core,eq_comm,835\nInit.Core,mt,730\nInit.Core,if_neg,665\nInit.Core,Subsingleton.elim,584\nInit.Core,if_pos,559\nInit.PropLemmas,exists_prop,515\nInit.Core,dif_pos,456\nInit.Core,dif_neg,399\nInit.Data.Fin.Basic,Fin.succ,381\nInit.Classical,Classical.choose_spec,343\nInit.Prelude,Or.resolve_left,326\nInit.Core,eq_self_iff_true,319\n</code></pre></div>",
        "id": 431971007,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712582861
    },
    {
        "content": "<p>can you exclude theorems from the list?</p>",
        "id": 431971449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712583007
    },
    {
        "content": "<p>There are other things like <code>convSeq1Indented</code> that aren't really hoverable, not really sure how to express that though</p>",
        "id": 431971605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712583059
    },
    {
        "content": "<p>That’s fine, at least for me I only need a sorted TODO list, it’s ok if not all are actionable.</p>",
        "id": 431972649,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712583397
    },
    {
        "content": "<p>I mean, start with Init and work your way up? Almost everything is undocumented, it's really easy to find things to work on</p>",
        "id": 431973042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712583534
    },
    {
        "content": "<p>Functions on List, String, Array are particularly important (i.e. the part of Std which is actually Init)</p>",
        "id": 431973133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712583565
    },
    {
        "content": "<p>Without theorems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Init.NotationExtra</span><span class=\"o\">,</span><span class=\"n\">cdotTk</span><span class=\"o\">,</span><span class=\"mi\">35292</span>\n<span class=\"n\">Init.Conv</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Tactic.Conv.convSeq</span><span class=\"o\">,</span><span class=\"mi\">1344</span>\n<span class=\"n\">Init.Conv</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Tactic.Conv.convSeq1Indented</span><span class=\"o\">,</span><span class=\"mi\">1333</span>\n<span class=\"n\">Init.Data.Fin.Basic</span><span class=\"o\">,</span><span class=\"n\">Fin.succ</span><span class=\"o\">,</span><span class=\"mi\">381</span>\n<span class=\"n\">Init.Classical</span><span class=\"o\">,</span><span class=\"n\">Classical.choose</span><span class=\"o\">,</span><span class=\"mi\">251</span>\n<span class=\"n\">Init.MetaTypes</span><span class=\"o\">,</span><span class=\"n\">Lean.Meta.Simp.Config.contextual</span><span class=\"o\">,</span><span class=\"mi\">226</span>\n<span class=\"n\">Init.Control.Basic</span><span class=\"o\">,</span><span class=\"n\">Alternative.failure</span><span class=\"o\">,</span><span class=\"mi\">216</span>\n<span class=\"n\">Init.Prelude</span><span class=\"o\">,</span><span class=\"n\">Prod.mk</span><span class=\"o\">,</span><span class=\"mi\">191</span>\n<span class=\"n\">Init.WF</span><span class=\"o\">,</span><span class=\"n\">WellFounded</span><span class=\"o\">,</span><span class=\"mi\">179</span>\n<span class=\"n\">Init.Data.Nat.Gcd</span><span class=\"o\">,</span><span class=\"n\">Nat.gcd</span><span class=\"o\">,</span><span class=\"mi\">177</span>\n<span class=\"n\">Init.Data.Option.Basic</span><span class=\"o\">,</span><span class=\"n\">Option.isSome</span><span class=\"o\">,</span><span class=\"mi\">128</span>\n<span class=\"n\">Init.Prelude</span><span class=\"o\">,</span><span class=\"n\">Nat.casesOn</span><span class=\"o\">,</span><span class=\"mi\">113</span>\n<span class=\"n\">Init.Control.Basic</span><span class=\"o\">,</span><span class=\"n\">guard</span><span class=\"o\">,</span><span class=\"mi\">113</span>\n<span class=\"n\">Init.Data.Repr</span><span class=\"o\">,</span><span class=\"n\">Repr</span><span class=\"o\">,</span><span class=\"mi\">103</span>\n<span class=\"n\">Init.Data.List.BasicAux</span><span class=\"o\">,</span><span class=\"n\">List.get</span><span class=\"bp\">?</span><span class=\"o\">,</span><span class=\"mi\">103</span>\n<span class=\"n\">Init.Meta</span><span class=\"o\">,</span><span class=\"n\">Lean.TSyntax.getId</span><span class=\"o\">,</span><span class=\"mi\">95</span>\n<span class=\"n\">Init.Data.Array.Basic</span><span class=\"o\">,</span><span class=\"n\">Array.map</span><span class=\"o\">,</span><span class=\"mi\">88</span>\n<span class=\"n\">Init.Data.Ord</span><span class=\"o\">,</span><span class=\"n\">Ordering.lt</span><span class=\"o\">,</span><span class=\"mi\">86</span>\n<span class=\"n\">Init.WF</span><span class=\"o\">,</span><span class=\"n\">Acc</span><span class=\"o\">,</span><span class=\"mi\">79</span>\n<span class=\"n\">Init.Meta</span><span class=\"o\">,</span><span class=\"n\">Lean.mkIdent</span><span class=\"o\">,</span><span class=\"mi\">78</span>\n</code></pre></div>",
        "id": 431973327,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712583625
    },
    {
        "content": "<p>yep it's almost all true positives now</p>",
        "id": 431973422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712583662
    },
    {
        "content": "<p>Ah, and I should include <code>Lean.*</code> in the list to get a better picture of syntax missing a docstring:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">~/</span><span class=\"n\">build</span><span class=\"bp\">/</span><span class=\"n\">lean</span><span class=\"bp\">/</span><span class=\"n\">mathlib4</span> <span class=\"bp\">$</span> <span class=\"n\">head</span> <span class=\"bp\">-</span><span class=\"n\">n</span> <span class=\"mi\">30</span> <span class=\"n\">undocumented2.csv</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.declaration</span><span class=\"o\">,</span><span class=\"mi\">150198</span>\n<span class=\"n\">Lean.Parser.Term</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Tactic.tacticSeq1Indented</span><span class=\"o\">,</span><span class=\"mi\">135514</span>\n<span class=\"n\">Init.NotationExtra</span><span class=\"o\">,</span><span class=\"n\">cdotTk</span><span class=\"o\">,</span><span class=\"mi\">35292</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.variable</span><span class=\"o\">,</span><span class=\"mi\">23193</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.end</span><span class=\"o\">,</span><span class=\"mi\">16660</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.section</span><span class=\"o\">,</span><span class=\"mi\">9454</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.open</span><span class=\"o\">,</span><span class=\"mi\">8132</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.namespace</span><span class=\"o\">,</span><span class=\"mi\">7387</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.moduleDoc</span><span class=\"o\">,</span><span class=\"mi\">7120</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.in</span><span class=\"o\">,</span><span class=\"mi\">4213</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.set_option</span><span class=\"o\">,</span><span class=\"mi\">4047</span>\n<span class=\"n\">Lean.Parser.Attr</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Attr.simple</span><span class=\"o\">,</span><span class=\"mi\">2709</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.attribute</span><span class=\"o\">,</span><span class=\"mi\">1511</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.universe</span><span class=\"o\">,</span><span class=\"mi\">1452</span>\n<span class=\"n\">Init.Conv</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Tactic.Conv.convSeq</span><span class=\"o\">,</span><span class=\"mi\">1344</span>\n<span class=\"n\">Init.Conv</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Tactic.Conv.convSeq1Indented</span><span class=\"o\">,</span><span class=\"mi\">1333</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.noncomputableSection</span><span class=\"o\">,</span><span class=\"mi\">855</span>\n<span class=\"n\">Lean.Parser.Attr</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Attr.instance</span><span class=\"o\">,</span><span class=\"mi\">655</span>\n<span class=\"n\">Lean.Parser.Syntax</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.notation</span><span class=\"o\">,</span><span class=\"mi\">568</span>\n<span class=\"n\">Lean.Meta.Basic</span><span class=\"o\">,</span><span class=\"n\">Lean.Meta.MetaM</span><span class=\"o\">,</span><span class=\"mi\">517</span>\n<span class=\"n\">Init.Data.Fin.Basic</span><span class=\"o\">,</span><span class=\"n\">Fin.succ</span><span class=\"o\">,</span><span class=\"mi\">381</span>\n<span class=\"n\">Lean.Parser.Syntax</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.mixfix</span><span class=\"o\">,</span><span class=\"mi\">265</span>\n<span class=\"n\">Init.Classical</span><span class=\"o\">,</span><span class=\"n\">Classical.choose</span><span class=\"o\">,</span><span class=\"mi\">251</span>\n<span class=\"n\">Lean.Parser.Syntax</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.syntax</span><span class=\"o\">,</span><span class=\"mi\">246</span>\n<span class=\"n\">Init.MetaTypes</span><span class=\"o\">,</span><span class=\"n\">Lean.Meta.Simp.Config.contextual</span><span class=\"o\">,</span><span class=\"mi\">226</span>\n<span class=\"n\">Lean.Linter.Deprecated</span><span class=\"o\">,</span><span class=\"n\">Lean.Linter.linter.deprecated</span><span class=\"o\">,</span><span class=\"mi\">225</span>\n<span class=\"n\">Init.Control.Basic</span><span class=\"o\">,</span><span class=\"n\">Alternative.failure</span><span class=\"o\">,</span><span class=\"mi\">216</span>\n<span class=\"n\">Lean.Elab.AutoBound</span><span class=\"o\">,</span><span class=\"n\">Lean.Elab.autoImplicit</span><span class=\"o\">,</span><span class=\"mi\">213</span>\n<span class=\"n\">Init.Prelude</span><span class=\"o\">,</span><span class=\"n\">Prod.mk</span><span class=\"o\">,</span><span class=\"mi\">191</span>\n<span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.export</span><span class=\"o\">,</span><span class=\"mi\">179</span>\n</code></pre></div>",
        "id": 431975769,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712584399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/undocumented.20things/near/431971605\">said</a>:</p>\n<blockquote>\n<p>There are other things like <code>convSeq1Indented</code> that aren't really hoverable, not really sure how to express that though</p>\n</blockquote>\n<p>I can get the hover text</p>\n<blockquote>\n<p>A sequence of tactics in brackets, or a delimiter-free indented sequence of tactics. Delimiter-free indentation is determined by the <em>first</em> tactic of the sequence.</p>\n</blockquote>\n<p>from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Tactic.tacticSeq#doc\">docs#Lean.Parser.Tactic.tacticSeq</a> whenever a tactic doesn’t have its own docstring, as in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"foo\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"n\">skip</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">foo</span>\n</code></pre></div>\n<p>so it wouldn’t be unreasonable to get the same behavior from <code>convSeq</code>. Although a <code>convSeq</code> will commonly be part of a <code>conv</code>, and then that’s docstring will show on hover. I guess that’s what you mean with “not really hoverable”.</p>\n<p>Hmm, and now I suddenly cannot reproduce seeing the <code>tacticSeq</code> docstring anymore, and am confused.</p>\n<p>Anyways, not so important.</p>",
        "id": 431978492,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712585092
    },
    {
        "content": "<p>Ah, I believe you can get <code>convSeq</code> under certain conditions, but <code>convSeq1Indented</code> will be harder</p>",
        "id": 431978881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585198
    },
    {
        "content": "<p>It seems that commands never show the generic docstring on hover. I wonder if that is something worth improving? A user might expect to be able to hover over <code>def</code> or <code>example</code> or <code>variable</code> and get an explanation what this command does?</p>",
        "id": 431978944,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712585210
    },
    {
        "content": "<p>Oh yeah all commands need docs</p>",
        "id": 431979029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585236
    },
    {
        "content": "<p><code>Lean.Syntax.Command.foo</code></p>",
        "id": 431979066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585249
    },
    {
        "content": "<p>But there <code>inductive</code> has a docstring, but it doesn't seem to be displayed when hovering, so besides more docstrings there is something to be fixed, isn’t it?</p>",
        "id": 431979302,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712585326
    },
    {
        "content": "<p>Also, <code>«def»</code> does not show up in my list, which is strange.</p>",
        "id": 431979624,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712585409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/undocumented.20things/near/431979302\">said</a>:</p>\n<blockquote>\n<p>But there <code>inductive</code> has a docstring, but it doesn't seem to be displayed when hovering, so besides more docstrings there is something to be fixed, isn’t it?</p>\n</blockquote>\n<p>it shows up only with <code>import Lean</code> apparently?</p>",
        "id": 431979666,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585423
    },
    {
        "content": "<p>I was already aware of this limitation for go-to-def but normally hover docs still show up for builtin syntax</p>",
        "id": 431979809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585462
    },
    {
        "content": "<p>Oh I see, the issue is that <code>declaration</code> is undocumented</p>",
        "id": 431980050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585521
    },
    {
        "content": "<p><code>inductive</code> is not actually a top level command</p>",
        "id": 431980131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585533
    },
    {
        "content": "<p>of course if you put a doc comment on <code>declaration</code> it will be about as generic as the parentheses doc comment</p>",
        "id": 431980519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585612
    },
    {
        "content": "<p>so indeed this is an area where just adding doc strings is probably insufficient to get a good result</p>",
        "id": 431980696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712585646
    },
    {
        "content": "<p>We do get the docstring on <code>inductive</code> after <code>import Lean</code>, so I assume we would get specific docstrings on <code>def</code> etc, even without putting an unhelpfully generic docstring on <code>declaration</code>.</p>\n<p>I don’t know yet what needs to be done so that the existing docstring on <code>inductive</code> is shown even without <code>import Lean</code>. Reported as <a href=\"https://github.com/leanprover/lean4/issues/3842\">https://github.com/leanprover/lean4/issues/3842</a>.</p>",
        "id": 431981427,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712585856
    },
    {
        "content": "<p>Also it shows a short coming in my script. If the user would get the hover from <code>inductive</code>, and ideally eventually from <code>def</code>, then the script should complain about <code>Lean.Parser.Command.def</code> instead of <code>Lean.Parser.Command.declaration</code>.</p>",
        "id": 431981629,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712585911
    },
    {
        "content": "<p>Fun fact: The script reports</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Lean.Parser.Command</span><span class=\"o\">,</span><span class=\"n\">Lean.Parser.Command.theorem</span><span class=\"o\">,</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>due to a mention as an explicit name:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">stx.setKind</span> <span class=\"bp\">``</span><span class=\"n\">Parser.Command.theorem</span>\n</code></pre></div>",
        "id": 431982143,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712586045
    },
    {
        "content": "<p>yes, I think any parser can show up as a hover target if it is used directly in <code>syntax</code> definitions</p>",
        "id": 431989463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712587845
    },
    {
        "content": "<p>I think it would be good to document the <code>pp*</code> parsers in particular</p>",
        "id": 431989633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712587880
    },
    {
        "content": "<p>Marc walked me through the hover code, and it’s looking for docstrings both in the info tree (where my script can grab it) and the syntax tree (where my script can’t). That explains where the <code>inductive</code> hover came from, even though it's not mentioned in the info tree.</p>",
        "id": 431992100,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712588346
    },
    {
        "content": "<p>oh yeah most syntax docs come from the syntax tree itself</p>",
        "id": 431992895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712588473
    },
    {
        "content": "<p>I see, and there we don’t really need every syntax kind to be documented, as long as some “containing” syntax node has a good docstring. So it’s not easy to list all the syntax nodes that should be documented (besides that my current script is infotree-based).</p>",
        "id": 431996341,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712589103
    },
    {
        "content": "<p>for \"should\", that's going to require some additional smarts indeed, but getting the closure of all syntax nodes that may need to be documented should not be that hard</p>",
        "id": 431998300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712589449
    },
    {
        "content": "<p>Long term though I think we want to have docs on everything and additional attributes to suppress those docs in hover if they would be covering up something more useful (e.g. <code>declaration</code> hiding <code>def</code>'s docstring)</p>",
        "id": 431998746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712589536
    },
    {
        "content": "<p>because it's not good to have negative incentives on documentation</p>",
        "id": 431998844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1712589557
    },
    {
        "content": "<blockquote>\n<p>e.g. <code>declaration</code> hiding <code>def</code>'s docstring</p>\n</blockquote>\n<p>Shouldn’t that already be the case since the hover comes from the “innermost” syntax parser that has a docstring?</p>",
        "id": 431999353,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1712589664
    }
]