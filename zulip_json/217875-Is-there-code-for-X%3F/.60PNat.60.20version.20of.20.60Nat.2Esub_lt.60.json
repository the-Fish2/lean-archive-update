[
    {
        "content": "<p>Hello, is there the following lemma on Mathlib?<br>\nGiven <code>a b : ℕ+</code> with <code>1 &lt; a</code>, we have <code>a - b &lt; a</code>.</p>",
        "id": 416484864,
        "sender_full_name": "Gian Cordana Sanjaya",
        "timestamp": 1705546458
    },
    {
        "content": "<p>I think you'd need to give <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PNat#doc\">docs#PNat</a> a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderedSub#doc\">docs#OrderedSub</a> instance and then you could use some theorem about <code>tsub</code></p>",
        "id": 416510317,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705562217
    },
    {
        "content": "<p>I doubt that will work since the theorem (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=tsub_lt_self#doc\">docs#tsub_lt_self</a>) requires a <code>0</code></p>",
        "id": 416519268,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705566324
    },
    {
        "content": "<p>We don't have something like a canonically ordered semigroup either. Should I try PRing this one?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.PNat.Basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">PNat.sub_lt_self</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">PNat.coe_lt_coe</span><span class=\"o\">,</span> <span class=\"n\">PNat.sub_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">split_ifs</span><span class=\"bp\">;</span> <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">Nat.sub_lt</span> <span class=\"n\">a.2</span> <span class=\"n\">b.2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 416607743,
        "sender_full_name": "Gian Cordana Sanjaya",
        "timestamp": 1705595511
    },
    {
        "content": "<p>I think it would be great to build up some more API for <code>PNat</code>, although my gut feeling is that the most sensible way to make progress would be to write a <code>natify</code> tactic (like <code>zify</code>) which translates goals in PNat to goals in Nat, which can then be solved with <code>omega</code>.</p>",
        "id": 416616481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705598461
    },
    {
        "content": "<p>If <code>PNat</code> was in Std, my understanding is that it would be very straightforward to use <code>omega</code> with it? But I assume this is scope-creep</p>",
        "id": 416618764,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1705599251
    },
    {
        "content": "<p>I'm assuming <code>omega</code> doesn't solve <code>PNat.sub_lt_self</code>?</p>",
        "id": 416640525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705608099
    },
    {
        "content": "<p>Nope, it doesn't. Are there any extra imports I need to load for <code>omega</code>?<br>\nInterestingly, if I replace the second line of proof that start with <code>split_ifs</code>, I get the following message:<br>\n<a href=\"/user_uploads/3121/DvL4DaqGKDfwEHbXp2VFVzCV/Screenshot-2024-01-18-at-3.05.30PM.png\">Screenshot-2024-01-18-at-3.05.30PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/DvL4DaqGKDfwEHbXp2VFVzCV/Screenshot-2024-01-18-at-3.05.30PM.png\" title=\"Screenshot-2024-01-18-at-3.05.30PM.png\"><img src=\"/user_uploads/3121/DvL4DaqGKDfwEHbXp2VFVzCV/Screenshot-2024-01-18-at-3.05.30PM.png\"></a></div>",
        "id": 416641278,
        "sender_full_name": "Gian Cordana Sanjaya",
        "timestamp": 1705608387
    },
    {
        "content": "<p>Apologies for the completely useless message when <code>omega</code> fails. It's on my lists.</p>",
        "id": 416669642,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705621701
    },
    {
        "content": "<p><code>omega</code> does not know how to handle <code>PNat</code> or <code>Fin</code> at all, only <code>Nat</code> and <code>Int</code>.</p>\n<p>In principle we could add a typeclass for \"types that embed into Int, with + and - being sent to operations involving +, -, %, and max\" and omega could then handle all such types. We would need to be careful with the implementation as it is important that <code>omega</code> fails very fast when it has nothing to do, so additional typeclass search is potentially problematic.</p>\n<p>There are other solutions that would allow users to register after the fact a short finite list of such types.</p>",
        "id": 416670061,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705621924
    },
    {
        "content": "<p>Isn't the path of least resistance just to write <code>natify</code>? I would like to see PNat get more love. For a long time here the computer scientists were doing a good job of convincing me that everything I knew about positive naturals extended to zero, but it's not always true, eg the n'th cyclotomic field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi></mrow></msup><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}(e^{2\\pi i/n}).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mathnormal mtight\">πi</span><span class=\"mord mtight\">/</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 416677962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705625158
    },
    {
        "content": "<p>Yes, if someone writes <code>natify</code> I could add a feature to <code>omega</code> so you can tell it to run certain preprocessor tactics, e.g. make <code>omega!</code> a macro for \"run anything registered as an omega preprocessor, then <code>omega</code>\". Then performance isn't my problem. :-)</p>",
        "id": 416687594,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705629637
    },
    {
        "content": "<p><code>natify</code> would be a pretty easy tactic to implement, following the existing <code>zify</code>. If someone is interested we could provide advice here. :-)</p>",
        "id": 416687661,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705629669
    },
    {
        "content": "<p>I've been using the following homemade tactic to deal with <code>Fin</code>. It works basically like <code>zify</code>, using a custom simp set to convert everything in sight to <code>Nat</code> or <code>Int</code>, together with the custom auxiliary tactic <code>fin_omega_aux</code> which just brings <code>(a : Nat) &lt; n</code> in the context for every <code>a : Fin n</code>. It could easily be adapted to deal with <code>PNat</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_iff_val_eq</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Fin.val_inj.mpr</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Fin.eq_of_val_eq</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">le_iff_val_le</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ge_iff_val_le</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≥</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">lt_iff_val_add_one_le</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">gt_iff_val_add_one_le</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ne_iff_val_ne</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Fin.val_ne_iff.symm</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_ofNat</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">Fin.ofNat</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">k</span> <span class=\"bp\">%</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Fin.ofNat</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_castSucc</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin.castSucc</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_castAdd</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin.castAdd</span> <span class=\"n\">k</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">last_val</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin.last</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">is_lt'</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">i.2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_sub</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a.val</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">b.val</span><span class=\"o\">))</span> <span class=\"bp\">%</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_addNat</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin.addNat</span> <span class=\"n\">i</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">val_natAdd</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Fin.natAdd</span> <span class=\"n\">m</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Fin</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Membership.mem_upper</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">step</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Std.Range</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">h.2</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Membership.mem_lower</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">step</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Std.Range</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">h.1</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Membership.mem_range_iff</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">step</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"o\">(⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">step</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">Std.Range</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Meta</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"fin_omega_aux\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withMainContext</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ctx</span> <span class=\"bp\">←</span> <span class=\"n\">getLCtx</span>\n  <span class=\"k\">let</span> <span class=\"n\">newhyps</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Expr</span> <span class=\"bp\">←</span> <span class=\"n\">ctx.foldlM</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"o\">[])</span> <span class=\"k\">fun</span> <span class=\"n\">acc</span> <span class=\"n\">decl</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">decl.toExpr</span>\n    <span class=\"k\">let</span> <span class=\"n\">declType</span> <span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">e</span>\n    <span class=\"k\">match</span> <span class=\"n\">declType.getAppFnArgs</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">``</span><span class=\"n\">Fin</span><span class=\"o\">,</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">])</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"k\">let</span> <span class=\"n\">newhyp</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">Fin.is_lt</span> <span class=\"o\">[])</span> <span class=\"n\">n</span> <span class=\"n\">e</span>\n        <span class=\"n\">return</span> <span class=\"n\">newhyp</span> <span class=\"o\">::</span> <span class=\"n\">acc</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">acc</span>\n  <span class=\"k\">let</span> <span class=\"n\">numfins</span> <span class=\"o\">:=</span> <span class=\"n\">newhyps.length</span>\n  <span class=\"k\">let</span> <span class=\"n\">newnames</span> <span class=\"o\">:=</span> <span class=\"n\">ctx.getUnusedUserNames</span> <span class=\"n\">numfins</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">str</span> <span class=\"bp\">.</span><span class=\"n\">anonymous</span> <span class=\"s2\">\"fin_lt\"</span><span class=\"o\">)</span>\n  <span class=\"n\">liftMetaTactic</span> <span class=\"k\">fun</span> <span class=\"n\">mvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">mvarIdNew</span> <span class=\"o\">:=</span> <span class=\"n\">mvarId</span>\n    <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">numfins</span><span class=\"o\">]</span> <span class=\"k\">do</span>\n      <span class=\"n\">mvarIdNew</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.assert</span> <span class=\"n\">newnames</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">inferType</span> <span class=\"n\">newhyps</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"n\">newhyps</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span>\n    <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvarIdNew'</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvarIdNew.introNP</span> <span class=\"n\">numfins</span>\n    <span class=\"n\">return</span> <span class=\"o\">[</span><span class=\"n\">mvarIdNew'</span><span class=\"o\">]</span>\n\n<span class=\"n\">macro</span> <span class=\"s2\">\"fin_omega\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">failIfUnchanged</span> <span class=\"o\">:=</span> <span class=\"n\">false</span><span class=\"o\">})</span> <span class=\"o\">[</span><span class=\"n\">Fin.eq_iff_val_eq</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.le_iff_val_le</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.ge_iff_val_le</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.lt_iff_val_add_one_le</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.gt_iff_val_add_one_le</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.ne_iff_val_ne</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_ofNat</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_castSucc</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_castAdd</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_add</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_mul</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_sub</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_succ</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_addNat</span><span class=\"o\">,</span>\n                             <span class=\"n\">Fin.val_natAdd</span><span class=\"o\">,</span>\n                             <span class=\"n\">Membership.mem_range_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*;</span> <span class=\"n\">fin_omega_aux</span><span class=\"bp\">;</span> <span class=\"n\">omega</span><span class=\"o\">})</span>\n</code></pre></div>",
        "id": 416688198,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1705629943
    },
    {
        "content": "<p>Probably better to not have this actually call <code>omega</code>, or at least factor it out so it is possible to call just the preprocessing step.</p>",
        "id": 416691354,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705630949
    },
    {
        "content": "<p>It would also be cleaner to actually have a <code>natify_simps</code> simpset, like for <code>zify</code>.</p>",
        "id": 416695656,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1705631958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> For setting up omega, an interesting strategy might be to revert the context then simp the goal using your simp set along with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.forall_iff#doc\">docs#Fin.forall_iff</a> to eliminate all Fin variables (maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin.exists_iff#doc\">docs#Fin.exists_iff</a> too), rather than write meta code. That doesn't preserve any names of anything however, so it wouldn't be a good factored-out preprocessing step.</p>",
        "id": 416696260,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705632342
    },
    {
        "content": "<p>Interesting approach! Do we already have a tactic that reverts everything?</p>",
        "id": 416696582,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1705632526
    },
    {
        "content": "<p>Looks like not, but here's one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Tactic</span> <span class=\"k\">in</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"revert_all\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">liftMetaTactic'</span> <span class=\"k\">fun</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"n\">Prod.snd</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">g.revert</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">g.getDecl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lctx.getFVarIds</span> <span class=\"o\">(</span><span class=\"n\">clearAuxDeclsInsteadOfRevert</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 416697211,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1705632968
    }
]