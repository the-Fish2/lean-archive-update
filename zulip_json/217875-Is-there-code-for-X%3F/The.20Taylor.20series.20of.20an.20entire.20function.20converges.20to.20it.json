[
    {
        "content": "<p>I would like to use the fact that the Taylor series (at zero, say) of an entire function <code>f : ‚ÑÇ ‚Üí ‚ÑÇ</code> converges everywhere to <code>f</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">taylorSeries_of_entire</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Differentiable</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">‚àë'</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n.factorial</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span> <span class=\"bp\">*</span> <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Using <code>Differentiable.hasFPowerSeriesOnBall</code>, I can get to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">(</span><span class=\"n\">cauchyPowerSeries</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">‚Üë</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but my problem now is that I need to relate <code>cauchyPowerSeries f 0 (‚ÜëR)</code> (where <code>R</code> is some suitable radius) with the Taylor series. Unfortunately,<br>\n<span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> cauchyPowerSeries, iteratedDeriv</p>",
        "id": 417295179,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705949730
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 417295182,
        "sender_full_name": "loogle",
        "timestamp": 1705949731
    },
    {
        "content": "<p>there does not seem to be API relating the two. Any ideas how to proceed here?</p>",
        "id": 417295287,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705949765
    },
    {
        "content": "<p>I see \"TODO: add a version for higher derivatives.\" in the docs for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.deriv_eq_smul_circleIntegral#doc\">docs#Complex.deriv_eq_smul_circleIntegral</a>, so maybe it is time to tackle this?</p>",
        "id": 417296291,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705950149
    },
    {
        "content": "<p>I can reduce my statement to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Complex</span>\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">iteratedDeriv_eq_smul_circleIntegral</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hR</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Differentiable</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">c</span> <span class=\"bp\">=</span>\n      <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">œÄ</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">‚Åª¬π</span> <span class=\"bp\">*</span> <span class=\"n\">n.factorial</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"bp\">‚àÆ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">))</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I guess the \"TODO\" mentioned above requires the first \"TODO: add a version for w ‚àà Metric.ball c R\".<br>\n<span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> I think you wrote <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.deriv_eq_smul_circleIntegral#doc\">docs#Complex.deriv_eq_smul_circleIntegral</a> originally. Did you have thoughts on how to deal with these TODOs?</p>",
        "id": 417306395,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705953980
    },
    {
        "content": "<p>I can have a look in 3h</p>",
        "id": 417310785,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705955688
    },
    {
        "content": "<p>I'll be in bed by then, but I'm looking forward to seeing whatever you might have tomorrow morning!</p>",
        "id": 417310883,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1705955736
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Analysis.Calculus.FDeriv.Analytic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">ENNReal</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">FormalMultilinearSeries</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Fin.snoc_zero</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"mi\">0</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fin.snoc</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">y</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Subsingleton</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">Fin.subsingleton_one</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Subsingleton.elim</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">Fin.last</span> <span class=\"mi\">0</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Finset.piecewise_same</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">Œ¥</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ¥</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">[(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n    <span class=\"n\">s.piecewise</span> <span class=\"n\">f</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">i</span><span class=\"bp\">;</span> <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">FormalMultilinearSeries</span>\n\n<span class=\"c1\">-- This series appears in `HasFPowerSeriesOnBall.fderiv`</span>\n<span class=\"kd\">def</span> <span class=\"n\">derivSeries</span> <span class=\"o\">:</span> <span class=\"n\">FormalMultilinearSeries</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">continuousMultilinearCurryFin1</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">[</span><span class=\"bp\">√ó</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n    <span class=\"bp\">|&gt;.</span><span class=\"n\">compFormalMultilinearSeries</span> <span class=\"o\">(</span><span class=\"n\">p.changeOriginSeries</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">derivSeries_apply_diag</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">derivSeries</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">derivSeries</span><span class=\"o\">,</span> <span class=\"n\">changeOriginSeries</span><span class=\"o\">]</span>\n  <span class=\"n\">convert</span> <span class=\"n\">Finset.sum_const</span> <span class=\"n\">_</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fin.snoc_zero</span><span class=\"o\">,</span> <span class=\"n\">changeOriginSeriesTerm_apply</span><span class=\"o\">,</span> <span class=\"n\">Finset.piecewise_same</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">Fintype.card</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_subtype</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">Finset.powersetCard_eq_filter</span><span class=\"o\">,</span>\n    <span class=\"n\">Finset.card_powersetCard</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">Fintype.card</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_fin</span><span class=\"o\">,</span>\n    <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">choose_succ_self_right</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">FormalMultilinearSeries</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">HasFPowerSeriesOnBall</span>\n<span class=\"kn\">open</span> <span class=\"n\">FormalMultilinearSeries</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"bp\">‚â•</span><span class=\"mi\">0</span><span class=\"bp\">‚àû</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasFPowerSeriesOnBall</span> <span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span>\n<span class=\"c1\">-- assumption h could be replaced by HasFPowerSeriesAt</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">iteratedFDeriv_zero_apply_diag</span> <span class=\"o\">:</span>\n    <span class=\"n\">iteratedFDeriv</span> <span class=\"bp\">ùïú</span> <span class=\"mi\">0</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">h.hasSum</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">EMetric.mem_ball_self</span> <span class=\"n\">h.r_pos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tsum_eq.symm</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">iteratedFDeriv_zero_apply</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">tsum_eq_single</span> <span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"bp\">¬∑</span> <span class=\"n\">exact</span> <span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"mi\">0</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n  <span class=\"n\">intro</span> <span class=\"n\">n</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">NeZero.mk</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">factorial_smul'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">ùïú</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">FormalMultilinearSeries</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">F</span><span class=\"o\">},</span> <span class=\"n\">HasFPowerSeriesOnBall</span> <span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">r</span> <span class=\"bp\">‚Üí</span>\n    <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">iteratedFDeriv</span> <span class=\"bp\">ùïú</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">F</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"n\">f</span> <span class=\"n\">h</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">factorial_zero</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">,</span> <span class=\"n\">h.iteratedFDeriv_zero_apply_diag</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">factorial_succ</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">derivSeries_apply_diag</span><span class=\"o\">,</span>\n    <span class=\"bp\">‚Üê</span> <span class=\"n\">ContinuousLinearMap.smul_apply</span><span class=\"o\">,</span> <span class=\"n\">derivSeries</span><span class=\"o\">,</span> <span class=\"n\">ih</span> <span class=\"n\">h.fderiv</span><span class=\"o\">,</span>\n    <span class=\"n\">iteratedFDeriv_succ_apply_right</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">factorial_smul</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">iteratedFDeriv</span> <span class=\"bp\">ùïú</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">factorial_zero</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">,</span> <span class=\"n\">h.iteratedFDeriv_zero_apply_diag</span><span class=\"o\">]</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">factorial_succ</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">derivSeries_apply_diag</span><span class=\"o\">,</span>\n    <span class=\"bp\">‚Üê</span> <span class=\"n\">ContinuousLinearMap.smul_apply</span><span class=\"o\">,</span> <span class=\"n\">factorial_smul'.</span><span class=\"o\">{</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">_</span> <span class=\"n\">h.fderiv</span><span class=\"o\">,</span>\n    <span class=\"n\">iteratedFDeriv_succ_apply_right</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">HasFPowerSeriesOnBall.hasSum_iteratedFDeriv</span> <span class=\"o\">[</span><span class=\"n\">CharZero</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasFPowerSeriesOnBall</span> <span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">‚àà</span> <span class=\"n\">EMetric.ball</span> <span class=\"mi\">0</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">HasSum</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">iteratedFDeriv</span> <span class=\"bp\">ùïú</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">h.hasSum</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">n</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">h.factorial_smul</span> <span class=\"n\">y</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">smul_comm</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one_div_cancel</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.cast_ne_zero</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.factorial_ne_zero</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> We can't quite show</span>\n<span class=\"cm\">  `HasFPowerSeriesOnBall f (fun n ‚Ü¶ (1 / n !) ‚Ä¢ iteratedFDeriv ùïú n f x) x r`</span>\n<span class=\"cm\">  because `r_le` requires bounding the norm of a multilinear map using values on</span>\n<span class=\"cm\">  the diagonal, so some polarization identity would be required. -/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">HasFPowerSeriesOnBall</span>\n</code></pre></div>",
        "id": 417334632,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1705965735
    },
    {
        "content": "<p>Combining the above with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iteratedDeriv_eq_iteratedFDeriv#doc\">docs#iteratedDeriv_eq_iteratedFDeriv</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMultilinearMap.map_smul_univ#doc\">docs#ContinuousMultilinearMap.map_smul_univ</a>, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Differentiable.hasFPowerSeriesOnBall#doc\">docs#Differentiable.hasFPowerSeriesOnBall</a> should get you there.</p>",
        "id": 417354085,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1705975010
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 417354155,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705975058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> thanks! I'll see how far I get with this, but it looks good.</p>",
        "id": 417425260,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706009176
    },
    {
        "content": "<p>With what you have provided, I now have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">Complex</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompleteSpace</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">taylorSeries_on_ball</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">NNReal</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">DifferentiableOn</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Metric.closedBall</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Metric.ball</span> <span class=\"n\">c</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">‚àë'</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"n\">n</span> <span class=\"bp\">!</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">iteratedDeriv</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">hz'</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">c</span> <span class=\"bp\">‚àà</span> <span class=\"n\">EMetric.ball</span> <span class=\"mi\">0</span> <span class=\"n\">r</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Metric.emetric_ball_nnreal</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mem_ball_zero_iff.mpr</span> <span class=\"n\">hz</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"n\">hf.hasFPowerSeriesOnBall</span> <span class=\"n\">hr</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hasSum_iteratedFDeriv</span> <span class=\"n\">hz'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tsum_eq</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_sub_cancel'_right</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n  <span class=\"n\">convert</span> <span class=\"n\">H</span> <span class=\"n\">using</span> <span class=\"mi\">4</span> <span class=\"k\">with</span> <span class=\"n\">n</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">iteratedDeriv_eq_iteratedFDeriv</span><span class=\"o\">,</span> <span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">Finset.prod_const</span><span class=\"o\">,</span>\n    <span class=\"n\">Finset.card_fin</span><span class=\"o\">]</span>\n    <span class=\"n\">using</span> <span class=\"o\">((</span><span class=\"n\">iteratedFDeriv</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_smul_univ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>\n<p>and variants for <code>Differentiable</code>/ functions <code>‚ÑÇ ‚Üí ‚ÑÇ</code>. Thanks again!</p>",
        "id": 417486652,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706028461
    },
    {
        "content": "<p>I will add this to the \"Auxiliary.lean\" file <a href=\"https://github.com/MichaelStollBayreuth/EulerProducts\">here</a> for the time being, where I collect all the missing API lemmas I need, to be turned into Mathlib PRs eventually.</p>",
        "id": 417487148,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706028607
    },
    {
        "content": "<p>I think it's possible to extract <a href=\"https://github.com/leanprover-community/mathlib4/compare/symmetrize_changeOrigin_eq_iteratedDeriv?expand=1#diff-afc1a6ce1a23be3624955d95e5804e193249ed762e40bc3f4adf5cecc0cb9822R105-R107\">a result</a> that is true in arbitrary characteristics; even though it's harder to prove and currently left as a sorry, it will make it easy to prove <code>HasPowerSeriesOnBall f (fun n ‚Ü¶ (1 / n!) ‚Ä¢ iteratedFDeriv ùïú n f x) x r</code> in the char zero case without resorting to a polarization identity, and without needing to prove the permutation invariance of <code>iteratedDeriv</code> (it follows as a consequence of the result for analytic functions, but it's more generally true for <code>ContDiff</code> functions). Once this is proved I'll make a PR.</p>",
        "id": 418229884,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706257261
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10087\">#10087</a> for the above and the application to holomorphic functions.</p>",
        "id": 418543599,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706483213
    },
    {
        "content": "<p>Thanks! Three initial comments:</p>\n<ul>\n<li>\n<p>I think your original formulation using <code>(n !)‚Åª¬π</code> is better because it's the simp normal form due to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=one_div#doc\">docs#one_div</a>; I used <code>1 / n !</code> mainly because I didn't read your goal carefully <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=taylorCoeffWithin#doc\">docs#taylorCoeffWithin</a> also uses <code>(n !)‚Åª¬π</code>, but that file is restricted to the reals, and doesn't state anything about limits or HasSum, only bounds on remainders.</p>\n</li>\n<li>\n<p>There are also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ftaylorSeries#doc\">docs#ftaylorSeries</a> which basically reorders the arguments of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iteratedFDeriv#doc\">docs#iteratedFDeriv</a> without incorporating the <code>(n !)‚Åª¬π</code> factor, and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFTaylorSeriesUpTo#doc\">docs#HasFTaylorSeriesUpTo</a> follows the same vein. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.taylor#doc\">docs#Polynomial.taylor</a> has coefficients given by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Polynomial.hasseDeriv#doc\">docs#Polynomial.hasseDeriv</a>, which has the <code>(k !)‚Åª¬π</code> built into the denominator of <code>n.choose k</code> (you could consider it a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FormalMultilinearSeries.changeOrigin#doc\">docs#FormalMultilinearSeries.changeOrigin</a>).<br>\nAlthough your PR is not about any of these defs with \"taylor\" in the name, I think your choice of using \"taylor\" to name the lemmas is acceptable.</p>\n</li>\n<li>\n<p>I'll still try to refactor your PR through <a href=\"https://github.com/leanprover-community/mathlib4/compare/symmetrize_changeOrigin_eq_iteratedDeriv?expand=1#diff-afc1a6ce1a23be3624955d95e5804e193249ed762e40bc3f4adf5cecc0cb9822R105\">this intermediate result</a>, but that could be a separate PR and could be merged before or after yours.</p>\n</li>\n</ul>",
        "id": 418566337,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706504493
    },
    {
        "content": "<p>Note that we have 2 incompatible types of \"Taylor series\" in Mathlib:</p>\n<ul>\n<li>the series of <code>n</code>-th derivatives, as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=HasFTaylorSeriesUpTo#doc\">docs#HasFTaylorSeriesUpTo</a></li>\n<li>the series that converges to the function, as in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AnalyticAt#doc\">docs#AnalyticAt</a></li>\n</ul>\n<p>Some day, we should separate these 2 notions into 2 separate type synonyms, but for now you have to be careful when you go from one series to another and back again.</p>",
        "id": 418566577,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706504671
    },
    {
        "content": "<p>BTW, I think that the first kind should be refactored into <code>Jet</code> and have <code>‚àÄ i : Fin n, ContinuousMultilinearMap ..</code> instead of <code>‚àÄ i : Nat, _</code> as its data.</p>",
        "id": 418566690,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706504764
    },
    {
        "content": "<p>This way we won't have unused data in the definition of <code>HasFTaylorSeriesUpTo</code></p>",
        "id": 418566715,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706504798
    },
    {
        "content": "<p>I think the docstring \"Formal Taylor series associated to a function within a set.\" of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ftaylorSeries#doc\">docs#ftaylorSeries</a> is not correct, as there is no set involved.</p>\n<p>If <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=taylorCoeffWithin#doc\">docs#taylorCoeffWithin</a> were not restricted to the reals and within a set, it would make sense to use it. But I have no intention in getting lost in rabbit holes fixing this part of Mathlib <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p>I'll change <code>1 / n !</code> to <code>(n !)‚Åª¬π</code> and would appreciate your reviews on the PR.</p>",
        "id": 418625535,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706531158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20Taylor.20series.20of.20an.20entire.20function.20converges.20to.20it/near/418625535\">said</a>:</p>\n<blockquote>\n<p>But I have no intention in getting lost in rabbit holes fixing this part of Mathlib <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n</blockquote>\n<p>(I think <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> has some plans in this direction, however.)</p>",
        "id": 418626419,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706531478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20Taylor.20series.20of.20an.20entire.20function.20converges.20to.20it/near/418566690\">said</a>:</p>\n<blockquote>\n<p>BTW, I think that the first kind should be refactored into <code>Jet</code> and have <code>‚àÄ i : Fin n, ContinuousMultilinearMap ..</code> instead of <code>‚àÄ i : Nat, _</code> as its data.</p>\n</blockquote>\n<p>Using <code>Nat</code> allows to treat smooth functions and finitely differentiable functions together; maybe that's the main reason why it's used.</p>",
        "id": 418676212,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706546116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20Taylor.20series.20of.20an.20entire.20function.20converges.20to.20it/near/418625535\">said</a>:</p>\n<blockquote>\n<p>I think the docstring \"Formal Taylor series associated to a function within a set.\" of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ftaylorSeries#doc\">docs#ftaylorSeries</a> is not correct, as there is no set involved.</p>\n</blockquote>\n<p>I fixed the docstring in the PR.</p>",
        "id": 418699158,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1706554134
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20Taylor.20series.20of.20an.20entire.20function.20converges.20to.20it/near/418676212\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20Taylor.20series.20of.20an.20entire.20function.20converges.20to.20it/near/418566690\">said</a>:</p>\n<blockquote>\n<p>BTW, I think that the first kind should be refactored into <code>Jet</code> and have <code>‚àÄ i : Fin n, ContinuousMultilinearMap ..</code> instead of <code>‚àÄ i : Nat, _</code> as its data.</p>\n</blockquote>\n<p>Using <code>Nat</code> allows to treat smooth functions and finitely differentiable functions together; maybe that's the main reason why it's used.</p>\n</blockquote>\n<p>We can use <code>EFin (n : ENat) := {k : Nat // k &lt; n}</code> as the index type.</p>",
        "id": 418708928,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706557880
    },
    {
        "content": "<p>But I didn't think all the details through, so it's possible that using functions from <code>Nat</code> is easier.</p>",
        "id": 418709066,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706557929
    }
]