[
    {
        "content": "<p>Are lines and points over commutative rings defined in mathlib? I imagine some generalization must be defined, but I couldn't find it.</p>",
        "id": 424482258,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709449866
    },
    {
        "content": "<p>What are lines and points of a commutative ring?</p>",
        "id": 424484608,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709452111
    },
    {
        "content": "<p>Line: a pair of ring elements <code>m, a</code>, with the associated function <code>f(x) = m x + a</code> (and addition, composition, etc.).<br>\nPoint: a pair of ring elements, so I guess this will just be <code>R  × R</code> with <code>Prod.instModule</code>.</p>",
        "id": 424486346,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709453545
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap#doc\">docs#LinearMap</a> close to what you are looking for?</p>",
        "id": 424487581,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709454758
    },
    {
        "content": "<p>Sorry, I meant to link <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineMap#doc\">docs#AffineMap</a>, but then linked the homogeneous one!</p>",
        "id": 424487715,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1709454864
    },
    {
        "content": "<p>This seems to be OK, yes, but does it have a theorem that two different lines intersect in at most one point?</p>",
        "id": 424520844,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709481895
    },
    {
        "content": "<p>Otherwise it might be easier to just define something more specific</p>",
        "id": 424521570,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709482468
    },
    {
        "content": "<p>You mean two different lines intersect at one point? Is that true for a general commutative ring? e.g. in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>8</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb {Z} /8\\mathbb {Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/8</span><span class=\"mord mathbb\">Z</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(x) = 2x + 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>4</mn><mi>x</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">g(x) = 4x + 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> intersect at both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(0) = g(0) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mn>4</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mn>4</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(4) = g(4) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\">4</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span></p>",
        "id": 424521819,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1709482683
    },
    {
        "content": "<p>Oh, right, it's only true over a domain.</p>",
        "id": 424521842,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709482708
    },
    {
        "content": "<p>Actually it appears the lines I need are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a x + b y + c = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. It seems these are just <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Projectivization#doc\">docs#Projectivization</a>. Is there a theorem that there is exactly one line which passes between any two distinct points?</p>",
        "id": 425115564,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709739279
    },
    {
        "content": "<p>Again this is not true in general (and even the definition of two lines being \"the same\" is now subtle). Maybe you should be formalising the statements you want in Lean rather than just saying them in words? Formalisation is exactly what you can use to say what you mean with vague statements like \"exactly one line passes between any two distinct points\".</p>",
        "id": 425133358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709743859
    },
    {
        "content": "<p>Yeah, I tried, but it was quite complicated, so I'm not sure if the approach I'm taking is good — I didn't manage to prove that if two such lines agree on the plane <code>(x : y : 1)</code> then they are equal. I guess I'll try again</p>",
        "id": 425141942,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709746406
    },
    {
        "content": "<blockquote>\n<p>didn't manage to prove</p>\n</blockquote>\n<p>This is step 2! Step 1 is writing the statements, as once you have those other people can help determine if they're correct.</p>",
        "id": 425142805,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709746710
    },
    {
        "content": "<p>Once you post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> with the statements, people here will be nerdsniped into proving them for you.</p>",
        "id": 425145560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709747644
    },
    {
        "content": "<p>On the contrary, I have sufficiently many times in the past responded to someone saying \"help me prove [natural language statement]\" by saying \"sure, here is some code\" and then they've responded with \"oh no I meant something else\" that I instinctively don't attempt to write Lean code answering questions written in natural language any more. So if you don't offer up some Lean code statement then we'll just keep having a natural language back-and-forth and progress will be made far more slowly.</p>",
        "id": 425145811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709747736
    },
    {
        "content": "<p>Ok, thanks! I'm not at home right now, I'll send a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> once I return home</p>",
        "id": 425152783,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709750098
    },
    {
        "content": "<p>This is what I want, I hope it's correct. Also, is there a nicer way to do <code>α × α × α</code>, which lets me do <code>.1, .2, .3</code> instead of <code>.1, .2.1, .2.2</code>? I thought about <code>Vector α 3</code>, but apparently it can't synthesize addition for it. <code>Fin 3 → α</code> would work, but it seems weird.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Classical</span> <span class=\"n\">LinearAlgebra.Projectivization</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Line</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">ℙ</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instSetLike</span> <span class=\"o\">:</span> <span class=\"n\">SetLike</span> <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">l</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"n\">l.submodule</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Equiv.apply_eq_iff_eq</span> <span class=\"o\">(</span><span class=\"n\">Projectivization.equivSubmodule</span> <span class=\"bp\">..</span><span class=\"o\">)]</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x₃</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">line_intersect</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">j</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">point_intersect</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 425225239,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709785526
    },
    {
        "content": "<p>Actually <code>submodule</code> has rank <code>1</code>, I would want the dual (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BilinForm.dualSubmodule#doc\">docs#BilinForm.dualSubmodule</a>, I think). Also, it might be better to look at lines like a set of <code>α × α × α</code>, and define a coercion from <code>α × α</code> to <code>α × α × α</code></p>",
        "id": 425448573,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709874190
    },
    {
        "content": "<p>Then <code>coe_injective'</code> is fairly immediate, for <code>line_intersect</code> I can assume by contradiction the existence of two different points and use <code>point_intersect</code>, and for <code>point_intersect</code> I want to say that two linearly independent points uniquely determine a subspace of rank 2. Is that a theorem anywhere?</p>",
        "id": 425449222,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709874704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lines.20and.20points.20over.20rings/near/425448573\">said</a>:</p>\n<blockquote>\n<p>Actually <code>submodule</code> has rank <code>1</code>, I would want the dual (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BilinForm.dualSubmodule#doc\">docs#BilinForm.dualSubmodule</a>, I think). Also, it might be better to look at lines like a set of <code>α × α × α</code>, and define a coercion from <code>α × α</code> to <code>α × α × α</code></p>\n</blockquote>\n<p>Actually there's no need for this entire thing then, <code>Line</code> can just be a submodule of <code>α × α × α</code> of rank 2.</p>",
        "id": 425451737,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709876683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lines.20and.20points.20over.20rings/near/425449222\">said</a>:</p>\n<blockquote>\n<p>Then <code>coe_injective'</code> is fairly immediate, for <code>line_intersect</code> I can assume by contradiction the existence of two different points and use <code>point_intersect</code>, and for <code>point_intersect</code> I want to say that two linearly independent points uniquely determine a subspace of rank 2. Is that a theorem anywhere?</p>\n</blockquote>\n<p>Found it, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FiniteDimensional.eq_of_le_of_finrank_eq#doc\">docs#FiniteDimensional.eq_of_le_of_finrank_eq</a></p>",
        "id": 425460608,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709881846
    },
    {
        "content": "<p>I managed to prove it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DivisionRing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Line</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Submodule</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">//</span> <span class=\"n\">FiniteDimensional.finrank</span> <span class=\"n\">α</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instSetLike</span> <span class=\"o\">:</span> <span class=\"n\">SetLike</span> <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">coe</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x.val</span>\n  <span class=\"n\">coe_injective'</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Subtype.ext</span>\n    <span class=\"n\">simp_all</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">set_like_val</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">mem2</span> <span class=\"o\">:</span> <span class=\"n\">Membership</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">mem</span> <span class=\"n\">x</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">point_intersect</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">card_eq_one</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{⟨</span><span class=\"n\">i.1</span><span class=\"o\">,</span> <span class=\"n\">i.2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">j.1</span><span class=\"o\">,</span> <span class=\"n\">j.2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩}</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">l'</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">l'</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Cardinal.natCast_inj</span><span class=\"o\">,</span> <span class=\"n\">finrank_eq_rank</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rank_span_set</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">norm_cast</span>\n    <span class=\"n\">apply</span> <span class=\"n\">card_pair</span>\n    <span class=\"n\">aesop</span>\n    <span class=\"n\">apply</span> <span class=\"n\">linearIndependent_pair</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">aesop</span>\n  <span class=\"o\">⟩</span>\n  <span class=\"n\">exists</span> <span class=\"n\">l</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_singleton_iff_unique_mem</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">simp</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">({⟨</span><span class=\"n\">i.1</span><span class=\"o\">,</span> <span class=\"n\">i.2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">j.1</span><span class=\"o\">,</span> <span class=\"n\">j.2</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">⟩}</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">⊆</span> <span class=\"n\">l'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">l'</span><span class=\"o\">]</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Submodule.subset_span</span>\n  <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"o\">{</span>\n  <span class=\"n\">apply</span> <span class=\"n\">set_like_val.mpr</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span>\n  <span class=\"n\">aesop</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l₂</span> <span class=\"n\">h</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">l'</span> <span class=\"bp\">≤</span> <span class=\"n\">l₂.val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">l'</span><span class=\"o\">,</span> <span class=\"n\">Submodule.span_le</span><span class=\"o\">,</span> <span class=\"n\">Set.subset_def</span><span class=\"o\">]</span>\n    <span class=\"n\">constructor</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">aesop</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Eq.symm</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Subtype.ext</span>\n  <span class=\"n\">apply</span> <span class=\"n\">FiniteDimensional.eq_of_le_of_finrank_eq</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l</span>\n  <span class=\"n\">cases</span> <span class=\"n\">l₂</span>\n  <span class=\"n\">simp_all</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">line_intersect</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">j</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">by_contra</span><span class=\"bp\">!</span> <span class=\"n\">nh</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.one_lt_card</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">nh</span>\n  <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">neq</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">nh</span>\n  <span class=\"n\">simp_all</span>\n  <span class=\"k\">let</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">univ.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Line</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">S.card</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">point_intersect</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">neq</span>\n  <span class=\"k\">have</span> <span class=\"n\">m1</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">m2</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_all</span> <span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">one_lt_card.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">m1</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">m2</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n  <span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 425515556,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709903367
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> has marked this topic as resolved.</p>",
        "id": 425515840,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709903458
    },
    {
        "content": "<p>You might also be interested in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineSubspace#doc\">docs#AffineSubspace</a>, which avoids the need to add the extra coordinate</p>",
        "id": 425517657,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709904159
    },
    {
        "content": "<p>I need to do a projective transformation later regardless, so I might as well just define it projectively</p>",
        "id": 425517814,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1709904232
    }
]