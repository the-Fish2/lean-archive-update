[
    {
        "content": "<p>I had to prove something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Subtype.image_preimage_val</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Subtype.image_preimage_val</span><span class=\"o\">,</span>\n    <span class=\"n\">image_subset_image_iff</span> <span class=\"n\">Subtype.val_injective</span><span class=\"o\">]</span>\n  <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">ht</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_preimage</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">closure_subtype</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ht</span>\n  <span class=\"n\">revert</span> <span class=\"n\">ht</span> <span class=\"n\">t</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsClosed.closure_subset</span>\n  <span class=\"c1\">-- goal state: `IsClosed (Subtype.val ⁻¹' s)`</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In informal mathematics, you would just get to this point by saying \"it suffices to show that <code>s ∩ t</code> is closed in the subspace topology of <code>t</code>\". Here, I had to finagle the goal into that form by some incantations that are not very discoverable, with all this subtype stuff that's foreign to people who just want to do some analysis.</p>\n<p>Is this an inevitable consequence of using type theory, or can we come up with a way to improve user experience when doing point set topology? What would it take, a duplicate API for intersecting with subtypes or writing some new tactic? Maybe something easier already exists in Mathlib?</p>",
        "id": 406845793,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1702073257
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.subset_inter_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.inter_subset_right</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">hxst</span><span class=\"o\">,</span> <span class=\"n\">hxt</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsub</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">IsClosed.closure_subset_iff</span> <span class=\"n\">hs</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Set.inter_subset_left</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hsub</span> <span class=\"n\">hxst</span>\n</code></pre></div>\n<p>I don't seem to need to touch subtype stuff during the proof. (I added <code>IsClosed</code> as it seems that I need it for the statement to be true )</p>",
        "id": 406901898,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702106057
    },
    {
        "content": "<p>In my case, <code>s</code> is not actually closed. It's <code>s ∩ t</code> that is closed in the subspace topology of <code>t</code></p>",
        "id": 406920856,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1702118097
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hst</span><span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.subset_inter_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.inter_subset_right</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">hxst</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">Set.inter_subset_left</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n  <span class=\"k\">have</span> <span class=\"n\">hsub</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">IsClosed.closure_subset_iff</span> <span class=\"n\">hst</span><span class=\"o\">)]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">hsub</span> <span class=\"n\">hxst</span><span class=\"o\">)</span>\n  <span class=\"n\">done</span>\n</code></pre></div>\n<p>Do you mean this? Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ? It doesn't seem that <code>IsClosed (s ∩ t)</code> can be deduced from other hypotheses, only that <code>IsClosed (closure (s ∩ t))</code>.</p>",
        "id": 406923968,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702120256
    },
    {
        "content": "<p>I believe he meant <code>IsClosed (Subtype.val ⁻¹' s : Set t)</code></p>",
        "id": 406924261,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1702120503
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">convert</span> <span class=\"n\">Set.image_subset</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">this</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">embedding_subtype_val.closure_eq_preimage_closure_image</span><span class=\"o\">]</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">IsClosed.closure_subset_iff</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 406924839,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1702120949
    },
    {
        "content": "<p>I thought that from the \"suffices\" up there, he doesn't like to see anything Subtype, particularly not in hypotheses.</p>",
        "id": 406925073,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702121138
    },
    {
        "content": "<p>At any rate, the proof needs something to be closed, but it's not given in the intial code.</p>",
        "id": 406925154,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702121198
    },
    {
        "content": "<p>However <code>IsClosed (s ∩ t)</code> is stronger than <code>IsClosed (Subtype.val ⁻¹' s : Set t)</code> and the equivalent without subtypes is probably <code>∃ s', IsClosed s' ∧ s ∩ t = s' ∩ t</code>.</p>",
        "id": 406925200,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1702121241
    },
    {
        "content": "<p>I did find that kind of problem when formalizing my general topology course, so I had to create my own API for that. For convenience, I did create an operation <code>↓∩ </code> to convert a set of the universe, to a set in a subtype by intersecting it, and then prove the lemmas I need for that subspace topology (many of them are marked as simp for convenience).</p>\n<p>It is in Lean3, but porting it to Lean4 should be straightforward. It also uses spanish names... I hope that is not a problem.<br>\nCheck it here:<br>\n<a href=\"https://github.com/miguelmarco/topologia_general_lean/blob/master/subconjuntos.lean\">https://github.com/miguelmarco/topologia_general_lean/blob/master/subconjuntos.lean</a><br>\nand here<br>\n<a href=\"https://github.com/miguelmarco/topologia_general_lean/blob/master/subespacios.lean\">https://github.com/miguelmarco/topologia_general_lean/blob/master/subespacios.lean</a></p>",
        "id": 406925669,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702121629
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"296911\">Utensil Song</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/API.2Ftactic.20for.20subspace.20topology/near/406925073\">said</a>:</p>\n<blockquote>\n<p>I thought that from the \"suffices\" up there, he doesn't like to see anything Subtype, particularly not in hypotheses.</p>\n</blockquote>\n<p>Apologies for being a bit unclear. I want Lean to be able to apply <code>IsClosed.closure_subset</code> nearly directly to a goal <code>closure (s ∩ t) ∩ t ⊆ s ∩ t</code> to turn it into <code>IsClosed (Subtype.val ⁻¹' s)</code>, by specifying that we are working in the subspace topology of <code>t</code>.</p>",
        "id": 406968774,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1702153578
    },
    {
        "content": "<p>If I hadn't learnt much type theory, I would not have thought that <code>Subtype.val</code> has anything to do with the original goal at hand, and would have overlooked all the <code>Subtype</code> lemmas. Being able to transform the goal from <code>... ∩ t</code> to the corresponding statement explicitly mentioning <code>Subtype.val</code> cues the user to now look for and apply <code>Subtype.val</code> lemmas.</p>",
        "id": 406968909,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1702153734
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461731\">@Miguel Marco</span> Thanks for sharing! This seems like the sort of thing that would've been useful to me! Do people think Mathlib could use something like this?</p>",
        "id": 406971512,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1702156356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416472\">Winston Yin (尹維晨)</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/API.2Ftactic.20for.20subspace.20topology/near/406971512\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"461731\">Miguel Marco</span> Thanks for sharing! This seems like the sort of thing that would've been useful to me! Do people think Mathlib could use something like this?</p>\n</blockquote>\n<p>I coinsidered trying to add it,but wasn't sure it would be a good fit. Subspace topology is treated in Mathlib as a particular case of inverse image topology, so there is no real need for that. But maybe other parts of Mathlib could find this kind of API useful. <span aria-label=\"man shrugging\" class=\"emoji emoji-1f937-200d-2642\" role=\"img\" title=\"man shrugging\">:man_shrugging:</span></p>",
        "id": 406976592,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702159064
    },
    {
        "content": "<p>I do think such a definition would be useful. We also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.subgroupOf#doc\">docs#Subgroup.subgroupOf</a> for example.</p>",
        "id": 406978514,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1702160015
    },
    {
        "content": "<p>I’d wager that <code>Subtype.val</code> is a pretty good special case of a continuous function, especially when I don’t think about it when dealing with topology within subsets.</p>",
        "id": 406990886,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1702170235
    },
    {
        "content": "<p><code>Subtype.val</code> should be considered an implementation detail during constructing a mathematical construct. All later interactions with the mathematical construct should be via API lemmas that make sense in math too. This doesn't just happen to <code>Subtype</code> or dependent type theory based ITPs, it also happens in Math, e.g. Clifford Algebra can be constructed by a quotient of Tensor Algebra, so in Lean it could be chosen for the definition, but we throw that detail away once its universal properties are defined, and use only those lemmas afterward, as much as possible.</p>",
        "id": 407018337,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702190404
    },
    {
        "content": "<p>The concept of lemma APIs are also discussed and explained <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20ProbabilitySpace.20class.3F/near/401645438\">here</a> recently.</p>",
        "id": 407018410,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702190507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/API.2Ftactic.20for.20subspace.20topology/near/406978514\">said</a>:</p>\n<blockquote>\n<p>I do think such a definition would be useful. We also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.subgroupOf#doc\">docs#Subgroup.subgroupOf</a> for example.</p>\n</blockquote>\n<p>What would be the right place for it?</p>",
        "id": 407025356,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702195942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461731\">Miguel Marco</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/API.2Ftactic.20for.20subspace.20topology/near/406976592\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"416472\">Winston Yin (尹維晨)</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/API.2Ftactic.20for.20subspace.20topology/near/406971512\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"461731\">Miguel Marco</span> Thanks for sharing! This seems like the sort of thing that would've been useful to me! Do people think Mathlib could use something like this?</p>\n</blockquote>\n<p>I coinsidered trying to add it,but wasn't sure it would be a good fit. Subspace topology is treated in Mathlib as a particular case of inverse image topology, so there is no real need for that. But maybe other parts of Mathlib could find this kind of API useful. <span aria-label=\"man shrugging\" class=\"emoji emoji-1f937-200d-2642\" role=\"img\" title=\"man shrugging\">:man_shrugging:</span></p>\n</blockquote>\n<p>Where is inverse image topology in Mathlib?  Can <code>(hs : IsClosed (Subtype.val ⁻¹' s : Set t)</code> be encoding by it and use lemmas there for this proof? With your code it can be encoded as <code>(hs : IsClosed (restringe t s))</code> and use your lemmas (it seems to need a little more for the closure).</p>",
        "id": 407032580,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702200937
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.induced#doc\">docs#TopologicalSpace.induced</a></p>",
        "id": 407074762,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702219237
    },
    {
        "content": "<p>The topology on a set (viewed as a type), is the topology induced by <code>Subtype.val</code>.</p>",
        "id": 407074914,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1702219346
    },
    {
        "content": "<p>Searching on moogle using \"​preimage topology\" didn't give me  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.induced#doc\">docs#TopologicalSpace.induced</a> on the first page <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> but it's in the doc string.</p>",
        "id": 407075566,
        "sender_full_name": "Utensil Song",
        "timestamp": 1702219842
    },
    {
        "content": "<p>I only proved the API lemmas I needed for the theorems we prove in my course, so my API is not as complete as it could be.<br>\nShouldn't be hard to extend it though.</p>",
        "id": 407096497,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1702234708
    },
    {
        "content": "<p>Linking <a href=\"https://github.com/leanprover-community/mathlib4/pull/9940\">#9940</a> here.</p>",
        "id": 418181572,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706225532
    },
    {
        "content": "<p>I'm very late to the party, but I just wanted to mention that I would be sad if we ended up writing too much specialized theorems about the subspace topology specifically on a <code>Subtype</code>. It takes a while getting used to, but stating theorems in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Embedding#doc\">docs#Embedding</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Inducing#doc\">docs#Inducing</a> instead of subtypes is one of the reasons the general topology library works so well.</p>",
        "id": 419131156,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706738599
    },
    {
        "content": "<p>That raises a good point. Do you see a way to restate <a href=\"https://github.com/leanprover-community/mathlib4/pull/9940\">#9940</a> in terms of <code>Inducing</code>? I do think the special notation for subtype topology is valuable.</p>",
        "id": 419131533,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706738740
    },
    {
        "content": "<p>I don't think anything from 9940 is useful in that general case</p>",
        "id": 419131718,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706738803
    },
    {
        "content": "<p>Because in the general case I believe we're talking about preimages by an arbitrary function, rather than by <code>Subtype.val</code></p>",
        "id": 419131821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706738851
    },
    {
        "content": "<p>To be clear, I'm not against all of <a href=\"https://github.com/leanprover-community/mathlib4/pull/9940\">#9940</a>. I think I'd be happy for getting the notation (writing preimages is a bit annoying sometimes). I haven't made up my mind about everything, I just wanted to mention my thoughts somewhere</p>",
        "id": 419131879,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706738877
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9940\">#9940</a> is unfortunate that it seems to both tread in the delicate area of API design, and that the original (but presumably not only) motivation for it seems to be an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem.</p>",
        "id": 419132142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706738963
    },
    {
        "content": "<p>What would be a solution to the problem at the start of this thread?</p>",
        "id": 419132293,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706739016
    },
    {
        "content": "<p>Do you mean a proof for the <code>example</code>? Presumably you're after something shorter than what Utensil already provided?</p>",
        "id": 419132871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706739274
    },
    {
        "content": "<p>Utensil's solution uses <code>IsClosed s</code> in the ambient topology, but that is not true in my case.</p>",
        "id": 419133024,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706739354
    },
    {
        "content": "<p>For reference, here is how I would have done it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Subtype.image_preimage_val</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"n\">embedding_subtype_val.closure_eq_preimage_closure_image</span><span class=\"o\">,</span> <span class=\"n\">hs.closure_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>It's very similar to Andrew's version, but I'm making explicit the key lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype.image_preimage_val#doc\">docs#Subtype.image_preimage_val</a>. Again, there are definitely documentation issues here, but this (and the more general <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.image_preimage_inter#doc\">docs#Set.image_preimage_inter</a>) are typically the lemmas to use when pulling and pushing sets (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.push_pull#doc\">docs#Filter.push_pull</a> makes that even more explicit).</p>\n<p>And then of course, there's the <code>embedding_subtype_val</code> part, which is exactly the property that you'd think of in the case of subspace topology</p>",
        "id": 419133122,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706739378
    },
    {
        "content": "<p>Oh that is much nicer</p>",
        "id": 419133162,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706739401
    },
    {
        "content": "<p>Of course I'm subject to the usual \"I had to fight these issues for a while so now I've internalized how to do it\" bias, so I really don't mean to say \"the actual situation is perfect, don't touch it\". Besides, we already have duplicates of a bunch of lemmas specific to the subtype case, and these would certainly benefit from better notation. I just wanted to make the point that it's more of a UX discussion than a mathematical one.</p>",
        "id": 419135220,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706740277
    },
    {
        "content": "<p>I'm incorporating your solution, Anatole, and it's great. However, this is still not very user-friendly given how basic subspace topology is.</p>",
        "id": 419135353,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706740331
    },
    {
        "content": "<p>I agree that it's more of a UX question.</p>",
        "id": 419135472,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706740389
    },
    {
        "content": "<p>Is your example deliberately stated as a subset inclusion when it appears to be true as an equality?</p>",
        "id": 419135838,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706740555
    },
    {
        "content": "<p>Yes. I applied another lemma that produced subset inclusion as a goal.</p>",
        "id": 419135958,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706740603
    },
    {
        "content": "<p>For what is worth, my original motivation for writing this API was totally UX-related: I wanted something that could allow my students to deal with subspace topology in a less intimidating form.</p>",
        "id": 419139532,
        "sender_full_name": "Miguel Marco",
        "timestamp": 1706742198
    },
    {
        "content": "<p>I get that the general advice is to avoid subtypes and especially subtypes of subtypes whenever possible, so all this <code>Subtype.val</code> showing up may be a feature rather than a bug, hinting that the user is using the wrong approach. But for subspace topology nested subtypes are unavoidable, and we should have good API / notation for it, along the lines of Miguel's PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/9940\">#9940</a>.</p>",
        "id": 419145827,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1706745395
    },
    {
        "content": "<p>I don't think that <code>Subtype.val</code> showing up is indicative of a bad approach; rather that if you can replace it with a general <code>f</code> that's an embedding, things become simpler</p>",
        "id": 419189494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706773662
    },
    {
        "content": "<p>Oh yes <code>Subtype.val</code> is definitely not a code smell. I was basically pushing foir the opposite: when dealing with subtypes, use <code>Subtype.val</code>as much as you want, because then it's easier to see that you could replace it by any map <code>f</code> with similar properties! (In this case, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Embedding#doc\">docs#Embedding</a>, but it could also be \"injective group morphism\", <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Isometry#doc\">docs#Isometry</a>, or whatever properties \"inclusion\" has in the category you're working with).</p>",
        "id": 419205423,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706779660
    }
]