[
    {
        "content": "<p>Does mathlib have this statement of Arzela-Ascoli for uniform spaces?<br>\n<a href=\"https://en.wikipedia.org/wiki/Arzel%C3%A0%E2%80%93Ascoli_theorem#Functions_on_non-compact_spaces\">https://en.wikipedia.org/wiki/Arzel%C3%A0%E2%80%93Ascoli_theorem#Functions_on_non-compact_spaces</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">arzeli_ascoli</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsCompact</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(perhaps with extra hypotheses)</p>",
        "id": 386170745,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692496116
    },
    {
        "content": "<p>Here is some code that <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> wrote, initially for lean3 but that I adapted for lean4. AFAIK this is not yet in Mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2022 Anatole Dedecker. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Anatole Dedecker</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UniformSpace.Equicontinuity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Uniformity</span> <span class=\"n\">Function</span> <span class=\"n\">UniformConvergence</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">supr_sUnion</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">‚®Ü</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">‚®Ü</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_eq_iUnion</span><span class=\"o\">,</span> <span class=\"n\">iSup_iUnion</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">iSup_subtype''</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">infi_sUnion</span> <span class=\"o\">[</span><span class=\"n\">CompleteLattice</span> <span class=\"n\">Œ≤</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">‚®Ö</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sUnion_eq_iUnion</span><span class=\"o\">,</span> <span class=\"n\">iInf_iUnion</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">iInf_subtype''</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">forall_sUnion</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">iInf_Prop_eq</span><span class=\"o\">,</span> <span class=\"n\">infi_sUnion</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_of_ne_bot</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Cauchy</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"n\">l</span> <span class=\"bp\">√óÀ¢</span> <span class=\"n\">l</span> <span class=\"bp\">‚â§</span> <span class=\"bp\">ùì§</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Cauchy</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_pi</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Œ±</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cauchy</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Function.eval</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">cauchy_of_ne_bot</span><span class=\"o\">,</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformity</span><span class=\"o\">,</span> <span class=\"n\">le_iInf_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_infi</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n    <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">NeBot</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Cauchy</span><span class=\"o\">,</span> <span class=\"n\">iInf_uniformity</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cauchy_map_iff_comap</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">UniformSpace</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ≤</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">‚Üî</span> <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">UniformSpace.comap</span> <span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Cauchy</span><span class=\"o\">,</span> <span class=\"n\">map_neBot_iff</span><span class=\"o\">,</span> <span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">,</span> <span class=\"n\">uniformity_comap</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"n\">Equicontinuous</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">UniformFun.uniformSpace</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">UniformSpace.comap_mono</span> <span class=\"o\">(</span><span class=\"n\">le_iff_uniformContinuous_id.mpr</span> <span class=\"n\">UniformFun.uniformContinuous_toFun</span><span class=\"o\">))</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">change</span> <span class=\"n\">comap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">‚â§</span> <span class=\"n\">comap</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformity</span><span class=\"o\">,</span> <span class=\"n\">Filter.comap_iInf</span><span class=\"o\">,</span> <span class=\"n\">Filter.comap_comap</span><span class=\"o\">,</span> <span class=\"n\">Function.comp</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">UniformFun.hasBasis_uniformity</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">Prod.map</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ge_iff.mpr</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">intro</span> <span class=\"n\">U</span> <span class=\"n\">hU</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">comp_comp_symm_mem_uniformity_sets</span> <span class=\"n\">hU</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">Vsymm</span><span class=\"o\">,</span> <span class=\"n\">hVU</span><span class=\"o\">‚ü©</span>\n  <span class=\"k\">let</span> <span class=\"bp\">Œ©</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">|</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">CompactSpace.elim_nhds_subcover</span> <span class=\"bp\">Œ©</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hF</span> <span class=\"n\">x</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">Scover</span><span class=\"o\">‚ü©</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">‚ãÇ</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">ij</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">√ó</span> <span class=\"n\">Œπ</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">ij.1</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">ij.2</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">‚àà</span> <span class=\"n\">V</span><span class=\"o\">})</span> <span class=\"bp\">‚äÜ</span> <span class=\"o\">(</span><span class=\"n\">Prod.map</span> <span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">‚Åª¬π'</span> <span class=\"n\">UniformFun.gen</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">‚ü®</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">‚ü©</span> <span class=\"n\">hij</span> <span class=\"n\">x</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_iInter‚ÇÇ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hij</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">mem_iUnion‚ÇÇ.mp</span> <span class=\"o\">(</span><span class=\"n\">Scover.symm.subset</span> <span class=\"bp\">$</span> <span class=\"n\">mem_univ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hsx</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hVU</span> <span class=\"o\">(</span><span class=\"n\">prod_mk_mem_compRel</span> <span class=\"o\">(</span><span class=\"n\">prod_mk_mem_compRel</span> <span class=\"o\">(</span><span class=\"n\">Vsymm.mk_mem_comm.mp</span> <span class=\"o\">(</span><span class=\"n\">hsx</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hij</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hsx</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_of_superset</span> <span class=\"o\">(</span><span class=\"n\">S.iInter_mem_sets.mpr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mem_iInf_of_mem</span> <span class=\"n\">x</span> <span class=\"bp\">$</span> <span class=\"n\">preimage_mem_comap</span> <span class=\"n\">hV</span><span class=\"o\">)</span> <span class=\"n\">this</span>\n\n<span class=\"c1\">-- TODO: this is too long</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1'</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"n\">K.restrict</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">UniformOnFun.uniformSpace</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"bp\">ùîñ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"bp\">‚®Ö</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">‚Äπ</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">‚Ä∫</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">UniformOnFun.uniformSpace</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace.comap_iInf</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">UniformSpace.comap_comap</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">iInf_congr</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">K</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iInf_congr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">hK</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"n\">isCompact_iff_compactSpace.mp</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">)</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"n\">K</span> <span class=\"n\">hK</span><span class=\"o\">),</span> <span class=\"n\">UniformSpace.comap_comap</span><span class=\"o\">,</span>\n            <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace.ofCoreEq_toCore</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace.comap_iInf</span><span class=\"o\">,</span> <span class=\"n\">iInf_subtype</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"n\">iInf_congr</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">iInf_congr</span> <span class=\"bp\">$</span> <span class=\"bp\">Œª</span> <span class=\"n\">hx</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">UniformSpace.comap_comap</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">theorem1''</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hcover</span> <span class=\"o\">:</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hF</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"n\">K.restrict</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">UniformOnFun.uniformSpace</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"bp\">ùîñ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">theorem1'</span> <span class=\"n\">h</span><span class=\"bp\">ùîñ</span> <span class=\"n\">hF</span><span class=\"o\">,</span> <span class=\"k\">Pi</span><span class=\"bp\">.</span><span class=\"n\">uniformSpace</span><span class=\"o\">,</span> <span class=\"n\">UniformSpace.ofCoreEq_toCore</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span><span class=\"n\">infi_sUnion</span><span class=\"o\">,</span> <span class=\"n\">hcover</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ascoli‚ÇÄ</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œπ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NeBot</span> <span class=\"n\">l</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Cauchy</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">Cauchy</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">‚®Ö</span> <span class=\"n\">K</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"bp\">‚®Ö</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">‚Äπ</span><span class=\"n\">UniformSpace</span> <span class=\"n\">_</span><span class=\"o\">‚Ä∫</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">F</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">cauchy_infi</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">cauchy_map_iff_comap</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">forall_sUnion</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h3</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">e1</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"n\">e3</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prod_map_map_eq</span><span class=\"o\">,</span> <span class=\"n\">map_le_iff_le_comap</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e3</span> <span class=\"bp\">‚ä¢</span>\n  <span class=\"n\">exact</span> <span class=\"n\">e3.trans</span> <span class=\"o\">(</span><span class=\"n\">theorem1'</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ge</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ascoli</span> <span class=\"o\">{</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"bp\">ùîñ</span><span class=\"o\">]</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">A</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Set.restrict</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">‚ãÉ‚ÇÄ</span> <span class=\"bp\">ùîñ</span><span class=\"o\">,</span> <span class=\"n\">TotallyBounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">F</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n    <span class=\"n\">TotallyBounded</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">totallyBounded_iff_ultrafilter</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h3</span> <span class=\"bp\">‚ä¢</span>\n  <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">''</span> <span class=\"n\">univ</span> <span class=\"bp\">‚àà</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">image_univ</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">Ultrafilter.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">le_principal_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">Ultrafilter.ofComapInfPrincipal_eq_of_map</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">Ultrafilter.ofComapInfPrincipal</span> <span class=\"n\">this</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ascoli‚ÇÄ</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h3</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"n\">g.map</span> <span class=\"o\">(</span><span class=\"n\">eval</span> <span class=\"n\">x</span> <span class=\"bp\">‚àò</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_principal_iff.mpr</span> <span class=\"n\">range_mem_map</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 386204482,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1692524113
    },
    {
        "content": "<p>Indeed this is not in mathlib yet. The reason is that, although total boundedness is fairly self contained, proving the completeness part to get compactness was easier with some tweaks to the API that I didn‚Äôt want to do while the port was going on. I tried an ad-hoc version but ended up never PR-ing it.</p>",
        "id": 386211439,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692529735
    },
    {
        "content": "<p>But I definitely want to go back to this now that the port is over. Does any of you two need the result in mathlib soon‚Ñ¢Ô∏è ?</p>",
        "id": 386211688,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692529831
    },
    {
        "content": "<p>Thanks for porting to Lean4 btw!</p>",
        "id": 386211781,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692529910
    },
    {
        "content": "<p>I would be more interested in a port of <a href=\"https://github.com/leanprover-community/mathlib/pull/18017\">!3#18017</a></p>",
        "id": 386212618,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1692530389
    },
    {
        "content": "<p>Okay, will work on that!</p>",
        "id": 386212886,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692530521
    },
    {
        "content": "<p>But it is not urgent at all</p>",
        "id": 386213171,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1692530755
    },
    {
        "content": "<p>I hacked together a proof of what I needed at <a href=\"https://github.com/leanprover-community/mathlib4/tree/tb_pontryagin_dual\">branch#tb_pontryagin_dual</a>. I'll PR it eventually, since I need it for local compactness of the Pontryagin dual. But I don't really understand this subject well. <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> Are there are any major strategy changes that you would suggest in the proof I wrote?</p>",
        "id": 386239908,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692548801
    },
    {
        "content": "<p>Well my advice would have been to use my code above, now I feel very bad for not PR-ing it (although in my defense there is a WIP mathlib3 PR on that). I still think that it would be nicer to wait a bit for my version, how quick do you need it?</p>",
        "id": 386241818,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692550451
    },
    {
        "content": "<p>Now that I'm diving back into this I have the feeling that I missed a big shortcut by relying too much on Bourbaki: the <code>theorem1'</code> in my code above should allow to get directly the compactness result without going through total boundedness and completeness, simply by reducing it to Tychonoff's theorem like Thomas does in his proof. Of course we'll want the completeness results anyways, so maybe the shortcut doesn't actually bring anything, but it still means that I could have provided a stronger statement to Vinvent to begin with...</p>",
        "id": 386247440,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692555514
    },
    {
        "content": "<p>Is compactness done (e.g., as stated in my branch)? Not sure whether it's an easy consequence of totally bounded, or requires some additional work.</p>",
        "id": 386261693,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692567493
    },
    {
        "content": "<p>The way Bourbaki does it is by combining total boundedness and completeness, but as I said there is a shortcut which allows to get compactness directly. They probably don't use it because, well, they have to prove the completeness anyway (and we'll have to do it), but this shortcut means that I should have a ready-for-review PR with almost exactly your statement in a few days (or at least a general statement that easily applies in your case)</p>",
        "id": 386261814,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692567630
    },
    {
        "content": "<p>If we had to go through completeness it would take more time because that involves a slight refactor of the <code>UniformOnFun</code> file</p>",
        "id": 386261840,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692567672
    },
    {
        "content": "<p>The idea is to use my <code>theorem1'</code> instead of your <code>suffices</code></p>",
        "id": 386261906,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692567733
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/6693\">#6693</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/6694\">#6694</a> are the two first prerequisite PRs, maybe there will be a third but probably not more</p>",
        "id": 386262473,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1692568325
    },
    {
        "content": "<p>Oh great, thanks!</p>",
        "id": 386262758,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1692568607
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 386263395,
        "sender_full_name": "Dean Young",
        "timestamp": 1692569334
    },
    {
        "content": "<p>It took more time than expected (of course...), but I think I've now got <a href=\"https://github.com/leanprover-community/mathlib4/pull/6844\">#6844</a> to a pretty good situation. There is still a bit of glue to get to Thomas' precise statement, but it's just a matter of reformulating the content of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/UniformSpace/CompactConvergence.html\">Topology.UniformSpace.CompactConvergence</a> in terms of the newer <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun#doc\">docs#UniformOnFun</a> (we should actually rewrite this file, but maybe that's less urgent). <span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span> <span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> could you check if the results seem usable enough?<br>\nI don't know how much time I will have to take care of this in the near future, so if you want to add some documentation, a module docstring, or simplify some proofs, please have a go!</p>",
        "id": 389292862,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1693952156
    },
    {
        "content": "<p>Thanks for your help! I'll take a closer look over this next week when I have time.</p>",
        "id": 389303345,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1693958156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> I was wondering how you were planning on getting from your PR to my statement? The issue that I'm having is deducing the inducing assumption present in your formulations from an equicontinuity assumption. I have a painful proof here: <a href=\"https://github.com/leanprover-community/mathlib4/compare/AD_ascoli_part1...tb_ascoli\">https://github.com/leanprover-community/mathlib4/compare/AD_ascoli_part1...tb_ascoli</a>, but I suspect there might be a way to use your work to streamline this a bit?</p>",
        "id": 402800526,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1700265978
    },
    {
        "content": "<p>Sorry for the (very) late answer. I think the reason this is painful is that you shouldn't be using <code>ùîñ = Set.range Set.singleton</code> (in this case Ascoli theorem is basically useless, you're just using Tychonoff), but rather <code>ùîñ = {K | IsCompact K}</code>. Then the only thing you have to know is that the natural map from <code>C(X, Y)</code> to <code>X ‚Üí·µ§[ùîñ] Y</code> is an inducing, which is essentially <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap.compactOpen_eq_compactConvergence#doc\">docs#ContinuousMap.compactOpen_eq_compactConvergence</a>. At some point we should refactor this whole file to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun#doc\">docs#UniformOnFun</a> by the way, but for now it should be easy to get the statement from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn#doc\">docs#ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun.tendsto_iff_tendstoUniformlyOn#doc\">docs#UniformOnFun.tendsto_iff_tendstoUniformlyOn</a></p>",
        "id": 409829673,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703438327
    },
    {
        "content": "<p>As I said elsewhere, I will have some Lean time during the holiday, and I want to make sure that Ascoli is ready by then so that you don't have to wait for me indefinitely</p>",
        "id": 409829702,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703438383
    },
    {
        "content": "<p>I'll try to refactor that file now.</p>",
        "id": 409832524,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703441345
    },
    {
        "content": "<p>First dependencies: <a href=\"https://github.com/leanprover-community/mathlib4/pull/9257\">#9257</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/9259\">#9259</a></p>",
        "id": 409836333,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703445667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Arzela-Ascoli.20for.20uniform.20spaces/near/409829673\">said</a>:</p>\n<blockquote>\n<p>I think the reason this is painful is that you shouldn't be using <code>ùîñ = Set.range Set.singleton</code> (in this case Ascoli theorem is basically useless, you're just using Tychonoff), but rather <code>ùîñ = {K | IsCompact K}</code>.</p>\n</blockquote>\n<p>Thanks, that did the trick!</p>",
        "id": 410376980,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1703817000
    },
    {
        "content": "<p>This is finally ready for review as <a href=\"https://github.com/leanprover-community/mathlib4/pull/6844\">#6844</a>. Thomas and Vincent, I'm really sorry that you had to wait for so long and suffer from my inability for finish things properly. I think Yury is almost done PR-ing the necessary glue to make that work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap#doc\">docs#ContinuousMap</a> (essentially a <code>ClosedEmbedding</code> statement, we have the embedding part as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap.uniformEmbedding_toUniformOnFunIsCompact#doc\">docs#ContinuousMap.uniformEmbedding_toUniformOnFunIsCompact</a>, and the core of the closed part as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun.isClosed_setOf_continuous_of_le#doc\">docs#UniformOnFun.isClosed_setOf_continuous_of_le</a>), so everything should be ready very soon. Sorry again for the delay.</p>",
        "id": 425788700,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710090748
    },
    {
        "content": "<p>(I'll admit it, this afternoon's thread about general Fourier theory gave me the final bit of motivation needed to write the module docstring, since I remember you needed that to study the Pontryagin dual)</p>",
        "id": 425788897,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710090910
    },
    {
        "content": "<p>Speaking for myself, I didn't really suffer that much!</p>",
        "id": 425789152,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710091174
    },
    {
        "content": "<p>Hey, how far are the results in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6844\">#6844</a> from the statement that Thomas wrote in the beginning of this discussion?</p>",
        "id": 426661773,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1710468757
    },
    {
        "content": "<p>Not far. Here's some glue I wrote a while ago: <a href=\"https://github.com/leanprover-community/mathlib4/compare/AD_ascoli_part1...tb_ascoli\">https://github.com/leanprover-community/mathlib4/compare/AD_ascoli_part1...tb_ascoli</a></p>",
        "id": 426662163,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1710468995
    },
    {
        "content": "<p>Cool, thanks. However there is still a compactness assumption that is not in the linked wikipedia article.</p>",
        "id": 426669965,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1710475102
    },
    {
        "content": "<p>Yes, I'm looking into that. I have a proof without the compactness assumption at <a href=\"https://github.com/leanprover-community/mathlib4/pull/11335\">#11335</a>, but I'm still figuring out how to deduce it from <a href=\"https://github.com/leanprover-community/mathlib4/pull/6844\">#6844</a></p>",
        "id": 426674117,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1710478186
    },
    {
        "content": "<p>I've dropped the compact assumption, but there's still an unnecessary separation assumption</p>",
        "id": 426678702,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1710482112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> The extra assumptions should all be gone now.</p>",
        "id": 426682280,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1710484753
    },
    {
        "content": "<p>I realize that the statements I wrote are a bit hard to decipher, but part of the reason is precisely that I had in mind that no one uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniformOnFun#doc\">docs#UniformOnFun</a> directly, so everything is stated with embeddings and so on. That said, I realize maybe I didn't make the best choices, e.g the Thomas' statement in <a href=\"https://github.com/leanprover-community/mathlib4/tree/tb_ascoli\">branch#tb_ascoli</a> doesn't follow from any of my versions because I assume things of the form \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚àÄ</mi><mi>x</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">{</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">‚à£</mi><mi>f</mi><mo>‚àà</mo><mi>F</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\forall x, \\{f(x) | f\\in F\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚àÄ</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">‚àà</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mclose\">}</span></span></span></span> is compact\" rather than directly assuming compactness of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> for the product topology, and thus I need some closedness or separation hypothesis to apply Tykhonov. Do you think such a version should be added? I'm completely open to suggestions here!</p>",
        "id": 426782115,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710520888
    },
    {
        "content": "<p>It's not too bad. I've hacked together a version that I am using for the Schwartz space (with unoptimized proof):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Œπ</span> <span class=\"n\">X</span> <span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">WeaklyLocallyCompactSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">arzela_ascoli'</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Œπ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">Œ±</span><span class=\"o\">)}</span>\n    <span class=\"o\">(</span><span class=\"n\">s_eqcont</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_hK</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">EquicontinuousOn</span> <span class=\"o\">(((</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">))</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">s_pointwiseCompact</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">),</span>\n      <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">Q</span> <span class=\"bp\">‚àß</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">f</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ArzelaAscoli.isCompact_closure_of_closedEmbedding</span> <span class=\"o\">(</span><span class=\"bp\">ùîñ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">s_eqcont</span> <span class=\"n\">s_pointwiseCompact</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">closedEmbedding_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">exact</span> <span class=\"n\">ContinuousMap.uniformEmbedding_toUniformOnFunIsCompact.embedding</span>\n  <span class=\"bp\">¬∑</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isClosed_iff_forall_filter</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">hu</span> <span class=\"n\">huf</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">Filter.tendsto_id'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">huf</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">UniformOnFun.tendsto_iff_tendstoUniformlyOn</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">huf</span>\n    <span class=\"n\">refine</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">‚ü©,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">continuous_iff_continuousAt</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">WeaklyLocallyCompactSpace.exists_compact_mem_nhds</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">hK1</span><span class=\"o\">,</span> <span class=\"n\">hK2</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">huf</span> <span class=\"n\">K</span> <span class=\"n\">hK1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuousOn</span> <span class=\"o\">(</span><span class=\"n\">Filter.le_principal_iff.mp</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">continuousAt</span> <span class=\"n\">hK2</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hu.trans</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">,</span> <span class=\"n\">Filter.le_principal_iff</span><span class=\"o\">,</span> <span class=\"n\">Filter.mem_principal</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">y</span> <span class=\"o\">‚ü®</span><span class=\"n\">y0</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">‚ü©</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Continuous.continuousOn</span>\n    <span class=\"n\">convert</span> <span class=\"n\">y0.continuous</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">hy</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">UniformOnFun.toFun_ofFun</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426783287,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1710521245
    },
    {
        "content": "<p>This is more the kind of version I was expecting. The closed part will be in Mathlib soon, Yury is working on it, so you'll be able to remove the last dot.</p>",
        "id": 426783610,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710521358
    },
    {
        "content": "<p>That said I've just realized there is a small catch. The fact that <code>C(X, Y)</code> has closed range in <code>X ‚Üí·µ§[ùîñ] Œ±</code> does require some form of local compactness (actually compact generation), but this is not the case for equicontinuous subsets since there even a pointwise limit of continuous functions is continuous. So we should add something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">ContinuousMap</span> <span class=\"k\">in</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Equicontinuous.closedEmbedding_toUniformOnFunIsCompact</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">Œ≤</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hœÜ‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">((</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span> <span class=\"bp\">‚àò</span> <span class=\"n\">œÜ</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">hœÜ‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">ClosedEmbedding</span> <span class=\"n\">œÜ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">ClosedEmbedding</span> <span class=\"o\">(</span><span class=\"n\">toUniformOnFunIsCompact</span> <span class=\"bp\">‚àò</span> <span class=\"n\">œÜ</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">}]</span> <span class=\"n\">Œ≤</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toEmbedding</span> <span class=\"o\">:=</span> <span class=\"n\">uniformEmbedding_toUniformOnFunIsCompact.embedding.comp</span> <span class=\"n\">hœÜ‚ÇÇ.toEmbedding</span>\n  <span class=\"n\">closed_range</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isClosed_iff_forall_filter</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">‚Ñ±</span> <span class=\"n\">h‚Ñ±</span> <span class=\"n\">h‚Ñ±œÜ</span> <span class=\"n\">h‚Ñ±f</span>\n    <span class=\"n\">set</span> <span class=\"bp\">ùí¢</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">toUniformOnFunIsCompact</span> <span class=\"bp\">‚àò</span> <span class=\"n\">œÜ</span><span class=\"o\">)</span> <span class=\"n\">‚Ñ±</span>\n    <span class=\"k\">have</span> <span class=\"n\">h‚Ñ±</span><span class=\"bp\">ùí¢</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">toUniformOnFunIsCompact</span> <span class=\"bp\">‚àò</span> <span class=\"n\">œÜ</span><span class=\"o\">)</span> <span class=\"bp\">ùí¢</span> <span class=\"bp\">=</span> <span class=\"n\">‚Ñ±</span> <span class=\"o\">:=</span>\n      <span class=\"n\">map_comap_of_mem</span> <span class=\"o\">(</span><span class=\"n\">h‚Ñ±œÜ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">mem_principal_self</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">NeBot</span> <span class=\"bp\">ùí¢</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">h‚Ñ±</span><span class=\"bp\">ùí¢</span><span class=\"o\">,</span> <span class=\"n\">map_neBot_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h‚Ñ±</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span><span class=\"bp\">ùí¢</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Tendsto</span> <span class=\"o\">(</span><span class=\"n\">toUniformOnFunIsCompact</span> <span class=\"bp\">‚àò</span> <span class=\"n\">œÜ</span><span class=\"o\">)</span> <span class=\"bp\">ùí¢</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">h‚Ñ±</span><span class=\"bp\">ùí¢</span><span class=\"o\">,</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">Tendsto</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h‚Ñ±f</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Tendsto</span> <span class=\"o\">((</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span> <span class=\"bp\">‚àò</span> <span class=\"n\">œÜ</span><span class=\"o\">)</span> <span class=\"bp\">ùí¢</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">UniformOnFun.toFun</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">refine</span> <span class=\"n\">UniformOnFun.uniformContinuous_toFun</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">continuous.tendsto</span> <span class=\"n\">_</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">comp</span> <span class=\"n\">h</span><span class=\"bp\">ùí¢</span><span class=\"n\">f</span>\n      <span class=\"n\">exact</span> <span class=\"n\">sUnion_eq_univ_iff.mpr</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"n\">isCompact_singleton</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Continuous</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">this.continuous_of_equicontinuous</span> <span class=\"n\">hœÜ‚ÇÅ</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">‚ü®</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">‚ü©</span> <span class=\"bp\">‚àà</span> <span class=\"n\">range</span> <span class=\"n\">œÜ</span> <span class=\"o\">:=</span> <span class=\"n\">hœÜ‚ÇÇ.closed_range.mem_of_tendsto</span>\n      <span class=\"o\">(</span><span class=\"n\">uniformEmbedding_toUniformOnFunIsCompact.embedding.tendsto_nhds_iff.mpr</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"bp\">ùí¢</span><span class=\"n\">f</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">eventually_of_forall</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">mem_range_self</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">range_comp</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">‚ü©,</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">‚ü©</span>\n</code></pre></div>\n<p>Then unfortunately one can no longer apply directly <code>isCompact_closure_of_closedEmbedding</code>, but we can mimick its proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">arzela_ascoli</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniformSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">T2Space</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">s_pointwiseCompact</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">),</span>\n      <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"bp\">‚àÉ</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">Q</span> <span class=\"bp\">‚àß</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">f</span> <span class=\"bp\">‚àà</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Q</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">S_eqcont</span> <span class=\"o\">:</span> <span class=\"n\">Equicontinuous</span> <span class=\"o\">(((</span><span class=\"bp\">‚Üë</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">X</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Y</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isCompact_iff_compactSpace</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">cls_eqcont</span> <span class=\"o\">:=</span> <span class=\"n\">S_eqcont.closure'</span> <span class=\"n\">ContinuousMap.continuous_coe</span>\n  <span class=\"k\">have</span> <span class=\"n\">cls_pointwiseCompact</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">K</span><span class=\"o\">,</span>\n      <span class=\"bp\">‚àÉ</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"n\">Q</span> <span class=\"bp\">‚àß</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">f</span> <span class=\"bp\">‚àà</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span>\n    <span class=\"k\">fun</span> <span class=\"n\">K</span> <span class=\"n\">hK</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">(</span><span class=\"n\">s_pointwiseCompact</span> <span class=\"n\">K</span> <span class=\"n\">hK</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"k\">fun</span> <span class=\"n\">Q</span> <span class=\"n\">hQ</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">hQ.1</span><span class=\"o\">,</span> <span class=\"n\">closure_minimal</span> <span class=\"n\">hQ.2</span> <span class=\"bp\">&lt;|</span>\n      <span class=\"n\">hQ.1.isClosed.preimage</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">ContinuousMap.continuous_eval_const</span> <span class=\"n\">_</span><span class=\"o\">‚ü©</span>\n  <span class=\"n\">refine</span> <span class=\"n\">ArzelaAscoli.compactSpace_of_closedEmbedding</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">cls_eqcont.closedEmbedding_toUniformOnFunIsCompact</span>\n      <span class=\"o\">(</span><span class=\"n\">isClosed_closure</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">closedEmbedding_subtype_val</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">‚Ü¶</span> <span class=\"n\">cls_eqcont.equicontinuousOn</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">K</span> <span class=\"n\">hK</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">(</span><span class=\"n\">cls_pointwiseCompact</span> <span class=\"n\">K</span> <span class=\"n\">hK</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"k\">fun</span> <span class=\"n\">Q</span> <span class=\"n\">hQ</span> <span class=\"bp\">‚Ü¶</span> <span class=\"o\">‚ü®</span><span class=\"n\">hQ.1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hQ.2</span><span class=\"o\">‚ü©)</span>\n</code></pre></div>",
        "id": 426799607,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710527013
    },
    {
        "content": "<p>I‚Äôll think about what‚Äôs the best API design here, I only realized recently that the natural map from continuous functions was not always a closed embedding‚Ä¶</p>",
        "id": 426800294,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710527281
    },
    {
        "content": "<p>Note also that for this to work you really need to assume equicontinuity everywhere, not on each compact (and indeed this is what is assumed in Bourbaki, I should have thought about why they don‚Äôt use the weaker assumption‚Ä¶)</p>",
        "id": 426800953,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710527540
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"242586\">@Vincent Beffara</span> Could you remind me what setup do you need this for exactly? I'd like to have an idea of what is actually useful and what is not. I'm pretty sure you're dealing with functions not continuous on the whole space so using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousMap#doc\">docs#ContinuousMap</a> is an option, is that right?</p>",
        "id": 426802714,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710528286
    },
    {
        "content": "<p>The results I need are this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compacts</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"bp\">|</span> <span class=\"n\">K</span> <span class=\"bp\">‚äÜ</span> <span class=\"n\">U</span> <span class=\"bp\">‚àß</span> <span class=\"n\">IsCompact</span> <span class=\"n\">K</span><span class=\"o\">}</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompleteSpace</span> <span class=\"o\">(</span><span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí·µ§</span><span class=\"o\">[</span><span class=\"n\">compacts</span> <span class=\"n\">U</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and Montel's theorem here: <a href=\"https://github.com/vbeffara/RMT4/blob/main/RMT4/montel.lean\">https://github.com/vbeffara/RMT4/blob/main/RMT4/montel.lean</a> (stated for <code>{F : Œπ ‚Üí ‚ÑÇ ‚Üí·µ§[compacts U] ‚ÑÇ}</code>)</p>\n<p>I probably should rebase my project on top of your PR and see what happens. Maybe using <code>ContinuousMap</code> instead of <code>ContinuousOn</code> makes sense (though I vaguely remember at some point that Patrick was warning me agains it because of all the coercions).</p>",
        "id": 426819486,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710535689
    },
    {
        "content": "<p>Note that I now go straight towards compactness (assuming compactness on the fibers), at least for that first PR, but it shouldn‚Äôt make your life any harder since total boundedness and relative compactness are the same in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>. So maybe you don‚Äôt need completeness anymore, but I think we will have it soon anyways</p>",
        "id": 426824364,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1710537950
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">RMT</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">IsConnected</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">‚â†</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">has_primitives</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">‚àÉ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">DifferentiableOn</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">f</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">‚àß</span> <span class=\"o\">(</span><span class=\"n\">InjOn</span> <span class=\"n\">f</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">‚àß</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">U</span> <span class=\"bp\">=</span> <span class=\"n\">ball</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"bp\">...</span>\n\n<span class=\"k\">#print</span> <span class=\"kd\">axioms</span> <span class=\"n\">RMT</span>\n<span class=\"bp\">-&gt;</span> <span class=\"bp\">'</span><span class=\"n\">RMT'</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"kd\">axioms</span><span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">propext</span><span class=\"o\">,</span> <span class=\"n\">Classical.choice</span><span class=\"o\">,</span> <span class=\"n\">Quot.sound</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Thanks! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 426832010,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1710541691
    }
]