[
    {
        "content": "<p>I am trying to break a multiset into a multiset (or finset) of multisets by an equivalence relation on elements.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Multiset.classes</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">equiv</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">op</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"o\">(</span><span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 412620094,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1705093362
    },
    {
        "content": "<p>This could work, but I wouldn't be surprised if there's a better way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Multiset.Powerset</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Multiset.classes</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">op</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">m.powerset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">op</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toFinset</span>\n</code></pre></div>",
        "id": 412647187,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705106951
    },
    {
        "content": "<p>the proof of <code>Equivalence op</code> isn't needed for the definition of <code>Multiset.classes</code> but would be used to prove things about the result</p>",
        "id": 412649423,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1705107900
    },
    {
        "content": "<p>I came up with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Multiset.classes</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">DecidableRel</span> <span class=\"n\">eq</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">m.powerset</span>\n  <span class=\"bp\">|&gt;.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">eq</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">x.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">≤</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 412649583,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1705107969
    },
    {
        "content": "<p>I have to do a second filter to get rid of subsets, since I want the join of set of classes to be the original set</p>",
        "id": 412649808,
        "sender_full_name": "Jesse Slater",
        "timestamp": 1705108129
    },
    {
        "content": "<p>This definition works, but if you had to compute that set, it would be inefficient: if the multiset <code>m</code> has <code>n</code>elements, you start by sifting out of its powerset, which has <code>2 ^ n</code> elements.</p>",
        "id": 412829094,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1705250769
    },
    {
        "content": "<p>I think it might be better to write the naive algorithm on <code>List</code> and show that when the relation is symmetric and transitive it is permutation invariant</p>",
        "id": 412898542,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705303381
    },
    {
        "content": "<p>Though I guess you could also use <code>(m.map (Quot.mk r)).toFinset.map ⟨fun q =&gt; m.filter (Quot.mk . = q), sorry⟩</code> or similar</p>",
        "id": 412900574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1705304457
    }
]