[
    {
        "content": "<p>Is there a definition or notation for the trivial group / monoid / monoid with zero, i.e. a monoid/group of a single element 1, and a monoid with zero  of two element {0,1}?</p>",
        "id": 412087205,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1704874583
    },
    {
        "content": "<p>For the first question, one answer is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Unit#doc\">docs#Unit</a></p>",
        "id": 412089803,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704875739
    },
    {
        "content": "<p>For the second one, you can use <code>WithZero Unit</code></p>",
        "id": 412089839,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704875760
    },
    {
        "content": "<p>I find that first two works and the third fails. I think I should write a <code>LinearOrderedCommMonoid</code> instance on my own.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Valuation.Basic</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">LinearOrder</span> <span class=\"n\">Unit</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">CommMonoid</span> <span class=\"n\">Unit</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">LinearOrderedCommMonoid</span> <span class=\"n\">Unit</span>\n</code></pre></div>",
        "id": 412114254,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1704883757
    },
    {
        "content": "<p>Do <code>import Mathlib</code> just to check, but if it's not there then feel free to add it!</p>",
        "id": 412118735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704885262
    },
    {
        "content": "<p>Note that you may prefer <code>Subsingleton G</code> if you want to speak about <em>a</em> trivial group. Otherwise your result will apply only to that literal group. What is you goal?</p>",
        "id": 412119836,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704885669
    },
    {
        "content": "<p>Yes, <code>Unit</code> is one very specific group, there are infinitely many other isomorphic but not equal groups with one element, and any theorem proved about <code>Unit</code> will not apply to them.</p>",
        "id": 412120224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704885840
    },
    {
        "content": "<p>My goal is to first define a trivial valuation using this Unit, then define a predicate ‘IsTrivial’ of a valuation if it is equivalent to this special valuation. Do you think this is a good way to do it?</p>",
        "id": 412120492,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1704885944
    },
    {
        "content": "<p>Maybe I am missing something, but isn't a valuation trivial iff <code>v x = 0</code> for all <code>x</code>?</p>",
        "id": 412120944,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704886113
    },
    {
        "content": "<p>I mean, you can define <code>isTrivial</code> directly</p>",
        "id": 412120969,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704886127
    },
    {
        "content": "<p>Oh this sounds like an OK usage because the equivalence will take care of the issue that Riccardo has raised. </p>\n<p>Another way of doing it would be to define a valuation to be trivial if the associated preorder (defined by x&lt;=y iff v(x)&lt;=v(y) is the preorder associated to the trivial valuation.</p>",
        "id": 412120983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704886136
    },
    {
        "content": "<p>Riccardo I think the trivial valuation has v(0)=0 and v(x)=1 for all nonzero x</p>",
        "id": 412121105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704886184
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 412121197,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1704886206
    },
    {
        "content": "<p>Oh, yes, <code>1</code>, not <code>0</code>.</p>",
        "id": 412121302,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704886254
    },
    {
        "content": "<p>Anyway as Kevin said you approach would work in this case</p>",
        "id": 412121357,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1704886279
    },
    {
        "content": "<p>In my opinion, if you are only interested in valuations up to equivalence (e.g. if you are thinking about adic spaces) then a much better model for this type would be preorders on the ring satisfying the relevant list of axioms. This way you don't have to work with equivalence classes at all.</p>",
        "id": 412121684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704886405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Trivial.20group.20.2F.20monoid.20.2F.20monoid.20with.20zero/near/412121684\">said</a>:</p>\n<blockquote>\n<p>In my opinion, if you are only interested in valuations up to equivalence (e.g. if you are thinking about adic spaces) then a much better model for this type would be preorders on the ring satisfying the relevant list of axioms. This way you don't have to work with equivalence classes at all.</p>\n</blockquote>\n<p>Oh that's what I didn't think of before. Thank you! Should I create a new post discussing this designing problem? Which stream should this post belong to?</p>",
        "id": 412122006,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1704886536
    },
    {
        "content": "<p>Yes please do -- in <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> maybe. My impression is that people working on things like DVRs really do want a concrete valuation but that people working in the adic theory don't need it.</p>",
        "id": 412122391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704886664
    },
    {
        "content": "<p>The preorder I'm talking about is mentioned at the bottom of p25 of these notes <a href=\"https://arxiv.org/pdf/1910.05934.pdf\">https://arxiv.org/pdf/1910.05934.pdf</a> . This is the trick we used in the perfectoid project to prove (the type-theoretic analogue of) that equivalence classes of valuations were actually a set (because of course the collection of all totally ordered groups with 0 is not a set, so there are set-theoretic issues in the definition of adic space which you find in the books, which are often ignored i.e. literally not even mentioned -- see for example the claim in Def 4.1 of that paper that something is a set without any mention of this issue.)</p>",
        "id": 412123316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704886969
    }
]