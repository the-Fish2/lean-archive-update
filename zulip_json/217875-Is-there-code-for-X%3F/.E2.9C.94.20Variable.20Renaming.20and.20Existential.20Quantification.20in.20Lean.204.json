[
    {
        "content": "<p>I'm trying to implement a new binary operator, that uses two expressions, e1 and e2, each containing free variables. It's possible that both expressions share some variables, denoted as <code>x</code> and  <code>x'</code> . Here's what I need to do:</p>\n<ol>\n<li>Rename <code>x'</code> to <code>x''</code> in e1.</li>\n<li>Rename <code>x</code> to <code>x''</code> in e2.</li>\n<li>Create the conjunction <code>e1 /\\ e2</code> .</li>\n<li>Wrap <code>e1 /\\ e2</code> in an \"Exists\" statement, where the double-primed variables become bound variables in the existential quantifier.</li>\n</ol>\n<p><strong>What's the best way to accomplish this?</strong></p>\n<p>Here's what I've tried so far:</p>\n<p>I've searched through the Lean 4 API and examples in the repository, but I couldn't find anything similar. One approach I attempted involved renaming variables in  expression <code>e1 /\\ e2</code> within a local context, then creating a lambda and wrapping it in an existential quantifier. However, with this method, the shared variables unintentionally got renamed as well.</p>\n<p>I've also experimented with abstracting the variables in the expressions and replacing them with placeholders. However, managing these placeholders in both expressions quickly became unwieldy.</p>\n<p>I'd greatly appreciate any assistance or advice on how to tackle this problem. Thank you.</p>",
        "id": 426223860,
        "sender_full_name": "Vlad",
        "timestamp": 1710282910
    },
    {
        "content": "<p>Why do you need to rename the variables?</p>",
        "id": 426233292,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710288507
    },
    {
        "content": "<p>I'm implementing sequential composition of program specifications.<br>\nIt's written as <code>S ;; R</code> where <code>S</code> and <code>R</code> are boolean expressions representing specifications.</p>\n<p>Both <code>S</code> and <code>R</code> can use variables with pre-state <code>σ</code> and post-state <code>σ'</code> values.<br>\nThe sequential composition is defined as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">S</span> <span class=\"bp\">;</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"bp\">∃</span> <span class=\"n\">σ''</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">σ'</span> <span class=\"bp\">↦</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">σ''</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">σ</span> <span class=\"bp\">↦</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">σ''</span>\n</code></pre></div>\n<p>Essentially, it checks if there exist intermediate state <code>σ''</code> such that both <code>S</code> and <code>R</code> hold after substituting these intermediate states for their respective variables in <code>S</code> and <code>R</code>.</p>\n<p>For example, if <code>x</code> and <code>y</code> are variables of <code>S</code> and <code>R</code>, then <code>S ; R</code> should be rewritten as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">∃</span> <span class=\"n\">x''</span> <span class=\"n\">y''</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"bp\">↦</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">x''</span> <span class=\"n\">y''</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">x''</span> <span class=\"n\">y''</span>\n<span class=\"bp\">=</span> <span class=\"bp\">∃</span> <span class=\"n\">x''</span> <span class=\"n\">y''</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">substitute</span> <span class=\"n\">x''</span><span class=\"o\">,</span> <span class=\"n\">y''</span> <span class=\"n\">for</span> <span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span> <span class=\"k\">in</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">substitute</span> <span class=\"n\">x''</span><span class=\"o\">,</span> <span class=\"n\">y''</span> <span class=\"n\">for</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"k\">in</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 426233562,
        "sender_full_name": "Vlad",
        "timestamp": 1710288645
    },
    {
        "content": "<p>If there's an easier way to do that, I'm open to suggestions</p>",
        "id": 426233782,
        "sender_full_name": "Vlad",
        "timestamp": 1710288776
    },
    {
        "content": "<p><code>(fun x' y' ↦ S) x'' y''</code> beta-reduces to <code>(substitute x'', y'' for x', y' in S)</code>... are you just asking about how to apply beta reduction?</p>",
        "id": 426234131,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710288954
    },
    {
        "content": "<p>a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> might help, a concrete example of the input and desired output</p>",
        "id": 426234775,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710289366
    },
    {
        "content": "<p>I apologize for the earlier misunderstanding. My question is actually about how to implement the operator in Lean 4.</p>\n<p>I've attempted an implementation (included below), but unfortunately, it's not working as intended. I'm hoping to get some guidance on a better approach. Perhaps there's an API within Lean's metaprogramming functionality that could achieve this, but I haven't found anything relevant yet.</p>",
        "id": 426235985,
        "sender_full_name": "Vlad",
        "timestamp": 1710290071
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Util.ExtendedBinder</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Meta</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.Elab.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean.TSyntax</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">collectVars</span> <span class=\"o\">(</span><span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)(</span><span class=\"n\">varNamePred</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Bool</span><span class=\"o\">):</span> <span class=\"n\">TermElabM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">FVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rvars</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">S.collectFVars</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">{}</span>\n  <span class=\"k\">let</span> <span class=\"n\">rvars</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">rvars.fvarSet.toList.filterM</span> <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span> <span class=\"n\">v.getUserName</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">getString</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">varNamePred</span>\n  <span class=\"n\">return</span> <span class=\"n\">rvars</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">funTrimQuote</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">):</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"n\">s.dropRightWhile</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toString</span> <span class=\"bp\">=</span> <span class=\"s2\">\"'\"</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">funWrapInExists</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)(</span><span class=\"n\">v1</span> <span class=\"n\">v2</span><span class=\"o\">:</span> <span class=\"n\">FVarId</span><span class=\"o\">):</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span>  <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">funTrimQuote</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.dropRightWhile</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.toString</span> <span class=\"bp\">=</span> <span class=\"s2\">\"'\"</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">vname</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span> <span class=\"n\">v1.getUserName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getString</span> <span class=\"bp\">|&gt;</span> <span class=\"n\">funTrimQuote</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">append</span> <span class=\"s2\">\"''\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">es</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">withLocalDecl</span> <span class=\"n\">vname</span> <span class=\"n\">BinderInfo.default</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"n\">v1.getType</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">e1</span> <span class=\"o\">:=</span> <span class=\"n\">e.replaceFVarId</span> <span class=\"n\">v1</span> <span class=\"n\">x</span>\n    <span class=\"k\">let</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"n\">e1.replaceFVarId</span> <span class=\"n\">v2</span> <span class=\"n\">x</span>\n    <span class=\"k\">let</span> <span class=\"n\">exp</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">mkLambdaFVars</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"n\">e2</span>\n    <span class=\"k\">let</span> <span class=\"n\">existsExpr</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">Exists</span> <span class=\"o\">[</span><span class=\"n\">levelZero</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"n\">v1.getType</span><span class=\"o\">)</span> <span class=\"n\">exp</span>\n    <span class=\"n\">return</span> <span class=\"n\">existsExpr</span>\n  <span class=\"n\">return</span> <span class=\"n\">es</span>\n\n<span class=\"c1\">--   ∃ σ'', (fun σ' ↦ S) σ'' ∧ (fun σ ↦ R) σ''</span>\n<span class=\"c1\">-- = ∃ x'' y'', (fun x' y' ↦ S) x'' y'' ∧ (fun x y ↦ R) x'' y''</span>\n<span class=\"n\">syntax</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">compose_seq</span><span class=\"o\">)</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ;; \"</span> <span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">21</span> <span class=\"o\">:</span> <span class=\"n\">term</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">abstract_spec</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">term</span><span class=\"o\">):</span> <span class=\"n\">TermElabM</span> <span class=\"n\">Expr</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">funFindVar</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">vs</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">FVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">vs.findM</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"n\">x.getUserName</span><span class=\"o\">)</span> <span class=\"bp\">==</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">elabTermAndSynthesize</span> <span class=\"n\">L</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">elabTermAndSynthesize</span> <span class=\"n\">R</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">lvars</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">collectVars</span> <span class=\"n\">L</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.endsWith</span> <span class=\"s2\">\"'\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">rvars</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">collectVars</span> <span class=\"n\">R</span> <span class=\"k\">fun</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s.endsWith</span> <span class=\"s2\">\"'\"</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">not</span>\n\n  <span class=\"k\">if</span> <span class=\"n\">lvars.isEmpty</span> <span class=\"k\">then</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">LandR</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">And</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"n\">R</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">exp</span> <span class=\"o\">:=</span> <span class=\"n\">LandR</span>\n  <span class=\"n\">for</span> <span class=\"n\">lv</span> <span class=\"k\">in</span> <span class=\"n\">lvars</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">unquotedName</span> <span class=\"o\">:=</span> <span class=\"n\">funTrimQuote</span> <span class=\"o\">(</span><span class=\"bp\">&lt;-</span><span class=\"n\">lv.getUserName</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">getString</span>\n    <span class=\"k\">let</span> <span class=\"n\">rv</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">funFindVar</span> <span class=\"n\">rvars</span> <span class=\"n\">unquotedName.toName</span>\n    <span class=\"n\">exp</span> <span class=\"o\">:=</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">funWrapInExists</span> <span class=\"n\">exp</span> <span class=\"n\">lv</span> <span class=\"n\">rv.get</span><span class=\"bp\">!</span>\n\n  <span class=\"n\">return</span> <span class=\"n\">exp</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span> <span class=\"n\">compose_seq</span><span class=\"kd\">]</span>\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">elab_compose_seq</span> <span class=\"o\">:</span> <span class=\"n\">TermElab</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">stx</span> <span class=\"n\">type</span><span class=\"bp\">?</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">stx</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"bp\">;;</span> <span class=\"bp\">$</span><span class=\"n\">S</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">return</span> <span class=\"bp\">&lt;-</span> <span class=\"n\">abstract_spec</span> <span class=\"n\">R</span> <span class=\"n\">S</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"n\">return</span> <span class=\"n\">unreachable</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">;;</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 426236003,
        "sender_full_name": "Vlad",
        "timestamp": 1710290090
    },
    {
        "content": "<p>This result is clearly wrong, because <code>x'</code> in rhs gets renamed to <code>x''</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">;;</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>   <span class=\"c1\">-- ∃ x'', x'' = 1 ∧ x'' = x'' : Prop</span>\n</code></pre></div>",
        "id": 426236162,
        "sender_full_name": "Vlad",
        "timestamp": 1710290192
    },
    {
        "content": "<p>what's the desired output?</p>",
        "id": 426236429,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710290397
    },
    {
        "content": "<p>The output should be <code>∃ x'', x'' = 1 ∧ x' = x'' : Prop</code> - the <code>x'</code> in RHS should not be renamed</p>",
        "id": 426236655,
        "sender_full_name": "Vlad",
        "timestamp": 1710290524
    },
    {
        "content": "<p>This happens because LHS and RHS have free variables in common. When I rename <code>x'</code> in the conjunction, both LHS and RHS are affected. I'm sure there must be a better way of implementing that</p>",
        "id": 426236964,
        "sender_full_name": "Vlad",
        "timestamp": 1710290747
    },
    {
        "content": "<p>but if you're renaming <code>x'</code> to <code>x''</code> on the left hand side, why aren't you renaming the same variable on the right hand side? shouldn't the result be <code>∃ x'', x'' = 1 ∧ x'' = x : Prop</code>?</p>",
        "id": 426237299,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710291007
    },
    {
        "content": "<p>No, the convention here is that computation starts with <code>x</code> and ends with <code>x'</code>. The <code>x'</code> on the LHS becomes the <code>x</code> on the RHS. In other words, the output of the computation on the LHS, becomes the input to the computation on the RHS.</p>",
        "id": 426237675,
        "sender_full_name": "Vlad",
        "timestamp": 1710291299
    },
    {
        "content": "<p>this would probably be easier if you worked with actual functions with inputs and outputs instead of manipulating free variables... I'm a bit confused why the Meta machinery is necessary here</p>",
        "id": 426237868,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710291423
    },
    {
        "content": "<p>but I'm also completely unfamiliar with the domain here and perhaps this kind of expression manipulation is integral to the math</p>",
        "id": 426238012,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710291498
    },
    {
        "content": "<p>if so, my apologies... I don't think I'll be much help here, but perhaps someone else can chime in</p>",
        "id": 426238265,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710291666
    },
    {
        "content": "<p>Thanks, I appreciate the assistance. I was also considering this, and I'm going to try re-implementing the operator so that specifications are functions instead of propositions with free variables.</p>",
        "id": 426238507,
        "sender_full_name": "Vlad",
        "timestamp": 1710291832
    },
    {
        "content": "<p>The problem is when specifications are represented with functions, then there seems to be no direct way to access the names of variables used withing the function. For instance, consider specifications L and R defined as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>The goal is to identify the bound variables in L (in this case, x') and find their corresponding variables in R (x). Unfortunately, there's no readily available API function to achieve this directly.</p>",
        "id": 426244304,
        "sender_full_name": "Vlad",
        "timestamp": 1710295135
    },
    {
        "content": "<p>those aren't functions though... they're propositions</p>",
        "id": 426244464,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710295206
    },
    {
        "content": "<p>also I'm still confused about how <code>x = y</code> is supposed to represent something with an input and output</p>",
        "id": 426244585,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710295256
    },
    {
        "content": "<p><code>(x = y) = (y = x)</code> so there's no way to capture directionality</p>",
        "id": 426244714,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710295320
    },
    {
        "content": "<p>In the example above <strong>x</strong> is a “state variable” or “program variable”.  It corresponds to two mathematical variables x and xʹ, where x is a pre-state of <strong>x</strong> (the state variable) and x' is a the post-state of <strong>x</strong>. </p>\n<p>As an example, the specification <code>x' = x</code> says that the state of x remains unchanged.<br>\nAnother example, the specification <code>x = 1 /\\ x' = x + 1</code> says that the computation begins with <strong>x</strong> = 1 and ends with <strong>x</strong> incremented by one.<br>\nYet another example, the specification <code>x' = x + 1 ; x' = x + 1</code> instructs to increment <strong>x</strong> by one and then increment <strong>x</strong> by one again. Using conventional notation, <code>∃ x'', x'' = x  + 1 ∧ x' = x'' + 1</code> - that's exactly what I'm trying to implement.</p>",
        "id": 426246215,
        "sender_full_name": "Vlad",
        "timestamp": 1710296175
    },
    {
        "content": "<p>I think the problem might be that you're treating <code>=</code> like it means assignment and it doesn't mean that in Lean</p>",
        "id": 426246350,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710296276
    },
    {
        "content": "<p>also, <code>∧</code> is symmetrical (<code>x ∧ y = y ∧ x</code>)</p>",
        "id": 426246673,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710296460
    },
    {
        "content": "<p>I think what you really want to do is model state as a structure and manipulate it via a sequence of state transformations</p>",
        "id": 426246718,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710296490
    },
    {
        "content": "<p>In my examples <code>=</code> is equality, not an assignment. <code>x' = x + 1</code> says that <code>x'</code> is equal <code>x</code> plus 1.<br>\nWhile <code>/\\</code> is symmetrical and associative, the sequential composition is not.</p>",
        "id": 426246904,
        "sender_full_name": "Vlad",
        "timestamp": 1710296586
    },
    {
        "content": "<p>Anyway, my question is about metaprogramming and how to implement that specific behavior in Lean 4. But I'm glad to answer any clarification questions.</p>",
        "id": 426247237,
        "sender_full_name": "Vlad",
        "timestamp": 1710296778
    },
    {
        "content": "<p>it seems like you're trying to repurpose basic Lean syntax to model state and transformations, and if you try to do that I think you're going to run into difficulties</p>\n<p>Lean has support for custom notation but it has to represent some underlying logic, so you can't just say \"<code>x = 1 /\\ x' = x + 1</code> says that the computation begins with x = 1 and ends with x incremented by one\" because it doesn't say that (conjunctions don't have a \"beginning\" or \"ending\")... unless you've defined <code>/\\</code> as custom notation</p>",
        "id": 426247474,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710296907
    },
    {
        "content": "<p>if that's your plan, that's cool, but it means you need to define some sort of underlying <code>ProgramSequence</code> type to give meaning to the idea that there's a \"beginning\" and \"ending\"</p>",
        "id": 426247691,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1710297005
    },
    {
        "content": "<p>The operator I'm trying to implement doesn't change the meaning of conjunction. Specifications <code>x = 1 /\\ x' = x + 1</code> and <code>x' = x + 1 /\\ x = 1</code> specify exactly the same behavior.  <br>\nThe operator is useful as a shortcut. Otherwise, writing the expanded form with an existential quantifier for specifications with many variables would be cumbersome.</p>",
        "id": 426262745,
        "sender_full_name": "Vlad",
        "timestamp": 1710307884
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"696014\">@Vlad</span>, either you are not explaining yourself clearly, or you need to pay attention to what <span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> is saying.</p>",
        "id": 426263020,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710308091
    },
    {
        "content": "<p>I think the definition for the sequential composition above is very clear. Not sure how can it be misinterpreted.<br>\nThe question is not even about its interpretation and I'm not looking for validation of that idea.<br>\nI'm just looking for guidance how to implement that in Lean 4.</p>\n<p>Seems like people are more interested in the interpretation of that operator, so I'll give another example.<br>\nHere's a program in some programming language using variables x,y, where <code>:=</code> is an assignment operator.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>   <span class=\"c1\">-- L</span>\n<span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>       <span class=\"c1\">-- R</span>\n</code></pre></div>\n<p>This program can be split into two programs - <strong>L</strong> and <strong>R</strong>, running sequentially, one after another.<br>\nRemember, the program variable <strong>x</strong> corresponds to two mathematical variables - <strong>x</strong> (pre-state) and <strong>x'</strong> (post-state).<br>\nHere's a possible specification for the program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"n\">L</span> <span class=\"bp\">;</span> <span class=\"n\">R</span>\n<span class=\"bp\">=</span>  <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>                                    <span class=\"c1\">-- definition of L and R</span>\n<span class=\"bp\">=</span>  <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">;</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>                  <span class=\"c1\">-- definition of assignment; note assignment to x leaves y without changes</span>\n<span class=\"bp\">=</span>  <span class=\"bp\">∃</span><span class=\"n\">x''</span> <span class=\"n\">y''</span><span class=\"o\">,</span> <span class=\"n\">x''</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">y''</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x''</span> <span class=\"bp\">∧</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x''</span> <span class=\"c1\">-- definition of sequential composition</span>\n<span class=\"bp\">=</span>  <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>                                <span class=\"c1\">-- one-point rule twice</span>\n</code></pre></div>\n<p>The last line is the final specification for <code>L ; R</code> after expanding the definition.<br>\nNow, <code>L ; R</code> is not the same as <code>R ; L</code> (try to expand the definition of <code>;</code> to convince yourself).<br>\nBut, these are the same specifications corresponding to <code>L ; R</code>:  <code>y' = x + 1 ∧ x' = x + 1</code> and <code>x' = x + 1 ∧ y' = x + 1</code><br>\nHope this clarifies the confusion.</p>",
        "id": 426265671,
        "sender_full_name": "Vlad",
        "timestamp": 1710309901
    },
    {
        "content": "<p>I think the main challenge here is determining what variables are in scope. I notice you haven't given a typing context for these equalities</p>",
        "id": 426269790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710312493
    },
    {
        "content": "<p>In this expression:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">;</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>do we have <code>x</code> and <code>x'</code> in context? Or are they bound by the syntax?</p>",
        "id": 426269875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710312564
    },
    {
        "content": "<p>In the next line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">;</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>it would appear that we have <code>x</code> and <code>x'</code> in context, but it's possible that this is not the case and <code>;</code> is some magical binding notation</p>",
        "id": 426269997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710312636
    },
    {
        "content": "<p>In the final line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>we are clearly working with normal logical expressions so <code>x</code> and <code>x'</code> would have to be in context by this point</p>",
        "id": 426270087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710312705
    },
    {
        "content": "<p>so we have to conclude they were in context the whole time</p>",
        "id": 426270107,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710312716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"696014\">@Vlad</span> I think I see more or less what you are trying to do, but it's not clear to me what you want to do with double-primed variables if the expression contains them. Also what happens when the variables used on the left and right don't match? Your code currently panics in that case, e.g. <code>x' = 1 ;; x' = 1</code> which I would have assumed is a valid specification.</p>",
        "id": 426271853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710313673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"696014\">@Vlad</span> I think this matches your specification:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Common</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Term</span> <span class=\"n\">Meta</span>\n\n<span class=\"n\">elab</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">compose_seq</span><span class=\"o\">)</span> <span class=\"n\">L</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">20</span> <span class=\"s2\">\" ;; \"</span> <span class=\"n\">R</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"o\">:</span><span class=\"mi\">21</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">L</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermAndSynthesize</span> <span class=\"n\">L</span> <span class=\"n\">none</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">R</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermAndSynthesize</span> <span class=\"n\">R</span> <span class=\"n\">none</span>\n  <span class=\"k\">show</span> <span class=\"n\">MetaM</span> <span class=\"n\">_</span> <span class=\"k\">from</span> <span class=\"k\">do</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">lvars</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">L.collectFVars</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">{})</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">fvarSet</span>\n  <span class=\"k\">let</span> <span class=\"n\">rvars</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">R.collectFVars</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">run</span> <span class=\"o\">{})</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">fvarSet</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">lAbstract</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">rAbstract</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">newVars</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"n\">lv'</span> <span class=\"k\">in</span> <span class=\"n\">lvars</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">name'</span> <span class=\"bp\">←</span> <span class=\"n\">lv'.getUserName</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">name'.toString.dropSuffix</span><span class=\"bp\">?</span> <span class=\"s2\">\"</span><span class=\"se\">\\'</span><span class=\"s2\">\"</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">toString</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">continue</span>\n    <span class=\"k\">if</span> <span class=\"n\">name.endsWith</span> <span class=\"s2\">\"</span><span class=\"se\">\\'</span><span class=\"s2\">\"</span> <span class=\"k\">then</span> <span class=\"n\">continue</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">lv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">getLCtx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">findFromUserName</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mkSimple</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">fvarId</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">continue</span>\n    <span class=\"k\">if</span> <span class=\"n\">rvars.contains</span> <span class=\"n\">lv</span> <span class=\"bp\">||</span> <span class=\"n\">rvars.contains</span> <span class=\"n\">lv'</span> <span class=\"k\">then</span>\n      <span class=\"n\">lAbstract</span> <span class=\"o\">:=</span> <span class=\"n\">lAbstract.push</span> <span class=\"o\">(</span><span class=\"n\">Expr.fvar</span> <span class=\"n\">lv'</span><span class=\"o\">)</span>\n      <span class=\"n\">rAbstract</span> <span class=\"o\">:=</span> <span class=\"n\">rAbstract.push</span> <span class=\"o\">(</span><span class=\"n\">Expr.fvar</span> <span class=\"n\">lv</span><span class=\"o\">)</span>\n      <span class=\"n\">newVars</span> <span class=\"o\">:=</span> <span class=\"n\">newVars.push</span> <span class=\"o\">(</span><span class=\"n\">name'.appendAfter</span> <span class=\"s2\">\"'\"</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">default</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">:</span><span class=\"n\">Array</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lv.getType</span><span class=\"o\">)</span>\n\n  <span class=\"n\">withLocalDecls</span> <span class=\"n\">newVars</span> <span class=\"k\">fun</span> <span class=\"n\">xs''</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">L.replaceFVars</span> <span class=\"n\">lAbstract</span> <span class=\"n\">xs''</span>\n    <span class=\"k\">let</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R.replaceFVars</span> <span class=\"n\">rAbstract</span> <span class=\"n\">xs''</span>\n    <span class=\"k\">let</span> <span class=\"n\">exp</span> <span class=\"o\">:=</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"n\">Lean.mkConst</span> <span class=\"bp\">``</span><span class=\"n\">And</span><span class=\"o\">)</span> <span class=\"n\">L</span> <span class=\"n\">R</span>\n    <span class=\"n\">Mathlib.Tactic.MkIff.mkExistsList</span> <span class=\"n\">xs''.toList</span> <span class=\"n\">exp</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">x'</span> <span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">;;</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"c1\">-- ∃ x'', x'' = 1 ∧ x' = x'' : Prop</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">;;</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- ∃ x'', x'' = x ∧ x' = 1 : Prop</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">;;</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"c1\">-- ∃ x'', x'' = 1 ∧ y' = x'' : Prop</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">;;</span> <span class=\"n\">y'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n<span class=\"c1\">-- ∃ x'' y'', (x'' = x + 1 ∧ y'' = y) ∧ y' = x'' ∧ x' = x'' : Prop</span>\n</code></pre></div>",
        "id": 426277117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710316295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  that's exactly what I was aiming at! Thank you so much!</p>\n<p>You made valid points above which I'd like to clarify:</p>\n<ul>\n<li>\n<p><strong>Specification context:</strong> specifications describe behavior of a program which operates on some state. A state is an assignment of values to state variables.<br>\nIn integer variable <strong>x,y,z</strong>  <code>x := 1</code> expands to <code>x' = 1 ∧ y' = y ∧ z' = z ...</code> which says the computation ends with <code>x' = 1</code> and leaves all other variables unchanged.<br>\nOf course, it's not practical to list all possible state variables, so we focus on variables mentioned in the spec for simplicity.<br>\nWhen composing specifications (<code>x := 1  ;  y := y + 2</code>) we assume they share the same variables, even if not explicitly mentioned.<br>\nHere, the LHS says nothing about <code>y</code>, and the RHS says nothing about <code>x</code>, but they are there implicitly.<br>\nWe can rewrite it as <code>x' = 1 ∧ y' = y ; y' = y + 2 ∧ x' = x</code>. Sequential composition <code> ; </code> operator essentially combines free variables from both parts.<br>\nI don't know yet how to implement the <code> := </code> assignment operator so that it only includes relevant state variables.<br>\nIt seems like it's easier to do in  <code> ; </code>, but that is a design problem.</p>\n</li>\n<li>\n<p><strong>double-primed variables:</strong> the name of the bounded variables inside the existential quantification doesn't matter and it can be any unique name. But they must bind the proper free variables in the LHS and the RHS. It's convenient to have a name of a bound variable that resembles the variable name it abstracts. Is there a function in Lean that ensures the name is unique? Something like <br>\n<code>ensureUniqueName `x''   -- returns uniqueprefix_x'' if x'' is already used </code></p>\n</li>\n</ul>",
        "id": 426381764,
        "sender_full_name": "Vlad",
        "timestamp": 1710347815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what is a good way to extend your implementation to handle this case? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">x'</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">L</span> <span class=\"bp\">;;</span> <span class=\"n\">R</span>\n<span class=\"c1\">-- actual result:  L ∧ R : Prop</span>\n<span class=\"c1\">-- desired result: ∃ x'', (x'' = 1) ∧ (x' = x'') : Prop</span>\n</code></pre></div>",
        "id": 426403107,
        "sender_full_name": "Vlad",
        "timestamp": 1710354572
    },
    {
        "content": "<p>that's going a bit too far for lean. To begin with <code>L</code> is of type <code>Nat -&gt; Nat -&gt; Prop</code>, there is no <code>x</code> to bind anymore in it and the way you've written <code>L</code> ensures that it can't be anything other than a regular proposition. The normal way you would use it in subsequent code is <code>L x' x</code>: <code>L</code> is itself not a <code>Prop</code> even though <code>x' = 1</code> is a <code>Prop</code> - the notation of <code>def</code> is slightly misleading in this case. If you put the correct variables in uses of <code>L</code> downstream, this results in <code>L x' x ;; R x' x</code>, and this will bind in the way you want (but it won't produce <code>∃ x'', (x'' = 1) ∧ (x' = x'')</code>, it will produce <code>∃ x'', L x'' x ∧ R x' x''</code>, which is the same up to definition unfolding).</p>",
        "id": 426408083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710356478
    },
    {
        "content": "<p>Makes perfect sense. Thank you so much! I learned a lot from your code and explanations. I've been learning Lean for the last 2 weeks and it's incredible to see such a great community.</p>",
        "id": 426409605,
        "sender_full_name": "Vlad",
        "timestamp": 1710357038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"696014\">Vlad</span> has marked this topic as resolved.</p>",
        "id": 426409622,
        "sender_full_name": "Notification Bot",
        "timestamp": 1710357050
    }
]