[
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.CartesianClosed#doc\">docs#CategoryTheory.CartesianClosed</a> which uses the (noncomputable) categorical products as an assumption. On the other hand, we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.monoidalOfChosenFiniteProducts#doc\">docs#CategoryTheory.monoidalOfChosenFiniteProducts</a> which lets us construct a (cartesian) monoidal structure by explicitly specifying a terminal object and binary products. However, we don't have any real API for cartesian monoidal categories. E.g. there is no <code>lift</code> which takes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f : X \\to Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">g : X \\to Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> and gives <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo>⊗</mo><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">X \\to Y \\otimes Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span></span></span></span>. </p>\n<p>For a personal project I'm working on, I would like to be able to talk about <em>explicit</em> cartesian (closed) structures on categories, where there is an explicitly chosen product and terminal object (and internal hom for the closed case). The approach I'm currently taking is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ChosenFiniteProducts</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">product</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Limits.LimitCone</span> <span class=\"o\">(</span><span class=\"n\">Limits.pair</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n  <span class=\"n\">terminal</span> <span class=\"o\">:</span> <span class=\"n\">Limits.LimitCone</span> <span class=\"o\">(</span><span class=\"n\">Functor.empty</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and providing a monoidal instance based on that. I then use the notation from the monoidal categories API to work with the chosen product and terminal object. </p>\n<p>Does anyone see a more convenient approach to accomplishing the same thing, using what's currently in mathlib?</p>",
        "id": 423482017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1708981000
    },
    {
        "content": "<p>I have opened a PR here: <a href=\"https://github.com/leanprover-community/mathlib4/pull/11248\">#11248</a></p>",
        "id": 425565710,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1709920440
    },
    {
        "content": "<p>One potential issue I see with this is that there are categories which have a natural monoidal structure and a natural Cartesian structure which don’t agree (e.g. modules). In such cases introducing an instance of this new class will cause diamond issues. A potential fix is to introduce custom notation for the explicit product and terminal object that doesn’t go through the monoidal instance, and to make that instance a def. Anyone have any thought about this?</p>",
        "id": 425567099,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1709920966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention silent\" data-user-id=\"671216\">Jujian Zhang</span> <span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span></p>",
        "id": 425567118,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1709920976
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"699016\">@Edison Xie</span> might also be interested in this</p>",
        "id": 425569194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709921914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Chosen.20finite.20products.20and.20internal.20homs/near/425569194\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"699016\">Edison Xie</span> might also be interested in this</p>\n</blockquote>\n<p>yes jujian has sent me a paragraph of codes written by Adam to bypass the proof of category over a monoid object being monoidal</p>",
        "id": 425569793,
        "sender_full_name": "Edison Xie",
        "timestamp": 1709922190
    },
    {
        "content": "<p>Am I missing something here. My understanding is that this is a solution to put a monoidal structure where we have good definition equality on a category whose natural monoidal structure is Cartesian product. So can we just manually avoid using <code>ChosenFiniteProducts</code> on category of modules etc whose monoidal structure and Cartesian product diverges. For example, we don’t mark <code>monoidalOfChosenFiniteProducts</code> and <code>monoidalOfFiniteProducts</code> as <code>instance</code> so that monoidal instance from <code>ChosenFiniteProducts</code> and <code>FiniteProducts</code> should be written manually and maybe with help of type alias, could diamonds be eliminated?</p>",
        "id": 425570317,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1709922414
    },
    {
        "content": "<p>If we worry that our version of carefully chosen Cartesian product might get confused with the product object by axiom of choice, we can use the <code>tensorObj</code> notation.</p>",
        "id": 425571609,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1709922993
    },
    {
        "content": "<p>Yeah you don’t have to introduce an instance of this class. But then using the explicit product of modules (whose underlying type is the type theoretic product) is not so convenient when doing category theory</p>",
        "id": 425572831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1709923558
    }
]