[
    {
        "content": "<p>I'm looking to define a set of constants that I'm going to be using throughout a namespace (or module, or file, I'm not super familiar with the Lean module system yet), but that can be parametrized from the outside. Essentially, I want something like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Axiomed</span>\n  <span class=\"kd\">axiom</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"kd\">axiom</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">Domain</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span>\n  <span class=\"kd\">def</span> <span class=\"n\">Codomain</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">Funs</span> <span class=\"o\">:=</span> <span class=\"n\">Domain</span> <span class=\"bp\">→</span> <span class=\"n\">Codomain</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">Axiomed</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funs12</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Axiomed</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Funs</span>\n<span class=\"kd\">def</span> <span class=\"n\">Funs23</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Axiomed</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Funs</span>\n</code></pre></div>\n<p>I cannot use <code>variable</code>s in that context because then in many cases the implitic dependencies cannot be inferred. For example, I want Lean to know that when I type <code>Domain</code> inside of <code>Axiomed</code> it refers to <code>Fin  n</code>, not (for example) <code>Fin m</code>, or <code>Fin &lt;any other nat&gt;</code>.</p>\n<p>Is there a way to do this in Lean?</p>",
        "id": 430836735,
        "sender_full_name": "Carlos Miguel Soto",
        "timestamp": 1712077844
    },
    {
        "content": "<p>In Lean 3 you could use <code>parameter</code> instead of <code>variable</code>, but Lean 4 does not have this feature.</p>\n<p>Now, either people use <code>variable</code> and pass <code>n</code> and <code>m</code> everywhere, or they use notation, like <code>local notation \"Domain\" =&gt; Fin n</code></p>",
        "id": 430837282,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712078022
    },
    {
        "content": "<p>But it looks to me that a <code>structure</code> might suffice for your use case? Though it might be too weird.</p>",
        "id": 430837425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712078052
    },
    {
        "content": "<p>Yeah, it's weird:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Axiomed</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Axiomed</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Domain</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">n</span>\n<span class=\"kd\">def</span> <span class=\"n\">Codomain</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funs</span> <span class=\"o\">:=</span> <span class=\"n\">s.Domain</span> <span class=\"bp\">→</span> <span class=\"n\">s.Codomain</span>\n<span class=\"kd\">end</span> <span class=\"n\">Axiomed</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funs12</span> <span class=\"o\">:=</span> <span class=\"o\">({}</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Funs</span>\n<span class=\"kd\">def</span> <span class=\"n\">Funs23</span> <span class=\"o\">:=</span> <span class=\"o\">({}</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Funs</span>\n</code></pre></div>\n<p>The idea is to make it so that there's just one thing to pass around. You can also put <code>n</code> and <code>m</code> as fields into the <code>structure</code>.</p>",
        "id": 430838234,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712078315
    },
    {
        "content": "<p>bummer that Lean 4 doesn't have this feature but your proposed solution looks cool, thanks for that. I'll try it and see if I don't get too confused</p>",
        "id": 430838582,
        "sender_full_name": "Carlos Miguel Soto",
        "timestamp": 1712078453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"706525\">Carlos Miguel Soto</span> has marked this topic as resolved.</p>",
        "id": 430839084,
        "sender_full_name": "Notification Bot",
        "timestamp": 1712078650
    },
    {
        "content": "<p>There's also a metaprogramming approach, with the weakness that it doesn't check the abstract theory, but rather it checks it whenever it's instantiated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"instantiate_axiomed \"</span> <span class=\"n\">ns</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\" with \"</span> <span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"s2\">\", \"</span> <span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"o\">:=</span> <span class=\"n\">ns.getId</span>\n  <span class=\"k\">let</span> <span class=\"n\">Domain</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"o\">(</span><span class=\"n\">ns</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">Domain</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">Codomain</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"o\">(</span><span class=\"n\">ns</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">Codomain</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">Funs</span> <span class=\"o\">:=</span> <span class=\"n\">mkIdent</span> <span class=\"o\">(</span><span class=\"n\">ns</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">Funs</span><span class=\"o\">)</span>\n  <span class=\"n\">Command.elabCommand</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span>\n  <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"n\">Domain</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">n</span>\n  <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"n\">Codomain</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"bp\">$</span><span class=\"n\">m</span>\n  <span class=\"kd\">def</span> <span class=\"bp\">$</span><span class=\"n\">Funs</span> <span class=\"o\">:=</span> <span class=\"bp\">$</span><span class=\"n\">Domain</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"n\">Codomain</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"n\">instantiate_axiomed</span> <span class=\"n\">Axiomed1</span> <span class=\"k\">with</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span>\n<span class=\"n\">instantiate_axiomed</span> <span class=\"n\">Axiomed2</span> <span class=\"k\">with</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funs12</span> <span class=\"o\">:=</span> <span class=\"n\">Axiomed1.Funs</span>\n<span class=\"kd\">def</span> <span class=\"n\">Funs23</span> <span class=\"o\">:=</span> <span class=\"n\">Axiomed2.Funs</span>\n</code></pre></div>",
        "id": 430839979,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712079000
    },
    {
        "content": "<p>I could see another sort of metaprogramming approach where you can abstract some particular axioms out of every definition that's present in some namespace</p>",
        "id": 430840221,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1712079075
    },
    {
        "content": "<p>What about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.SimpRw</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Axiomed</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Axiomed</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Domain</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">self.n</span>\n<span class=\"kd\">def</span> <span class=\"n\">Codomain</span> <span class=\"o\">:=</span> <span class=\"n\">Fin</span> <span class=\"n\">self.m</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funs</span> <span class=\"o\">:=</span> <span class=\"n\">self.Domain</span> <span class=\"bp\">→</span> <span class=\"n\">self.Codomain</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Axiomed</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">def</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"kd\">def</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Funs12</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Axiomed.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Funs</span>\n<span class=\"kd\">def</span> <span class=\"n\">Funs23</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Axiomed.mk</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Funs</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Funs12</span> <span class=\"bp\">=</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Funs12</span><span class=\"o\">,</span> <span class=\"n\">Axiomed.Funs</span><span class=\"o\">,</span> <span class=\"n\">Axiomed.Domain</span><span class=\"o\">,</span> <span class=\"n\">Axiomed.Codomain</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 430853508,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712083967
    },
    {
        "content": "<p>All <code>self</code> must be explicit, just like Python I think.</p>",
        "id": 430853856,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712084105
    },
    {
        "content": "<p>That's even nicer! However, you seem to lose the ability to use dot-notation for other structs completely</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Axiomed</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Axiomed</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">structure</span> <span class=\"n\">Par</span> <span class=\"n\">where</span>\n    <span class=\"n\">first</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">self.n</span>\n    <span class=\"n\">second</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">self.n</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">self.Par</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">p.first</span> <span class=\"bp\">+</span> <span class=\"n\">p.second</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Axiomed</span>\n</code></pre></div>\n<p>That doesn't compile, for example</p>",
        "id": 430856557,
        "sender_full_name": "Carlos Miguel Soto",
        "timestamp": 1712085157
    },
    {
        "content": "<p>You need <code>p.first self + p.second self</code></p>",
        "id": 430857777,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1712085609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20Namespace-scoped.20Axioms/near/430857777\">said</a>:</p>\n<blockquote>\n<p>You need <code>p.first self + p.second self</code></p>\n</blockquote>\n<p>Nope, still doesn't work. Seems like it's expecting <code>self</code> to be the first parameter, but due to dot-notation <code>p</code> ends up being the first.</p>",
        "id": 430858007,
        "sender_full_name": "Carlos Miguel Soto",
        "timestamp": 1712085694
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">self.Par</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">Par.first</span> <span class=\"n\">p</span> <span class=\"bp\">+</span> <span class=\"n\">Par.second</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>Seems to work, although not very ergonomic with longer struct names</p>",
        "id": 430858285,
        "sender_full_name": "Carlos Miguel Soto",
        "timestamp": 1712085812
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Axiomed</span> <span class=\"n\">where</span>\n  <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n  <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Axiomed</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">parent</span> <span class=\"o\">:</span> <span class=\"n\">Axiomed</span><span class=\"o\">)</span>\n\n  <span class=\"kd\">structure</span> <span class=\"n\">Par</span> <span class=\"n\">where</span>\n    <span class=\"n\">first</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">parent.n</span>\n    <span class=\"n\">second</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">parent.n</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">parent.Par</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">p.first</span> <span class=\"bp\">+</span> <span class=\"n\">p.second</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Axiomed</span>\n</code></pre></div>\n<p>Maybe because too many variables named <code>self </code> <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>, for example, if using your original code, <code>#check Par.first</code> outputs <code>Axiomed.Par.first {self : Axiomed} (self : Par self) : Fin self.n</code>, there are two <code>self</code>...</p>",
        "id": 430861799,
        "sender_full_name": "Jz Pan",
        "timestamp": 1712087326
    }
]