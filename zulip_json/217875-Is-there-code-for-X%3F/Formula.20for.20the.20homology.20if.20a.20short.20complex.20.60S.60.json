[
    {
        "content": "<p>Given a <code>ShortComplex</code> <code>S</code> in an abelian category, I have been looking for the isomorphism between <code>S.homology</code> and <code>Limits.cokernel S.abelianImageToKernel</code> in mathlib and not finding it, which makes me feel very stupid. Is that isomorphism really not there? (It did seem like the perfect use of <code>ShortComplex.abelianImageToKernel</code>.)</p>\n<p>Just to be clear:<br>\n(1) I am aware of <code>ShortComplex.homology'IsoHomology</code> that says that the homology is <code>S</code> is the cokernel of <code>imageToKernel</code>, but I want to use the actual kernel and image (in its <code>Abelian.image</code> version) with their universal properties and all their API, not their \"subobject\" versions.<br>\n(2) I am also aware of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Homology/ImageToKernel.html#imageToKernel'\">imageToKernel'</a> and of its isomorphism with <code>imageToKernel</code>, however mathlib does not seem to know that <code>imagetoKernel'</code> is a monomorphism, while it does know that <code>abelianImageToKernel</code> is; also, and more importantly because the <code>Mono</code> part would be easy to fix, I find <code>Abelian.image</code> much easier to use than <code>Limits.image</code>...<br>\n(3) I am also aware that the isomorphism between <code>Abelian.image</code> and <code>Limits.image</code> is in mathlib, however I did not find the compatibility betweem this isomorphism and the various versions of the <code>imageToKernel</code> morphism. In fact, it cost me some trouble to prove this.<br>\n(4) I did write my own code for the isomorphism I want, I just find it horribly ugly. Here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Homology</span><span class=\"bp\">.</span><span class=\"n\">ShortComplex</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">image_compat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageIsoImage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imageToKernel'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">abelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Mono</span><span class=\"bp\">.</span><span class=\"n\">right_cancellation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernel</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Epi</span><span class=\"bp\">.</span><span class=\"n\">left_cancellation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageIsoImage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">conv_lhs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">inv_hom_id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">id_comp</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">imageToKernel'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">kernel</span><span class=\"bp\">.</span><span class=\"n\">lift_ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsImage</span><span class=\"bp\">.</span><span class=\"n\">isoExt_inv</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">isImage_lift</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">ShortComplex</span><span class=\"bp\">.</span><span class=\"n\">abelianImageToKernel_comp_kernel_ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">equalizer_as_kernel</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Epi</span><span class=\"bp\">.</span><span class=\"n\">left_cancellation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">factorThruImage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">fac</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">fac_lift_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageStrongEpiMonoFactorisation_I</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageStrongEpiMonoFactorisation_e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">kernel</span><span class=\"bp\">.</span><span class=\"n\">lift_ι</span><span class=\"o\">]</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"bp\">.</span><span class=\"n\">homologyIsoCokernelAbelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">homology</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">cokernel</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">abelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">homology'IsoHomology</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">homology'IsoCokernelImageToKernel'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">mapIso</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imageToKernel'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">abelianImageToKernel</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageIsoImage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Epi</span><span class=\"bp\">.</span><span class=\"n\">left_cancellation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageIsoImage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">symm_hom</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">hom_inv_id</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">id_comp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">image_compat</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 443950795,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718096337
    },
    {
        "content": "<p>In fact I found more formulas for the homology of a short complex <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Homology/ShortComplex/Abelian.html\">there</a>, but I couldn't figure out an easy way to get the one I wanted. I'm hoping that this is just because I missed something.</p>",
        "id": 443952013,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718096719
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Homology</span><span class=\"bp\">.</span><span class=\"n\">ShortComplex</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"bp\">.</span><span class=\"n\">homologyIsoCokernelAbelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">homology</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">cokernel</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">abelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">homology'IsoHomology</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">≪≫</span><span class=\"w\"> </span><span class=\"n\">homology'IsoCokernelImageToKernel'</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">≪≫</span>\n<span class=\"w\">    </span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">mapIso</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Abelian</span><span class=\"bp\">.</span><span class=\"n\">imageIsoImage</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Iso</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">imageToKernel'</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>Looks better, but maybe there's a way to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian#doc\">docs#CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian</a>. <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> might know more.</p>",
        "id": 443955792,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1718097911
    },
    {
        "content": "<p>Usually any purely category theoretical compatibility arguments could be proved with <code>ext; simp</code>. If not, we are probably missing simp lemmas. <br>\nAlso why do you find <code>Limits.image</code> hard to work with? Can you list some pain points so that we can try to improve the API?</p>",
        "id": 443957852,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1718098539
    },
    {
        "content": "<p>The purpose of the file <code>ShortComplex.Abelian</code> was to show the existence of a <code>HomologyData</code>, such that the \"left\" homology and \"right\" homology are respectively given by the coimage/image of a certain map, which are isomorphic because of one of the characterizations of abelian categories.</p>",
        "id": 443975369,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718104352
    },
    {
        "content": "<p>I have not formalized this specific isomorphism, but it should be easy following the general principle of the API that in order to compute the homology, we may provide a structure <code>LeftHomologyData</code> (or <code>RightHomologyData</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Homology.ShortComplex.Abelian</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">LeftHomologyData.ofIsColimitCokernelCoforkAbelianImageToKernel</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CokernelCofork</span><span class=\"w\"> </span><span class=\"n\">S.abelianImageToKernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsColimit</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S.LeftHomologyData</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernel</span><span class=\"w\"> </span><span class=\"n\">S.g</span>\n<span class=\"w\">  </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cc.pt</span>\n<span class=\"w\">  </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">S.g</span>\n<span class=\"w\">  </span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cc.π</span>\n<span class=\"w\">  </span><span class=\"n\">wi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernelIsKernel</span><span class=\"w\"> </span><span class=\"n\">S.g</span>\n<span class=\"w\">  </span><span class=\"n\">wπ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Abelian.factorThruImage</span><span class=\"w\"> </span><span class=\"n\">S.f</span><span class=\"w\"> </span><span class=\"bp\">≫=</span><span class=\"w\"> </span><span class=\"n\">cc.condition</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">comp_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cancel_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">hπ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CokernelCofork.IsColimit.ofπ</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hcc.desc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CokernelCofork.ofπ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cancel_epi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Abelian.factorThruImage</span><span class=\"w\"> </span><span class=\"n\">S.f</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">comp_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cancel_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)])))</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hcc.fac</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Cofork.IsColimit.hom_ext</span><span class=\"w\"> </span><span class=\"n\">hcc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"o\">))</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">homologyIsoCokernelAbelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S.homology</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">cokernel</span><span class=\"w\"> </span><span class=\"n\">S.abelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">LeftHomologyData.ofIsColimitCokernelCoforkAbelianImageToKernel</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cokernelIsCokernel</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">homologyIso</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div>",
        "id": 443975377,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718104356
    },
    {
        "content": "<p>The definitions with names like <code>homology'</code> or <code>homology'IsoHomology</code> are remains of the old homology API, and shall be removed at some point...</p>",
        "id": 443975523,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718104418
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Formula.20for.20the.20homology.20if.20a.20short.20complex.20.60S.60/near/443957852\">said</a>:</p>\n<blockquote>\n<p>Usually any purely category theoretical compatibility arguments could be proved with <code>ext; simp</code>. If not, we are probably missing simp lemmas. <br>\nAlso why do you find <code>Limits.image</code> hard to work with? Can you list some pain points so that we can try to improve the API?</p>\n</blockquote>\n<p>Thank you for the nicer code!</p>\n<p>Concerning <code>Limits.image</code>, I've mostly worked with abelian categories so far, so for me the image is the kernel of the cokernel and I use that a lot. But <code>Limits.image</code> does not behave like that. For example I tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Homology</span><span class=\"bp\">.</span><span class=\"n\">ShortComplex</span><span class=\"bp\">.</span><span class=\"n\">Abelian</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">KernelFork</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">KernelFork</span><span class=\"bp\">.</span><span class=\"n\">ofι</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n</code></pre></div>\n<p>And then I asked <code>simp</code> to close the goal. It couldn't. Then I asked <code>exact?</code>, and it also couldn't. Then I asked <code>apply?</code>, used its first suggestion and after that <code>simp</code> closed the goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">KernelFork</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">KernelFork</span><span class=\"bp\">.</span><span class=\"n\">ofι</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">comp_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">fac_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Okay, then I tried to see if lean knew that <code>IsLimit (test f)</code>, but I couldn't find it.</p>\n<p>I'm actually quite happy to use <code>Abelian.image</code> instead, until I run into stuff like what I mentioned in my original message, where some things exist for <code>Limits.image</code> for not <code>Abelian.image</code>. (I was trying to prove that a short complex <code>S</code> is exact if and only if the canonical morphism from the image of <code>S.f</code> to the kernel of <code>S.g</code> is an isomorphism and went back and forth on which version of the image I was supposed to use, since mathlib knew that <code>S.homology</code> is isomorphic to  the cokernel of <code>imageToKernel' S.f S.g S.zero</code> but not that that morphism is a monomorphism, while it knew that <code>S.abelianImageToKernel</code> is a monomorphism but not that <code>S.homology</code> is isomorphic to its cokernel!)</p>",
        "id": 444060531,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718126884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Formula.20for.20the.20homology.20if.20a.20short.20complex.20.60S.60/near/443975377\">said</a>:</p>\n<blockquote>\n<p>I have not formalized this specific isomorphism, but it should be easy following the general principle of the API that in order to compute the homology, we may provide a structure <code>LeftHomologyData</code> (or <code>RightHomologyData</code>):</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Algebra.Homology.ShortComplex.Abelian</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span>\n\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Abelian</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">LeftHomologyData.ofIsColimitCokernelCoforkAbelianImageToKernel</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CokernelCofork</span><span class=\"w\"> </span><span class=\"n\">S.abelianImageToKernel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsColimit</span><span class=\"w\"> </span><span class=\"n\">cc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S.LeftHomologyData</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernel</span><span class=\"w\"> </span><span class=\"n\">S.g</span>\n<span class=\"w\">  </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cc.pt</span>\n<span class=\"w\">  </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">S.g</span>\n<span class=\"w\">  </span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cc.π</span>\n<span class=\"w\">  </span><span class=\"n\">wi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">kernelIsKernel</span><span class=\"w\"> </span><span class=\"n\">S.g</span>\n<span class=\"w\">  </span><span class=\"n\">wπ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Abelian.factorThruImage</span><span class=\"w\"> </span><span class=\"n\">S.f</span><span class=\"w\"> </span><span class=\"bp\">≫=</span><span class=\"w\"> </span><span class=\"n\">cc.condition</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">comp_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cancel_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">hπ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CokernelCofork.IsColimit.ofπ</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hcc.desc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">CokernelCofork.ofπ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">π</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cancel_epi</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Abelian.factorThruImage</span><span class=\"w\"> </span><span class=\"n\">S.f</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">comp_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">assoc</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">cancel_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">kernel.ι</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)])))</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hcc.fac</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Cofork.IsColimit.hom_ext</span><span class=\"w\"> </span><span class=\"n\">hcc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"o\">))</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">homologyIsoCokernelAbelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">S.homology</span><span class=\"w\"> </span><span class=\"bp\">≅</span><span class=\"w\"> </span><span class=\"n\">cokernel</span><span class=\"w\"> </span><span class=\"n\">S.abelianImageToKernel</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">LeftHomologyData.ofIsColimitCokernelCoforkAbelianImageToKernel</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">cokernelIsCokernel</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">homologyIso</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">ShortComplex</span>\n\n<span class=\"kd\">end</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks for the code!</p>\n<p>I understand that homology in mathlib is in the middle of an overhaul so it may be too early, but I think that this particular isomorphism should be there when homology is stabilized, because it's the definition that is most familiar to people in math.</p>",
        "id": 444168251,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718178000
    },
    {
        "content": "<p>(And the dual isomorphism as well, of course! Though I cannot argue that \"kernel of the morphism from the cokernel to <code>S.f</code> to the coimage of <code>S.g</code>\" is the definition that is commonly taught for the cohomology, I found myself just now using it without meaning to. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> )</p>",
        "id": 444171118,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718179009
    },
    {
        "content": "<p>The homology API provides <code>S.cycles</code> (which is isomorphic to kernel of <code>S.g</code>, though it is not definitionally equal to it), and <code>S.homology</code> identifies to the cokernel of the morphism <code>S.toCycles : S.X₁ ⟶ S.cycles</code>. Then, any factorization of <code>S.toCycles</code> as an epi followed by another map (typically a mono) would give an alternative expression of the homology as a cokernel (even though, we may have missing definitions in order to show this: the API for cokernel coforks could be improved so that the <code>hπ</code> field above would become a one-liner). (More precisely if <code>p ≫ g = f</code> with <code>p</code> an epi, then there is an equivalence between cokernel coforks of <code>f</code> and <code>g</code>, and colimit coforks correspond via this bijection.)</p>",
        "id": 444185438,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718183347
    },
    {
        "content": "<p>I would like to encourage people to use more <code>S.cycles</code> and all this homology API. This is the reason why I am not completely sure we absolutely need this particular isomorphism. The API already allows to construct and prove results in several different manners, and every time we introduce new isomorphisms, it is yet another way to phrase definitions and lemmas, even though the differences are only superficial, and introducing new isomorphisms also means that we need more simp lemmas to express the compatibilities they satisfy. If it is very important for certain applications, we will add it, but I would rather wait and see...</p>",
        "id": 444185467,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718183354
    },
    {
        "content": "<p>The dual definition <code>S.opcycles</code> (and <code>S.homology</code> as a kernel instead of a cokernel) is actually very important for the applications. When I formalized Verdier's approach to spectral sequences from <em>Des catégories dérivées des catégories abéliennes</em>, even though there is no explicit mention of it in the book, certain objects which appear in the computations can be interpreted as <code>S.opcycles</code> for some <code>S</code>, and it turned out that for every lemma about <code>cycles</code>, I had to prove a dual one for <code>opcycles</code> in order to formalise spectral sequences in general abelian categories.</p>",
        "id": 444185481,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718183359
    },
    {
        "content": "<p>Okay, I'll see if I can things with <code>cycles</code> instead of <code>kernel</code> then.</p>\n<p>I will probably be trying to use spectral sequences soon, and then things should get really fun. I am trying to formalize some constructions/lemmas of Beilinson (plus some additional stuff I had to do) about filtered triangulated categories, realization functors etc.</p>",
        "id": 444269660,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718207278
    },
    {
        "content": "<p>It will take a lot of time before the following (undocumented) code on spectral objects in triangulated categories and abelian categories, and spectral sequences enters mathlib:<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/tree/jriou_localization/Mathlib/Algebra/Homology/SpectralObject\">https://github.com/leanprover-community/mathlib4/tree/jriou_localization/Mathlib/Algebra/Homology/SpectralObject</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/tree/jriou_localization/Mathlib/Algebra/Homology/SpectralSequence\">https://github.com/leanprover-community/mathlib4/tree/jriou_localization/Mathlib/Algebra/Homology/SpectralSequence</a></p>",
        "id": 444317815,
        "sender_full_name": "Joël Riou",
        "timestamp": 1718221368
    },
    {
        "content": "<p>No problem, I have been using a terrible Frankensteined merge of mathlib and your \"localization\" branch for a while now, because I was doing stuff with t-structures and I didn't want to write the definition of the cohomology functor myself. So in that way I already have spectral sequences in my branch.</p>",
        "id": 444383289,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1718255053
    }
]