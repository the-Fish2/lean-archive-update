[
    {
        "content": "<p>I really like <code>calc</code> proofs, they are pretty, easy to understand and easier to maintain (as you know what step broke when you change something). But they are sometimes a bit tedious to write out.</p>\n<p>Do we have a tactic that works a bit like <code>show_term</code>, but produces a nice sequence of <code>calc</code> steps?<br>\n(I could imagine a tactic that mangles the proof term to right-associate all <code>trans</code> rules, distributes <code>cong</code> into <code>trans</code>, and finally writes out the top-level sequence of <code>trans</code> steps a explicit calc steps.)<br>\nIf not, who would find it useful?</p>",
        "id": 391528678,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1694965667
    },
    {
        "content": "<p>What do you mean by \"distributes <code>cong</code> into <code>trans</code>\"?</p>",
        "id": 391529258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1694965818
    },
    {
        "content": "<p>something like <code>congr_arg f (Eq.trans h1 h2) = Eq.trans (congr_arg f h1) (congr_arg f h2)</code>.<br>\nOr in prose: A proof that takes two rewriting steps under some expression can be turned into a proof that takes two top-level rewriting steps, each under some expression.</p>",
        "id": 391529515,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1694965918
    },
    {
        "content": "<p>Of course, things can become arbitrary complicated when the relation isn’t equality, or when there are dependent motives, I expect… but I could imagine it would work well with rewriting <code>simp</code> or <code>rw</code> calls to more explicit forms.<br>\nVery much anti-golfing, of course :-)</p>",
        "id": 391530175,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1694966047
    },
    {
        "content": "<p>I cam back to this a bit, and just wanted to jot down some notes, mostly for my own reference later.</p>\n<p>The bulk of the work seems to be to massage the proof terms produced by <code>simp</code> and <code>rw</code> into long chain of <code>Eq.trans</code>. I started doing that with a manual traversal of the <code>Expr</code> syntax tree. This works somewhat:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: calc</span>\n<span class=\"sd\">  0 + n</span>\n<span class=\"sd\">  _ = n := (Nat.zero_add n)</span>\n<span class=\"sd\">  _ = 1 * n := (Eq.symm (Nat.one_mul n))</span>\n<span class=\"sd\">  _ = 1 * 1 * n := Eq.symm (congrFun (congrArg HMul.hMul (Nat.mul_one 1)) n)</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">calcify</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>but writing such code is rather tedious and error-prone.</p>\n<p>It would be nice to have a more convenient engine for applying rewrites to (proof) terms. We almost have that in the form of <code>simp</code>, and wouldn’t it be nice if I could just declare a bunch of rules like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">un_of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">of_eq_true</span> <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">Eq</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_self</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>and then run <code>simp</code> on a proof <em>term</em> to simplify it it.</p>\n<p>But naturally, <code>simp</code> isn't used to work on proof terms, and usually there is little point, so it normally refuses to do anything there. I applied  a little hack (branch <code>joachim/simp-prop</code>) of the form</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">--- a/src/Lean/Meta/Tactic/Simp/Main.lean</span>\n<span class=\"gi\">+++ b/src/Lean/Meta/Tactic/Simp/Main.lean</span>\n<span class=\"gu\">@@ -273,7 +273,7 @@ def getSimpLetCase (n : Name) (t : Expr) (b : Expr) : MetaM SimpLetCase := do</span>\n<span class=\"w\"> </span>partial def simp (e : Expr) : M Result := withIncRecDepth do\n<span class=\"w\"> </span>  checkSystem \"simp\"\n<span class=\"w\"> </span>  let cfg ← getConfig\n<span class=\"gd\">-  if (← isProof e) then</span>\n<span class=\"gi\">+  if ! cfg.simpProofs &amp;&amp; (← isProof e) then</span>\n<span class=\"w\"> </span>    return { expr := e }\n<span class=\"w\"> </span>  if cfg.memoize then\n<span class=\"w\"> </span>    if let some result := (← get).cache.find? e then\n</code></pre></div>\n<p>With that flag set, it at least <em>tries</em> to simplify a proof term  like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">of_eq_true</span>\n         <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">HAdd.hAdd</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">eq_self</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but fails with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.Tactic.simp.discharge</span><span class=\"o\">]</span> <span class=\"n\">un_of_eq_true</span><span class=\"o\">,</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">discharge</span> <span class=\"n\">hypotheses</span>\n      <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I believe the the problem is somewhere between near</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">tryTheoremCore</span> <span class=\"o\">(</span><span class=\"n\">lhs</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bis</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">BinderInfo</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">type</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">thm</span> <span class=\"o\">:</span> <span class=\"n\">SimpTheorem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">numExtraArgs</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">discharge</span><span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span> <span class=\"bp\">→</span> <span class=\"n\">SimpM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Expr</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">SimpM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Result</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">go</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">SimpM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">Result</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">isDefEq</span> <span class=\"n\">lhs</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n      <span class=\"n\">unless</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">synthesizeArgs</span> <span class=\"n\">thm.origin</span> <span class=\"n\">xs</span> <span class=\"n\">bis</span> <span class=\"n\">discharge</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"k\">do</span>\n        <span class=\"n\">return</span> <span class=\"n\">none</span>\n</code></pre></div>\n<p>and the fact that <code>isDefEq</code> does not assign assign some proof metavariables  (according to docs of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Meta.isAbstractedUnassignedMVar#doc\">docs#Lean.Meta.isAbstractedUnassignedMVar</a>), because despite</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.isDefEq</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">of_eq_true</span>\n      <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">Eq</span> <span class=\"bp\">?</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">b</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">eq_self</span>\n          <span class=\"bp\">?</span><span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">=?=</span> <span class=\"n\">of_eq_true</span>\n      <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">congrFun</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"n\">Eq</span> <span class=\"o\">(</span><span class=\"n\">Eq.trans</span> <span class=\"o\">(</span><span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">HAdd.hAdd</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">eq_self</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>it still thinks it has to solve the <code>?h</code> hypothesis of the lemma, when I would expect the <code>isDefEq</code> to assign that metavariable.</p>\n<p>Enough tinkering for now, maybe I’ll return to this in a few months when maybe I understand all this better.</p>",
        "id": 410181961,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703698073
    },
    {
        "content": "<blockquote>\n<p>it still thinks it has to solve the ?h hypothesis of the lemma, when I would expect the isDefEq to assign that metavariable.</p>\n</blockquote>\n<p><code>isDefEq</code> doesn't assign proof variables, this is a known issue</p>",
        "id": 410183543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703699191
    },
    {
        "content": "<p>on the one hand it makes sense because of proof irrelevance, the answer is true without even assigning the variable, but- on the other hand assigning proof metavariables is also good to do since otherwise they come back as subgoals and the like, and because of proof irrelevance the only downside to assigning a proof metavariable is that this may make the metavariable depend on a local constant you did not want it to</p>",
        "id": 410183753,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703699356
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 410187285,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703701505
    },
    {
        "content": "<p>Are there other use cases that would benefit from assigning proof meta variables and might warrant a flag for this behavior?</p>",
        "id": 410188674,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1703702375
    },
    {
        "content": "<p>I tried to make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (with an unpatched <code>Lean</code>, so simplifying non-Prop-terms) to see how <code>simp</code> lemmas are applied when proof variables aren’t assigned, but at least in this example they are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Q</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">simp_lemma</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq.assign</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">):</span> <span class=\"n\">Q</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">simp_lemma</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>prints</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.isDefEq</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">Q</span> <span class=\"bp\">?</span><span class=\"n\">n</span> <span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"bp\">=?=</span> <span class=\"n\">Q</span> <span class=\"mi\">0</span> <span class=\"n\">h</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"bp\">?</span><span class=\"n\">n</span> <span class=\"bp\">=?=</span> <span class=\"mi\">0</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">?</span><span class=\"n\">n</span> <span class=\"o\">[</span><span class=\"n\">assignable</span><span class=\"o\">]</span> <span class=\"bp\">=?=</span> <span class=\"mi\">0</span> <span class=\"o\">[</span><span class=\"n\">nonassignable</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">assign</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"bp\">?</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"bp\">▶</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"bp\">=?=</span> <span class=\"n\">h</span> <span class=\"bp\">▼</span>\n    <span class=\"o\">[]</span> <span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"o\">[</span><span class=\"n\">assignable</span><span class=\"o\">]</span> <span class=\"bp\">=?=</span> <span class=\"n\">h</span> <span class=\"o\">[</span><span class=\"n\">nonassignable</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">assign</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"bp\">▼</span>\n      <span class=\"o\">[</span><span class=\"n\">beforeMkLambda</span><span class=\"o\">]</span> <span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n      <span class=\"o\">[</span><span class=\"n\">checkTypes</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n        <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"bp\">=?=</span> <span class=\"n\">P</span> <span class=\"mi\">0</span> <span class=\"bp\">▼</span>\n          <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"mi\">0</span> <span class=\"bp\">=?=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>So either this is too simple, compared to the example above, in some crucial way.</p>",
        "id": 410833120,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704195353
    },
    {
        "content": "<p>Ah, indeed, the example is too simple; this is better. With</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">opaque</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">axiom</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">P_of_succ</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">foo_eq</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">P_of_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.Tactic.simp</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq.assign</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">pp.proofs</span> <span class=\"n\">true</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">P_of_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">foo_eq</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>the <code>simp</code> lemma is not applied, because it cannot discharge <code>P n</code>, even though that could fall out of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">Meta.isDefEq</span><span class=\"o\">]</span> <span class=\"bp\">✅</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">P_of_succ</span> <span class=\"bp\">?</span><span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=?=</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">P_of_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">▼</span>\n  <span class=\"o\">[]</span> <span class=\"bp\">✅</span> <span class=\"bp\">?</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=?=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">▶</span>\n</code></pre></div>\n<p>Is it correct to say that in some (rare?) cases not unifying proofs prevents useful things from happening, but overall the benefits of not doing that outweigh that?</p>",
        "id": 410835409,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704196761
    },
    {
        "content": "<p>I now have a prototype at <a href=\"https://github.com/nomeata/lean-calcify\">https://github.com/nomeata/lean-calcify</a></p>",
        "id": 424284851,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709311258
    },
    {
        "content": "<p>This is really nice!</p>\n<p>I was thinking about requesting <em>exactly</em> this feature the other day (I had missed this thread). It's great to see it implemented!</p>\n<p>I hope to see this feature incorporated into Mathlib in the future.</p>",
        "id": 424329348,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1709328897
    },
    {
        "content": "<p>If you play around with it and help find the flaws, that would be great!</p>",
        "id": 424377083,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1709365018
    },
    {
        "content": "<p>I added support for <code>ite_cong</code>, so that it can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">info: Try this: calc</span>\n<span class=\"sd\">    if 0 + 1 * x = 0 then x + (2 * x + n) else 0 + n</span>\n<span class=\"sd\">    _ = if 0 + x = 0 then x + (2 * x + n) else 0 + n :=</span>\n<span class=\"sd\">    _ = if x = 0 then x + (2 * x + n) else 0 + n :=</span>\n<span class=\"sd\">    _ = if x = 0 then 0 + (2 * x + n) else 0 + n :=</span>\n<span class=\"sd\">    _ = if x = 0 then 0 + (2 * 0 + n) else 0 + n :=</span>\n<span class=\"sd\">    _ = if x = 0 then 0 + n else 0 + n :=</span>\n<span class=\"sd\">    _ = if x = 0 then n else 0 + n := (ite_congr (Eq.refl (x = 0)) (fun a =&gt; Nat.zero_add n) fun a =&gt; Eq.refl (0 + n))</span>\n<span class=\"sd\">    _ = if x = 0 then n else n := (ite_congr (Eq.refl (x = 0)) (fun a =&gt; Eq.refl n) fun a =&gt; Nat.zero_add n)</span>\n<span class=\"sd\">    _ = n := ite_self n</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span> <span class=\"k\">in</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">calcify</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"o\">(</span><span class=\"n\">config</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">}))</span>\n</code></pre></div>\n<p>(I removed some of the proofs in this paste because they are quite verbose.)</p>\n<p>The implementation is very unsatisfying; lots of code for just one congruence lemma, and ideally it should support general congrence lemmas. But that seems quite a tough metaprogramming puzzle…</p>",
        "id": 426224231,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1710283148
    }
]