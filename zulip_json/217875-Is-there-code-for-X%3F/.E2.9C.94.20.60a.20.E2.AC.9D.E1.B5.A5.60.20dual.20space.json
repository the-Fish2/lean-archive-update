[
    {
        "content": "<p>Given a vector <code>a</code> explicitly, I would like to express the map <code>a ⬝ᵥ</code> as an element of the dual space.<br>\nSimilar thing for a matrix <code>A</code> and the map <code>A *ᵥ</code> using the new notation.<br>\nI guess I don't have to prove their linearity on my own:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.DotProduct</span>\n<span class=\"kn\">open</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨(</span><span class=\"n\">a</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨⟨</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩,</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Where is it in Mathlib please?</p>",
        "id": 438416215,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715622404
    },
    {
        "content": "<p>I doubt we actually have either of these bundled as a linear map. But we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.dotProduct_smul#doc\">docs#Matrix.dotProduct_smul</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.dotProduct_add#doc\">docs#Matrix.dotProduct_add</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.dotProduct_zero#doc\">docs#Matrix.dotProduct_zero</a> for the first one.  And can't you realize the second one as an application of the first?</p>",
        "id": 438421941,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715624406
    },
    {
        "content": "<p>(also, if we <em>did</em> have this, we'd bundle it as a bilinear map anyway)</p>",
        "id": 438422269,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715624534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438421941\">said</a>:</p>\n<blockquote>\n<p>And can't you realize the second one as an application of the first?</p>\n</blockquote>\n<p>Of course I can.<br>\nHowever, I thought I would do in the Mathlib-idiomatic way and obtain API for free.</p>",
        "id": 438422725,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715624718
    },
    {
        "content": "<p>Afaik the Mathlib-idiomatic way almost never is \"treat your Matrix as a function from row index to (...)\".</p>",
        "id": 438423052,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715624862
    },
    {
        "content": "<p>Code for potential future visitors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.Matrix.DotProduct</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Matrix</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Matrix.dotProduct_toLinearMap</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨⟨(</span><span class=\"n\">a</span> <span class=\"bp\">⬝ᵥ</span> <span class=\"bp\">·</span><span class=\"o\">),</span> <span class=\"n\">Matrix.dotProduct_add</span> <span class=\"n\">a</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Matrix.dotProduct_smul</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Matrix.mulVec_toLinearMap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Matrix.dotProduct_toLinearMap</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Matrix.mulVec_toLinearMap_apply</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Matrix</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">A.mulVec_toLinearMap</span> <span class=\"bp\">·</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">*ᵥ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 438425315,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715625799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438423052\">said</a>:</p>\n<blockquote>\n<p>Afaik the Mathlib-idiomatic way almost never is \"treat your Matrix as a function from row index to (...)\".</p>\n</blockquote>\n<p>well, sure, unless you want to talk about the rows of your matrix ... which is exactly what you are trying to do here.</p>",
        "id": 438425918,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715626035
    },
    {
        "content": "<p>Also, just note that we have <code>Module.Dual R (J → R)</code> for <code>(J → R) →ₗ[R] R</code>, and likewise the type of <code>Matrix.mulVec_toLinearMap</code> (aside: that's a bad name, it sounds like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.mulVecLin#doc\">docs#Matrix.mulVecLin</a>) could be written as <code>I → Module.Dual R (J → R)</code>.</p>",
        "id": 438426461,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715626239
    },
    {
        "content": "<p>Thanks for pointing out! Should <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.mulVecLin#doc\">docs#Matrix.mulVecLin</a> be used inside my definition? I want to have good definitional equalities if possible.</p>",
        "id": 438426976,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715626424
    },
    {
        "content": "<p>It should just  replace your second definition?</p>",
        "id": 438431642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715628196
    },
    {
        "content": "<p>Hmmmm, it will lead to more reshuffling in the paper I am formalizing, but I don't see a good reason not to do it.<br>\nThanks!</p>",
        "id": 438433338,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715628822
    },
    {
        "content": "<p>It seems Mathlib does not have an analogue of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.mulVecLin#doc\">docs#Matrix.mulVecLin</a> for dotProduct. Should I PR it?</p>",
        "id": 438435050,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715629454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438422269\">said</a>:</p>\n<blockquote>\n<p>(also, if we <em>did</em> have this, we'd bundle it as a bilinear map anyway)</p>\n</blockquote>\n<p>Or is there a strong preference for this?</p>",
        "id": 438435927,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715629784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438431642\">said</a>:</p>\n<blockquote>\n<p>It should just  replace your second definition?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I think you misread <span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> 's definition.</p>",
        "id": 438436450,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715629968
    },
    {
        "content": "<p>I mean, I refactored the use case to fit what <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  suggested.</p>",
        "id": 438436536,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715629999
    },
    {
        "content": "<p>I think having the dot product bundled as a bilinear map would be fine.</p>",
        "id": 438436605,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715630026
    },
    {
        "content": "<p>You're right, I did; though upon second reading, it seems quite strange to me</p>",
        "id": 438436759,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715630073
    },
    {
        "content": "<p>In general, we can use <code>(α → β → γ)</code> and <code>(β → α → γ)</code> almost interchangeably.<br>\nWhen it comes to <code>(α → β →ₗ[F] γ)</code> and <code>(β →ₗ[F] α → γ)</code>, is it different?</p>",
        "id": 438437331,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715630287
    },
    {
        "content": "<p>Yes, those are reasonably different, but here you want <code>α →ₗ[F] β →ₗ[F] γ</code>, and for this we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.flip#doc\">docs#LinearMap.flip</a></p>",
        "id": 438437549,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715630385
    },
    {
        "content": "<p>Those both look to me at first glance like the maps alpha x beta -&gt; gamma which are linear in the second variable</p>",
        "id": 438437743,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1715630432
    },
    {
        "content": "<p>When I say \"reasonably different\" I mean from Lean's perspective. And the point is I don't think we have any API to go between them.</p>",
        "id": 438437985,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715630516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438437549\">said</a>:</p>\n<blockquote>\n<p>Yes, those are reasonably different, but here you want <code>α →ₗ[F] β →ₗ[F] γ</code>, and for this we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.flip#doc\">docs#LinearMap.flip</a></p>\n</blockquote>\n<p>In my example <code>α</code> is just the type of indexes. The linearity makes sense to me on <code>β →ₗ[F] γ</code> only.</p>",
        "id": 438438007,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715630522
    },
    {
        "content": "<p>The thing that is weird about your statement is that you have <code>(A.mulVec_toLinearMap · x) = A *ᵥ x</code> not <code>A.mulVec_toLinearMap x = (A *ᵥ x)</code></p>",
        "id": 438438084,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715630536
    },
    {
        "content": "<p>And once you fix that, you're left with <code>mulVecLin</code></p>",
        "id": 438438177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715630579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438437549\">said</a>:</p>\n<blockquote>\n<p>Yes, those are reasonably different, but here you want <code>α →ₗ[F] β →ₗ[F] γ</code>, and for this we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.flip#doc\">docs#LinearMap.flip</a></p>\n</blockquote>\n<p>Would your type even mean anything if <code>α</code> is not equipped with addition?</p>",
        "id": 438438289,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715630635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438435927\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438422269\">said</a>:</p>\n<blockquote>\n<p>(also, if we <em>did</em> have this, we'd bundle it as a bilinear map anyway)</p>\n</blockquote>\n<p>Or is there a strong preference for this?</p>\n</blockquote>\n<p>Arguably yes; but this opens the noncommutative rings can of worms, and you end up with <code>(I → R) →ₗ[R] (J → R) →ₗ[S] R</code> to cover that case too (where <code>S</code> is taken as <code>R</code> for commutative rings and <code>Rᵐᵒᵖ</code> for non-commutative ones)</p>",
        "id": 438438363,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715630651
    },
    {
        "content": "<p>Hell yeah! In the full version, I'd actually like to have <code>LinearOrderedDivisionRing</code> which does not exist yet.</p>",
        "id": 438438535,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715630729
    },
    {
        "content": "<p>Can you give an example of a LinearOrderedDivisionRing that isn't a field?</p>",
        "id": 438438767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715630814
    },
    {
        "content": "<p>I don't know. The paper talks about \"linearly ordered skew field\", so I guess there was a motivation for it.</p>",
        "id": 438438873,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715630862
    },
    {
        "content": "<p>It seems that if an ordered division ring is archimedean or algebraic over its center, then it's a field, but there are examples of interest otherwse. See <a href=\"https://math.hawaii.edu/~tom/mathfiles/orderings_skew.pdf\">here</a>.</p>",
        "id": 438439673,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715631166
    },
    {
        "content": "<p>Oh hey, this is the Witt-Grothendieck ring stuff that came up at LftCM 2023!</p>",
        "id": 438440388,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715631429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438438289\">said</a>:</p>\n<blockquote>\n<p>Would your type even mean anything if <code>α</code> is not equipped with addition?</p>\n</blockquote>\n<p>Should I care about  the difference between <code>(α → β →ₗ[F] γ)</code> and <code>(β →ₗ[F] α → γ)</code> in my setting?</p>",
        "id": 438440395,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715631432
    },
    {
        "content": "<p>If you don't care about the difference, then it sounds like you don't need either of them</p>",
        "id": 438444893,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715633178
    },
    {
        "content": "<p>I mean, I have <code>(Fin m → β →ₗ[F] F)</code> where <code>β</code> is a vector space (not necessarily having finite base).</p>",
        "id": 438445213,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715633305
    },
    {
        "content": "<p>Right, and I claim that<code>β →ₗ[F] (Fin m → F)</code> is more useful because it takes arguments in the expected order</p>",
        "id": 438446506,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715633745
    },
    {
        "content": "<p>And you can go from that to your version (or vice versa) with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.pi#doc\">docs#LinearMap.pi</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.proj#doc\">docs#LinearMap.proj</a></p>",
        "id": 438446683,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715633808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60a.20.E2.AC.9D.E1.B5.A5.60.20dual.20space/near/438444893\">said</a>:</p>\n<blockquote>\n<p>If you don't care about the difference, then it sounds like you don't need either of them</p>\n</blockquote>\n<p>Can you elaborate?</p>",
        "id": 438450404,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715635122
    },
    {
        "content": "<p>I don't understand why <code>Matrix.mulVec_toLinearMap A i</code> is of any use to you as a linear map when you can write <code>Matrix.dotProduct_toLinearMap (A i)</code> instead to get the same linear map</p>",
        "id": 438450704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635222
    },
    {
        "content": "<p>In contrast the other ordering of arrows <em>is</em> a useful linear map in its own right; it just sounds like not the one you wanted after all.</p>",
        "id": 438450836,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715635277
    },
    {
        "content": "<p>Speaking of <code>LinearOrderedDivisionRing</code> is it possible for me to get rid of the following line?<br>\n<a href=\"https://github.com/madvorak/vcsp/blob/3da0844a11e4128d9011adcd5b4c4867a5528ae2/VCSP/FarkasBartl.lean#L30\">https://github.com/madvorak/vcsp/blob/3da0844a11e4128d9011adcd5b4c4867a5528ae2/VCSP/FarkasBartl.lean#L30</a></p>",
        "id": 438773547,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715769786
    },
    {
        "content": "<p>Only by changing the definition in mathlib</p>",
        "id": 438792736,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715776872
    },
    {
        "content": "<p>Thanks for the reply! I'm not going to do it now.</p>",
        "id": 438792816,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1715776909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> has marked this topic as resolved.</p>",
        "id": 438792829,
        "sender_full_name": "Notification Bot",
        "timestamp": 1715776914
    },
    {
        "content": "<p>But I don't think mathlib wants <code>LinearOrderedDivisionRing</code> unless someone is actively interested in contributing an <code>instance : LinearOrderedDivisionRing _</code> that is not just the one from <code>LinearOrderedField</code></p>",
        "id": 438792917,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1715776935
    },
    {
        "content": "<p>True, but if we split the hierarchies, then having theorems about linear ordered division rings would be pretty easy.</p>",
        "id": 438808096,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715781369
    },
    {
        "content": "<p>From having played around the algebraic order hierarchy a lot, I don't think there's that many to be had</p>",
        "id": 438808237,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1715781417
    },
    {
        "content": "<p>My point is that Martin has some above.</p>",
        "id": 438814938,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1715782981
    },
    {
        "content": "<p>One day, people will want to formalize cases of hasse principle on real algebraic varieties and Mathlib will be ready for that.</p>",
        "id": 439095696,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1715891273
    }
]