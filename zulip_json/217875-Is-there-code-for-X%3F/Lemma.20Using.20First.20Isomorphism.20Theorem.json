[
    {
        "content": "<p>Hello, I'm a master student (new in Lean) trying to Re-proving First Isomorphism Theorem and some corollaries. I managed to give a proof of the First Isomorphism Theorem using the \"lift\" function and now I'm trying to do an exercise using it.  In particular, the following  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ProdCylic</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">H.Normal</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">K.Normal</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Disjoint</span> <span class=\"n\">H</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">H.index</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">K.index</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.mk'</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.mk'</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n <span class=\"k\">have</span> <span class=\"n\">fSurj</span> <span class=\"o\">:</span> <span class=\"n\">Function.Surjective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n <span class=\"k\">have</span> <span class=\"n\">KerCap</span> <span class=\"o\">:</span> <span class=\"n\">f.ker</span> <span class=\"bp\">=</span> <span class=\"n\">H</span> <span class=\"bp\">⊓</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">MonoidHom.ker_prod</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">QuotientGroup.ker_mk'</span><span class=\"o\">,</span><span class=\"n\">QuotientGroup.ker_mk'</span><span class=\"o\">]</span>\n  <span class=\"n\">done</span>\n <span class=\"k\">have</span> <span class=\"n\">KerCapBot</span> <span class=\"o\">:</span> <span class=\"n\">f.ker</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">KerCap</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h.eq_bot</span>\n    <span class=\"n\">done</span>\n <span class=\"k\">have</span> <span class=\"n\">fImage</span> <span class=\"o\">:</span> <span class=\"n\">f.range</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">MonoidHom.range_top_iff_surjective</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">fSurj</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">eq_top_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">fSurj</span>\n  <span class=\"gr\">sorry</span>\n <span class=\"k\">have</span> <span class=\"n\">FirstIso</span> <span class=\"o\">:=</span> <span class=\"n\">first_isomorphism_theorem</span> <span class=\"n\">f</span>\n <span class=\"k\">have</span> <span class=\"n\">KerTrivial</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.quotientMulEquivOfEq</span> <span class=\"n\">KerCapBot</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n <span class=\"k\">have</span> <span class=\"n\">GBot</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">QuotientGroup.quotientBot.symm</span>\n  <span class=\"n\">done</span>\n <span class=\"k\">have</span> <span class=\"n\">concatenation</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"n\">G</span><span class=\"bp\">⧸</span><span class=\"n\">MonoidHom.ker</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MulEquiv.trans</span> <span class=\"n\">GBot</span> <span class=\"n\">KerTrivial</span>\n  <span class=\"n\">done</span>\n <span class=\"k\">have</span> <span class=\"n\">finalIso</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"n\">MonoidHom.range</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MulEquiv.trans</span> <span class=\"n\">concatenation</span> <span class=\"n\">FirstIso</span>\n  <span class=\"n\">done</span>\n <span class=\"k\">have</span> <span class=\"n\">fImageIso</span> <span class=\"o\">:</span> <span class=\"n\">f.range</span> <span class=\"bp\">≃*</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n <span class=\"k\">have</span> <span class=\"n\">finalIso</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃*</span> <span class=\"o\">((</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">MulEquiv.trans</span> <span class=\"n\">finalIso</span> <span class=\"n\">fImageIso</span>\n  <span class=\"n\">done</span>\n <span class=\"n\">exact</span> <span class=\"n\">finalIso</span>\n</code></pre></div>\n<p>In particular I got stucked in proving f.range = ((G ⧸ H) × (G ⧸ K)) because I'd like to find a theorem which gives that the product of projection has image the product of images (since for ker it exists). But I was unable to find it with <a href=\"http://moogle.ai\">moogle.ai</a> or such. So I thought it could have been a good idea proving that f is surjective and then unfold who the codomain is, but I failed since I got problem in understanding how to use \\top to my purpose. </p>\n<p>Finally, the other theorem I'd like to know the name that I'm not finding is the one giving f.range ≃* ((G ⧸ H) × (G ⧸ K)) since I should have proved f.range = ((G ⧸ H) × (G ⧸ K)).</p>\n<p>Any help would be appreciated as any other tip about the code as well, thank you for your time.</p>",
        "id": 409341592,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703149267
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 409427392,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703177440
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 409427447,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703177457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"675865\">@brokkilisoup</span> I don't have time to read your question in details, but did you do the very similar exercise from <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>?</p>",
        "id": 409427614,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703177519
    },
    {
        "content": "<p>The exercise is at the end of Section 8.1 and decomposed into several statements.</p>",
        "id": 409427736,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703177555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lemma.20Using.20First.20Isomorphism.20Theorem/near/409427736\">ha scritto</a>:</p>\n<blockquote>\n<p>The exercise is at the end of Section 8.1 and decomposed into several statements.</p>\n</blockquote>\n<p>Yes Indeed, and I managed to solve it. Here I didn't want to use the Theorem strictly related to first isomorphism theorem in mil since I made my own proof of first isomorphism theorem for exercise, and I was trying to use it to re-solve this corollary. But I got stucked here since I can't find the names for the theorems I'd like to apply.</p>",
        "id": 409456802,
        "sender_full_name": "brokkilisoup",
        "timestamp": 1703188917
    },
    {
        "content": "<p>Well, one thing that might help for this particular exercise is use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.index_inf_le#doc\">docs#Subgroup.index_inf_le</a> to show that <code>G</code> is actually finite with order <code>p^2</code>, and from there show that <code>H</code> and <code>K</code> satisfy <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup.IsComplement%27#doc\">docs#Subgroup.IsComplement'</a>.</p>",
        "id": 409743571,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1703360127
    }
]