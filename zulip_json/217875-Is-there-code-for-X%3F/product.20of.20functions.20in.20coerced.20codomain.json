[
    {
        "content": "<p>Hello!<br>\nIs there a simple way to write a product of <code>f1 : X → ℂ</code> <code>f2 : X → ℝ</code>? Writing <code>f1 * f2</code> gives an error. Of course one can write <code>def f3 : X → ℂ := fun x =&gt; f1 x * f2 x</code>, but is there a reason why there is no coercion from <code>X → ℝ</code> to <code>X → ℂ</code> when there is a coercion <code>ℝ → ℂ</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f2</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"n\">f1</span> <span class=\"bp\">*</span> <span class=\"n\">f2</span> <span class=\"c1\">-- failed to synthesize instance  HMul (X → ℂ) (X → ℝ) ?m.19669</span>\n<span class=\"kd\">def</span> <span class=\"n\">f3</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f1</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f2</span> <span class=\"n\">x</span>\n<span class=\"k\">#check</span> <span class=\"n\">f3</span> <span class=\"n\">f1</span> <span class=\"n\">f2</span>\n</code></pre></div>",
        "id": 430222788,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1711701959
    },
    {
        "content": "<p><code>f2 • f1</code> should do the trick. important to note is that in this case, the function to <code>ℝ</code> has to be on the left side for this notation</p>",
        "id": 430236134,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711708609
    },
    {
        "content": "<p>also, it works for any <code>f2:X → Y</code> as long as there is an instance <code>SMul Y ℝ</code> (or more generally <code>SMul Y ℂ</code>)</p>",
        "id": 430236674,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1711708814
    },
    {
        "content": "<p>The reason why there is no coercion from <code>X → ℝ</code> to <code>X → ℂ</code> is that it would lead to pretty poor performance</p>",
        "id": 430237162,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1711709021
    },
    {
        "content": "<p><code>#check f1 * ((f2 ·) : X → ℂ)</code> also works.</p>",
        "id": 430238630,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1711709764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/product.20of.20functions.20in.20coerced.20codomain/near/430236134\">said</a>:</p>\n<blockquote>\n<p><code>f2 • f1</code> should do the trick.</p>\n</blockquote>\n<p>Note this approach can behave unpredictably if the right function takes two arguments (for instance, is a vector-valued function where the second argument is the index) but the left takes one.</p>",
        "id": 430239139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711710009
    },
    {
        "content": "<p>ok, thanks to you all for your replies!<br>\nso is there a common/canonical choice or one just uses a preferred way?</p>\n<p>actually I wanted to take <code>f1 : C₀(X, ℂ)</code> <code>f2 : C₀(X, ℝ)</code> and have that <code>f1 * f2 : C₀(X, ℂ)</code>. there are several ways to do an equivalent thing, and I wonder which is the best.</p>",
        "id": 430250137,
        "sender_full_name": "Yoh Tanimoto",
        "timestamp": 1711715957
    }
]