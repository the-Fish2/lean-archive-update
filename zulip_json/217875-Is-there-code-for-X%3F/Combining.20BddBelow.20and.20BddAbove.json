[
    {
        "content": "<p>Is it worth bundling together the <code>BddBelow</code> and <code>BddAbove</code> properties into a single predicate, say <code>OrdBounded</code>?  This would be particularly useful on the reals since in that case it is equivalent to <code>Bornology.IsBounded</code>.  One could bundle a large number of the existing lemmas concerning <code>BddBelow</code> and <code>BddAbove</code> separately into lemmas for <code>OrdBounded</code>, e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OrdBounded</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">BddBelow</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">BddAbove</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">OrdBounded.mono</span> <span class=\"o\">⦃</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">⦄</span> <span class=\"o\">⦃</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">OrdBounded</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">OrdBounded</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hb</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span> <span class=\"n\">BddBelow.mono</span> <span class=\"n\">h</span> <span class=\"n\">hb.1</span><span class=\"o\">,</span> <span class=\"n\">BddAbove.mono</span> <span class=\"n\">h</span> <span class=\"n\">hb.2</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">OrdBounded.icc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"o\">(</span><span class=\"n\">Set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">bddBelow_Icc</span><span class=\"o\">,</span> <span class=\"n\">bddAbove_Icc</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">OrdBounded.ico</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"o\">(</span><span class=\"n\">Set.Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">bddBelow_Ico</span><span class=\"o\">,</span> <span class=\"n\">bddAbove_Ico</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">OrdBounded.ioc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"o\">(</span><span class=\"n\">Set.Ioc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">bddBelow_Ioc</span><span class=\"o\">,</span> <span class=\"n\">bddAbove_Ioc</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">OrdBounded.ioo</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"o\">(</span><span class=\"n\">Set.Ioo</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">bddBelow_Ioo</span><span class=\"o\">,</span> <span class=\"n\">bddAbove_Ioo</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ordBounded_of_subset_of_icc</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">OrdBounded.mono</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">OrdBounded.icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ordBounded_def</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">Set.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">bddBelow_bddAbove_iff_subset_Icc</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ordBounded_iff_bounded</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span>  <span class=\"n\">Bornology.IsBounded</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Real.isBounded_iff_bddBelow_bddAbove.symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Int.finite_iff_bounded</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OrdBounded</span> <span class=\"n\">I</span> <span class=\"bp\">↔</span> <span class=\"n\">Set.Finite</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>  <span class=\"n\">Set.finite_iff_bddBelow_bddAbove.symm</span>\n</code></pre></div>",
        "id": 418437804,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706380674
    },
    {
        "content": "<p>I think what we should have is a class <code>OrderBornology</code> asserting that the ambient bornology on a type is the one induced by the order. But yes, we should make some API for this kind of things</p>",
        "id": 418439435,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706382283
    },
    {
        "content": "<p>In fact, I think I would also like to remove the <code>MetricSpace -&gt; Bornology</code> instance (maybe localize it ?), and have a <code>MetricBornology</code> class, but this is an other discussion</p>",
        "id": 418439493,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1706382354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Combining.20BddBelow.20and.20BddAbove/near/418439435\">said</a>:</p>\n<blockquote>\n<p>I think what we should have is a class <code>OrderBornology</code> asserting that the ambient bornology on a type is the one induced by the order. But yes, we should make some API for this kind of things</p>\n</blockquote>\n<p>Perhaps one should have both, since `OrdBounded' only defines a bornology assuming one has meets and joins.</p>",
        "id": 418442195,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706385096
    },
    {
        "content": "<p>Anatole, having a <code>MetricBornology</code> class wouldn't really solve our bornology problems, would it? I thought the issue was more that we don't want it to be a class at all.</p>",
        "id": 418442380,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706385289
    },
    {
        "content": "<p>Feel free to split the discussion topic.</p>",
        "id": 418442395,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1706385320
    }
]