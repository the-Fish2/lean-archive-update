[
    {
        "content": "<p>In case I'm XYing it, I'll start by saying that what I'm really trying to do is make an inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">_Memory</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">_Memory</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">false</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span>\n</code></pre></div>\n<p>which I've achieved with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">canonical</span><span class=\"o\">:</span> <span class=\"n\">_Memory</span> <span class=\"bp\">→</span> <span class=\"n\">_Memory</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">v</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">f.canonical</span><span class=\"o\">,</span> <span class=\"n\">t.canonical</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">,</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span>\n  <span class=\"bp\">|</span> <span class=\"n\">v'</span><span class=\"o\">,</span> <span class=\"n\">f'</span><span class=\"o\">,</span> <span class=\"n\">t'</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">v'</span> <span class=\"n\">f'</span> <span class=\"n\">t'</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">setoid</span><span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">_Memory</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"n\">lhs</span> <span class=\"n\">rhs</span> <span class=\"o\">:=</span> <span class=\"n\">lhs.canonical</span> <span class=\"bp\">=</span> <span class=\"n\">rhs.canonical</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">Eq.refl</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Eq.symm</span><span class=\"o\">,</span> <span class=\"n\">Eq.trans</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Memory</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">_Memory.setoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Memory</span><span class=\"o\">):</span> <span class=\"n\">Memory</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦.</span><span class=\"n\">node</span> <span class=\"n\">v</span> <span class=\"n\">f.out</span> <span class=\"n\">t.out</span><span class=\"bp\">⟧</span>\n\n<span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">Memory</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦.</span><span class=\"n\">leaf</span><span class=\"bp\">⟧</span>\n</code></pre></div>\n<p>but I'd like to be able to use structural recursion directly on type Memory, instead of having to define it on _Memory (admittedly I can also use <code>termination_by</code>, but that also isn't great).</p>\n<p>In particular I can prove (I've left it as sorry here -since the proof is a little bit involved) a recOn rule as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Memory.recOn.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"o\">:</span> <span class=\"n\">Memory</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Memory</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">leaf</span><span class=\"o\">:</span> <span class=\"n\">motive</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Memory</span><span class=\"o\">),</span> <span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"n\">t</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">t</span><span class=\"o\">)):</span>\n  <span class=\"n\">motive</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I'd like to be able to write a <code>[match_pattern]</code> def that allows me to inductively define a rule. F.x.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">countOnes</span><span class=\"o\">:</span> <span class=\"n\">Memory</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Memory</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b.toNat</span> <span class=\"bp\">+</span> <span class=\"n\">countOnes</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">countOnes</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>instead of writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">countOnes</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">Memory</span><span class=\"o\">):</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Memory.recOn</span> <span class=\"n\">m</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f_ih</span> <span class=\"n\">t_ih</span> <span class=\"bp\">↦</span> <span class=\"n\">b.toNat</span> <span class=\"bp\">+</span> <span class=\"n\">f_ih</span> <span class=\"bp\">+</span> <span class=\"n\">t_ih</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In particular if I want to write something that pattern matches multiple levels, I can't do it directly with the rec function.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo</span><span class=\"o\">:</span> <span class=\"n\">Memory</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">b</span> <span class=\"bp\">.</span><span class=\"n\">leaf</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span> <span class=\"n\">b</span> <span class=\"n\">ff</span> <span class=\"n\">ft</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- foo ff</span>\n</code></pre></div>\n<p>The other way I thought about doing it is to define the inductive type with the condition directly, this seems a little built more annoying when building the API, but Lean won't let me use Or or not recursively.<br>\ni.e.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Memory</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">_Memory</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">≠</span> <span class=\"n\">leaf</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 'Memory.node' has a non positive occurrence of the datatypes being declared</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">_Memory</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">_Memory</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">value</span> <span class=\"bp\">∨</span> <span class=\"n\">t</span> <span class=\"bp\">≠</span> <span class=\"n\">leaf</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"n\">leaf</span><span class=\"o\">)</span>\n<span class=\"c1\">-- invalid nested inductive datatype 'Or', nested inductive datatypes parameters cannot contain local variable</span>\n</code></pre></div>",
        "id": 411083518,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1704316609
    }
]