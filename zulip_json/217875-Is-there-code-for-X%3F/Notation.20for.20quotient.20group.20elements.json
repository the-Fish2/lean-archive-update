[
    {
        "content": "<p>I'm currently trying to define a property of cosets of a certain normal subgroup.<br>\nfor this, i need to treat elements of the quotient as cosets. (i'd like to define a function which means i need to be able to talk about the collection of cosets, as a type)</p>\n<p>what is the preferred spelling for this? there are currently two ways to spell this (which don't appear to be defeq, sadly), but my personal preference would be a third yet-to-be-added option... take the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">Coset</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"n\">g</span><span class=\"bp\">⟧</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- option 1. does not have as great of an api as option 2.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- option 2. using `rfl` doesn't unify this with option 1. this does seem to have good api, however.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- the same as option 2, but with coe-sugar</span>\n\n<span class=\"c1\">-- preferably i'd like to write things like g ∈ a.</span>\n</code></pre></div>\n<p>i am a bit at a loss for what i should do here, because at least  <code>⟦g⟧</code> is close to the notation you might come across in a paper as denoting a coset. i would rather not use <code>↑g</code> as meaning \"the coset containing <code>g</code>\".</p>",
        "id": 442202116,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717408006
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">Coset</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">g</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>This works for me though</p>",
        "id": 442202544,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717408107
    },
    {
        "content": "<p>But you are right that mathlib prefer <code>QuotientGroup.mk</code> more.</p>",
        "id": 442202926,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717408205
    },
    {
        "content": "<p>Do you have a concrete example of what you need? I'm guessing that <code>G ⧸ N</code> is good enough but I have to see the applications to make sure.</p>",
        "id": 442203115,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717408260
    },
    {
        "content": "<p>ah, i realise why i thought they weren't defeq: the simp-nf is not the same for them.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"n\">x</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟦</span><span class=\"n\">y</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp?</span><span class=\"w\"> </span><span class=\"n\">says</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 442203881,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717408444
    },
    {
        "content": "<p>and at that point they no longer unify with <code>rfl</code></p>",
        "id": 442203958,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717408464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Notation.20for.20quotient.20group.20elements/near/442202926\">said</a>:</p>\n<blockquote>\n<p>But you are right that mathlib prefer <code>QuotientGroup.mk</code> more.</p>\n</blockquote>\n<p>but the square brackets look so much nicer <span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span></p>",
        "id": 442204549,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717408609
    },
    {
        "content": "<p>as for my specific use case, i'd like to pick the infimum of a function <code>G -&gt; Nat</code> per-coset. i already have <code>Fintype N</code>, all that really seems to be missing is an instance of <code>SetLike (G/N) G</code>...</p>",
        "id": 442205890,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717408923
    },
    {
        "content": "<p>Yeah I think <code>SetLike</code> would be a nice way of doing it; we're currently experimenting with <code>SetLike</code> for <code>RingCon</code> as a model for two-sided ideals at Imperial and it's working great.</p>",
        "id": 442211976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717410365
    },
    {
        "content": "<p>it <em>is</em> a bit annoying that you would have to define these instances for all instances of <code>HasQuotient</code> because the notation seems to be opaque... it would have been a bit easier if the way to say <code>A / B</code> has some meaning was rather something along these lines:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">AlternativeQuotientClass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">to_setoid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">A</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">AlternativeQuotientClass</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AlternativeQuotientClass</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inst</span><span class=\"bp\">.</span><span class=\"n\">to_setoid</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>this way, you can give a single instance for <code>SetLike (A / b) A</code>. Would i be correct in assuming that this definition would still be a fit for most of mathlib?</p>",
        "id": 442215289,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717411222
    },
    {
        "content": "<p>The advantage of Lean's opaque quotients is that the proof that the universal diagram commutes is <code>rfl</code>, and if quotients were defined via setoids then the universal property would spit out functions which would not even be computable (\"use the axiom of choice to take a random element of the coset, and apply the function to that\").</p>",
        "id": 442217207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717411766
    },
    {
        "content": "<p>i think there is some kind of miscommunication here... for instance,<br>\nthere is the following definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instHasQuotientSubgroup</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasQuotient</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">leftRel</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 442217759,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717411921
    },
    {
        "content": "<p>i don't see the problem with making this go via <code>AlternativeQuotientClass</code>...</p>",
        "id": 442217949,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717411980
    },
    {
        "content": "<p>this quotient <em>is already</em> defined via a setoid</p>",
        "id": 442218032,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412012
    },
    {
        "content": "<p>not <em>as</em> one, but <em>via</em> one</p>",
        "id": 442218260,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412070
    },
    {
        "content": "<p>Sorry, you're right. Rather than editing my message and confusing things even more I'll say what I meant to say here: if quotients were defined via <em>equivalence classes</em> (i.e. a type whose terms were subsets) then (what I said above).</p>",
        "id": 442218495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717412144
    },
    {
        "content": "<p>While this might work, I think practically every <code>A / B</code> in mathlib is based on <code>HasQuotient α (Subgroup α)</code> or its additive version, so I don't think it is that much of a work to \"define these instances for all instances of <code>HasQuotient</code>\" (which is practically two, and practically one under <code>to_additive</code>)?</p>",
        "id": 442218690,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717412194
    },
    {
        "content": "<p>(But now I realise that \"define them as equivalence classes\" is not what you're suggesting)</p>",
        "id": 442218749,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717412215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Notation.20for.20quotient.20group.20elements/near/442218690\">said</a>:</p>\n<blockquote>\n<p>While this might work, I think practically every <code>A / B</code> in mathlib is based on <code>HasQuotient α (Subgroup α)</code> or its additive version, so I don't think it is that much of a work to \"define these instances for all instances of <code>HasQuotient</code>\" (which is practically two, and practically one under <code>to_additive</code>)?</p>\n</blockquote>\n<p>as i've just found out : Not the case. i defined the version for <code>AddSubgroup</code>, but because i'm actually taking the quotient with <code>Submodule</code>, it fails to synthesise the instance...</p>",
        "id": 442219656,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412486
    },
    {
        "content": "<p>I don't think we have quotients by submonoids?</p>",
        "id": 442220322,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717412673
    },
    {
        "content": "<p>oh sorry i meant submodules</p>",
        "id": 442220359,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412685
    },
    {
        "content": "<p>Yeah but it should be one line away?</p>",
        "id": 442220470,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717412723
    },
    {
        "content": "<p>the point is that you're still duplicating code</p>",
        "id": 442220575,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412753
    },
    {
        "content": "<p>also, i'm not sure how you'd make it one line?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddSubgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">QuotientAddGroup</span><span class=\"bp\">.</span><span class=\"n\">instSetLike</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">coe_injective'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x'</span><span class=\"o\">,</span><span class=\"n\">hx'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">QuotientAddGroup</span><span class=\"bp\">.</span><span class=\"n\">mk_surjective</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">heq</span><span class=\"w\"> </span><span class=\"n\">x'</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx'</span><span class=\"o\">,</span><span class=\"n\">true_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">heq</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"c1\">-- this fails</span>\n</code></pre></div>\n<p>here is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> , if you'd like to give it a try</p>",
        "id": 442220881,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412834
    },
    {
        "content": "<p>I think <br>\n<code>instance : SetLike (A / B) A := inferInstanceAs (SetLike (A / B.toAddSubgroup) A)</code><br>\nis the best you can get?</p>",
        "id": 442220905,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717412841
    },
    {
        "content": "<p>that <em>is</em> short <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 442221020,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717412875
    },
    {
        "content": "<p>Please, <em>please</em> don’t make it easy to see elements of <code>G/N</code> as sets in <code>G</code>. This will only encourage people to write bad code. This is a habit inherited from teachers trying to be nice to students discovering abstract maths, but in the long run this is making everything more complicated. In 99% cases those people should be using the universal property, and for the other cases we still have the projection to the quotient.</p>",
        "id": 442249730,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717420480
    },
    {
        "content": "<p>I think for his particular use case, it is fine to have this API? Is including this piece of warning somewhere near the <strong>scoped</strong> instance good enough?</p>",
        "id": 442252228,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717421094
    },
    {
        "content": "<p>personally i don't see the harm. The fact that the type depends on those parameters already means that there are many types for \"the same\" group. Also, a proof is a proof is a proof, and when that proof becomes more understandable because it has an <em>intuitive representation</em>, that is a better proof imo</p>",
        "id": 442252930,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717421248
    },
    {
        "content": "<p>No, that’s not how formalized math work. I’m sure you will be happier in the long run if you try to think in more efficient terms, and change your intuition if needed.</p>",
        "id": 442254256,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717421556
    },
    {
        "content": "<p>Could you share your code so that we can have a less abstract discussion?</p>",
        "id": 442254345,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717421579
    },
    {
        "content": "<p>i'm afraid it's a bit much to share as a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>... i'm currently working on formalizing the simplicity of the Mathieu-24 group</p>",
        "id": 442255344,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717421788
    },
    {
        "content": "<p>for that, i have defined the extended binary GolayCode</p>",
        "id": 442255422,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717421810
    },
    {
        "content": "<p>in order to prove simplicity, i will need to define the action of the automorphisms of the GolayCode (which are some mononomials on 2^24) on the cosets where the minimal weight is equal to 4</p>",
        "id": 442255774,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717421887
    },
    {
        "content": "<p>this \"minimal weight\" notion is where i need the coersion to sets.</p>",
        "id": 442256023,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717421948
    },
    {
        "content": "<p>i intend to define the following function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">golay_code_space</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">minimal_weight</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">golay_code_space</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">GolayCode</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 442256391,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717422040
    },
    {
        "content": "<p>i intend on doing this by casting <code>x:(golay_code_space / GolayCode)</code> to <code>Finset (Fin 4 x Fin 6)</code>, then using <code>Finset.inf'</code> with <code>hammingNorm : golay_code_space -&gt; Nat</code></p>",
        "id": 442256798,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717422127
    },
    {
        "content": "<p>We cannot really be sure without seeing what you need to prove, but with what you provided so far, it seems you could define your <code>minimal_weight</code> function using</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">argminOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">wellFounded_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">⁻¹'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk_surjective</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How is that more complicated than trying to get a <code>SetLike</code> instance?</p>",
        "id": 442280149,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717427196
    },
    {
        "content": "<p>This is using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.argminOn#doc\">docs#Function.argminOn</a></p>",
        "id": 442280299,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717427229
    },
    {
        "content": "<p>Note that finiteness of <code>N</code> is completely irrelevant here since <code>ℕ</code> is well-founded.</p>",
        "id": 442280588,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717427283
    },
    {
        "content": "<p>As far as simplicity of M24 is concerned, have you considered the outline given in <a href=\"https://planetmath.org/proofofsimplicityofmathieugroups\">PlanetMath</a>, which just uses multiple transitivity of the permutation action?</p>",
        "id": 442298752,
        "sender_full_name": "Scott Carnahan",
        "timestamp": 1717430853
    },
    {
        "content": "<p>i had not. however, it would seem that that still relies on the simplicity of projective special linear groups in addition to the fact that M21 is isomorphic to PSL (3,F4), neither of which seem easy to prove (from my perspective) or are in mathlib</p>",
        "id": 442300424,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717431134
    },
    {
        "content": "<p>i am attempting to follow the proof in <a href=\"https://link.springer.com/book/10.1007/978-1-84800-988-2\">The Finite Simple Groups</a></p>",
        "id": 442301311,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717431290
    },
    {
        "content": "<p>Did you coordinate with <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span>? He worked a lot on Iwasawa’s simplicity criterion.</p>",
        "id": 442303068,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1717431610
    },
    {
        "content": "<p>i did not coordinate, but i am aware of their work. i am planning on assuming the criterion.</p>",
        "id": 442303543,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717431706
    },
    {
        "content": "<p>In any case, the Iwasawa criterion is now a PR, <a href=\"https://github.com/leanprover-community/mathlib4/pull/12048\">#12048</a> (with merge conflicts to solve, and a few dependent PR before that…)</p>",
        "id": 442338820,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1717439782
    }
]