[
    {
        "content": "<p>I recently had need of the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ico_Int_ofNat_eq_Int_ofNat_ico</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set.Ico</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Int.ofNat</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">Set.Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span> <span class=\"o\">⟩</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">Int.eq_ofNat_of_zero_le</span> <span class=\"o\">((</span><span class=\"n\">Int.zero_le_ofNat</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">⟩</span>\n    <span class=\"n\">norm_cast</span> <span class=\"n\">at</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span>\n    <span class=\"n\">use</span> <span class=\"n\">n</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">norm_cast</span>\n</code></pre></div>\n<p>Of course there are also analogues for<code>Set.Icc</code>, <code>Set.Ioc</code>, <code>Set.Ioo</code>, <code>Set.Ioi</code>, <code>Set.Ici</code> (but not <code>Set.Iio</code>, <code>Set.Iic</code>).  Is this lemma essentially already in Mathlib?  I was unable to locate it with standard searches.</p>",
        "id": 417281288,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705944810
    },
    {
        "content": "<p>Is <code>Int.ofNat</code> the common spelling? Have you looked at <code>Nat.cast</code>? (Just guessing)</p>",
        "id": 417285618,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1705946308
    },
    {
        "content": "<p>I guess one could formulate a general assertion about monotone maps which preserve convexity (injectivity would also be needed for some variants)</p>",
        "id": 417286240,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705946523
    },
    {
        "content": "<p>But unfortunately <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Convex#doc\">docs#Convex</a> is not the right notion.</p>",
        "id": 417286331,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705946554
    },
    {
        "content": "<p>In any case, I'm surprised that we don't have such a lemma already in mathlib, using <code>Nat.cast</code>.</p>",
        "id": 417288286,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1705947289
    },
    {
        "content": "<p>Seems that I missed it</p>",
        "id": 417288513,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705947349
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> if you try <code>simp</code> on your lemma, it changes <code>Int.ofNat a</code> to <code>↑a</code> (the notation for <code>Nat.cast a</code>), which is a hint that this is the preferred spelling for mathlib lemmas (<code>Int.ofNat a</code> is not in \"simp normal form\")</p>",
        "id": 417291471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705948360
    },
    {
        "content": "<p>How would one write the lemma using <code>Nat.cast</code> to specifically cast to the integers?  Just replace all occurrences of <code>Int.ofNat</code> with <code>Nat.cast (R := ℤ)</code> (or <code>fun n ↦ (n:ℤ)</code>)?  In any event I was not able to find this lemma in a <code>Nat.cast</code> form either.</p>",
        "id": 417307393,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705954343
    },
    {
        "content": "<p>If <code>(n : \\N)</code> then you can just write <code>(n : \\Z)</code> and Lean will cast it.</p>",
        "id": 417307900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705954544
    },
    {
        "content": "<p>Yes I agree that the main issue is that the lemma isn't there even in the simp normal form :-)</p>",
        "id": 417308022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1705954579
    },
    {
        "content": "<p>OK, so <code>Set.Ico (a:ℤ) (b:ℤ) = (fun (n:ℕ) ↦ (n:ℤ)) '' (Set.Ico a b)</code> seems to work as an alternate spelling.  (Not sure how to name it now though.)</p>",
        "id": 417308067,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705954601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Identifying.20intervals.20of.20N.20with.20intervals.20of.20Z/near/417286240\">said</a>:</p>\n<blockquote>\n<p>I guess one could formulate a general assertion about monotone maps which preserve convexity (injectivity would also be needed for some variants)</p>\n</blockquote>\n<p>I guess the general assertion is that if a map between totally ordered spaces is monotone, injective, and has <code>OrdConnected</code> image, then it maps intervals to intervals; if it is monotone, injective, and has <code>UpperSet</code> image, then it maps right-infinite intervals to right-infinite intervals; and if it is monotone, injective, and has <code>LowerSet</code> image, then it maps left-infinite intervals to left-infinite intervals.</p>",
        "id": 417309271,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705955093
    },
    {
        "content": "<p>also without the hypotheses on the image (and for partially ordered sets instead of totally ordered sets) one always has a set inclusion instead of equality.  (For <code>Set.Icc</code> one can also drop injectivity.)</p>",
        "id": 417309892,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705955321
    },
    {
        "content": "<p>We already have a few lemmas about <code>OrdConnected</code> range. See around <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CovBy#doc\">docs#CovBy</a>. Treatment is not very thorough yet.</p>",
        "id": 417312672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705956495
    },
    {
        "content": "<p>Ah, there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.image_subtype_val_Ico#doc\">docs#Set.image_subtype_val_Ico</a> etc. which already comes close to this.</p>",
        "id": 417312709,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705956508
    },
    {
        "content": "<p><code>Set.OrdConnected</code> assumptions really should not be typeclass arguments... <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 417312830,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705956563
    },
    {
        "content": "<p>To get from  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.image_subtype_val_Ico#doc\">docs#Set.image_subtype_val_Ico</a> to my original application, one would need that (a) <code>StrictMono</code> maps create an <code>OrderIso</code> between the domain and the image; and (b) intervals are preserved by <code>OrderIso</code>.  Presumably (a) is somewhere in <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Hom/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Hom/Basic.html</a> but I can't find (b) yet.</p>",
        "id": 417313382,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705956791
    },
    {
        "content": "<p>Actually (a) seems to be missing as well. (It's only true for linear orders, which may be one reason why it is missing.)</p>",
        "id": 417313604,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705956871
    },
    {
        "content": "<p>(a) does seem to be missing. (b) is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderIso.image_Icc#doc\">docs#OrderIso.image_Icc</a></p>",
        "id": 417315278,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705957550
    },
    {
        "content": "<p>So I guess the minimal thing to do is add (a) to Mathlib?  Then everything else can be done in like three lines of existing Mathlib code.</p>",
        "id": 417320759,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705959841
    },
    {
        "content": "<p>(Well, one needs a proof of <code>Set.OrdConnected (Set.range (fun (n:ℕ) ↦ (n:ℤ)))</code> (and also <code>UpperSet (Set.range (fun (n:ℕ) ↦ (n:ℤ)))</code>), but this isn't too hard. Maybe this could go into Mathlib too?)</p>",
        "id": 417322126,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705960347
    },
    {
        "content": "<p>All of this could go to Mathlib, we just need to find a good place for these lemmas.</p>",
        "id": 417354031,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705974968
    },
    {
        "content": "<p>(possibly, a new file for <code>Nat</code>/<code>Int</code>-specific lemmas)</p>",
        "id": 417354044,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705974976
    },
    {
        "content": "<p>It looks like we don't have <code>Set.range (Nat.cast : Nat → Int) = Ici 0</code></p>",
        "id": 417354223,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705975092
    },
    {
        "content": "<p>Do you want me to add some of this or you prefer to do it yourself?</p>",
        "id": 417355233,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705975686
    },
    {
        "content": "<p>I haven't actually done a mathlib PR before, and am unfortunately a bit overwhelmed with other tasks, so if you are willing to do the honours that would be great.  </p>\n<p>For what it's worth, here is a proof of the last statement you made:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Set.Ici</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">⟩</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Int.ofNat_nonneg</span> <span class=\"n\">n</span>\n  <span class=\"n\">exact</span> <span class=\"n\">CanLift.prf</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 417355607,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705975909
    },
    {
        "content": "<p>Not sure exactly how to even spell the <code>OrderIso</code> statement though.  Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OrderIso.image</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"n\">StrictMono</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n   <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">Set.range</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>?   I'm not very good at actually building isomorphisms.</p>",
        "id": 417356448,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705976399
    },
    {
        "content": "<p>I'll do it.</p>",
        "id": 417357093,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705976777
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=StrictMono.orderIso#doc\">docs#StrictMono.orderIso</a></p>",
        "id": 417357149,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705976822
    },
    {
        "content": "<p>Slick proof.</p>",
        "id": 417357378,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705976978
    },
    {
        "content": "<p>I started <a href=\"https://github.com/leanprover-community/mathlib4/tree/YK-nat-int-range\">branch#YK-nat-int-range</a>. I have family duties for the next hour, then I'll complete it before going to bed.</p>",
        "id": 417357823,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705977223
    },
    {
        "content": "<p>This is what the proof of my original lemma looks like now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Int.range_natCast</span> <span class=\"o\">:</span> <span class=\"n\">Set.range</span> <span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Ici</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Subset.antisymm</span> <span class=\"o\">(</span><span class=\"n\">range_subset_iff.2</span> <span class=\"n\">Int.ofNat_nonneg</span><span class=\"o\">)</span> <span class=\"n\">CanLift.prf</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ico_Int_ofNat_eq_Int_ofNat_ico</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">))</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">equiv</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">StrictMono.orderIso</span> <span class=\"n\">_</span> <span class=\"n\">Int.coe_nat_strictMono</span>\n  <span class=\"n\">change</span> <span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"n\">equiv</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">equiv</span> <span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Subtype.val</span> <span class=\"bp\">∘</span> <span class=\"n\">equiv</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">OrdConnected</span> <span class=\"o\">(</span><span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">Nat.cast</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">Int.range_natCast</span> <span class=\"bp\">▸</span> <span class=\"n\">Set.ordConnected_Ici</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">image_comp</span><span class=\"o\">,</span> <span class=\"n\">OrderIso.image_Ico</span><span class=\"o\">,</span> <span class=\"n\">image_subtype_val_Ico</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 417359464,
        "sender_full_name": "Terence Tao",
        "timestamp": 1705978237
    },
    {
        "content": "<p>I'm going to generalize lemmas about <code>Subtype.val</code> to an <code>OrderEmbedding</code> instead.</p>",
        "id": 417362344,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705979852
    },
    {
        "content": "<p>This is more work but it's better for future applications in the library.</p>",
        "id": 417362372,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705979875
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9927\">#9927</a> has all the intervals but <code>Ioi</code> and <code>Ici</code>. I'll add them once the kids are sleeping.</p>",
        "id": 417364486,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705981246
    },
    {
        "content": "<p>Done. <a href=\"https://github.com/leanprover-community/mathlib4/pull/9927\">#9927</a> and its dependencies.</p>",
        "id": 417372378,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705986484
    },
    {
        "content": "<p>Also note that <code>Data.Nat.Interval</code> exists</p>",
        "id": 417391498,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1705997682
    },
    {
        "content": "<p>There are also the <code>Finset</code> versions, e.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">image_cast_int_Icc_finset</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset.image</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Finset.Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Finset.Icc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>but I am not sure whether it is worth putting these into Mathlib also as they can be obtained from the set versions easily enough using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.coe_inj#doc\">docs#Finset.coe_inj</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.coe_image#doc\">docs#Finset.coe_image</a> , and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.coe_Icc#doc\">docs#Finset.coe_Icc</a>.</p>",
        "id": 417557057,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706058233
    },
    {
        "content": "<p>Those should probably be stated using <code>Finset.map</code> if possible</p>",
        "id": 417558475,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706059067
    },
    {
        "content": "<p>We <code>simp</code>lify <code>Filter.map</code> to <code>Filter.image</code>, so <code>simp</code> versions should use <code>Filter.image</code>.</p>",
        "id": 417567747,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706065912
    },
    {
        "content": "<p>I guess, <code>Finset</code> versions are provable by <code>mod_cast &lt;| image_cast_int_Icc a b</code></p>",
        "id": 417567829,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706065945
    },
    {
        "content": "<p>I'll have a look once <code>Set</code> versions are merged.</p>",
        "id": 417567844,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706065957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Identifying.20intervals.20of.20N.20with.20intervals.20of.20Z/near/417391498\">said</a>:</p>\n<blockquote>\n<p>Also note that <code>Data.Nat.Interval</code> exists</p>\n</blockquote>\n<p>It depends on <code>Finset</code>s, and these lemmas don't need <code>Finset</code>s.</p>",
        "id": 417567870,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706065981
    },
    {
        "content": "<p>Yes, but you should coordinate with those lemmas</p>",
        "id": 417593229,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706084109
    }
]