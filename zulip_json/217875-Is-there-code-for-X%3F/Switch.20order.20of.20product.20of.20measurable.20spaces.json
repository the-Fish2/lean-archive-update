[
    {
        "content": "<p>I'm trying to show that convolution of measures on a CommMonoid is commutative. On paper the proof is straightforward (included in the docstring in the below example), but I need to somehow reverse the order of coordinates in both the function and the product of measures in the application of map, and I'm not sure how to do this; it would boil down to filling in the sorry. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.Prod.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Measure</span>\n\n<span class=\"sd\">/-- Convolutions of measures. They are defined for arbitrary measures on a monoid M that is also</span>\n<span class=\"sd\">a measurable space. TODO: should get a to_additive version for AddMonoids -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">conv</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measure</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">Measure.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- To get commutativity, we need the underlying multiplication to be commutative. In this case,</span>\n<span class=\"sd\">we get for f(x,y) = xy that f⁻¹(B) = symm f⁻¹(B), where 'symm' is suggestive notation for flipping</span>\n<span class=\"sd\">around the cartesian coordinates. We can then use:</span>\n<span class=\"sd\">(μ*ν)(B) = (μ × ν)(f⁻¹(B)) = (μ × ν) (symm f⁻¹(B)) = (ν × μ) (f⁻¹(B)) = (ν × μ)(B). -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">comm</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">μ.conv</span> <span class=\"n\">ν</span> <span class=\"bp\">=</span> <span class=\"n\">ν.conv</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mul_comm</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">ν</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 410563609,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703960620
    },
    {
        "content": "<p>Any suggestions to make the proof more streamlined are welcome as well, of course! I had an earlier post about associativity of convolution, but (as far as I could tell) that requires stronger assumptions on the underlying space than I originally thought, so I've removed that post.</p>",
        "id": 410563775,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703960819
    },
    {
        "content": "<p>Try <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure.prod_swap#doc\">docs#MeasureTheory.Measure.prod_swap</a></p>",
        "id": 410567121,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703964303
    },
    {
        "content": "<p>Note that the definition of the product of measures is not symmetric, so you need the measures to be s-finite.</p>",
        "id": 410567169,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703964358
    },
    {
        "content": "<p>Can't you use the fact that <code>Prod.swap : M × M → M × M</code> sends <code>μ.prod ν</code> to <code>ν.prod μ</code>?</p>",
        "id": 410567213,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703964366
    },
    {
        "content": "<p>The following proof should work (not tested):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prod_swap</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prod.swap</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 410567270,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703964429
    },
    {
        "content": "<p>Should we introduce <code>Measure.map₂</code> similarly to <code>Set.image2</code>, <code>Filter.map₂</code> etc?</p>",
        "id": 410567309,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703964467
    },
    {
        "content": "<p>With <code>conv μ ν := map₂ (⋅ * ⋅) μ ν</code></p>",
        "id": 410567363,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703964499
    },
    {
        "content": "<p>I've tried that proof, but it doesn't fully cut it yet. Simp doesn't make progress (I've added SFinite for both measures)</p>",
        "id": 410572174,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703969356
    },
    {
        "content": "<p>I've written out three versions, all three proofs are incomplete.</p>\n<p>Also, perhaps I'm misunderstanding this, but I'm a bit confused that we would need SFinite for this, or is this assumption very innocuous? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Constructions.Prod.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Measure</span>\n\n<span class=\"sd\">/-- Convolutions of measures. They are defined for arbitrary measures on a monoid M that is also</span>\n<span class=\"sd\">a measurable space. TODO: should get a to_additive version for AddMonoids -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">conv</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Measure</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">Measure.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">comm1</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">ν</span><span class=\"o\">]:</span>\n    <span class=\"n\">μ.conv</span> <span class=\"n\">ν</span> <span class=\"bp\">=</span> <span class=\"n\">ν.conv</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prod_swap</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">Prod.swap</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">ν</span> <span class=\"n\">μ</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n      <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">Prod.swap</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">ν</span> <span class=\"n\">μ</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">comm2</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">ν</span><span class=\"o\">]:</span>\n    <span class=\"n\">μ.conv</span> <span class=\"n\">ν</span> <span class=\"bp\">=</span> <span class=\"n\">ν.conv</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prod_swap</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prod.swap</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">comm3</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">ν</span><span class=\"o\">]:</span>\n    <span class=\"n\">μ.conv</span> <span class=\"n\">ν</span> <span class=\"bp\">=</span> <span class=\"n\">ν.conv</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">×</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↦</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mul_comm</span> <span class=\"n\">x.1</span> <span class=\"n\">x.2</span>\n  <span class=\"k\">calc</span>\n    <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.2</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">μ</span> <span class=\"n\">ν</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x.1</span> <span class=\"bp\">*</span> <span class=\"n\">x.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Measure.prod</span> <span class=\"n\">ν</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prod_swap</span><span class=\"o\">]</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Prod.swap</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 410572563,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703969786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Switch.20order.20of.20product.20of.20measurable.20spaces/near/410567309\">said</a>:</p>\n<blockquote>\n<p>Should we introduce <code>Measure.map₂</code> similarly to <code>Set.image2</code>, <code>Filter.map₂</code> etc?</p>\n</blockquote>\n<p>Perhaps that is useful yes, do you think that would make it easier to work with e.g. convolutions of measures?</p>",
        "id": 410573344,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1703970547
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">comm</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableMul₂</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">ν</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">μ.conv</span> <span class=\"n\">ν</span> <span class=\"bp\">=</span> <span class=\"n\">ν.conv</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prod_swap</span><span class=\"o\">,</span> <span class=\"n\">map_map</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_def</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">measurability</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 410574723,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703972179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> What do you think about <code>map₂</code>?</p>",
        "id": 410574990,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703972533
    },
    {
        "content": "<p>I'm not sure if there are applications besides convolution (multiplicative+additive).</p>",
        "id": 410575002,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703972563
    },
    {
        "content": "<p>If no, then it makes no sense to introduce <code>map₂</code>.</p>",
        "id": 410575020,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703972599
    },
    {
        "content": "<p>I'm not sure if there are applications other than convolution of <code>map₂</code>, but it seems like a natural operation to define.</p>",
        "id": 410581922,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1703980484
    },
    {
        "content": "<p>It would describe the law of any binary operation applied to two independent random variables, which is a common enough operation in probability theory that I think it's worth setting up some API for (and for this application at least, the sigma-finite hypothesis is no restriction).  For instance, besides addition and multiplication, subtraction of two random variables is quite common, as is max and min. And one can start accessing triples, quadruples, etc. of independent random variables once one has API for pairs by grouping together one pair at a time (although it is possible to also work with <code>iIndepFun</code> after developing some further API there, which is what we did for PFR).</p>",
        "id": 410590531,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703986270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Switch.20order.20of.20product.20of.20measurable.20spaces/near/410574723\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">comm</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">MeasurableMul₂</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ν</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">μ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SFinite</span> <span class=\"n\">ν</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">μ.conv</span> <span class=\"n\">ν</span> <span class=\"bp\">=</span> <span class=\"n\">ν.conv</span> <span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">conv</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">prod_swap</span><span class=\"o\">,</span> <span class=\"n\">map_map</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Function.comp_def</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">measurability</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you!</p>",
        "id": 410611698,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1704006858
    },
    {
        "content": "<p>I put the definition of convolution of measures, commutativity of convolution of measures on CommMonoid and the finiteness of convolution of measures in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9372\">#9372</a>. This is very much WIP, feel free to add to this! Progress will probably be slow on my end, from my background I'm used to dealing with convolutions of measures in the probability theory setting, for which I'm used to having a bit more structure on the underlying space! If anyone has any recommendations for a good source for the more general theory, I am happy to hear them!</p>",
        "id": 410632673,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1704027749
    },
    {
        "content": "<p>If we want to integrate this with a pr that adds <code>Measure.map₂</code>, that is also fine with me of course!</p>",
        "id": 410634307,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1704029602
    }
]