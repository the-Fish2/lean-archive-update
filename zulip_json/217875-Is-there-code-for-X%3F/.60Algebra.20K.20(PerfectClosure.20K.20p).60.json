[
    {
        "content": "<p>I think <code>Algebra K (PerfectClosure K p)</code> is not in mathlib, only a ring homomorphism <code>PerfectClosure.of</code> from <code>K</code> to <code>PerfectClosure K p</code>. Is there any consideration not making <code>Algebra K (PerfectClosure K p)</code> an instance? I want to add the result <code>IsPurelyInseparable K (PerfectClosure K p)</code> in my work.</p>",
        "id": 407314990,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702326527
    },
    {
        "content": "<p>Maybe it was because of a diamond with <code>K = F_p</code>, but I think this is now solved. You can try and see what happens, but don't use <code>RingHom.toAlgebra</code>, it is usually a bad idea.</p>",
        "id": 407318661,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702328314
    },
    {
        "content": "<p>I think it works, at least there is no typeclass error (yet):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.ZMod.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.PerfectClosure</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">PerfectClosure</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"o\">(</span><span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">PerfectClosure</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">of</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toAlgebra</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">PerfectClosure</span> <span class=\"n\">F</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">F</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">induction_on</span> <span class=\"n\">x</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">iterate_frobenius</span><span class=\"o\">,</span> <span class=\"n\">iterate_frobenius_mk</span><span class=\"o\">]</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">ZMod</span> <span class=\"n\">p</span>\n  <span class=\"k\">have</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">PerfectClosure</span> <span class=\"n\">E</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">test2</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/407318661\">said</a>:</p>\n<blockquote>\n<p>... but don't use <code>RingHom.toAlgebra</code>, it is usually a bad idea.</p>\n</blockquote>\n<p>Can you explain a bit of this? If this is not supposed to be used, what is the better approach?</p>",
        "id": 407330831,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702333825
    },
    {
        "content": "<p>It usually creates diamond, but you can easily add the instance by hand.</p>",
        "id": 407332117,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702334424
    },
    {
        "content": "<p>Maybe in this specific case it doesn't, but avoiding it is usually a good idea. Is there already a <code>SMul</code> instance?</p>",
        "id": 407332883,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702334836
    },
    {
        "content": "<p>BTW it is 100% sure that we want a characteristic predicate rather than <code>PerfectClosure</code></p>",
        "id": 407333013,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702334917
    },
    {
        "content": "<p>I mean, we want both, but all the results should be about the characteristic predicate</p>",
        "id": 407333142,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702335001
    },
    {
        "content": "<p>I wonder why the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PerfectClosure#doc\">docs#PerfectClosure</a> doesn't use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.DirectLimit#doc\">docs#Ring.DirectLimit</a> ... but there's no Algebra instance there too.<br>\n(for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ring.Perfection#doc\">docs#Ring.Perfection</a> it's understandable as <del>there's apparently no dual API for inverse limits.</del> Edit: there's no need for API, as it's just a subring of the direct product. Maybe we should make it a subring?)</p>",
        "id": 407333680,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702335270
    },
    {
        "content": "<p>Would you really want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi>p</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Z_p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.975em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> to be a subring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><msup><mi>p</mi><mi>n</mi></msup><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\prod_n(\\Z/p^n\\Z)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497em;vertical-align:-0.2997em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.0017em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2997em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\">p</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">)</span></span></span></span>? Note that it also gives the correct topology so there are advantages...</p>",
        "id": 407337903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702337426
    },
    {
        "content": "<p>BTW, the (absolute) perfect closure (of a field) can be defined without talking about the characteristic: first define the (relative) perfect closure of <code>E/F</code> to be the compositum of all intermediate fields which are purely inseparable over <code>F</code>, then define the (absolute) perfect closure to be the relative perfect closure of <code>AlgebraicClosure F / F</code> <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>\n<p>PS: <code>AlgebraicClosure F</code> is indeed an algebra over <code>F</code>.</p>",
        "id": 407338076,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702337528
    },
    {
        "content": "<p>I thought that you could have two purely inseparable extensions whose composite was not purely inseparable. Am I wrong?</p>",
        "id": 407338201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702337641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/407333680\">said</a>:</p>\n<blockquote>\n<p>... but there's no Algebra instance there too.</p>\n</blockquote>\n<p>Unless the direct systems of these rings are all algebra over some base ring, and <code>IsScalarTower</code> for each morphism.</p>",
        "id": 407338388,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702337754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/407338201\">said</a>:</p>\n<blockquote>\n<p>I thought that you could have two purely inseparable extensions whose composite was not purely inseparable. Am I wrong?</p>\n</blockquote>\n<p>No, it's not possible. An equivalent characterization of purely inseparable <code>E/F</code> is that for any <code>x</code> in <code>E</code> there exists <code>n</code> such that <code>x^(q^n)</code> is contained in <code>F</code> where <code>q</code> is the exponential characteristic of <code>F</code> (cf. Wikipedia).</p>",
        "id": 407338666,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702337928
    },
    {
        "content": "<p>Therefore, if <code>x1...xn</code> are purely inseparable elements, then their rational functions are also purely inseparable elements.</p>",
        "id": 407338936,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702338105
    },
    {
        "content": "<p>Maybe we can define a <code>IsPerfectClosure</code> similar to <code>IsAlgClosure</code> and <code>IsSepClosure</code>? And in the definition of <code>IsPerfectClosure</code>, we are not talking about <code>p</code> directly, but use <code>ringChar</code> instead.</p>",
        "id": 407339385,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702338423
    },
    {
        "content": "<blockquote>\n<p>Unless the direct systems of these rings are all algebra over some base ring, and IsScalarTower for each morphism.</p>\n</blockquote>\n<p>Indeed, or the RingHoms need to be AlgHoms.</p>",
        "id": 407350818,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702344208
    },
    {
        "content": "<p>Wikipedia talks about universal properties of the perfect closure and the perfection:<br>\n<a href=\"/user_uploads/3121/8SE5qV697AmztI5S3B-N3YpF/image.png\">image.png</a><br>\nI guess universal properties are not ideal for definitions though (quantifies over a universe).</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/8SE5qV697AmztI5S3B-N3YpF/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/8SE5qV697AmztI5S3B-N3YpF/image.png\"></a></div>",
        "id": 407350843,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1702344228
    },
    {
        "content": "<p>I thought that Kenny lau did a bunch of perfection stuff years ago as part of his masters project with me. Do we not have this stuff already in some huge generality?</p>",
        "id": 407430429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702372841
    },
    {
        "content": "<p><code>Mathlib.FieldTheory.PerfectClosure</code> says \"Copyright (c) 2018 Kenny Lau. All rights reserved.\"</p>",
        "id": 407433799,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702373837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366779\">Jz Pan</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/407339385\">said</a>:</p>\n<blockquote>\n<p>Maybe we can define a <code>IsPerfectClosure</code> similar to <code>IsAlgClosure</code> and <code>IsSepClosure</code>? And in the definition of <code>IsPerfectClosure</code>, we are not talking about <code>p</code> directly, but use <code>ringChar</code> instead.</p>\n</blockquote>\n<p>I think we want the characteristic predicate. I am not sure about using <code>ringChar</code>, we should discuss this. What to do in characteristic 0?</p>",
        "id": 407434107,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702373942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/407350843\">said</a>:</p>\n<blockquote>\n<p>... I guess universal properties are not ideal for definitions though (quantifies over a universe).</p>\n</blockquote>\n<p>Oh I see. What about this: let <code>q</code> be the exponential character of a field <code>F</code> (which always exists, and is <code>if ringChar F = 0 then 1 else ringChar F</code>), then <code>E / F</code> is a perfect closure if and only if:</p>\n<ul>\n<li>for any <code>y</code> in <code>F</code> and any natural number <code>n</code>, there exists <code>x</code> in <code>E</code> such that <code>x ^ (q ^ n) = (algebraMap F E) y</code>.</li>\n<li>Conversely, for any <code>x</code> in <code>E</code> there exist <code>y</code> in <code>F</code> and a natural number <code>n</code> such that <code>x ^ (q ^ n) = (algebraMap F E) y</code>.</li>\n</ul>\n<p>Are these characterize <code>E</code> uniquely? I think it's true at least for fields.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/407434107\">said</a>:</p>\n<blockquote>\n<p>I think we want the characteristic predicate. I am not sure about using <code>ringChar</code>, we should discuss this.</p>\n</blockquote>\n<p>I don't know either. Maybe leave for experts.</p>\n<blockquote>\n<p>What to do in characteristic 0?</p>\n</blockquote>\n<p>In characteristic 0 case the perfect closure is itself. Correspondingly, the purely inseparable extensions are all trivial.</p>",
        "id": 407485486,
        "sender_full_name": "Jz Pan",
        "timestamp": 1702390473
    },
    {
        "content": "<p>We already have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PerfectRing#doc\">docs#PerfectRing</a>. If we define <code>IsPerfectClosure K p</code> as a perfect algebraic extension of <code>K</code> we are good right?</p>",
        "id": 407487601,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391000
    },
    {
        "content": "<p>The drawback is that we have to write <code>p</code></p>",
        "id": 407487629,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391010
    },
    {
        "content": "<p>For a general commutative ring of characteristic p the map to the perfection might not even be injective (it's just the colimit of A -&gt; A -&gt; A -&gt; ... where the maps are all x goes to x^p right?). It seems to me that these two conditions are very close to saying that the colimit surjects onto E but in the non-field case one might have to control the kernel.</p>",
        "id": 407487936,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702391094
    },
    {
        "content": "<p>Sorry, purely inseparable, not algebraic</p>",
        "id": 407487940,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> this is the perfection I think, not the perfect closure, they're dual notions</p>",
        "id": 407488054,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391128
    },
    {
        "content": "<p>So you're saying that the perfect closure of a commutative ring of characteristic p is not this colimit in general? I was using \"perfection\" and \"perfect closure\" to mean the same thing.</p>",
        "id": 407489046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702391394
    },
    {
        "content": "<p>I am using <a href=\"https://en.wikipedia.org/wiki/Perfect_field#Perfect_closure_and_perfection\">wikipedia</a> terminology</p>",
        "id": 407489547,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391496
    },
    {
        "content": "<p>I don't know if the perfect closure makes sense for a ring, but it does for a field</p>",
        "id": 407489636,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391519
    },
    {
        "content": "<p>The point is to have a map <em>from</em> the field to the perfect closure</p>",
        "id": 407489825,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391567
    },
    {
        "content": "<p>Yeah there's a map from A to the direct limit, just send it to the first factor.</p>",
        "id": 407490393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702391716
    },
    {
        "content": "<p>Oh sorry, I thought you were talking about the tilting procedure, or whatever it is (taking the inverse limit)</p>",
        "id": 407490652,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1702391784
    },
    {
        "content": "<p>Yeah having looked at the Wikipedia page it seems that there is one word which is used to mean two different things? :-/  Sorry, I was always talking about what Wikipedia calls perfect closure.</p>",
        "id": 407490929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702391873
    },
    {
        "content": "<p>Yeah the Wikipedia has two different definitions for it depending on the paragraph. Classic.</p>",
        "id": 407510979,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702397004
    },
    {
        "content": "<p>Maybe because there is no canonical choice of the map from <code>K</code> to <code>PerfectClosure K p</code>? You can twist it by <code>n</code>-th iterate of Frobenius for any integer <code>n</code>. Maybe this operation is needed in <code>p</code>-adic Hodge theory? I don't know.</p>",
        "id": 419231512,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706788895
    },
    {
        "content": "<p>There is a canonical choice of the map from a field to its perfect closure. The perfect closure of a commring K is a K-algebra with a universal property (it's initial in the category of perfect K-algebras).</p>",
        "id": 419262243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706798954
    },
    {
        "content": "<p>Do we have a characteristic predicate <code>IsPerfectClosure</code>? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPerfectClosure#doc\">docs#IsPerfectClosure</a></p>",
        "id": 419276982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706803002
    },
    {
        "content": "<p>Answer: no, but we should!</p>",
        "id": 419277047,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706803022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/419276982\">said</a>:</p>\n<blockquote>\n<p>Do we have a characteristic predicate <code>IsPerfectClosure</code>? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsPerfectClosure#doc\">docs#IsPerfectClosure</a></p>\n</blockquote>\n<p>Work in progress: <a href=\"https://github.com/leanprover-community/mathlib4/blob/12ab4a7eb6d9539b61833eecf64fde9f49f9e87f/Mathlib/FieldTheory/RelPerfectClosure.lean#L68-72\">https://github.com/leanprover-community/mathlib4/blob/12ab4a7eb6d9539b61833eecf64fde9f49f9e87f/Mathlib/FieldTheory/RelPerfectClosure.lean#L68-72</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/8696\">#8696</a></p>",
        "id": 419288654,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706806086
    },
    {
        "content": "<p>... which all depend on <a href=\"https://github.com/leanprover-community/mathlib4/pull/9488\">#9488</a>, which is in turn blocked by one other PR.</p>",
        "id": 419294055,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706807461
    },
    {
        "content": "<p>Since we can talk about perfect closure of a ring which is not a field, my WIP definition is not enough. What about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.FieldTheory.PerfectClosure</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">IsPerfectClosure</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">K</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">L</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">[</span><span class=\"n\">perfectRing</span> <span class=\"o\">:</span> <span class=\"n\">PerfectRing</span> <span class=\"n\">L</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">pow_mem'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span>\n</code></pre></div>\n<p>This works for general rings, and it has no dependencies on unmerged PRs.</p>\n<p>The <code>[CharP K p]</code> has to be written manually, otherwise it cannot be captured by the definition of <code>IsPerfectClosure</code> and we can talk about <code>IsPerfectClosure  Z F_p</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>.</p>",
        "id": 419317874,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706815676
    },
    {
        "content": "<p><del>But a prerequisite of adding such definition is adding <code>Algebra K (PerfectClosure K p)</code> to mathlib.</del></p>",
        "id": 419319621,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706816288
    },
    {
        "content": "<p>And then I think I can split the above WIP work as two PRs, one (even includes <code>perfectField_iff_splits_of_natSepDegree_eq_one</code>) does not depend on anything, another one which proves that the relative perfect closure is indeed a perfect closure depends on <a href=\"https://github.com/leanprover-community/mathlib4/pull/9488\">#9488</a>.</p>",
        "id": 419320174,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706816498
    },
    {
        "content": "<p>Unfortunately, the above definition is incorrent, it makes <code>F_p</code> a perfect closure of <code>F_p[X]</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. What about this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→+*</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fact</span> <span class=\"n\">p.Prime</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">K</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">L</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CharP</span> <span class=\"n\">M</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- If `i : K →+* L` is a ring homomorphism of characteristic `p` rings, then it makes `L`</span>\n<span class=\"sd\">a perfect closure of `K` if the following conditions are satisfied:</span>\n\n<span class=\"sd\">- `L` is a perfect ring,</span>\n<span class=\"sd\">- `i : K →+* L` is \"purely inseparable\" in the sense that for any element `x` of `L` there exists</span>\n<span class=\"sd\">  a natural number `n` such that `x ^ (p ^ n)` is contained in `K`.</span>\n<span class=\"sd\">- The kernel of `i` is contained in (in fact, equal to) the nilradical of `K`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">mk_iff</span><span class=\"kd\">]</span>\n<span class=\"kd\">class</span> <span class=\"n\">IsPerfectClosure</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n  <span class=\"o\">[</span><span class=\"n\">perfectRing</span> <span class=\"o\">:</span> <span class=\"n\">PerfectRing</span> <span class=\"n\">L</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n  <span class=\"n\">pow_mem'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">n</span>\n  <span class=\"n\">ker_le'</span> <span class=\"o\">:</span> <span class=\"n\">RingHom.ker</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">nilradical</span> <span class=\"n\">K</span>\n</code></pre></div>",
        "id": 419432080,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706870997
    },
    {
        "content": "<p>This second definition looks like a great definition of <code>IsPerfectClosure</code> because it avoids the universal property; in fact it feels quite similar to the definition of <code>IsLocalisation</code> which has been quite successful.</p>",
        "id": 419439222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706873616
    },
    {
        "content": "<p>Why do you not use <code>Algebra K L</code> in the latest definition?<br>\nI wondered why you use nilradical rather than the supremum of the kernels of <code>iterateFrobenius</code>, but then I realized that p^n tends to infinity. However if we replace CharP+Prime by ExpChar, then when ExpChar is 1 we need to say that the kernel is trivial.</p>",
        "id": 419584612,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706944957
    },
    {
        "content": "<p>I think that the concept of perfect closure should be bound to a fixed prime if we're dealing with rings, as opposed to being a general thing which applies to all rings and attempts to figure out what to do by first trying to check if there's a prime such that the ring has characteristic p etc etc. I don't think the perfect closure of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>6</mn><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/6\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/6</span><span class=\"mord mathbb\">Z</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> is a thing. I think the concept should be called <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-perfect closure.</p>",
        "id": 419591412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706951919
    },
    {
        "content": "<p>This is indeed the case (the field <code>perfectRing : PerfectRing L p</code> and <code>pow_mem'</code> already depend on <code>p</code>). It's just that CharP could be replaced by ExpChar after <a href=\"https://github.com/leanprover-community/mathlib4/pull/10016\">#10016</a>, which allows p = 1 (indicating CharZero).</p>",
        "id": 419592710,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706953094
    },
    {
        "content": "<p>Oh but the relative <code>perfectClosure</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9488\">#9488</a> doesn't take p as an argument; it basically takes p = ring_expChar R.</p>",
        "id": 419592865,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706953243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60Algebra.20K.20.28PerfectClosure.20K.20p.29.60/near/419584612\">said</a>:</p>\n<blockquote>\n<p>Why do you not use <code>Algebra K L</code> in the latest definition?</p>\n</blockquote>\n<p>Because by using this definition we don't need to add <code>Algebra</code> instance to the existing <code>PerfectClosure</code>.<br>\nWe can simply say <code>IsPerfectClosure (PerfectClosure.of K p) p</code>.</p>\n<blockquote>\n<p>I wondered why you use nilradical rather than the supremum of the kernels of <code>iterateFrobenius</code>, but then I realized that p^n tends to infinity. However if we replace CharP+Prime by ExpChar, then when ExpChar is 1 we need to say that the kernel is trivial.</p>\n</blockquote>\n<p>That's why I restrict current definition to prime characteristic case.</p>\n<p>[EDIT] But maybe you're right. We should use <code>p</code>-nilradical (contains <code>x</code> such that <code>x ^ p ^ n = 0</code> for some <code>n</code>) instead of nilradical, where <code>p</code> is the exponential characteristic. It is an ideal since <code>iterateFrobenius</code> is a ring homomorphism. In fact it is equal to nilradical for positive characteristic, and equal to zero for characteristic zero.</p>",
        "id": 419601626,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706960368
    },
    {
        "content": "<p>Now I have working definition of <code>PerfectRing.lift</code> and <code>IsPerfectClosure.equiv</code>, just like <code>IsSepClosed.lift</code> and <code>IsSepClosure.equiv</code>. Later I'll replace <a href=\"https://github.com/leanprover-community/mathlib4/pull/8696\">#8696</a> (was about separable closure, but now it only contains perfect closure) with that file (<span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>).</p>",
        "id": 419602399,
        "sender_full_name": "Jz Pan",
        "timestamp": 1706961122
    },
    {
        "content": "<p>Draft PR is uploaded to <a href=\"https://github.com/leanprover-community/mathlib4/pull/8696\">#8696</a>. Comments welcome.</p>",
        "id": 419657363,
        "sender_full_name": "Jz Pan",
        "timestamp": 1707009857
    }
]