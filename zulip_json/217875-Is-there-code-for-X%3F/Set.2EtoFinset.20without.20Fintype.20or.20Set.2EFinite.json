[
    {
        "content": "<p>Is the following variant of <code>Set.toFinset</code> already somewhere in Mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Set.toFinset'</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">dite</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.dec</span> <span class=\"o\">(</span><span class=\"n\">Set.Finite</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"n\">Set.Finite.toFinset</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_of_set_finite</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"n\">Set.Finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"n\">h.toFinset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Set.toFinset'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_of_finite</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"n\">s.toFinite.toFinset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">toFinite</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Set.toFinset'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_of_set_infinite</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Set.Infinite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mt</span> <span class=\"n\">Set.Finite.not_infinite</span> <span class=\"o\">(</span><span class=\"n\">not_not_intro</span> <span class=\"n\">h</span><span class=\"o\">),</span> <span class=\"n\">Set.toFinset'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_of_infinite</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">Infinite</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mt</span> <span class=\"n\">Set.Finite.not_infinite</span> <span class=\"o\">(</span><span class=\"n\">not_not_intro</span> <span class=\"o\">(</span><span class=\"n\">infinite_coe_iff.mp</span> <span class=\"n\">h</span><span class=\"o\">)),</span> <span class=\"n\">Set.toFinset'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_of_fintype</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"n\">s.toFinset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.toFinite</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Set.toFinset'</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>That is to say, the same operation as <code>Set.toFinset</code> or <code>Set.Finite.toFinset</code>, but without the requirement of <code>Set.Finite s</code> or <code>[Fintype s]</code>, instead assigning a junk value of <code>∅</code> in the case of infinite sets.  I found it useful to have this broader version of <code>Set.toFinset</code> in order to make certain definitions shorter (e.g., summing over a set that one eventually will prove is finite, but for which one doesn't want to embed the proof of finiteness into the definition that involves the sum).</p>\n<p>[Also, a tangential question: why does one need to suppress the argument <code>Set.Finite s</code> in the invocation of <code>dite</code>?  From <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dite#doc\">docs#dite</a> I would have thought I needed to write <code>dite (Set.Finite s) (h := Classical.dec (Set.Finite s)) Set.Finite.toFinset (fun _ ↦ ∅)</code>, but Lean doesn't like that spelling.]</p>",
        "id": 418374814,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706318627
    },
    {
        "content": "<p>I like the idea of this variant. I'd considered it before, but I didn't have a project to motivate it.</p>\n<p>Here's some more development on the idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Card</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Given a set `s`, `s.toFinset'` is a `Finset` that has the same elements as `s`</span>\n<span class=\"sd\">if `s` is a finite set.</span>\n<span class=\"sd\">This is similar to `s.toFinset` but it does not require a `Set.Finite` proof.</span>\n\n<span class=\"sd\">In case `s` is not finite, then it is defined to use `s.toFinset' = ∅`.</span>\n\n<span class=\"sd\">The specification for this function is given by the lemmas</span>\n<span class=\"sd\">`Set.Finite.toFinset'` and `Set.Infinite.toFinset'`.</span>\n\n<span class=\"sd\">This definition satisfies `s.toFinset'.card = s.ncard` (see `Set.card_toFinite'_eq_ncard`).</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Set.toFinset'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.dec</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span> <span class=\"k\">then</span> <span class=\"n\">h.toFinset</span> <span class=\"k\">else</span> <span class=\"bp\">∅</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Defining lemma specifying `s.toFinset'` if `s` is finite. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">Set.Finite.toFinset'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.Finite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"n\">h.toFinset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.toFinset'</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- missing set API</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">Set.Infinite.not_finite</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.Infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">s.Finite</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">not_infinite</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Defining lemma specifying `s.toFinset'` if `s` is infinite. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">Set.Infinite.toFinset'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.Infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.toFinset'</span><span class=\"o\">,</span> <span class=\"n\">h.not_finite</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_eq_of_finite</span> <span class=\"o\">[</span><span class=\"n\">Finite</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"n\">s.toFinite.toFinset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.toFinset'</span><span class=\"o\">,</span> <span class=\"n\">s.toFinite</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- missing set API</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.infinite_of_subtype</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.Infinite</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.infinite_coe_iff.mp</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_eq_of_infinite</span> <span class=\"o\">[</span><span class=\"n\">Infinite</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n  <span class=\"n\">s.infinite_of_subtype.toFinset'</span>\n\n<span class=\"c1\">-- Not sure this should be a simp lemma, since it leads to switching from Set to Finset worlds.</span>\n<span class=\"c1\">-- An issue is that the result of the simplification depends on exactly what Fintype instances</span>\n<span class=\"c1\">-- are around, and how they are defined.</span>\n<span class=\"c1\">-- Maybe we should have a custom simp set for trying to convert to Finset?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.toFinset'_of_fintype</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'</span> <span class=\"bp\">=</span> <span class=\"n\">s.toFinset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toFinset'_eq_of_finite</span><span class=\"o\">,</span> <span class=\"n\">toFinite_toFinset</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Set.card_toFinite'_eq_ncard</span> <span class=\"o\">:</span> <span class=\"n\">s.toFinset'.card</span> <span class=\"bp\">=</span> <span class=\"n\">s.ncard</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Set.finite_or_infinite</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.toFinset'</span><span class=\"o\">,</span> <span class=\"n\">ncard_eq_toFinset_card</span> <span class=\"n\">s</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.toFinset'</span><span class=\"o\">,</span> <span class=\"n\">h.ncard</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 418448583,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706391822
    },
    {
        "content": "<p>In the realm of finiteness, before the port started I was thinking about developing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">FiniteSet</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toSet</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span>\n  <span class=\"n\">finite</span> <span class=\"o\">:</span> <span class=\"n\">toSet.Finite</span>\n</code></pre></div>\n<p>The idea is that this would be for purely classical finite sets; it lets you completely avoid Decidable. I like how it also has the property that creating a FiniteSet and then coercing back to the Set is defeq to the original Set. If there are places where you do want computational content, then the idea would be that you could register Fintype instances and use Set.toFinset on the coerced FiniteSet.</p>\n<p>If we had this, then there could be a <code>Set.toFiniteSet : Set α -&gt; FiniteSet α</code> analogue of your function, that gives the empty set for infinite sets.</p>",
        "id": 418448919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706392178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Set.2EtoFinset.20without.20Fintype.20or.20Set.2EFinite/near/418374814\">said</a>:</p>\n<blockquote>\n<p>[Also, a tangential question: why does one need to suppress the argument <code>Set.Finite s</code> in the invocation of <code>dite</code>?  From <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=dite#doc\">docs#dite</a> I would have thought I needed to write <code>dite (Set.Finite s) (h := Classical.dec (Set.Finite s)) Set.Finite.toFinset (fun _ ↦ ∅)</code>, but Lean doesn't like that spelling.]</p>\n</blockquote>\n<p>That's odd. It looks like it might be an elaboration bug.</p>",
        "id": 418449133,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706392404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Set.2EtoFinset.20without.20Fintype.20or.20Set.2EFinite/near/418448919\">said</a>:</p>\n<blockquote>\n<p>I like how it also has the property that creating a FiniteSet and then coercing back to the Set is defeq to the original Set.</p>\n</blockquote>\n<p>My idea of adding a <code>carrier</code> field to <code>Finset</code> would also give you this</p>",
        "id": 418462440,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706406193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Set.2EtoFinset.20without.20Fintype.20or.20Set.2EFinite/near/418448583\">said</a>:</p>\n<blockquote>\n<p>Here's some more development on the idea:</p>\n</blockquote>\n<p>Thanks!  That may be close to the full API available for <code>Set.toFinset'</code>, which is otherwise a pretty lousy operation.  (It behaves well with respect to embeddings and equivalences, and also <code>erase</code>, but actually it may be better <em>not</em> to put in the few lemmas that it does satisfy, because I view this operation as a placeholder whose primary purpose is to allow certain <code>Finset</code>-based definitions (such as anything involving <code>Finset.sum</code>) to be made easily, with the intent to pass from <code>Set.toFinset'</code> to <code>Set.toFinset</code> (or <code>∅</code>) as quickly as possible to take advantage of the much better API there.  That's why I thought <code>Set.toFinset'_of_fintype</code> (and also <code>Set.toFinset'_eq_of_infinite</code>) should be <code>simp</code> lemmas - anything that gets you out of <code>Set.toFinset'</code> is progress.</p>\n<p>As for a yet another structure to capture finiteness beyond the four we already have (<code>Fintype</code>, <code>Finite</code>, <code>Set.Finite</code>, and <code>Finset</code>), I feel that this could be too much complexity (cf. <a href=\"https://xkcd.com/927/\">https://xkcd.com/927/</a>).  <code>Finset</code> seems quite deeply embedded in the current Mathlib library and I don't see a realistic way to dethrone it; at best one could create a niche variant of the concept (something like <code>ClassicalFinset</code> perhaps?) with a much smaller API (ideally with easy ways to transfer a large fraction of <code>Finset</code> lemmas over to <code>ClassicalFinset</code> without having to duplicate everything).</p>",
        "id": 418513962,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706457763
    },
    {
        "content": "<p>The xkcd reference is very pertinent. I was part of the problem here: I found finsets very hard to work with in 2019, partly because the community had not understood all the tricks yet (so we would end up with problems when dealing with finite sets of naturals because some lemmas would use decidability in Nat and others would use classical decidability, and there would be subsingleton diamonds which stopped <code>rw</code> from working and it was very frustrating; since then we discovered the rules of thumb such as asking for decidability rather than working classically if the theorem statment wouldn't compile otherwise). I pushed for <code>Set.Finite</code> and with an undergraduate at Imperial wrote a bunch of API for it, with a typical proof being \"this is proved for finsets, so use the finset version and deduce the finite version\", and the ridiculous irony was that by the end of developing the API I had worked so much with finsets that I had now really got the hang of them, so afterwards I just went back to using finsets instead :-/</p>",
        "id": 418519096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706461953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Set.2EtoFinset.20without.20Fintype.20or.20Set.2EFinite/near/418513962\">said</a>:</p>\n<blockquote>\n<p><code>Finset</code> seems quite deeply embedded in the current Mathlib library and I don't see a realistic way to dethrone it.</p>\n</blockquote>\n<p>IMHO we could and should dethrone <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a>. It would be a significant refactor but certainly not impossible. As noted above, the thing we currently lack is bundled, classical finiteness for subsets and so we constantly use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a> instead, which forces us to care about <em>how</em> things are finite when most of the time we only care <em>that</em> they are finite.</p>",
        "id": 418536850,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706476975
    },
    {
        "content": "<p>OTOH, we will no longer have computability this way.</p>",
        "id": 418556051,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706495539
    },
    {
        "content": "<p>So, it will be no longer possible to <code>decide</code> away simple properties.</p>",
        "id": 418556096,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706495610
    },
    {
        "content": "<p>Though we may have a tactic that moves things from noncomputable world to computable world finding necessary <code>Decidable*</code> or whatever on its way.</p>",
        "id": 418556156,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706495651
    },
    {
        "content": "<p>For me as an analyst, the main reason why I have to work with <code>Finset</code> is that the default summation notation <code>∑</code> is tied to <code>Finset.sum</code>.  (There is of course also <code>∑'</code> that is tied to infinite summation <code>tsum</code>, but often one really wants to work with finite summation.)  For most other usecases it doesn't seem to matter much which flavor of finiteness one works with - one just changes the methods and does some appropriate coercions - but for summation it would be rather annoying to use a class other than the one that <code>∑</code> is defaulted to using.</p>",
        "id": 418557264,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706496782
    },
    {
        "content": "<p>We also have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finsum#doc\">docs#finsum</a></p>",
        "id": 418557343,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706496852
    },
    {
        "content": "<p>It moves proofs of finiteness from statements of theorems to their proofs.</p>",
        "id": 418557356,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706496879
    },
    {
        "content": "<p>It came to Mathlib much later and has less API at the moment.</p>",
        "id": 418557374,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706496898
    },
    {
        "content": "<p>Ah, didn't know about that alternative.  Actually, that's a pretty reasonable solution.  Also fits well with the <code>toFinset'</code> method I proposed above.</p>",
        "id": 418557406,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706496919
    },
    {
        "content": "<p>The xkcd reference is <strong>very</strong> appropriate for anything \"finite\"-related in Mathlib.</p>",
        "id": 418557553,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706497021
    },
    {
        "content": "<p>For instance, one can now add to the previous proposed API:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">toFinset'_subset</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s.toFinset'</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Set.finite_or_infinite</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.toFinset'</span><span class=\"o\">,</span> <span class=\"n\">Eq.subset</span> <span class=\"n\">rfl</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.toFinset'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finsum_eq_sum'</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">∑ᶠ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFinset'</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Set.finite_or_infinite</span> <span class=\"o\">(</span><span class=\"n\">Function.support</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inl</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsum_eq_sum</span> <span class=\"n\">f</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Set.Finite.toFinset'</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inr</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finsum_of_infinite_support</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Set.Infinite.toFinset'</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Finset.sum_empty</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finsum_on_set_eq_sum'</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"bp\">∑ᶠ</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">Function.support</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFinset'</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">finsum_eq_sum'</span><span class=\"o\">,</span> <span class=\"n\">finsum_eq_indicator_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Finset.sum_congr</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.support_indicator</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"n\">replace</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">toFinset'_subset</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_of_mem_diff</span> <span class=\"n\">hx</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>[Edited to add the version restricted to sets.]</p>",
        "id": 418558666,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706497842
    },
    {
        "content": "<p>In that case, <code>Finset</code>s are actually quite avoidable in most of the type of math I've been dealing with then.</p>",
        "id": 418559649,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706498660
    },
    {
        "content": "<p>(though <code>finsum</code> definitely needs a bit more API, in particular for restricted sums <code>∑ᶠ x in s, f x</code>, which doesn't seem to exist yet.)</p>",
        "id": 418559832,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706498819
    },
    {
        "content": "<p>We have <code>∑ᶠ x ∈ s, f x</code></p>",
        "id": 418562546,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706501162
    },
    {
        "content": "<p>The <code>PLift</code> trick allows us to use <code>∑ᶠ k &lt; 10, f k</code></p>",
        "id": 418562589,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706501178
    },
    {
        "content": "<p>But a lot of API is missing.</p>",
        "id": 418562599,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706501190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Set.2EtoFinset.20without.20Fintype.20or.20Set.2EFinite/near/418562546\">said</a>:</p>\n<blockquote>\n<p>We have <code>∑ᶠ x ∈ s, f x</code></p>\n</blockquote>\n<p>Is there a systematic naming convention on when to use <code>∈</code> and when to use <code>in</code>?  Right now, <code>∑</code>and <code>∫</code> use <code>in</code>, while <code>∑ᶠ</code>, <code>⋃</code>,  and <code>⋂</code> use <code>∈</code>.</p>",
        "id": 418565737,
        "sender_full_name": "Terence Tao",
        "timestamp": 1706503970
    },
    {
        "content": "<p>They mean different things. The <code>in</code> variant, when it exists, represents a single composite operation, like a finset sum which requires the finset for its definition. The other binary operators are piggybacking on general support for extended binders, and generally mean some kind of iterated binder</p>",
        "id": 418565884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1706504157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Set.2EtoFinset.20without.20Fintype.20or.20Set.2EFinite/near/418374814\">said</a>:</p>\n<blockquote>\n<p>Also, a tangential question: why does one need to suppress the argument <code>Set.Finite s</code> in the invocation of <code>dite</code>?  [...]</p>\n</blockquote>\n<p>(It appears that <a href=\"https://github.com/leanprover/lean4/pull/1867\">lean4#1867</a> is the relevant issue, and I added this <code>dite</code> example.)</p>",
        "id": 418694468,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1706552351
    }
]