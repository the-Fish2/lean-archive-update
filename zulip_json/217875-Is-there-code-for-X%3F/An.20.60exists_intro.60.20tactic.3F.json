[
    {
        "content": "<p>Are there (could there be) tactics analogous to <code>intro</code> and <code>revert</code> but for ∃  quantifiers?</p>\n<p>I'm a new Lean user and I've been trying my hand at writing some non trivial formalizations. I like how there are Lean tactics that correspond to steps in informal mathematical reasoning (initially Terry Tao's <a href=\"https://docs.google.com/spreadsheets/d/1Gsn5al4hlpNc_xKoXdU6XGmMyLiX4q-LFesFVsMlANo/edit#gid=0\">dictionary</a> was a good guide for me). But I've found that there's currently an asymmetry between the tactics for dealing with ∀ and ∃ quantifiers.</p>\n<p>The problem of course has to do with manipulating the goal or a hypothesis under quantifiers. For transformations that involve equality or iff, this to some degree can be done by <code>simp</code>, <code>rw</code> and <code>simp_rw</code>. But for modifications that change the strength of the goal or hypothesis, one has to use <code>intro</code>, <code>obtain</code>, ...</p>\n<p>I have seen the <code>peel</code> tactic, that can match sequences of quantifiers between the goal and a hypothesis, which then allows for interactive simplification. But that requires a hypothesis with the appropriate quantifier structure to exist. In practice, with a complicated goal, it might be tedious to build such a hypothesis by hand.</p>",
        "id": 411205982,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704381083
    },
    {
        "content": "<p>Here's a toy example that illustrates the difference for a ∀ goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">intro_or_peel</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">and_self_iff.mp</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">a</span>   <span class=\"c1\">-- ⊢ β → δ</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span>   <span class=\"c1\">-- ⊢ δ</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span>   <span class=\"c1\">-- ⊢ γ</span>\n    <span class=\"n\">revert</span> <span class=\"n\">b</span>  <span class=\"c1\">-- ⊢ β → γ</span>\n    <span class=\"n\">revert</span> <span class=\"n\">a</span>  <span class=\"c1\">-- ⊢ α → β → γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span>   <span class=\"c1\">-- done</span>\n  <span class=\"bp\">.</span> <span class=\"n\">peel</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"c1\">-- ⊢ δ</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span>           <span class=\"c1\">-- ⊢ γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span>           <span class=\"c1\">-- done</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">just_intro</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">and_self_iff.mp</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">a</span>   <span class=\"c1\">-- ⊢ β → δ</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span>   <span class=\"c1\">-- ⊢ δ</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span>   <span class=\"c1\">-- ⊢ γ</span>\n    <span class=\"n\">revert</span> <span class=\"n\">b</span>  <span class=\"c1\">-- ⊢ β → γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span>   <span class=\"c1\">-- done</span>\n  <span class=\"bp\">.</span> <span class=\"n\">peel</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Tactic 'peel' could not match quantifiers in</span>\n<span class=\"cm\">      β → γ</span>\n<span class=\"cm\">    and</span>\n<span class=\"cm\">      α → β → δ -/</span>\n</code></pre></div>",
        "id": 411206118,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704381102
    },
    {
        "content": "<p>Finally, I did manage to cobble together an <code>intro</code> tactic for an ∃ goal using <code>Exists.imp</code>. Here's an analogous example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_intro_or_peel</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">and_self_iff.mp</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Exists.imp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">new_goal</span> <span class=\"c1\">-- simulate `exists_intro a`</span>\n    <span class=\"c1\">-- a : α, new_goal : ?p a ⊢ β → δ</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span>                <span class=\"c1\">-- ⊢ δ</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span>                <span class=\"c1\">-- ⊢ γ</span>\n    <span class=\"n\">revert</span> <span class=\"n\">b</span>               <span class=\"c1\">-- ⊢ β → γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">new_goal</span>  <span class=\"c1\">-- simulate `exists_revert a`</span>\n    <span class=\"c1\">--                        ⊢ ∃ a : α, β → γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span>                <span class=\"c1\">-- done</span>\n  <span class=\"bp\">·</span> <span class=\"n\">peel</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"c1\">--    a : α, b : β, H : γ ⊢ δ</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span>                <span class=\"c1\">-- ⊢ γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span>                <span class=\"c1\">-- done</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">just_exists_intro</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">and_self_iff.mp</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Exists.imp</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">new_goal</span> <span class=\"c1\">-- simulate `exists_intro a`</span>\n    <span class=\"c1\">-- a : α, new_goal : ?p a ⊢ β → δ</span>\n    <span class=\"n\">intro</span> <span class=\"n\">b</span>                <span class=\"c1\">-- ⊢ δ</span>\n    <span class=\"n\">apply</span> <span class=\"n\">h</span>                <span class=\"c1\">-- ⊢ γ</span>\n    <span class=\"n\">revert</span> <span class=\"n\">b</span>               <span class=\"c1\">-- ⊢ β → γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">new_goal</span>  <span class=\"c1\">-- simulate `exists_revert a`</span>\n    <span class=\"c1\">--                        ⊢ ∃ a : α, β → γ</span>\n    <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>         <span class=\"c1\">-- ⊢ β → γ</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span>                <span class=\"c1\">-- done (`exists x` is faster, but I wanted to show this step)</span>\n  <span class=\"bp\">·</span> <span class=\"n\">peel</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"c\">/-</span><span class=\"cm\"> Tactic 'peel' could not match quantifiers in</span>\n<span class=\"cm\">      β → γ</span>\n<span class=\"cm\">    and</span>\n<span class=\"cm\">      ∃ (_ : α), β → δ -/</span>\n</code></pre></div>\n<p>More generally, one could invoke <code>BEx.imp_right</code>, <code>Exists₂.imp</code>, ...</p>",
        "id": 411206242,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704381129
    },
    {
        "content": "<p>While the above solution is workable, it would be nice if it were encapsulated in a tactic. Maybe this can already be done in a standard way that I've missed? For example, one disadvantage of the above solution is that any modification to the proof context (<code>have</code> or <code>let</code> statements) inside the <code>Exists.imp</code> subgoal are thrown away when it is closed with <code>exact new_goal</code>. I suspect that a tactic could keep the modifications to the context that were independent of the <code>intro</code>-ed variables, like <code>revert</code> does.</p>",
        "id": 411206269,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704381138
    },
    {
        "content": "<p>Could you come up with a non-toy example?</p>\n<p>Something I find worrisome is that <code>exists_intro a</code> is giving you a <code>?p a</code> goal, which can be difficult to work with. At the moment, Lean's unification algorithm doesn't handle unifying against <code>?p a</code> as well as it can.</p>",
        "id": 411209945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704382193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I've used this pattern successfully a few times in a long proof that I've been working on. It'd be rather involved extracting those specific cases into a MWE.</p>\n<p>To describe it in words, the goal is something like  <code>∃ x, P U x</code> where <code>P</code> is some property relating <code>x</code> to a <code>U</code> that belongs to some filter (say of open neighborhoods in a topology, or of entourages in a uniformity), and you want to replace <code>U</code> by an element of a filter basis. Since the elements of a filter basis are typically much more structured, under the quantifier the goal can be simplified to some much more concrete formula say <code>Q x</code>. But since this changes the strength of the goal, <code>∃ x, P U x</code> can't be turned into <code>∃ x, Q x</code> using <code>simp_rw</code>, for instance. Also, you might not know exactly what <code>Q x</code>is  until you apply some interactive simplifications, so building the <code>∀ x, Q x -&gt; P U x</code> hypothesis for <code>Exists.imp</code> by hand could be quite tedious.</p>\n<p>I know you could also feed a metavariable into the goal (something like <code>use ?y</code>), but then I've had problems forcing an assignment of <code>?y</code> later on.</p>",
        "id": 411217402,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704384299
    },
    {
        "content": "<p>It sounds like this is again a task for a port of the Coq procrastination tactic.</p>",
        "id": 411218343,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704384557
    },
    {
        "content": "<p>What would that tactic do exactly? And is this something that's just on a wishlist, or there's a concrete plan to port it?</p>",
        "id": 411248194,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704396454
    },
    {
        "content": "<p>A very quick zulip search answers those questions, but let me answer anyway. The Coq tactic description is at <a href=\"https://armael.github.io/coq-procrastination/manual/manual.pdf\">https://armael.github.io/coq-procrastination/manual/manual.pdf</a>. The concrete plan is that someone will end up being tired of seeing this tactic mentioned pretty often, or will simply really need it, and port it.</p>",
        "id": 411251863,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704397970
    },
    {
        "content": "<p>Your examples are a little strange.  In particular, your quantifiers are vacuous.  You write <code>∀ a : α</code> or <code>∃ a : α</code> followed by a proposition that doesn't mention <code>a</code>.  I wonder if you have misunderstood quantifier notation in Lean.</p>\n<p>I suspect that the tactics you are looking for are <code>obtain</code> and <code>use</code>, which are tactics you can use if you have either a hypothesis or a goal that starts with <code>∃</code>.  Here are much shorter proofs of your lemmas, where the last two use <code>obtain</code> and <code>use</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">intro_or_peel</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">just_intro</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_intro_or_peel</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">H2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">H</span>\n  <span class=\"n\">use</span> <span class=\"n\">a</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">H2</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">just_exists_intro</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">δ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 411259901,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1704401759
    },
    {
        "content": "<p>By the way <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Coq-procrastination would need to be implemented in core, so if you actually want this to happen you should open an RFC.</p>",
        "id": 411262030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704402596
    },
    {
        "content": "<p>Really? What is the missing piece?</p>",
        "id": 411262125,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704402623
    },
    {
        "content": "<p>The coq version certainly does not look like it required coq core changes.</p>",
        "id": 411262171,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704402648
    },
    {
        "content": "<p>The concept of \"shelved\" goals does not exist in lean</p>",
        "id": 411262587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704402869
    },
    {
        "content": "<p>and you would need some code to check for those at the end of the block or something, when your tactic is not running</p>",
        "id": 411262636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704402903
    },
    {
        "content": "<p>basically this is a request to extend the definition of <code>TacticM</code> with additional state</p>",
        "id": 411262674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704402924
    },
    {
        "content": "<p>Do you know what else uses this feature in Coq? Surely it hasn't been added for this tactic?</p>",
        "id": 411262864,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704403019
    },
    {
        "content": "<p>You can already do a limited amount of procrastination using named metavariables, for example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UnionFind.link#src\">src#UnionFind.link</a> uses this technique</p>",
        "id": 411262865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704403020
    },
    {
        "content": "<p>It has a whole tab for it in vscoq</p>",
        "id": 411262903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704403040
    },
    {
        "content": "<p>I don't know if it was added for this tactic, I would expect there are other tactics that interact with it too</p>",
        "id": 411262949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704403074
    },
    {
        "content": "<p>but coq and lean have slightly different tactic framework designs so this shouldn't be too surprising</p>",
        "id": 411263029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704403105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/An.20.60exists_intro.60.20tactic.3F/near/411251863\">said</a>:</p>\n<blockquote>\n<p>A very quick zulip search answers those questions, but let me answer anyway. The Coq tactic description is at <a href=\"https://armael.github.io/coq-procrastination/manual/manual.pdf\">https://armael.github.io/coq-procrastination/manual/manual.pdf</a>. The concrete plan is that someone will end up being tired of seeing this tactic mentioned pretty often, or will simply really need it, and port it.</p>\n</blockquote>\n<p>Thanks for kindly explaining. :-) As a newcomer, I had no context to go with your first remark.</p>",
        "id": 411274012,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704408778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453098\">Dan Velleman</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/An.20.60exists_intro.60.20tactic.3F/near/411259901\">said</a>:</p>\n<blockquote>\n<p>Your examples are a little strange.  In particular, your quantifiers are vacuous.  You write <code>∀ a : α</code> or <code>∃ a : α</code> followed by a proposition that doesn't mention <code>a</code>.  I wonder if you have misunderstood quantifier notation in Lean.</p>\n<p>I suspect that the tactics you are looking for are <code>obtain</code> and <code>use</code>, which are tactics you can use if you have either a hypothesis or a goal that starts with <code>∃</code>. [...]</p>\n</blockquote>\n<p>Thanks for the well-meaning effort. The emphasis in my toy examples is on \"toy\", where I just wanted to illustrate the interactive workflow that I had in mind. I guess you'll just have to trust me if I say that I'm not under some elementary misunderstanding. :-) The informal example in my reply to Kyle Miller is closer to \"real world\". Anyway, I think I'm describing standard practice in informal proofs of applying non reversible simplifications at every level of a goal with multiply nested quantifiers. For instance, if working through an analysis proof interactively, you might not know how to choose all the \\epsilon's and \\delta's until the end of the proof, but <code>use</code> doesn't easily allow you to delay that choice.</p>",
        "id": 411275886,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1704409684
    },
    {
        "content": "<p>Yes, I see now that I misunderstood your question.  Thanks for recognizing my effort as well-meaning:)</p>",
        "id": 411383137,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1704466890
    }
]