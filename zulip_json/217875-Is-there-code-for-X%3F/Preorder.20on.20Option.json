[
    {
        "content": "<p>Does Option have any kind of preorder relationship defined (assuming the underlying type does)? I've run myself into a mild pickle through assuming it did but I'm not sure it does.</p>",
        "id": 408984776,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703007156
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithTop#doc\">docs#WithTop</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithBot#doc\">docs#WithBot</a></p>",
        "id": 408985452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703007406
    },
    {
        "content": "<p>depending on whether you want <code>none</code> to be at the top or bottom</p>",
        "id": 408985494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703007425
    },
    {
        "content": "<p>I guess you could put an order on <code>Option X</code> that has <code>none</code> as incomparable?</p>",
        "id": 408990835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703009475
    },
    {
        "content": "<p>Yeah, that's what I was assuming.</p>",
        "id": 408993272,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703010438
    },
    {
        "content": "<p>Or hoping for.</p>",
        "id": 408993280,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703010442
    },
    {
        "content": "<p>Oddly there is an LT instance defined? But it isn't much use.</p>",
        "id": 408993318,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703010458
    },
    {
        "content": "<p>But what I want is<br>\ninstance (priority := 10) le [LE α] : LE (Option α) := ⟨Option.Rel (. ≤ .)⟩<br>\ninstance (priority := 10) lt [LT α] : LT (Option α) := ⟨Option.Rel (. &lt; .)⟩</p>\n<p>(and then ideally a preorder...)</p>",
        "id": 408996590,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703011828
    },
    {
        "content": "<p>Wait no. I want that for LE, for LT I don't because obviously Bot should not be LT itself as then you can't make a Preorder</p>",
        "id": 408999383,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703012873
    },
    {
        "content": "<p>Urrrgh. That might be a day's work buggered if this is a challenge. I assumed (given that &lt; worked!) that it would just nicely inherit the structure.</p>",
        "id": 408999526,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703012926
    },
    {
        "content": "<p>Just define <code>a &lt; b ↔ a ≤ b ∧ ¬ b ≤ a</code></p>",
        "id": 408999623,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703012965
    },
    {
        "content": "<p>Sure, that's what I want.</p>",
        "id": 408999668,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703012985
    },
    {
        "content": "<p>But obviously if it doesn't already exist there will be lots of fiddly lemmas to sort.</p>",
        "id": 408999758,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703013005
    },
    {
        "content": "<p>Also, <code>instLTOption</code> exists by default, and makes none lt everything else - which I don't particularly want. But also trying to move to WithBot or WithTop means parts of the Option API don't work - I want to retain that.</p>",
        "id": 409175929,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075164
    },
    {
        "content": "<p>That instance is in <code>Init.Data.Option.Basic</code></p>",
        "id": 409175994,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075185
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instLTOption#doc\">docs#instLTOption</a></p>",
        "id": 409176043,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075210
    },
    {
        "content": "<p>Oh that's ancient</p>",
        "id": 409176056,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703075215
    },
    {
        "content": "<p>Indeed, but because it already exists it somewhat gets in the way for me/was a footgun because <code>&lt;</code> worked, but actually it didn't really have any way of using it properly.</p>",
        "id": 409176173,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075267
    },
    {
        "content": "<p><code>&lt;</code> is defined correctly, isn't it?</p>",
        "id": 409176192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075279
    },
    {
        "content": "<p>Oh wait, no it isn't</p>",
        "id": 409176275,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075295
    },
    {
        "content": "<p>It declares <code>none</code> as a bottom element</p>",
        "id": 409176292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075303
    },
    {
        "content": "<p>It uses <code>Option.lt</code>, so, no.</p>",
        "id": 409176309,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075311
    },
    {
        "content": "<p>I think we should remove it, if you want that behavior you should use <code>WithBot</code></p>",
        "id": 409176315,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075315
    },
    {
        "content": "<p>Yes, I agree.</p>",
        "id": 409176331,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/408990835\">said</a>:</p>\n<blockquote>\n<p>I guess you could put an order on <code>Option X</code> that has <code>none</code> as incomparable?</p>\n</blockquote>\n<p>I think this is a good idea though</p>",
        "id": 409176413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075358
    },
    {
        "content": "<p>Yep.</p>",
        "id": 409176428,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075365
    },
    {
        "content": "<p>I think what you do is</p>\n<ul>\n<li>define &lt;= as Option.Rel (le)</li>\n<li>Define &lt; as Yaël says above, the standard a &lt; b if a &lt;=b and not (b &lt;= a) thing.</li>\n</ul>",
        "id": 409176607,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075422
    },
    {
        "content": "<p>I believe that will also give a Preorder if your base type has one. I assume you also get PartialOrder and LinearOrder as appropriate too?</p>",
        "id": 409176689,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075458
    },
    {
        "content": "<p>Actually if you want to make <code>none</code> incomparable you can just define <code>¬ none &lt; none</code>, <code>¬ none &lt; some b</code>, <code>¬ some a &lt; none</code> and <code>some a &lt; some b ↔ a &lt; b</code> and that will give you nice definitional properties</p>",
        "id": 409176848,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703075513
    },
    {
        "content": "<p>Well, yeah - that also looks great. Just would like the inheriting thing really!</p>",
        "id": 409176980,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075561
    },
    {
        "content": "<p>I don't have time today (or honestly the mental space - I'm not in a good place with the stres right now) to put a PR together, but it seems like honestly it would be good. And this feels like the \"right\" order to have on Option as opposed to WithBot or WithTop.</p>",
        "id": 409177076,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075594
    },
    {
        "content": "<p>(We don't have a notation for <code>none</code> and <code>some x</code>, right? You just write that?)</p>",
        "id": 409177168,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703075624
    },
    {
        "content": "<p><code>some</code> is also the coercion</p>",
        "id": 409177241,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703075644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409176689\">said</a>:</p>\n<blockquote>\n<p>I believe that will also give a Preorder if your base type has one. I assume you also get PartialOrder and LinearOrder as appropriate too?</p>\n</blockquote>\n<p>Not a linear order, because <code>none</code> is incomparable and therefore <code>le_total</code> isn't true</p>",
        "id": 409177316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703075673
    },
    {
        "content": "<p>Oh yes ofc</p>",
        "id": 409178400,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703076096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409177316\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409176689\">said</a>:</p>\n<blockquote>\n<p>I believe that will also give a Preorder if your base type has one. I assume you also get PartialOrder and LinearOrder as appropriate too?</p>\n</blockquote>\n<p>Not a linear order, because <code>none</code> is incomparable and therefore <code>le_total</code> isn't true</p>\n</blockquote>\n<p>Oh yes. But I think it would be a perfectly good PartialOrder?</p>",
        "id": 409178550,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703076150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409177076\">said</a>:</p>\n<blockquote>\n<p>I don't have time today (or honestly the mental space - I'm not in a good place with the stres right now) to put a PR together</p>\n</blockquote>\n<p>A middle ground that maybe we should encourage more is to create a github issue to track the idea</p>",
        "id": 409178915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703076310
    },
    {
        "content": "<p>Heck, this might even be a \"good first issue\"</p>",
        "id": 409178963,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703076332
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"n\">le_refl</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_trans</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Not actually sure how you fill the sorries here. Also I get some kind of weird error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">HEq.rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">HEq</span> <span class=\"bp\">?</span><span class=\"n\">m.92552</span> <span class=\"bp\">?</span><span class=\"n\">m.92552</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">a</span><span class=\"bp\">✝</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"bp\">✝</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span><span class=\"bp\">✝</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"bp\">✝</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">b</span><span class=\"bp\">✝</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>But I assume this is something to do with the existing LT instance interfering? IDK.</p>",
        "id": 409179488,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703076549
    },
    {
        "content": "<p>It seems like there are two, maybe three PRs here:</p>\n<ul>\n<li>kill the existing Option instance (That is in <code>Init.Data.Option.Basic</code> - is that Mathlib? Deeper?)</li>\n<li>Add in a new instance for Option (where should this go?)</li>\n<li>Add the Preorder and Partial Order results.</li>\n</ul>",
        "id": 409180407,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703076875
    },
    {
        "content": "<p>Wow yeah it looks like that instance is in the actual Lean 4 repo. I don't even know if they accept PRs.</p>",
        "id": 409183805,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703078076
    },
    {
        "content": "<p>Is there a way to supress an existing instance? I wonder if that instance is actually <em>used</em> by anything.</p>",
        "id": 409184279,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703078238
    },
    {
        "content": "<p>The weird error is coming from the <code>lt_iff_le_not_le</code> field that you omitted</p>",
        "id": 409186609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703078993
    },
    {
        "content": "<p>aha</p>",
        "id": 409186701,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079012
    },
    {
        "content": "<p>It didn't list that as a missing field so I didn't think to.</p>",
        "id": 409186776,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079046
    },
    {
        "content": "<p>Here's a full proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span>\n    <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"n\">le</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"n\">le_refl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">le_refl</span> <span class=\"n\">a</span>\n  <span class=\"n\">le_trans</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">trivial</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hbc</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">le_trans</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n  <span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n    <span class=\"o\">⟨(</span><span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">·</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lt_iff_le_not_le.1</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n     <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">·</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">hn</span> <span class=\"n\">trivial</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lt_iff_le_not_le.2</span> <span class=\"n\">h</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 409188052,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703079560
    },
    {
        "content": "<p>Aha. Thanks, I was trying to use <code>rfl</code> where you have <code>trivial</code> but I see now the issue.</p>",
        "id": 409188200,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079615
    },
    {
        "content": "<p>The last one is a fun golfing challenge</p>",
        "id": 409188216,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703079620
    },
    {
        "content": "<p>Is there not some existing inductive proposition to lift <code>α → β → Prop</code> to <code>Option α → Option β → Prop</code>?</p>",
        "id": 409188217,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703079621
    },
    {
        "content": "<p>Yes, but that only works for <code>le</code></p>",
        "id": 409188245,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703079633
    },
    {
        "content": "<p>Yes, <code>Option.Rel</code>.</p>",
        "id": 409188250,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079636
    },
    {
        "content": "<p>Surely you don't need <code>iff_iff_implies_and_implies </code>?</p>",
        "id": 409188281,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703079648
    },
    {
        "content": "<p>Yes you can't lift <code>&lt;</code> using that.</p>",
        "id": 409188317,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409188250\">said</a>:</p>\n<blockquote>\n<p>Yes, <code>Option.Rel</code>.</p>\n</blockquote>\n<p>Yeah but without the <code>none</code> case</p>",
        "id": 409188320,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703079665
    },
    {
        "content": "<p>Oh I see. I haven't found one!</p>",
        "id": 409188359,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079678
    },
    {
        "content": "<p>I guess we could adjust <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Option.Rel#doc\">docs#Option.Rel</a> to take the <code>none</code> value too</p>",
        "id": 409188503,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703079726
    },
    {
        "content": "<p>Or define <code>Option.StrictRel</code></p>",
        "id": 409188549,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703079747
    },
    {
        "content": "<p><code>Option.lt</code> imposes the \"none is least\" condition and is a bit of a trap imo.</p>",
        "id": 409188729,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079821
    },
    {
        "content": "<p>You would possibly want to consider nixing it at the same time as nixing <code>instLTOption</code>, and add <code>Option.StrictRel</code> as you say.</p>",
        "id": 409188872,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703079864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409183805\">said</a>:</p>\n<blockquote>\n<p>Wow yeah it looks like that instance is in the actual Lean 4 repo. I don't even know if they accept PRs.</p>\n</blockquote>\n<p>You could make a <em>draft</em> PR that deletes the instance and sees what breaks (or just do this in a fork)</p>",
        "id": 409189225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703080002
    },
    {
        "content": "<p>Having experimented with deleting it, the answer seems to be: not much. If it builds OK I might well actually submit a PR if that's in line with the <code>lean4</code> contribution guidance.</p>",
        "id": 409210084,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703086363
    },
    {
        "content": "<p>Looks like I should open an issue first.</p>",
        "id": 409210195,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703086404
    },
    {
        "content": "<p>My process has been 1) open a draft PR, check it compiles, discuss on zulip 2) write the issue, linking the zulip thread 3) promote the draft PR to a real PR</p>",
        "id": 409211908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703086983
    },
    {
        "content": "<p>The draft PR is nice because it also tests Std and mathlib for you</p>",
        "id": 409211972,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703087006
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/issues/3100\">https://github.com/leanprover/lean4/issues/3100</a></p>",
        "id": 409212943,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703087315
    },
    {
        "content": "<p>Their contribution guidelines say \"make an issue before making a PR\". I am not sure how to distinguish between a draft PR and a real PR.</p>",
        "id": 409213037,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703087344
    },
    {
        "content": "<p>When you make a PR the \"open PR\" button has a \"draft\" dropdown</p>",
        "id": 409213198,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703087399
    },
    {
        "content": "<p>Oh interesting. Perhaps if it compiles fine locally I will do that.</p>",
        "id": 409213317,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703087431
    },
    {
        "content": "<p>Interestingly it couldn't even successfully detect the Lean version in the file when I opened it, I assume because it's just running at the bottom of the stack and a project isn't set up? Idk.</p>",
        "id": 409213444,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703087472
    },
    {
        "content": "<p>How do I link to commits in repos other than mathlib?</p>",
        "id": 409257842,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703105308
    },
    {
        "content": "<p>Eg <a href=\"https://github.com/YaelDillies/LeanAPAP/pull/3\">YaelDillies/LeanAPAP#3</a></p>",
        "id": 409257921,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703105360
    },
    {
        "content": "<p>Ta</p>",
        "id": 409258195,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703105495
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/3102\">leanprover/lean4#3102</a> and <a href=\"https://github.com/leanprover/std4/pull/473\">leanprover/std4#473</a> may be of interest then</p>",
        "id": 409275376,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703113697
    },
    {
        "content": "<p>neat, everything is green with the core change</p>",
        "id": 409276653,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703114345
    },
    {
        "content": "<p>Yep, it seems to genuinely break nothing. So I am hoping it will be an easy decision for them.</p>",
        "id": 409279300,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703115968
    },
    {
        "content": "<p>What is the theorem for like - so I have Option.Rel. I know <code>Option.Rel r (some a) (some b)</code>. So I can conclude that r a b.</p>",
        "id": 409279348,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703116006
    },
    {
        "content": "<p>That's <code>Option.Rel.rec</code></p>",
        "id": 409284239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703119526
    },
    {
        "content": "<p>Or just <code>cases h</code></p>",
        "id": 409284271,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703119554
    },
    {
        "content": "<p>Aye, cases h worked fine, just was trying to do it as a term. I was using Option.Rel.casesOn and it wasn't really working.</p>",
        "id": 409337797,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703148000
    },
    {
        "content": "<p>Incidentally, there is an argument that there shouldn't be any kind of ordering on Option at all, and we have a third synonym for the incomparable ordering. What do you think?</p>",
        "id": 409337966,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703148061
    },
    {
        "content": "<p>Personally I like the idea of Option having an ordering and it being that one, because to me it's the best \"default\".</p>",
        "id": 409338067,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703148100
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">StrictRel</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"sd\">/-- If `a ~ b`, then `some a ~ some b` -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">StrictRel</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">instLTOption'</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LT</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">StrictRel</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">instance</span> <span class=\"n\">instLEOption</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LE</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">Rel</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">≤</span> <span class=\"bp\">·</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">none_le_none</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">Rel.none</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_none_le_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">none</span> <span class=\"bp\">≤</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">ha</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_some_le_none</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">ha</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">some_le_some_of_le</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Rel.some</span> <span class=\"n\">hab</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">le_of_some_le_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hab</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">some_le_some_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">le_of_some_le_some</span><span class=\"o\">,</span> <span class=\"n\">some_le_some_of_le</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_none_lt_none</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">ha</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_none_lt_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">ha</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">not_some_lt_none</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"bp\">¬</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">ha</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">some_lt_some_of_lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">StrictRel.some</span> <span class=\"n\">hab</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lt_of_some_lt_some</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hab</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">some_lt_some_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LT</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">lt_of_some_lt_some</span><span class=\"o\">,</span> <span class=\"n\">some_lt_some_of_lt</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le_refl</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">a.casesOn</span> <span class=\"n\">Rel.none</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Rel.some</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n  <span class=\"n\">le_trans</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases'</span> <span class=\"n\">hbc</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hbc</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Rel.some</span> <span class=\"o\">(</span><span class=\"n\">hab.trans</span> <span class=\"n\">hbc</span><span class=\"o\">)</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">hbc</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Rel.none</span>\n  <span class=\"n\">lt_iff_le_not_le</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.intro</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hab</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">some_le_some_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">le_not_le_of_lt</span> <span class=\"n\">hab</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n      <span class=\"n\">cases'</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span>\n      <span class=\"bp\">·</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">some_le_some_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hba</span>\n        <span class=\"n\">exact</span> <span class=\"n\">some_lt_some_of_lt</span> <span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hba</span><span class=\"o\">⟩)</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hba</span> <span class=\"n\">none_le_none</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PartialOrder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">PartialOrder</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span> <span class=\"n\">hba</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases'</span> <span class=\"n\">hab</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hab</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">some.injEq</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"o\">(</span><span class=\"n\">le_antisymm</span> <span class=\"n\">hab</span> <span class=\"o\">(</span><span class=\"n\">le_of_some_le_some</span> <span class=\"n\">hba</span><span class=\"o\">))</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 409349648,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703151842
    },
    {
        "content": "<p>Now, where in Mathlib should this go? We don't seem to import any order files in the basic Option/Data/* files. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, should it go in Order/Basic.lean?</p>",
        "id": 409351627,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703152509
    },
    {
        "content": "<p>Either there or in a new <code>Data.Option.Order</code> file</p>",
        "id": 409351953,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703152617
    },
    {
        "content": "<p>That has something to commend it.</p>",
        "id": 409352130,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703152680
    },
    {
        "content": "<p>There are various other things - <code>some</code> is an order embedding, I guess some results about <code>Option.get</code>, that sort of thing - that really are very Option-flavoured and might need other order imports.</p>",
        "id": 409352310,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703152731
    },
    {
        "content": "<p>Data/Option/Order.lean would seem reasonable</p>",
        "id": 409352341,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703152745
    },
    {
        "content": "<p>Incidentally we should probably remove <code>Option.rel</code> from Mathlib.</p>",
        "id": 409353626,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703153153
    },
    {
        "content": "<p>Give it is identical to <code>Option.Rel</code> in Standard</p>",
        "id": 409353651,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703153161
    },
    {
        "content": "<p>I'm skeptical about this being the \"default\". It would not have occurred to me as being better than the <code>WithBot</code> interpretation, which for me is the obviously correct one. :-)</p>",
        "id": 409360437,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1703155372
    },
    {
        "content": "<p>(Just like <code>false &lt; true</code> for everyone, right!? :-)</p>",
        "id": 409360496,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1703155402
    },
    {
        "content": "<p>Yeah, I think that's a valid way to feel. I also think it's legitimate to simply not have an ordering on Option itself. Do you have a good name for, uh, the incomparable space, I don't know what to call it?</p>",
        "id": 409364950,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703156942
    },
    {
        "content": "<p><code>IncomparableNoneOption</code>? :-)</p>",
        "id": 409365363,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1703157107
    },
    {
        "content": "<p>That feels a little long to me.</p>",
        "id": 409365462,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157139
    },
    {
        "content": "<p>I think the incomparable order is a decent default.</p>",
        "id": 409365631,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703157200
    },
    {
        "content": "<p>Fundamentally I was in a context where None just had no meaning, a partial function sort of thing, and in that context I don't want theorems to be accidentally true without caveating for good inputs. To me, that's the appropriate place to use the incomparable one - and it's the closest to the semantic meaning of Option in my head.</p>",
        "id": 409365706,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157225
    },
    {
        "content": "<p>Option = \"I've added an element, and literally it represents nothing except that it exists and is distinct to all things that correspond to a value, and I want to have a partial order on this if I can and to do that I guess it needs to have minimal relations\"</p>",
        "id": 409365878,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157275
    },
    {
        "content": "<p>\"WithBot = all of that but it's less than everything\"</p>",
        "id": 409365914,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157288
    },
    {
        "content": "<p>So that's I think why it's the default for me - it's a kind of \"minimal property\", the closure in a sense.</p>",
        "id": 409365997,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157317
    },
    {
        "content": "<p>I asked ChatGPT for whimsical options for a name for an incomparable type synonym. Most were not that great, but I did like <code>WildCard α</code>.</p>",
        "id": 409366245,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1703157399
    },
    {
        "content": "<p>That's fun.</p>",
        "id": 409366284,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157413
    },
    {
        "content": "<p>It also somewhat represents having a default or error value, so <code>WithDefault</code> is not bad.</p>",
        "id": 409366436,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157465
    },
    {
        "content": "<p>Better yet it fits the naming convention.</p>",
        "id": 409366613,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157526
    },
    {
        "content": "<p>It would be ideal if the API for this was as straightforward to use as possible. Once you create a synonym that does create a debt of lots of fiddly little bits you want to do.</p>",
        "id": 409366696,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157565
    },
    {
        "content": "<p>I also suspect there's a bunch of places we currently use Option where semantically <code>WithDefault</code> is more appropriate.</p>",
        "id": 409366756,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157596
    },
    {
        "content": "<p>I really don't think there's any point bothering with a type synonym here.</p>",
        "id": 409366895,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703157634
    },
    {
        "content": "<p>I mean that would be my wish! But clearly there's differing views.</p>",
        "id": 409366951,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157660
    },
    {
        "content": "<p>I'm concerned about the programming use case though, I don't think we want to make people use a type synonym to be able to put options in map keys</p>",
        "id": 409367068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703157698
    },
    {
        "content": "<p>What's the requirement for that?</p>",
        "id": 409367114,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157721
    },
    {
        "content": "<p>It needs to be ordered?</p>",
        "id": 409367183,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157733
    },
    {
        "content": "<p><code>Option T</code> should have a total order if <code>T</code> does</p>",
        "id": 409367197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703157737
    },
    {
        "content": "<p>Right. I mean that wasn't the case already so we're going to need to add something. (Indeed the problem was that Option T actually didn't have anything really.)</p>",
        "id": 409367271,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157771
    },
    {
        "content": "<p>If <code>Option T</code> has to have a total order if T does, I don't really see how you can avoid having it be one of WithBot or WithTop. In which case, why have them?</p>",
        "id": 409367419,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157843
    },
    {
        "content": "<p>Personally I think it should be the case that it has a partial order (or at the very least a preorder) if T does. It's entirely clear that for the most part of it that is just T wearing a hat you know what the order should be. There's just this other element you need to stick on.</p>",
        "id": 409367820,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703157968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409367068\">said</a>:</p>\n<blockquote>\n<p>I'm concerned about the programming use case though, I don't think we want to make people use a type synonym to be able to put options in map keys</p>\n</blockquote>\n<p>Would a solution be to have maps use <code>[Trunc (LinearOrder X)]</code> as a typeclass instead of <code>LinearOrder X</code>?</p>",
        "id": 409368333,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> arrrrguably if I want to create a map with Option as its keys, that should be better thought of as an Option (map). Like in the sense that I'm uncomfortable with the idea that you could create a map such that putting None in gave data out.</p>",
        "id": 409368342,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158185
    },
    {
        "content": "<p>There are cases where there is obviously <em>an</em> order, but while the exact choice of order isn't clear, it's not actually relevant to the implementation</p>",
        "id": 409368453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409368333\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409367068\">said</a>:</p>\n<blockquote>\n<p>I'm concerned about the programming use case though, I don't think we want to make people use a type synonym to be able to put options in map keys</p>\n</blockquote>\n<p>Would a solution be to have maps use <code>[Trunc (LinearOrder X)]</code> as a typeclass instead of <code>LinearOrder X</code>?</p>\n</blockquote>\n<p>No.</p>",
        "id": 409368458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158214
    },
    {
        "content": "<p>Like kinda what Option wants is to be able to use it as monadically as possible, where essentially I chunter along using it but if at any point a None appears everything after it is None too.</p>",
        "id": 409368549,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158245
    },
    {
        "content": "<p>(this also feels a bit like the <code>Repr (Multiset X)</code> problem, where on <code>X = Prod A B</code> we want to print in a lexicographic order, even though it's not as canonical as the standard order)</p>",
        "id": 409368609,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409368342\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> arrrrguably if I want to create a map with Option as its keys, that should be better thought of as an Option (map). Like in the sense that I'm uncomfortable with the idea that you could create a map such that putting None in gave data out.</p>\n</blockquote>\n<p>That's not what a map with option keys is though, a <code>HashMap (Option K) V</code> is isomorphic to <code>Option V x HashMap K V</code></p>",
        "id": 409368645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158286
    },
    {
        "content": "<p>What's the story for <code>HashMap (Prod X Y) Z</code> right now? Do you have to use <code>HashMap (Lex (Prod X Y)) Z</code>?</p>",
        "id": 409368705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158315
    },
    {
        "content": "<p>Quotients make printing and lots of other things difficult. Consider the <code>Repr Real</code> instance which cannot be made safe</p>",
        "id": 409368723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158321
    },
    {
        "content": "<p>No hashmaps of products work fine</p>",
        "id": 409368868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409368645\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409368342\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> arrrrguably if I want to create a map with Option as its keys, that should be better thought of as an Option (map). Like in the sense that I'm uncomfortable with the idea that you could create a map such that putting None in gave data out.</p>\n</blockquote>\n<p>That's not what a map with option keys is though, a <code>HashMap (Option K) V</code> is isomorphic to <code>Option V x HashMap K V</code></p>\n</blockquote>\n<p>Hang on, why isn't it <code>V x HashMap K V</code>?</p>",
        "id": 409368892,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158373
    },
    {
        "content": "<p>Because the <code>none</code> key could be absent</p>",
        "id": 409368935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158389
    },
    {
        "content": "<p>For that matter why is it prod and not sum - ah!</p>",
        "id": 409368977,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158405
    },
    {
        "content": "<p>Right yes of course</p>",
        "id": 409368997,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409367068\">said</a>:</p>\n<blockquote>\n<p>I'm concerned about the programming use case though, I don't think we want to make people use a type synonym to be able to put options in map keys</p>\n</blockquote>\n<p>I think I'm missing something; where is the order requirement coming from for map keys? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashMap#doc\">docs#Std.HashMap</a> doesn't have one</p>",
        "id": 409369159,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158455
    },
    {
        "content": "<p>Was trying to work out where that extra state came from. Still think it seems more like a sum though.</p>",
        "id": 409369183,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158461
    },
    {
        "content": "<p>For hashmaps actually everything is fine, these types already have derived hash and eq impls</p>",
        "id": 409369221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158482
    },
    {
        "content": "<p>it's order-based maps that require ord impls</p>",
        "id": 409369261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158505
    },
    {
        "content": "<p>like <code>RBMap</code></p>",
        "id": 409369279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158512
    },
    {
        "content": "<p>Maybe we should have a <code>HasLexicographicOrder X Y</code> typeclass which provides a map from a type <code>X</code> to an outparam linearly-ordered type <code>Y</code>?</p>",
        "id": 409369333,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158535
    },
    {
        "content": "<p><del>Though maybe <code>LinearOrder (Lex X)</code> is sufficient for that and we should just put the with_bot order on <code>Lex Option</code></del></p>",
        "id": 409369457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158580
    },
    {
        "content": "<p>that would also be bad in the programming use case, it adds an additional computationally relevant operation on the hot path</p>",
        "id": 409369465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158582
    },
    {
        "content": "<p>Is an identity function computationally relevant?</p>",
        "id": 409369512,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158609
    },
    {
        "content": "<p>only if it's the identity function</p>",
        "id": 409369533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158618
    },
    {
        "content": "<p>Or is the point that the compiler can't see its an identity function?</p>",
        "id": 409369535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158618
    },
    {
        "content": "<p>it may not <em>be</em> the identity</p>",
        "id": 409369564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158630
    },
    {
        "content": "<p>and in the derived impls it won't be</p>",
        "id": 409369574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158636
    },
    {
        "content": "<p>even if it is <code>Prod.map id id</code> I don't think the compiler will know it is the identity, but I expect some of these to also be genuinely non-identity maps</p>",
        "id": 409369725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158695
    },
    {
        "content": "<p>And all these problems are solved if <code>none &lt; some k</code>?</p>",
        "id": 409369825,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158743
    },
    {
        "content": "<p>yes, at least for option</p>",
        "id": 409369867,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158760
    },
    {
        "content": "<p>In the cases where it's a non-identity map, aren't we just choosing between baking that map into the comparator vs storing it separately?</p>",
        "id": 409369883,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158765
    },
    {
        "content": "<p>I think a better approach would be <code>HasWeirdOrd X</code> which has derived total ordering impls</p>",
        "id": 409369889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158767
    },
    {
        "content": "<p>The latter is arguably more efficient because you can avoid recomputing the embedding in the linear order when doing multiple comparisons</p>",
        "id": 409369940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409369889\">said</a>:</p>\n<blockquote>\n<p>I think a better approach would be <code>HasWeirdOrd X</code> which has derived total ordering impls</p>\n</blockquote>\n<p>What's the weird ord here?</p>",
        "id": 409370049,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158824
    },
    {
        "content": "<p><code>none &lt; some k</code> in this case</p>",
        "id": 409370083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158840
    },
    {
        "content": "<p>Right</p>",
        "id": 409370113,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158850
    },
    {
        "content": "<p>it might not even be a <code>LT</code> implementation, I think RBMap uses <code>compare</code></p>",
        "id": 409370118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158853
    },
    {
        "content": "<p>Maybe the answer here is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=compare#doc\">docs#compare</a> gets to have the weird order</p>",
        "id": 409370169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158877
    },
    {
        "content": "<p><code>compare</code> is interesting. Does it need total ordering?</p>",
        "id": 409370198,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158890
    },
    {
        "content": "<p>Since  it can't agree with le / lt anyway unless the order is linear</p>",
        "id": 409370200,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158890
    },
    {
        "content": "<p>if we do that though then a lot of <code>LawfulOrd</code> instances go out the window</p>",
        "id": 409370222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158902
    },
    {
        "content": "<p>(and it might also be confusing)</p>",
        "id": 409370331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158934
    },
    {
        "content": "<p>Do they? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LawfulOrd#doc\">docs#LawfulOrd</a> is never true on a non-linear order ,is it?</p>",
        "id": 409370338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703158937
    },
    {
        "content": "<p>right, but if we put a linear order whenever there is a cmp then of course it will be lawful</p>",
        "id": 409370395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703158961
    },
    {
        "content": "<p>Yeah, one of the odd things here is that baked into the very definition of <code>Ordering</code> is an assumption of totality</p>",
        "id": 409370419,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158971
    },
    {
        "content": "<p>One could imagine a type that had INC along with LT, EQ, and GT.</p>",
        "id": 409370464,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703158990
    },
    {
        "content": "<p>you would not have a LawfulOrd instance unless you have a cmp anyway</p>",
        "id": 409370493,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159002
    },
    {
        "content": "<p>... Option (Ordering), if you will</p>",
        "id": 409370494,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409370222\">said</a>:</p>\n<blockquote>\n<p>if we do that though then a lot of <code>LawfulOrd</code> instances go out the window</p>\n</blockquote>\n<p>I don't think this typeclass even exists?</p>",
        "id": 409370501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159006
    },
    {
        "content": "<p>no it doesn't, our metatheory around this area is in shambles in part because of the issues being discussed here</p>",
        "id": 409370567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159033
    },
    {
        "content": "<p><code>LinearOrder</code> is a candidate for it, which has the compatibility requirements</p>",
        "id": 409370570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159034
    },
    {
        "content": "<p>Incidentally <code>Option Ordering</code> is a great example, perhaps the prototypical example, of somewhere where the incomparable ordering is appropriate.</p>",
        "id": 409370688,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159073
    },
    {
        "content": "<p>I think the main relevant issue is <a href=\"https://github.com/leanprover/lean4/pull/1777\">lean4#1777</a></p>",
        "id": 409370698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159078
    },
    {
        "content": "<p>This solution looks like it works to me:</p>\n<ul>\n<li>On linearly ordered types, Lt, Le, cmp all agree (and we have a lawful instance that declares this)</li>\n<li>On partially-ordered types, cmp is the \"most canonical\" lexicographic linear order, which is independent of <code>&lt;</code> and <code>&lt;=</code></li>\n</ul>",
        "id": 409370705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159080
    },
    {
        "content": "<p>Sure, it's a bit confusing that cmp can disagree with le/lt, but that seems like precisely the design requirement to put things with a partial order in an rbmap</p>",
        "id": 409370878,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159149
    },
    {
        "content": "<p>might be nice to have at least some partial agreement like <code>x &lt;= y -&gt; (cmp x y).isLE</code></p>",
        "id": 409370950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159166
    },
    {
        "content": "<p>I think that one is fairly easy to keep</p>",
        "id": 409371015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409370698\">said</a>:</p>\n<blockquote>\n<p>I think the main relevant issue is <a href=\"https://github.com/leanprover/lean4/pull/1777\">lean4#1777</a></p>\n</blockquote>\n<p>I don't know if I agree with this feature request; this feels like a problem for downstream code (std/mathlib) to deal with, not a core issue</p>",
        "id": 409371074,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159222
    },
    {
        "content": "<p>Would this mean that Option was free to have the incomparable ordering without breaking things?</p>",
        "id": 409371079,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159225
    },
    {
        "content": "<p>well it's in core in part because <code>Ord</code> is in core</p>",
        "id": 409371103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159238
    },
    {
        "content": "<p>I think we could just remove it?</p>",
        "id": 409371120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159245
    },
    {
        "content": "<p>and relocate it to std</p>",
        "id": 409371139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159253
    },
    {
        "content": "<p>Well, <code>OfNat</code> is in core and so is <code>HAdd</code>, but that doesn't mean we need core to enforce <code>0 + x = x</code></p>",
        "id": 409371164,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159266
    },
    {
        "content": "<p>Presumably the rationale for things being in core is \"this really is necessary to even have a programming language at all\".</p>",
        "id": 409371249,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159287
    },
    {
        "content": "<p>well some of those things are in std too</p>",
        "id": 409371302,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159307
    },
    {
        "content": "<p>I'm not entirely sure I understand the user who would <em>not</em> use std4 but.</p>",
        "id": 409371313,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159313
    },
    {
        "content": "<p>So why do we need it to enforce lawfulness of <code>Ord</code> and <code>LT</code>? To me, keeping <code>Ord</code> as the raw notation class seems sensible, and Std should be building lawfulness on top of the notation classes</p>",
        "id": 409371320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159316
    },
    {
        "content": "<p>not lawfulness, it just provides both operations</p>",
        "id": 409371358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409371249\">said</a>:</p>\n<blockquote>\n<p>Presumably the rationale for things being in core is \"this really is necessary to even have a programming language at all\".</p>\n</blockquote>\n<p>My interpretation of this is \"this is really necessary to _write_ the programming language itself\"</p>",
        "id": 409371396,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159347
    },
    {
        "content": "<p>that way you have a one stop shop for assuming you have an ordered type</p>",
        "id": 409371424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159359
    },
    {
        "content": "<p>mathlib understands the value of this very well but in lean4 programming mode we have 3 to 6 different ways to assume ordering on a type used in various combinations</p>",
        "id": 409371563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159411
    },
    {
        "content": "<p>Ghastly.</p>",
        "id": 409371614,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409371563\">said</a>:</p>\n<blockquote>\n<p>mathlib understands the value of this very well but in lean4 programming mode we have 3 to 6 different ways to assume ordering on a type used in various combinations</p>\n</blockquote>\n<p>Does mathlib have any typeclasses that provide a bundle of data with no lawfulness?</p>",
        "id": 409371691,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159467
    },
    {
        "content": "<p>from what I can tell <code>Ord</code> is used exactly 0 times in lean core for reasons other than deriving <code>Ord</code> instances</p>",
        "id": 409371698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159470
    },
    {
        "content": "<p>No, but that's not the point. In math mode of course you want lawfulness, in programming mode the lawfulness is in our hearts</p>",
        "id": 409371760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159508
    },
    {
        "content": "<p>the point is that in mathlib you write <code>LinearOrder</code> and get &lt; and &lt;= and compare and min and max, etc, rather than having that as 5 different typeclass arguments</p>",
        "id": 409371947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159574
    },
    {
        "content": "<p>\"the lawfulness is in our hearts\" is very funny to me</p>",
        "id": 409372175,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159667
    },
    {
        "content": "<p>It do be like that</p>",
        "id": 409372204,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703159678
    },
    {
        "content": "<p>Ah, so the compromise you're proposing is that the lawfulness in our hearts become the weaker <code>x &lt;= y -&gt; (cmp x y).isLE</code> and <code>x = y -&gt; (cmp x y).isEQ</code>, and then the operators can always coexist?</p>",
        "id": 409372766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159901
    },
    {
        "content": "<p>(that is, lawfulness means that <code>cmp</code> always describes an order at least as strong as <code>&lt;</code>/<code>&lt;=</code>)</p>",
        "id": 409372849,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703159936
    },
    {
        "content": "<p>yeah, there would be two <code>LawfulOrd</code> like typeclasses in this case</p>",
        "id": 409372901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703159959
    },
    {
        "content": "<p>but <code>Ord</code> itself would just give you the whole bundle</p>",
        "id": 409373041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703160006
    },
    {
        "content": "<p>... and a warning that it is likely to not be quite as lawful as you might expect</p>",
        "id": 409373092,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703160026
    },
    {
        "content": "<p>and it would be used for both linear and partial order cases</p>",
        "id": 409373095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703160027
    },
    {
        "content": "<p>I think we still want a separate typeclass for <code>compare</code> alone, to let you define things one piece at a time</p>",
        "id": 409373153,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703160047
    },
    {
        "content": "<p>Usually when defining things one piece at a time it suffices to just have a standalone <code>Foo.compare</code> function and use that as part of the construction</p>",
        "id": 409373287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703160092
    },
    {
        "content": "<p>it's often a good idea to do that anyway even if the typeclass just wraps it</p>",
        "id": 409373345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703160113
    },
    {
        "content": "<p>The main downside in that approach is that if you state any lemmas about it, you have to state them again when you assemble the typeclass</p>",
        "id": 409374540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703160543
    },
    {
        "content": "<p>As I alluded to above, you could have a <code>cmp?</code> which mapped into <code>Option Ordering</code>.</p>",
        "id": 409375030,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703160719
    },
    {
        "content": "<p>Like in a sense that might be what a partial order needs.</p>",
        "id": 409375123,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703160742
    },
    {
        "content": "<p>Incidentally have submitted <a href=\"https://github.com/leanprover-community/mathlib4/pull/9178\">#9178</a> which is another small and easy PR around this issue.</p>",
        "id": 409382175,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703163219
    },
    {
        "content": "<p>Is there a way to make a mathlib commit depend on a std4 commit?</p>",
        "id": 409382475,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703163321
    },
    {
        "content": "<p>Yes, you update the lake manifest to point at your std branch</p>",
        "id": 409383051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703163487
    },
    {
        "content": "<p>we should have a tag to track PRs which do that so that we don't accidentally merge them</p>",
        "id": 409383133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703163518
    },
    {
        "content": "<p>Could we just have CI fail on anything other than <code>master</code> in the lakefile?</p>",
        "id": 409384313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703163856
    },
    {
        "content": "<p>no, because we want these PRs to pass CI to justify merging the things they depend on</p>",
        "id": 409391974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703166344
    },
    {
        "content": "<p>We could have CI fail for the master/staging branch only, that would make bors reject it</p>",
        "id": 409392126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703166396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I wonder if there's a way to make a class that contains <code>WithBot</code>, <code>WithTop</code>, and whatever it is we call the thing with the incomparable whatsit, which might just be <code>Option</code>.</p>",
        "id": 409406896,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703170966
    },
    {
        "content": "<p>It occurs that there's lemmas that are always true for all of them - e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">some_le_some_iff</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">some</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">le_of_some_le_some</span><span class=\"o\">,</span> <span class=\"n\">some_le_some_of_le</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Where the proof is essentially the same for all of them.</p>",
        "id": 409407097,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171029
    },
    {
        "content": "<p>Wheras there are things that are only true in one of them.</p>",
        "id": 409407151,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171044
    },
    {
        "content": "<p>This to me feels like the kind of thing that a class is meant to handle.</p>",
        "id": 409407207,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171056
    },
    {
        "content": "<p>More like \"<code>some</code> is an <code>OrderEmbedding</code>\"</p>",
        "id": 409407485,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703171161
    },
    {
        "content": "<p>Note that each of <code>WithBot</code>, <code>WithTop</code>, and <code>Option</code> have a different <code>some</code> anyway, so what Yael describes is exactly the bit that is actually generalizable</p>",
        "id": 409407702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703171228
    },
    {
        "content": "<p>Sure.</p>",
        "id": 409407779,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171257
    },
    {
        "content": "<p>But the point is, there's a common structure there.</p>",
        "id": 409408023,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171340
    },
    {
        "content": "<p>Incidentally, why does <code>OrderEmbedding.subtype</code> require <code>Preorder</code></p>",
        "id": 409408067,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171353
    },
    {
        "content": "<p>because we don't really care about things weaker than preorders</p>",
        "id": 409408184,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703171400
    },
    {
        "content": "<p>Ye-es.</p>",
        "id": 409408305,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171427
    },
    {
        "content": "<p>But it could just require <code>LE</code>, right? It's just a notational truth.</p>",
        "id": 409408389,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171447
    },
    {
        "content": "<p>In that case, yes</p>",
        "id": 409408614,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703171521
    },
    {
        "content": "<p>Essentially, I can say this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">optionIsSomeOrderIso</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">LE</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"n\">x.isSome</span> <span class=\"o\">}</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">o</span> <span class=\"o\">:=</span> <span class=\"n\">Option.get</span> <span class=\"n\">_</span> <span class=\"n\">o.2</span>\n  <span class=\"n\">invFun</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">some</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"n\">left_inv</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Subtype.eq</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Option.some_get</span> <span class=\"n\">_</span>\n  <span class=\"n\">right_inv</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">Option.get_some</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n  <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"n\">get_le_get_iff_le</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>Obviously I can do something similar with the embedding of <code>some</code>. But in a sense it would be good to derive the latter from the former. Unfortunately for that...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">someOrderEmbedding</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OrderEmbedding</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">RelEmbedding.trans</span> <span class=\"o\">(</span><span class=\"n\">optionIsSomeOrderIso</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.toOrderEmbedding</span> <span class=\"o\">(</span><span class=\"n\">OrderEmbedding.subtype</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 409408694,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171533
    },
    {
        "content": "<p>You need Preorder.</p>",
        "id": 409408711,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171540
    },
    {
        "content": "<p>If you look at <code>WithBot.some_le_some</code>, the WithBot version of what I cited above, it just needs <code>LE</code>. So clearly you would want to do the same thing here.</p>",
        "id": 409409097,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171663
    },
    {
        "content": "<p>This is in general a problem; if you make your morphisms assume any lawful structure, then you find that you can't use the morphisms to pull back / push forward structure</p>",
        "id": 409409768,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703171879
    },
    {
        "content": "<p>Aye. Because this is the bit where their structure is in agreement I had hoped this wouldn't be an issue</p>",
        "id": 409409984,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171943
    },
    {
        "content": "<p>And you know, things like <code>MulEquivClass</code> seem magic to me</p>",
        "id": 409410025,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703171955
    },
    {
        "content": "<p>(but if your morphisms don't assume any structure, then often you end up needing way more fields; group morphisms and monoid morphisms are the same, but <code>one</code>/<code>mul</code>/<code>inv</code> morphisms and <code>one</code>/<code>mul</code> morphisms are different)</p>",
        "id": 409410076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703171971
    },
    {
        "content": "<p>Partially I just think it's things having differing levels of generality across the library - in this case, <code>Monotone</code> is only defined on Preorders, even though it makes sense as a sentence (even if it has less meaning) for LE.</p>",
        "id": 409410451,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172099
    },
    {
        "content": "<p>But you could change it.</p>",
        "id": 409410474,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172106
    },
    {
        "content": "<p>Personally I think definitions should always be made with minimal assumptions.</p>",
        "id": 409410589,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172133
    },
    {
        "content": "<p>So should we have separate <code>MonoidHom</code> and <code>GroupHom</code> in order to permit that? That creates massive amounts of extra boilerplate...</p>",
        "id": 409410757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703172186
    },
    {
        "content": "<p>I'm not sure I understand what that has to do with <code>Monotone</code>...</p>",
        "id": 409410851,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172212
    },
    {
        "content": "<p>Always here should be understood to mean \"not always, but often\".</p>",
        "id": 409410892,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172226
    },
    {
        "content": "<p>I am not sure you would need GroupHom? That's actually an example of the kind of generality I think is good.</p>",
        "id": 409411003,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172257
    },
    {
        "content": "<blockquote>\n<p>Always here should be understood to mean \"not always, but often\".</p>\n</blockquote>\n<p>I don't think defining <code>X</code> in terms of <code>not X</code> is particularly transparent...</p>",
        "id": 409411036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703172270
    },
    {
        "content": "<p>?</p>",
        "id": 409411059,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172280
    },
    {
        "content": "<p>Oh I see - I mean I'm just being colloquial I guess.</p>",
        "id": 409411139,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172305
    },
    {
        "content": "<p>As a rule of thumb, one should always bend towards minimal assumptions for things, but sometimes that isn't necessary.</p>",
        "id": 409411195,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172330
    },
    {
        "content": "<p>In this case I was asking \"can we have less boilerplate here somehow\".</p>",
        "id": 409411243,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172344
    },
    {
        "content": "<p>And I would think this is pretty minimal in terms of boilerplate already.</p>",
        "id": 409411353,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703172368
    },
    {
        "content": "<p>Also pointing out that it is mildly absurd that the assumptions for defining an OrderEmbedding are in fact less than that needed to define an OrderHom.</p>",
        "id": 409411388,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172383
    },
    {
        "content": "<p>Agreed. I'm happy to merge a PR to change it to <code>Preorder</code>!</p>",
        "id": 409411449,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703172407
    },
    {
        "content": "<p>Ha!</p>",
        "id": 409411472,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172414
    },
    {
        "content": "<p>But presumably not to go in the other direction?</p>",
        "id": 409411564,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172444
    },
    {
        "content": "<p>No, I wouldn't really see the point</p>",
        "id": 409411622,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703172467
    },
    {
        "content": "<p>Hmm.</p>",
        "id": 409411890,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172562
    },
    {
        "content": "<p>I think in my view they're equally pointless - so I don't really understand why you'd be happy to do one but not the other.</p>",
        "id": 409412562,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172771
    },
    {
        "content": "<p>(I am perfectly content for pointless things to happen.)</p>",
        "id": 409412639,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172796
    },
    {
        "content": "<p>And, indeed, if I look at, say, the structure of <code>WithBot.lean</code>, I can see a clear distinction between <code>LE</code> and <code>LT</code> assumptions and Preorder ones.</p>",
        "id": 409413071,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703172934
    },
    {
        "content": "<p>I have PR'd <a href=\"https://github.com/leanprover-community/mathlib4/pull/9181\">#9181</a>, just to get something in there. But the core issue of what the solution should be is not resolved.</p>",
        "id": 409436638,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703180810
    },
    {
        "content": "<p>I have also summarised the above discussion - <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I haven't gone into all the detail you gave but I've tried to represent your position fairly. Of course, if you feel there are important points to add, please do do so.</p>",
        "id": 409436719,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703180856
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110994\">@Joe Hendrix</span> if you're interested in the context of that PR to std, it's here.</p>",
        "id": 409476663,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703198805
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9181\">#9181</a> tries to summarise the situation. Unfortunately there are a few moving parts.</p>",
        "id": 409477444,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703199230
    },
    {
        "content": "<p>If we end up removing Rel and not putting StrictRel into standard, I suspect I will add them to <a href=\"https://github.com/leanprover-community/mathlib4/pull/9181\">#9181</a>!</p>",
        "id": 409477983,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703199405
    },
    {
        "content": "<p>Amused that we are solving all the issues with this being spread across three places by just adding everything into Mathlib.</p>",
        "id": 409479280,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200052
    },
    {
        "content": "<p>I feel like that has historically been the solution to quite a lot of problems</p>",
        "id": 409479366,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200087
    },
    {
        "content": "<p>And the cause!</p>",
        "id": 409479398,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200109
    },
    {
        "content": "<p>It's interesting because presumably these were deliberately added to std4? But I agree they taste more mathsy.</p>",
        "id": 409479425,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200136
    },
    {
        "content": "<p>they were part of the initial mathlib import of these basic files</p>",
        "id": 409479464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200171
    },
    {
        "content": "<p>Right.</p>",
        "id": 409479494,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200190
    },
    {
        "content": "<p>Well, Rel and StrictRel would fit well into Data/Option/Order when it exists though we still haven't entirely resolved this issue of what should actually happen to Option by default.</p>",
        "id": 409479646,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200275
    },
    {
        "content": "<p>they may not be defined like that though</p>",
        "id": 409479693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200309
    },
    {
        "content": "<p>best wait until we have the rest of it together</p>",
        "id": 409479761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330967\">Wrenna Robson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409479280\">said</a>:</p>\n<blockquote>\n<p>Amused that we are solving all the issues with this being spread across three places by just adding everything into Mathlib.</p>\n</blockquote>\n<p>This strategy served us extremely well in the past. Now we are trying to move away from this. There are good reasons to do that, but the cost is <a href=\"https://leanprover-community.github.io/contribute/tags_and_branches.html\">huge</a>.</p>",
        "id": 409479796,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703200358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409479761\">said</a>:</p>\n<blockquote>\n<p>best wait until we have the rest of it together</p>\n</blockquote>\n<p>Is there any reason not to have (in mathlib) Rel, StrictRel, and the lemmas saying that if <code>R</code> is transitive then so is <code>Rel R</code> etc? I think the contention in this thread is about canonical orders, not arbitrary relations</p>",
        "id": 409480229,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703200642
    },
    {
        "content": "<p>I think those are fine theorems to have in mathlib</p>",
        "id": 409480248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200663
    },
    {
        "content": "<p>without a use case in std they are just dead weight</p>",
        "id": 409480262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200681
    },
    {
        "content": "<p>Ah, so you mean \"wait until the rest is together before upstreaming anything to std\"?</p>",
        "id": 409480334,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703200719
    },
    {
        "content": "<p>we should have a coherent strategy for how all these theorems are to be used together to improve the general usability of lean qua programming language</p>",
        "id": 409480387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200769
    },
    {
        "content": "<p>Indeed.</p>",
        "id": 409480408,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200787
    },
    {
        "content": "<p>But this isn't a prerequisite for (partial?) inclusion in mathlib</p>",
        "id": 409480494,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703200822
    },
    {
        "content": "<p>(maybe it is a prerequisite for the global instance being proposed)</p>",
        "id": 409480530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703200851
    },
    {
        "content": "<p>indeed not, the mathlib bar is a bit closer to \"it's true and potentially useful\"</p>",
        "id": 409480551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703200867
    },
    {
        "content": "<p>As I say, this all started because I had some function I'd defined to Option (Fin n), because having it defined to Fin n with junk values was giving me a need to have NeZero n everywhere. Semantically, Option is correct. But then I wanted certain ordering theorems to be true - essentially think \"this is a partial function, but when it has values, these nice inequalities are true\".</p>",
        "id": 409480579,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200892
    },
    {
        "content": "<p>This was in the context of my real actual work I've been doing (well - actually it was in a refactor to SuccAbove I was looking at that had come from that - the point is it was me actually using Lean for a real purpose - at the end of the day, trying to verify this particular subroutine in some cryptography - so I am here wearing the hat, partially, of Real Actual User).</p>",
        "id": 409480682,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703200974
    },
    {
        "content": "<p>right, that sounds like sufficient grounds to get it in mathlib</p>",
        "id": 409480720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703201003
    },
    {
        "content": "<p>I think you should split <a href=\"https://github.com/leanprover-community/mathlib4/pull/9181\">#9181</a> into the bit that doesn't conflict with the core instance, and the bit that does</p>",
        "id": 409480855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703201088
    },
    {
        "content": "<p>Indeed. And I'd quite like this default order to be on Option, because for the interpretation of Option as \"partial function codomain\", if you see what I mean, you kinda really don't want none to accidentally mean anything.</p>",
        "id": 409480865,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201092
    },
    {
        "content": "<p>Ah, so just the LE instance, and then the LT part and beyond?</p>",
        "id": 409480893,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201111
    },
    {
        "content": "<p>I think by std standards this mainly motivates not having a LE or LT instance on Option at all</p>",
        "id": 409480948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703201161
    },
    {
        "content": "<p>That's reasonable. As I say I do think having the core instance is not <em>unreasonable</em> - it is just unfortunate that a) it has zero API, b) we re-implement that as WithBot.</p>",
        "id": 409480987,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201165
    },
    {
        "content": "<p>let downstream users decide what they want to do with it</p>",
        "id": 409480996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703201171
    },
    {
        "content": "<p>Yes, I think that would be the correct choice for std.</p>",
        "id": 409481013,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201188
    },
    {
        "content": "<p>As a reminder Mario, the problem is that core has already decided for us</p>",
        "id": 409481020,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703201191
    },
    {
        "content": "<p>that one seems to be on its way out, I don't think anyone has objected to that</p>",
        "id": 409481050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703201215
    },
    {
        "content": "<p>From a mathlib point of view you know my view.</p>",
        "id": 409481060,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201221
    },
    {
        "content": "<p>But I'm in total agreement also that this is a better choice for <em>maths</em> than for <em>programmers</em>.</p>",
        "id": 409481112,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201262
    },
    {
        "content": "<p>it was added in very early lean 4, if it's not used by now then I doubt anyone will defend it</p>",
        "id": 409481119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1703201270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Preorder.20on.20Option/near/409481050\">said</a>:</p>\n<blockquote>\n<p>that one seems to be on its way out, I don't think anyone has objected to that</p>\n</blockquote>\n<p>I think the context for <a href=\"https://github.com/leanprover/lean4/pull/3100\">lean4#3100</a> has grown so large there's a serious chance of the core PR being ignored because the benefit is not worth reading this zulip thread to work out what the consensus is</p>",
        "id": 409481134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703201282
    },
    {
        "content": "<p>2018 I think?</p>",
        "id": 409481176,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> Thanks for mentioning this thread.  If your code is publicly is available, I'd be interested in taking a look to get more context.</p>",
        "id": 409481183,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1703201291
    },
    {
        "content": "<p>It is. <a href=\"https://github.com/leanprover-community/mathlib4/pull/9181\">#9181</a> contains a summary of the relevant PRs and the discussion so you don't have to read scrollback.</p>",
        "id": 409481236,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201320
    },
    {
        "content": "<p>I was trying to obey the contribution guidelines of \"don't expect everyone to have to read Zulip\" &lt;_&lt;</p>",
        "id": 409481269,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330967\">@Wrenna Robson</span> Oh, I meant the crypto code.</p>",
        "id": 409481288,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1703201358
    },
    {
        "content": "<p>Oh!</p>",
        "id": 409481302,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201370
    },
    {
        "content": "<p>Well, that's a whole other thing. Technically my project is not cryptography per se - I've been working on a verification of Classic McEliece's representation of permutations as bitvectors, extending prior work by DJB. In particular this necessitated some annoying to prove theorems about succAbove and predAbove (... which I think might actually be the simplicial identities...) and that prompted an attempt at a refactor of <em>that</em>.</p>",
        "id": 409481493,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201486
    },
    {
        "content": "<p>Perhaps <code>BitVec n</code> (or some other type than <code>Option (Fin n)</code> would  be useful).   I think the downside of a type of like <code>Option</code> is that <code>none</code> can mean virtually anything.</p>",
        "id": 409481512,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1703201500
    },
    {
        "content": "<p>It's the XKCD sharks comic.</p>",
        "id": 409481515,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201502
    },
    {
        "content": "<p>In this case, Option (Fin n) is being used in the sense of, I have a map from pairs of Fin (n + 1) to Fin n, but it only really applies to <em>distinct</em> pairs.</p>",
        "id": 409481616,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201565
    },
    {
        "content": "<p>It's actually precisely the existing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finSuccEquiv%27#doc\">docs#finSuccEquiv'</a></p>",
        "id": 409481692,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201636
    },
    {
        "content": "<p>Which you'll note maps to Option.</p>",
        "id": 409481741,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201647
    },
    {
        "content": "<p>I agree that none can mean virtually anything, but the interpretation of Option I favour, the one we all learn metaphorically on our grandmother's knee, right, is \"computations that might fail\".</p>",
        "id": 409481854,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201744
    },
    {
        "content": "<p>BUT - other choices are available, I get that.</p>",
        "id": 409481998,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201830
    },
    {
        "content": "<p>Thanks for the context.  It's being used as something like a set with at most one element.</p>",
        "id": 409482060,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1703201879
    },
    {
        "content": "<p>Yes - bit like how List can mean \"computations which can have a variable number of outputs\".</p>",
        "id": 409482150,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703201928
    },
    {
        "content": "<p>I think keeping the definitions and theorems in Mathlib makes sense to me, but the context is helpful.</p>",
        "id": 409482358,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1703202074
    },
    {
        "content": "<p>Indeed. The debate has been about whether or not there should be any kind of order on Option at all and if so what it should be.</p>",
        "id": 409482386,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703202110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'm not sure about splitting that PR until we've obtained some consensus about the holistic plan.</p>",
        "id": 409541023,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703232727
    },
    {
        "content": "<p>Unfortunately I don't really know how to rework my core issue or PR so that the maintainers will spend any time on it. I would hope it would be an easy choice for them.</p>",
        "id": 409582858,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703251603
    },
    {
        "content": "<p>But that requires them to actually look at it.</p>",
        "id": 409582874,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1703251614
    }
]