[
    {
        "content": "<p>Hi! </p>\n<p>I'm looking at the following MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">union</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">change</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I know the first line is optional but I would like to know if there is a tactic that changes the goal to <code>∀ x ∈ A ∪ B, x ∈ C</code> without having to enter this expression manually?</p>\n<p>If I use <code>simp</code> in the above, the goal gets changed to <code>A ⊆ C ∧ B ⊆ C</code>.</p>",
        "id": 409202593,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703084108
    },
    {
        "content": "<p>You can unfold the definitions, with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">HasSubset.Subset</span><span class=\"o\">,</span> <span class=\"n\">LE.le</span><span class=\"o\">,</span> <span class=\"n\">Set.Subset</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 409203712,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1703084427
    },
    {
        "content": "<p>Or do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>see what comes out, and decide that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.subset_def</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>is probably a good pick.</p>",
        "id": 409204036,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1703084514
    },
    {
        "content": "<p>Thanks! <code>rw?</code> suggests many more options that <code>simp?</code> in this case.</p>",
        "id": 409205396,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703084870
    },
    {
        "content": "<p><code>simp?</code> only uses lemmas that are tagged with <code>simp</code> in the library, while <code>rw?</code> will try to rewrite using all the lemmas in the library. So it will give a lot of noise, but you can be sure that what you want will be in the list.</p>",
        "id": 409206080,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1703085068
    },
    {
        "content": "<p>I noticed that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Set.subset_def\">#Set.Basic</a> contains the following comment just above <code>Set.subset_def</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- TODO(Jeremy): write a tactic to unfold specific instances of generic notation?</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">subset_def</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">set.subset_def</span> <span class=\"n\">Set.subset_def</span>\n</code></pre></div>\n<p>Is writing such a tactic still a current objective? I think this was written by <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span>, but perhaps a long time ago?</p>\n<p>Is there a reason for not tagging this with <code>dsimp</code> or <code>simp</code>?</p>",
        "id": 409333014,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703145896
    },
    {
        "content": "<p>Yes, you don't want <em>every</em> set inclusion to be unfolded. It is pretty rare to need unfolding it, even.</p>",
        "id": 409340517,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703148933
    },
    {
        "content": "<p>OK! And how about an explicit tactic to unfold this kind of notation? I mean one that would work <em>without</em> knowing the name of the lemma (such as <code>rw [Set.subset_def]</code>).</p>",
        "id": 409340960,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703149074
    },
    {
        "content": "<p>Do you want it to work without knowing what the result looks like? If not, you can use <code>change ∀ _ ∈ _, _ ∈ _</code> or similar.</p>",
        "id": 409341194,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703149144
    },
    {
        "content": "<p>Yes, indeed, when I use <code>change ∀ x ∈ A ∪ B, x ∈ C</code>, I get exactly what I want.</p>\n<p>I just had in mind the case of a user who does not know that <code>(A ∪ B) ⊆ C</code> is definitionally equivalent to <code>∀ x ∈ A ∪ B, x ∈ C</code>, how can they simplify or rewrite the goal?</p>\n<p>Sebastien's suggestion to use <code>rw?</code> is great because it shows a list of things that one can use to rewrite the goal.</p>\n<p>Now I am wondering about a tactic that would do that automatically. I think I understand why <code>simp</code> is not the way to go here. But the comment in the docs made me curious about how a <code>tactic to unfold specific instances of generic notation</code> would go. Specifically, its it already exists and, if so, what it is called <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 409342503,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703149578
    },
    {
        "content": "<p>You can always do <code>dsimp [(· ⊆ ·)]</code>and recursively unfold the instances that appear. It's tedious but it works.</p>",
        "id": 409342835,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703149695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span> has a tactic to unfold notation, although not in mathlib.</p>",
        "id": 409342889,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703149720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C.60/near/409342835\">said</a>:</p>\n<blockquote>\n<p>You can always do <code>dsimp [(· ⊆ ·)]</code>and recursively unfold the instances that appear. It's tedious but it works.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">dsimp'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">nested</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">maximum</span> <span class=\"n\">recursion</span> <span class=\"n\">depth</span> <span class=\"n\">has</span> <span class=\"n\">been</span> <span class=\"n\">reached</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"bp\">`</span><span class=\"kd\">set_option</span> <span class=\"n\">maxRecDepth</span> <span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;`</span> <span class=\"n\">to</span> <span class=\"n\">increase</span> <span class=\"n\">limit</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But I do get something with <code>simp [(· ⊆ ·)]</code>, namely <code>(fun x x_1 =&gt; x ⊆ x_1) (A ∪ B) C</code> which indeed is not so pleasant to look at.</p>",
        "id": 409343417,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703149900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C.60/near/409342889\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span> has a tactic to unfold notation, although not in mathlib.</p>\n</blockquote>\n<p>Sounds interesting! I'll take a look if I can find it.</p>",
        "id": 409344165,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703150148
    },
    {
        "content": "<p>The <code>unfold</code> tactic that <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span> and I wrote is at <a href=\"https://github.com/leanprover/std4/pull/417\">std4#417</a>. The tactic is meant to unfold one layer of definitions at a time, so it currently takes three invocations to unfold it all the way; but I just tested locally with a recursive version of the same tactic and now <code>unfold' (occs := 1) A ∪ B ⊆ C</code> changes the goal to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">C</span>\n</code></pre></div>\n<p>in one step.</p>",
        "id": 409351707,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1703152541
    },
    {
        "content": "<p>We could add an optional argument for how many times to unfold. Because for general notations like subset notation, the first unfolding turns it into Set.subset, which on its own is not very useful. Or instead we could tag certain lemmata as unfold lemmata, so that this unfolding is in one step.</p>",
        "id": 409362046,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703155947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span>, what do we still need to do before we can merge this into Std?</p>",
        "id": 409362468,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703156115
    },
    {
        "content": "<p>That's great! I look forward to being able to use this tactic <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 409362856,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703156262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C.60/near/409362046\">said</a>:</p>\n<blockquote>\n<p>Or instead we could tag certain lemmata as unfold lemmata, so that this unfolding is in one step.</p>\n</blockquote>\n<p>For the users I have I mind (beginners who are familiar neither with mathlib nor with the mathematical content of the expression <code>A ∪ B ⊆ C</code>), I think that this option would be the best. But I understand that there might be others things to check before such a decision can be made.</p>",
        "id": 409363105,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703156348
    },
    {
        "content": "<p>Another idea would be to tag certain constants as unwanded/implementation detail. So in particular Set.mem, Set.subset, Add.add. Then if one unfolding step gets you to this  constant, you unfold again.</p>",
        "id": 409369147,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703158451
    },
    {
        "content": "<p>We also have a library rewrite tactic which is basically a more general version of the unfold' tactic, allowing you to choose which lemma to rewrite with. This would probably give the rewrite into <code>A ⊂ C ∧ B ⊂ C</code> as the first option. The reason to also have a separate unfold tactic is that not all definitions have a corresponding rewrite lemma.</p>",
        "id": 409369182,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703158461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C.60/near/409369182\">said</a>:</p>\n<blockquote>\n<p>We also have a library rewrite tactic which is basically a more general version of the unfold' tactic, allowing you to choose which lemma to rewrite with. This would probably give the rewrite into <code>A ⊂ C ∧ B ⊂ C</code> as the first option.</p>\n</blockquote>\n<p>Yes, that's also what <code>simp</code> currently does <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 409369594,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703158648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C.60/near/409362468\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303675\">Anand Rao Tadipatri</span>, what do we still need to do before we can merge this into Std?</p>\n</blockquote>\n<p>I have pushed a few minor formatting fixes, and I think the PR is now ready for review. In the future, I think the tactic could use some (non-essential) improvements to its syntax, as I have mentioned in a new comment on the PR.</p>",
        "id": 409375902,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1703161044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C.60/near/409369147\">said</a>:</p>\n<blockquote>\n<p>Another idea would be to tag certain constants as unwanded/implementation detail. So in particular Set.mem, Set.subset, Add.add. Then if one unfolding step gets you to this  constant, you unfold again.</p>\n</blockquote>\n<p>That sounds like a good idea. In this case, we want to unfold constants related to notation/typeclass instances.</p>",
        "id": 409376183,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1703161140
    },
    {
        "content": "<p>I wonder if it makes sense to make the <code>ext</code> tactic work here; right now it only works on equalities, but you could imagine teaching it to do something similar on inequalities too (in practice, for sets / finsets / pi types it would just mean <code>intro x</code>)</p>",
        "id": 409451189,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703186581
    },
    {
        "content": "<p>In your particular example, <code>intro x; revert x</code> works.</p>",
        "id": 409461173,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703191127
    },
    {
        "content": "<p>But then you have to do <code>intro x hx</code> again, am I right?</p>",
        "id": 409461462,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703191312
    },
    {
        "content": "<p>Maybe you mean to go back and forth between the two expressions <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 409461808,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703191494
    },
    {
        "content": "<p>This was to answer your original question of how to perform <code>change ∀ x ∈ A ∪ B, x ∈ C</code> without actually writing out the expression.  Obviously it would be redundant if your next step was to introduce variables again.  One could imagine a tactic that <code>intros</code> all possible variables and then immediately <code>revert</code>s them in order to change the goal to one in which all quantified variables are made explicit, which could potentially have some pedagogical value perhaps.</p>",
        "id": 409472929,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703197116
    },
    {
        "content": "<p>Is there a reason you want to see the <code> ∀</code> in the goal state? It's not there when you use <code>ext</code> on set <em>equality</em></p>",
        "id": 409480661,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703200953
    },
    {
        "content": "<p>Initially, I tried <code>change ∀ x ∈ A ∪ B, x ∈ C</code> because this is what I wanted in the specific case <code>(A ∪ B) ⊆ C</code>. But maybe there are better options, depending also on the local context.</p>\n<p>For <code>(A ∪ B) = C</code>, I would expect <code>(A ∪ B) ⊆ C ∧ C ⊆ (A ∪ B)</code> to come out, which happens if we use <code>rw [Set.Subset.antisymm_iff]</code>. Then we use <code>constructor</code> and we are back to proving <code>(A ∪ B) ⊆ C</code> first.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">union</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⊆</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.Subset.antisymm_iff</span><span class=\"o\">]</span>  <span class=\"c1\">-- A ∪ B ⊆ C ∧ C ⊆ A ∪ B</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Another option is to use <code>rw [Set.ext_iff]</code>, which changes the goal <code>(A ∪ B) = C</code> to <code> ∀ (x : X), x ∈ A ∪ B ↔ x ∈ C</code>.  So again with the quantifiers.</p>\n<p>Both uses of the <code>rw</code> tactic were obtained following <span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span>'s suggestion <code>rw?</code> and choosing from the list.</p>\n<p>Neither <code>change A ∪ B ⊆ C ∧ C ⊆ A ∪ B </code> nor  <code>change ∀ (x : X), x ∈ A ∪ B ↔ x ∈ C </code> work in this case (produces a <code>type mismatch</code>).</p>\n<p>A slightly modified version of <span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> 's suggestion also works here:  running <code>ext x; revert x</code> on <code>(A ∪ B) = C</code> changes the goal to <code>∀ (x : X), x ∈ A ∪ B ↔ x ∈ C </code>. Based on this, we could imagine a <code>set</code> tactic  (or something) that runs <code>intro x; revert x</code> on inclusions and <code>ext x; revert x</code> on equalities?</p>\n<p>Or the tactic could avoid making the quantifiers explicit, changing <code>(A ∪ B) = C</code> to <code>A ∪ B ⊆ C ∧ C ⊆ A ∪ B</code> first and, after <code>constructor</code> has been applied, changing <code>(A ∪ B) ⊆ C</code> to <code>A ⊆ C ∧ B ⊆ C</code>, which is what <code>rw [Set.union_subset_iff]</code> does.</p>\n<p>I wonder what happens if one applies the <code>unfold</code> tactic of <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span>  and <span class=\"user-mention\" data-user-id=\"479299\">@Jovan Gerbscheid</span>  to the new statement above? The point would be to solve the goal by a succession of <code>unfold</code>, <code>constructor</code> and <code>assumption</code> only.</p>\n<p>One final (very minor) question I have is whether it is preferable, in the examples above,  to use <code>rw [@Set.ext_iff]</code> as opposed to <code>rw[Set.ext_iff]</code>? Both seem to work in this particular case, but maybe in general the version with <code>@</code> deals better with implicit variables?</p>",
        "id": 409542443,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703233489
    },
    {
        "content": "<p>The version with the <code>@</code> is an artifact of the <code>rw?</code> tactic; generally I'd remove it</p>",
        "id": 409544458,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703234551
    },
    {
        "content": "<p>Also note the difference between <code>⊂</code> and <code>⊆</code></p>",
        "id": 409544715,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703234683
    },
    {
        "content": "<p>Oh, yes, thanks, I'll edit my previous message <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 409545185,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703234902
    },
    {
        "content": "<p>Still, <code>change A ∪ B ⊆ C ∧ C ⊆ A ∪ B </code> does not rewrite <code>A ∪ B = C</code>, if I'm not mistaken.</p>",
        "id": 409545556,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703235103
    },
    {
        "content": "<p>Well, no, you're expecting rather too much from <code>change</code>. <code>change</code> only works with definitional equality; you could try <code>convert_to A ∪ B ⊆ C ∧ C ⊆ A ∪ B</code> and then <code>apply?</code> will likely find the correct lemma</p>",
        "id": 409546807,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703235643
    },
    {
        "content": "<p>Equality is not a constant that can be unfolded definitionally, so <code>unfold'</code> wouldn't be of use there.</p>",
        "id": 409555076,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703239353
    },
    {
        "content": "<p>Although it seems like a good idea to have <code>unfold'</code> try to apply extensionality if other things fail, because people usually think of set extensionality as the \"definition\" of equality on sets.</p>",
        "id": 409557959,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703240622
    },
    {
        "content": "<p>Indeed. But as you say, <code>unfold'</code> should probably try to apply extensionality only <em>if others things fail</em>, not as a first option.</p>",
        "id": 409560684,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703241710
    },
    {
        "content": "<p>But based on the discussion we have been having in this thread, I now think that to avoid having <code>∀</code> in the goal state might be better. </p>\n<p>So I would hope for a tactic that does the following <code>rw</code> automatically (<code>simp</code> takes care of the second one, but not the first one).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">union</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span> <span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">⊆</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⊆</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.Subset.antisymm_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.union_subset_iff</span><span class=\"o\">]</span>  <span class=\"c1\">-- simp also works</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">assumption</span>\n  <span class=\"n\">assumption</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 409562065,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703242302
    },
    {
        "content": "<p>Since the rewrite of set equality that you want is a very natural one, but not the most natural one (which would be extensionality), I would suggest a tactic that gives you multiple options, where the rewrite you want is the first or second option. The targeted library rewrite that <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao Tadipatri</span> and I have would do this.</p>",
        "id": 409567918,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703245035
    },
    {
        "content": "<p>A separate <code>anti_symm</code> tactic could also solve this, but maybe that would be too specific.</p>",
        "id": 409568184,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703245168
    },
    {
        "content": "<p>Indeed, that would probably be too specific. I'll look forward to trying out your library rewrite!</p>",
        "id": 409579706,
        "sender_full_name": "Flo (Florent Schaffhauser)",
        "timestamp": 1703250249
    },
    {
        "content": "<p>I tend to think of extensionality lemmas as Iff statements, but it turns out that unfortunately the extensionality lemmas used by <code>ext</code> are all implications, meaning that I can't use them for rewriting arbitrary sub-expressions, which is what I want with the <code>unfold'</code>  tactic.</p>",
        "id": 409593291,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703256261
    },
    {
        "content": "<p>The iff statements are usually called <code>ext_iff</code>.</p>",
        "id": 409597910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703257815
    },
    {
        "content": "<p>There are a lot of <code>ext</code> lemmas with no corresponding <code>ext_iff</code> lemmas; maybe we should be generating one from the other?</p>",
        "id": 409598337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703258016
    },
    {
        "content": "<p>(usually the reverse direction is a trivial substitution)</p>",
        "id": 409598366,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703258032
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28A.20.E2.88.AA.20B.29.20.E2.8A.86.20C/near/409597910\">said</a>:</p>\n<blockquote>\n<p>The iff statements are usually called <code>ext_iff</code>.</p>\n</blockquote>\n<p>I could make the tactic rely on this naming convention: get the name of the type, add <code>ext_iff</code> to the name, and see if this gives a lemma that applies. Would such a hacky approach be accepted?</p>",
        "id": 409644736,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703280793
    },
    {
        "content": "<p>I think that probably would not be accepted, it would be better to have the <code>ext</code> attribute include information about where to find the <code>iff</code> lemma</p>",
        "id": 409644775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703280837
    },
    {
        "content": "<p>I think it's ok for an attribute to use heuristics to <em>generate</em> a lookup table, but using heuristics during the lookup seems likely to be fragile</p>",
        "id": 409644888,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703280917
    },
    {
        "content": "<p>The former lets you emit an error at the point someone tries to register an ext (iff) lemma if they make a typo, the latter just silently fails</p>",
        "id": 409644927,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703280943
    },
    {
        "content": "<p>For <em>How To Prove It with Lean</em>, I wrote a tactic that writes out definitions.  Examples of what it does:</p>\n<ul>\n<li>It changes the example that started this discussion, <code>A ∪ B ⊆ C</code> (where <code>A</code>, <code>B</code>, and <code>C</code> have type <code>Set X</code>), into <code>∀ ⦃a : X⦄, a ∈ A ∪ B → a ∈ C</code>.</li>\n<li>It changes <code>a ∈ A ∪ B</code> into <code>a ∈ A ∨ a ∈ B</code>.</li>\n<li>It changes <code>a ∣ b</code> (where <code>a</code> and <code>b</code> are integers) into <code>∃ (c : ℤ), b = a * c</code>.</li>\n</ul>\n<p>The function that does most of the work of my tactic is similar to <code>whnf</code>.  (In fact, I think a tactic that simply called <code>whnf </code>on an expression would do a pretty good job of writing out definitions.)  The function repeatedly calls <code>Lean.Meta.whnfCore</code> and <code>Lean.Meta.unfoldDefinition?</code>.  At each step, it does some additional checks.  Perhaps most significantly, it checks to see if the expression has the form \"not (something)\".  If so, it leaves the \"not\" there and tries to write out the definition of \"something.\"  As a result, not only will it change <code>a ∈ A ∪ B</code> into <code>a ∈ A ∨ a ∈ B</code>, it will also change <code>a ∉ A ∪ B</code> into <code>¬(a ∈ A ∨ a ∈ B)</code>.  There are also special checks to prevent certain unfoldings that could be confusing to beginners.  For example, \"if-then-else\" statements unfold to something unreadable, so they don't get unfolded.  A statement of the form <code>x ∈ A</code> would unfold to <code>A x</code>, so this unfolding is prevented.</p>",
        "id": 410069823,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1703626944
    },
    {
        "content": "<p>This is exactly what the <code>unfold'</code> tactic does as well. I don't understand though how it changes a ∈ A ∪ B into a ∈ A ∨ a ∈ B using just whnf and unfolding definition. Where can i see the code?</p>",
        "id": 410070801,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703627688
    },
    {
        "content": "<p>I wrote a version of the tactic that lists all the steps it went through in writing out a definition.  Here are the steps in writing out the definition of <code>a ∈ A ∪ B</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">dfn_1</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">Set.instMembershipSet.1</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"n\">dfn_2</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">Set.Mem</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"n\">dfn_3</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"n\">dfn_4</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">Set.instUnionSet.1</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">a</span>\n<span class=\"n\">dfn_5</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">Set.union</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">a</span>\n<span class=\"n\">dfn_6</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">setOf</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"n\">dfn_7</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"n\">a</span>\n<span class=\"n\">dfn_8</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∪</span> <span class=\"n\">B</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span>\n</code></pre></div>\n<p>The code is in the Lean package that accompanies <em>How To Prove It with Lean</em>, which is here:<br>\n<a href=\"https://github.com/djvelleman/HTPILeanPackage\">https://github.com/djvelleman/HTPILeanPackage</a><br>\nThe tactic definitions are in the file HTPILib.HTPIDefs, and the main function for the <code>define</code> tactic is called <code>unfoldHeadCore</code>.</p>",
        "id": 410072450,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1703628942
    },
    {
        "content": "<p>I'm a little embarrassed to have anyone look at the code, because it's so full of kludges.</p>",
        "id": 410072919,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1703629348
    },
    {
        "content": "<p>I just realized that <code>whnf</code> does the same simplification of <code>a ∈ A ∪ B</code>. The difference with the <code>unfold'</code> tactic is that this only does one layer of unfolding at a time. It just so happens to be in this case that doing all unfolding gets you to the most natural unfolding.</p>",
        "id": 410076177,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703632293
    },
    {
        "content": "<p>It's a bit awkward that I can't build in special unfold behaviour for set containment since sets are defined in Mathlib, and we're pr-ing this tactic to std.</p>",
        "id": 410076319,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1703632422
    }
]