[
    {
        "content": "<p>Do you know any examples of formalized results on implementation of algorithms together with a proof of the algorithm's correctness in Lean or other proof assistants?<br>\nIn other words,<br>\n<code>def f_algorithm := ...</code><br>\nfollowed by<br>\n<code>example : f 17 = 4 := by decide</code> (which should run reasonably fast) and<br>\n<code>theorem (x : Nat): f_algorithm x = well_known_function x</code><br>\nI can give an example if it helps.</p>",
        "id": 419661501,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1707014196
    },
    {
        "content": "<p>I think some sorting algorithms are proven correct in Std4?</p>",
        "id": 419661731,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707014370
    },
    {
        "content": "<p>I’m sure there are other more interesting examples</p>",
        "id": 419661757,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707014398
    },
    {
        "content": "<p>This isn't quite what you have in mind, and it's not anywhere public (it was for a project for my class last term), but <span class=\"user-mention\" data-user-id=\"607411\">@Isaac Hernando</span> used quadratic reciprocity to write an algorithm for computing Legendre symbols, and proved that it agrees with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=legendreSym#doc\">docs#legendreSym</a> with a lemma tagged with <code>csimp</code>. I think that's really nice, and I wish we had more stuff like this in mathlib.</p>",
        "id": 419662401,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707014710
    },
    {
        "content": "<p>Looking around now I see that there is a <code>norm_num</code> extension for Legendre symbols. Does this actually use quadratic reciprocity in any way?</p>",
        "id": 419662428,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707014749
    },
    {
        "content": "<p>Oh, and now I also remember <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> doing something similar for the 2-adic valuation. Did that ever make it to mathlib?</p>",
        "id": 419662518,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707014821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algorithm.20correctness/near/419662428\">said</a>:</p>\n<blockquote>\n<p>Looking around now I see that there is a <code>norm_num</code> extension for Legendre symbols. Does this actually use quadratic reciprocity in any way?</p>\n</blockquote>\n<p>Indeed it does :) <a href=\"https://github.com/leanprover-community/mathlib4/blob/b8ea7cb7072a51dd9c80dcc72153af0d07e7a64b/Mathlib/Tactic/NormNum/LegendreSymbol.lean#L252\">https://github.com/leanprover-community/mathlib4/blob/b8ea7cb7072a51dd9c80dcc72153af0d07e7a64b/Mathlib/Tactic/NormNum/LegendreSymbol.lean#L252</a></p>",
        "id": 419662715,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707015047
    },
    {
        "content": "<p><code>norm_num</code> extensions aren't themselves proved correct though -- all they do is create a proof that some function evaluates to something, and then that proof is checked.</p>",
        "id": 419662835,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707015192
    },
    {
        "content": "<p>I'm just glad that quadratic reciprocity is used in <em>some</em> algorithm in mathlib :)</p>",
        "id": 419663413,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707015495
    },
    {
        "content": "<p>How about the Euclidean algorithm (to take something with the word 'algorithm' in the name)?</p>",
        "id": 419664521,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1707016836
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.xgcd#doc\">docs#Nat.xgcd</a> for the extended Euclidean algorithm with proofs of correctness like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd_eq_gcd_ab#doc\">docs#Nat.gcd_eq_gcd_ab</a> (Bézout's identity) connecting it to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd#doc\">docs#Nat.gcd</a> (which is defined using the Euclidean algorithm). Key results of correctness are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.gcd_dvd#doc\">docs#Nat.gcd_dvd</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.dvd_gcd#doc\">docs#Nat.dvd_gcd</a></p>",
        "id": 419664822,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1707017243
    },
    {
        "content": "<p>Are you aware of the Coq <em>Software Foundations</em> book?  For example, here's the page doing implementation and correctness-proof of mergesort.<br>\n<a href=\"https://softwarefoundations.cis.upenn.edu/vfa-current/Merge.html\">https://softwarefoundations.cis.upenn.edu/vfa-current/Merge.html</a></p>",
        "id": 419664899,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1707017313
    },
    {
        "content": "<p>A small example in Lean: <span class=\"user-mention\" data-user-id=\"455674\">@Matej Penciak</span> came to speak to my undergraduate class and taught them about fast exponentiation (<a href=\"https://en.wikipedia.org/wiki/Exponentiation_by_squaring\">exponentiation by squaring</a>).  Here's his code giving the algorithm and proof of correctness: <br>\n<a href=\"https://github.com/mpenciak/FordhamSp2023/blob/main/Fordham/ProofDemos.lean\">https://github.com/mpenciak/FordhamSp2023/blob/main/Fordham/ProofDemos.lean</a></p>",
        "id": 419665113,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1707017526
    },
    {
        "content": "<p>Other theorem provers have been used a lot for such work.  For example, I don't know how much is published but John Harrison verified Intel's floating point Pentium chip algorithms in HOL-Light.  He even was able to reduce the number of instructions in one of those.</p>",
        "id": 419665308,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707017767
    },
    {
        "content": "<p>There is an entire C compiler verified in Coq: <a href=\"https://compcert.org/\">https://compcert.org/</a></p>",
        "id": 419665363,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707017874
    },
    {
        "content": "<p>However, I should clarify that both of those projects are verifying the correctness of code written in another language separate from the formal proof assistant.</p>",
        "id": 419665703,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707018253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algorithm.20correctness/near/419664899\">said</a>:</p>\n<blockquote>\n<p>Are you aware of the Coq <em>Software Foundations</em> book?  For example, here's the page doing implementation and correctness-proof of mergesort.<br>\n<a href=\"https://softwarefoundations.cis.upenn.edu/vfa-current/Merge.html\">https://softwarefoundations.cis.upenn.edu/vfa-current/Merge.html</a></p>\n</blockquote>\n<p>Nice, thanks. I was particularly looking for depth-first search but that seems to be missing.</p>",
        "id": 419666278,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1707018975
    },
    {
        "content": "<p>I think you are looking for more basic stuff, but here are some more examples of big projects done in Coq: <a href=\"https://coq.discourse.group/t/high-assurance-high-code-complexity-use-of-coq/209\">https://coq.discourse.group/t/high-assurance-high-code-complexity-use-of-coq/209</a></p>",
        "id": 419666377,
        "sender_full_name": "Jason Rute",
        "timestamp": 1707019141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algorithm.20correctness/near/419665308\">said</a>:</p>\n<blockquote>\n<p>Other theorem provers have been used a lot for such work.  For example, I don't know how much is published but John Harrison verified Intel's floating point Pentium chip algorithms in HOL-Light.  He even was able to reduce the number of instructions in one of those.</p>\n</blockquote>\n<p>Oh right, I recall he gave an invited talk at an ASL meeting in 2010 (although not about that work).</p>",
        "id": 419667607,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1707020616
    },
    {
        "content": "<p>I have experimented with such things at different scales:</p>\n<ul>\n<li>My first Lean project <a href=\"https://github.com/siddhartha-gadgil/Saturn\">SATurn</a> is a DPLL SAT solver in Lean with proved algorithms.</li>\n<li>In a <a href=\"https://github.com/siddhartha-gadgil/proofs-and-programs-2023/\">course</a> I taught, I had a few small examples: solving a linear Diaphontine equation in two variables, finding the minimum in a List and then insertion sort as a homework.</li>\n</ul>",
        "id": 419684900,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1707040105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115715\">Jason Rute</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algorithm.20correctness/near/419665308\">said</a>:</p>\n<blockquote>\n<p>Other theorem provers have been used a lot for such work.  For example, I don't know how much is published but John Harrison verified Intel's floating point Pentium chip algorithms in HOL-Light.  He even was able to reduce the number of instructions in one of those.</p>\n</blockquote>\n<p>There was recently someone in the Zulip who wanted a proof of a theorem in order to get rid of two instructions from his cryptography routine, iirc</p>",
        "id": 419693663,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1707048255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Algorithm.20correctness/near/419662518\">said</a>:</p>\n<blockquote>\n<p>Oh, and now I also remember <span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> doing something similar for the 2-adic valuation. Did that ever make it to mathlib?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.maxPowDiv#doc\">docs#Nat.maxPowDiv</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=padicValNat.padicValNat_eq_maxPowDiv#doc\">docs#padicValNat.padicValNat_eq_maxPowDiv</a></p>",
        "id": 419702572,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707056968
    },
    {
        "content": "<p>Grepping reveals three uses of <code>csimp</code> in mathlib-proper</p>",
        "id": 419702644,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1707057022
    },
    {
        "content": "<p>I've implemented and proved equivalent Karatsuba on my warpath towards proving algorithmic complexities:<br>\n<a href=\"https://github.com/calcu16/lean_complexity/blob/main/Karatsuba.lean\">https://github.com/calcu16/lean_complexity/blob/main/Karatsuba.lean</a></p>\n<p>search for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Nat.karatsuba_eq_mul</span><span class=\"o\">:</span> <span class=\"n\">karatsuba</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.mul</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>in general any <code>funext</code> proof would seem to be a proof of \"algorithmic correctness\" right?</p>",
        "id": 419760406,
        "sender_full_name": "Andrew Carter",
        "timestamp": 1707105091
    }
]