[
    {
        "content": "<p>How should one implement the \"re-use proof with <code>(Œ± := Œ±·µí·µà)</code>\" pattern when there is an <code>Icc</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">icc_od</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Icc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">Icc</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">Œ±</span><span class=\"bp\">·µí·µà</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- `rfl`, `simp [Set.dual_Icc]`, `exact Set.dual_Icc`, `aesop`, etc fail</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Set.ext</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">and_comm</span> <span class=\"c1\">-- copied proof</span>\n</code></pre></div>\n<p>EDIT: actually,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Set.dual_Icc</span><span class=\"o\">]</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>\n<p>works. Is this the way?</p>",
        "id": 425369466,
        "sender_full_name": "llllvvuu",
        "timestamp": 1709836283
    },
    {
        "content": "<p>You should state using the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.preimage#doc\">docs#Set.preimage</a> along <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.toDual#doc\">docs#OrderDual.toDual</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual.ofDual#doc\">docs#OrderDual.ofDual</a></p>",
        "id": 425386141,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1709842116
    },
    {
        "content": "<p>Is this an outdated pattern then?</p>\n<blockquote>\n<p>git grep \"Œ± := Œ±·µí·µà\"</p>\n</blockquote>\n<p>Here's the place I want to use <code>(Œ± := Œ±·µí·µà)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Integral.IntegralEqImproper</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">MeasureTheory</span> <span class=\"n\">Set</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">Œ±</span> <span class=\"n\">Œπ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Œº</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">Œπ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">LinearOrder</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderClosedTopology</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">OpensMeasurableSpace</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Œ±</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">aecover_Iio_of_Icc</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">Tendsto</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">atBot</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">Tendsto</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">AECover</span> <span class=\"o\">(</span><span class=\"n\">Œº.restrict</span> <span class=\"o\">(</span><span class=\"n\">Iio</span> <span class=\"n\">B</span><span class=\"o\">))</span> <span class=\"n\">l</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Icc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">aecover_Ioi_of_Icc</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">Tendsto</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"bp\">ùìù</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">Tendsto</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"n\">atTop</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">AECover</span> <span class=\"o\">(</span><span class=\"n\">Œº.restrict</span> <span class=\"o\">(</span><span class=\"n\">Ioi</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"n\">l</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Icc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">convert</span> <span class=\"n\">aecover_Iio_of_Icc</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:=</span> <span class=\"n\">Œ±</span><span class=\"bp\">·µí·µà</span><span class=\"o\">)</span> <span class=\"n\">hb</span> <span class=\"n\">ha</span> <span class=\"n\">using</span> <span class=\"mi\">2</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Set.dual_Icc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I haven't figured out how to make <code>aecover_Iio_of_Icc</code> return <code>toDual</code> or <code>ofDual</code> terms.</p>",
        "id": 425392254,
        "sender_full_name": "llllvvuu",
        "timestamp": 1709844493
    },
    {
        "content": "<p>Those uses are in proofs, not theorem statements</p>",
        "id": 425395872,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1709845925
    },
    {
        "content": "<p>Most proofs that use <code>(Œ± := Œ±·µí·µà)</code> are abusing the fact that <code>Œ± = Œ±·µí·µà</code> is true by definition. This is ok in proofs where the abuse is contained, but if you use the trick in a _statement_ then the abuse contaminates users of the theorem too, and makes a mess</p>",
        "id": 425398418,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1709847060
    },
    {
        "content": "<p>That makes sense, thanks! (And fortunately, my original problem has been resolved)</p>",
        "id": 425405829,
        "sender_full_name": "llllvvuu",
        "timestamp": 1709850091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"607118\">llllvvuu</span> has marked this topic as resolved.</p>",
        "id": 425405870,
        "sender_full_name": "Notification Bot",
        "timestamp": 1709850106
    }
]