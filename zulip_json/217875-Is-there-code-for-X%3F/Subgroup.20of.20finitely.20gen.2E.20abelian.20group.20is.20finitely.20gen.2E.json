[
    {
        "content": "<p>Is this result in Mathlib somewhere?  For minor technical reasons I'd prefer it in the module form</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_finite</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I'll be happy to take the abelian group version</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_finite</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">AddGroup.FG</span> <span class=\"n\">G</span><span class=\"o\">)</span>  <span class=\"o\">:</span> <span class=\"n\">AddSubgroup.FG</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(I also only need it in the case when <code>G</code> is free, though that's not such a big help since it's easy to reduce to that case.)   I suppose I could try to equate my free abelian group with a <code>Zlattice</code> and use the machinery in Mathlib.Algebra.Module.Zlattice, but this is a somewhat weird approach (using geometry to prove a purely algebraic statement) and I was wondering if there was a more direct route.</p>",
        "id": 410487727,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703891501
    },
    {
        "content": "<p>It should follow from that Z is a Noetherian ring ...</p>",
        "id": 410488969,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703892636
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isNoetherian_of_isNoetherianRing_of_finite#doc\">docs#isNoetherian_of_isNoetherianRing_of_finite</a> and then all submodules are FG by definition. Let me look up how to convert between Submodule.FG and AddSubgroup.FG ...</p>",
        "id": 410489086,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703892793
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.fg_iff_add_subgroup_fg#doc\">docs#Submodule.fg_iff_add_subgroup_fg</a><br>\nand <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddSubgroup.toIntSubmodule#doc\">docs#AddSubgroup.toIntSubmodule</a> too</p>",
        "id": 410489173,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703892852
    },
    {
        "content": "<p>Ah, I should have tried thinking like an algebraist and generalizing to a more abstract setting. <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> Thanks!</p>",
        "id": 410489578,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703893195
    },
    {
        "content": "<p>Ah and I have discovered (for the third time in two days) that I have unintentionally made life difficult for myself by redundantly declaring an instance (in this case, <code>Module ℤ G</code>), causing all sorts of weird defeq issues.</p>",
        "id": 410490633,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703894012
    },
    {
        "content": "<p>Got it to work.  Thanks again!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_finite</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite.iff_addGroup_fg</span><span class=\"o\">,</span> <span class=\"n\">AddGroup.fg_iff_addSubgroup_fg</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span><span class=\"n\">AddSubgroup.toIntSubmodule_toAddSubgroup</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span><span class=\"n\">Submodule.fg_iff_add_subgroup_fg</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">isNoetherian_def.mp</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">infer_instance</span><span class=\"o\">)</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 410491119,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703894420
    },
    {
        "content": "<p>... which can be golfed to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_finite</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">AddSubgroup.toIntSubmodule</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg_iff_finite.mp</span> <span class=\"o\">(</span><span class=\"n\">IsNoetherian.noetherian</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here I'm using that <code>↥H</code> is defeq to <code>↥(AddSubgroup.toIntSubmodule H)</code> even though <code>H</code> doesn't have the same type as <code>AddSubgroup.toIntSubmodule H</code>. The reason is that <code>↥H</code> is defined to be <code>{x // x ∈ H}</code> and <code>x ∈ AddSubgroup.toIntSubmodule H</code> is defined to be <code>x ∈ H</code>.</p>",
        "id": 410496900,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703897883
    },
    {
        "content": "<p>Maybe this proof (or the abelian subgroup version) is suitable for Mathlib?  I could imagine that other people might have use of this basic fact.</p>",
        "id": 410499342,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703899930
    },
    {
        "content": "<p>For sake of completeness, here is the matching lemma for freeness.  (Following <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> 's example, I ended up exploring the theory of modules over a PID.  Brings back memories of grad school algebra quals...)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_finite</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"n\">AddSubgroup.toIntSubmodule</span> <span class=\"n\">H</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg_iff_finite.mp</span> <span class=\"o\">(</span><span class=\"n\">IsNoetherian.noetherian</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subgroup_free</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">AddSubgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Free</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module.Free</span> <span class=\"n\">ℤ</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">Submodule.nonempty_basis_of_pid</span> <span class=\"o\">(</span><span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">AddSubgroup.toIntSubmodule</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span> <span class=\"n\">b</span> <span class=\"o\">⟩</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Module.Free.of_basis</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 410505380,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703904879
    },
    {
        "content": "<p>Just noting that there is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddGroup.FG#doc\">docs#AddGroup.FG</a> (and arguably these lemmas should be stated in terms of this) and we can translate between them via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Finite.iff_addGroup_fg#doc\">docs#Module.Finite.iff_addGroup_fg</a>.</p>",
        "id": 410505848,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1703905319
    },
    {
        "content": "<p>And <code>AddGroup.FG</code> -&gt; <code>Module.Finite ℤ</code> can potentially be an instance?</p>",
        "id": 410506205,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1703905645
    },
    {
        "content": "<p>I'll defer to others on instances, they seem to be double-edged swords.</p>\n<p>To write <code>subgroup_free</code> in purely group theoretic terms, it would be nice to have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">AddCommGroup.free_iff_torsion_free</span> <span class=\"o\">[</span><span class=\"n\">Module.Finite</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module.Free</span> <span class=\"n\">ℤ</span> <span class=\"n\">G</span> <span class=\"bp\">↔</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I can't find a slick proof of this; <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.free_of_finite_type_torsion_free%27#doc\">docs#Module.free_of_finite_type_torsion_free'</a> comes sort of close, but it's a pain to get from <code>NoZeroSMulDivisors</code> to <code>AddMonoid.IsTorsionFree</code>.  I feel like there could be a bit more API here.</p>",
        "id": 410506353,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703905803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Subgroup.20of.20finitely.20gen.2E.20abelian.20group.20is.20finitely.20gen.2E/near/410506205\">said</a>:</p>\n<blockquote>\n<p>And <code>AddGroup.FG</code> -&gt; <code>Module.Finite ℤ</code> can potentially be an instance?</p>\n</blockquote>\n<p>Yes, we should definitely try that. Maybe it wasn't because it would create a loop in Lean 3?</p>",
        "id": 410506389,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703905811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"657719\">@Terence Tao</span> Note that diamonds are only an issue for instances that carry data. Prop-valued instances don't have <em>that</em> double edge.</p>",
        "id": 410506417,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1703905852
    },
    {
        "content": "<p>More generally I have the sense that the classification of finitely generated abelian groups is implicitly in Mathlib, but somehow scattered across a bunch of different APIs (in principle it's all extractable from Mathlib.LinearAlgebra.FreeModule.PID , but for a non-algebraist like myself this wasn't so easy to work with).</p>",
        "id": 410506785,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703906270
    },
    {
        "content": "<p>The main result is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.equiv_free_prod_directSum#doc\">docs#Module.equiv_free_prod_directSum</a> but yes we should definitely specialize them to groups.</p>",
        "id": 410506986,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1703906463
    },
    {
        "content": "<p>Huh, so <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.equiv_free_prod_directSum_zmod#doc\">docs#AddCommGroup.equiv_free_prod_directSum_zmod</a> does exist, but the API around it is skimpy.  (For instance, no mention of invariant factors, and no relations between the classification of a f.g. abelian group and that of its subgroups or quotients.)</p>",
        "id": 410507620,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703907184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Subgroup.20of.20finitely.20gen.2E.20abelian.20group.20is.20finitely.20gen.2E/near/410506353\">said</a>:</p>\n<blockquote>\n<p>It's a pain to get from <code>NoZeroSMulDivisors</code> to <code>AddMonoid.IsTorsionFree</code>. </p>\n</blockquote>\n<p>Done in <a href=\"https://github.com/leanprover-community/mathlib4/pull/9345\">#9345</a>. Something similar was needed in FLT-regular as well.</p>",
        "id": 410508526,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1703908260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Subgroup.20of.20finitely.20gen.2E.20abelian.20group.20is.20finitely.20gen.2E/near/410507620\">said</a>:</p>\n<blockquote>\n<p>Huh, so <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.equiv_free_prod_directSum_zmod#doc\">docs#AddCommGroup.equiv_free_prod_directSum_zmod</a> does exist, but the API around it is skimpy.</p>\n</blockquote>\n<p>I have a bit more in <a href=\"https://github.com/YaelDillies/LeanAPAP/blob/master/LeanAPAP/Mathlib/GroupTheory/FiniteAbelian.lean\">https://github.com/YaelDillies/LeanAPAP/blob/master/LeanAPAP/Mathlib/GroupTheory/FiniteAbelian.lean</a> if that helps.</p>",
        "id": 410520903,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703921545
    }
]