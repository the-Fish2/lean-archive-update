[
    {
        "content": "<p>Does Mathlib have a notion of \"finitely generated commutative group\"?<br>\nLooking via loogle for names containing \"fin\" and \"gen\" does not turn up anything useful...<br>\n(And then I will be looking for the fact that a finitely generated commutative torsion-free group is free...)</p>",
        "id": 421145696,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1707778799
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddGroup.FG#doc\">docs#AddGroup.FG</a> is maybe what you want?</p>",
        "id": 421146903,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1707779283
    },
    {
        "content": "<p>There are a few versions of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.equiv_free_prod_directSum_zmod#doc\">docs#AddCommGroup.equiv_free_prod_directSum_zmod</a>.</p>",
        "id": 421147908,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1707779833
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 421148676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1707780215
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.basisOfFiniteTypeTorsionFree#doc\">docs#Module.basisOfFiniteTypeTorsionFree</a> that mathematically is what you want.</p>",
        "id": 421191931,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707811194
    },
    {
        "content": "<p>There are various versions of this result, but I think using <code>ℤ</code>-modules is better (we have a reasonable API for free modules).</p>",
        "id": 421192165,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707811271
    },
    {
        "content": "<p>Thanks! I'll have a look (but may not have a lot of time before the weekend).</p>",
        "id": 421217345,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1707820898
    },
    {
        "content": "<p>PS: It did not occur to me to look for \"FG\"...</p>",
        "id": 421227013,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1707824751
    },
    {
        "content": "<p>I started a publicly editable Google Doc for various mathematical notions that are not always obvious to locate in Mathlib, and added finitely generated groups to the list: <a href=\"https://docs.google.com/spreadsheets/d/1ap8ByJDvXw9c1G629UxRRoag3gTcMpPsRpm3_yCINyo/edit#gid=0\">https://docs.google.com/spreadsheets/d/1ap8ByJDvXw9c1G629UxRRoag3gTcMpPsRpm3_yCINyo/edit#gid=0</a> .  Any further additions welcome!</p>",
        "id": 421371812,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707887403
    },
    {
        "content": "<p>I'm trying to prove that a finitely generated torsion-free additive abelian group is free via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.equiv_free_prod_directSum_zmod#doc\">docs#AddCommGroup.equiv_free_prod_directSum_zmod</a> (idea: show that the finite part in the decomposition is trivial), but I'm running into the problem that the function <code>e</code> in this statement (which gives the exponents of the prime powers) is not required to take only nonzero values (so that one needs to deal with a potential product of trivial groups). Is this just an oversight, or is there a reason for not requiring positive exponents? (The proof uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.equiv_free_prod_directSum#doc\">docs#Module.equiv_free_prod_directSum</a>, which has the same problem.)</p>",
        "id": 421897209,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1708101587
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"657719\">Terence Tao</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Finitely.20generated.20.28additive.20commutative.29.20groups/near/421371812\">said</a>:</p>\n<blockquote>\n<p>I started a publicly editable Google Doc for various mathematical notions that are not always obvious to locate in Mathlib, and added finitely generated groups to the list: <a href=\"https://docs.google.com/spreadsheets/d/1ap8ByJDvXw9c1G629UxRRoag3gTcMpPsRpm3_yCINyo/edit#gid=0\">https://docs.google.com/spreadsheets/d/1ap8ByJDvXw9c1G629UxRRoag3gTcMpPsRpm3_yCINyo/edit#gid=0</a> .  Any further additions welcome!</p>\n</blockquote>\n<p>This is a great idea! It might be worth trying to integrate it into mathlib's documentation as somewhere for longevity</p>",
        "id": 422022145,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1708184777
    },
    {
        "content": "<p>I now have a solution to my problem (see below), but I found that I had to work around missing API lemmas (or at least lemmas I was unable to find) and DTT problems. I wonder if there is a better way (staying within abelian group land)...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.FiniteAbelian</span>\n<span class=\"c1\">-- import Mathlib.Algebra.Lie.OfAssociative -- suggested by `#minimize_imports` with `import Mathlib`</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">AddEquiv.IsTorsionFree</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">at</span> <span class=\"n\">hA</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">hA</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg₀</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hA</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">h.symm</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">map_ne_zero_iff</span> <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"n\">h</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">hg₀</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">IsOfFinAddOrder</span><span class=\"o\">,</span> <span class=\"n\">Function.periodicPts</span><span class=\"o\">,</span> <span class=\"n\">Function.IsPeriodicPt</span><span class=\"o\">,</span> <span class=\"n\">Function.IsFixedPt</span><span class=\"o\">,</span>\n    <span class=\"n\">add_left_iterate</span><span class=\"o\">,</span> <span class=\"n\">add_left_eq_self</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg</span> <span class=\"bp\">⊢</span>\n  <span class=\"n\">peel</span> <span class=\"n\">hg</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hn.1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">map_nsmul</span><span class=\"o\">,</span> <span class=\"n\">map_zero</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">congr_arg</span> <span class=\"n\">h.symm</span> <span class=\"n\">hn.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">AddCommGroup.equiv_free</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddGroup.FG</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℤ</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">ftι</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">AddCommGroup.equiv_free_prod_directSum_zmod</span> <span class=\"n\">A</span>\n  <span class=\"n\">use</span> <span class=\"n\">n</span>\n  <span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"n\">h.some</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"n\">Hu</span> <span class=\"o\">:</span> <span class=\"n\">Unique</span> <span class=\"o\">(</span><span class=\"n\">DirectSum</span> <span class=\"n\">ι</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">ZMod</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">^</span> <span class=\"n\">e</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n    <span class=\"c1\">-- I'd like to rewrite `p i ^ e i` to `1` ussing `key`, but trying that I keep</span>\n    <span class=\"c1\">-- ending up in DTT hell. So work with an equivalence instead:</span>\n    <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"n\">Equiv.unique</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">≃</span> <span class=\"n\">DirectSum</span> <span class=\"n\">ι</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">ZMod</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n      <span class=\"c1\">-- It should be possible to do that without using `Fintype ι`...</span>\n      <span class=\"n\">refine</span> <span class=\"n\">DFinsupp.equivFunOnFintype.trans</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Equiv.trans</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"n\">DFinsupp.equivFunOnFintype.symm</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Equiv.piCongrRight</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">pow_zero</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nonempty.intro</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">φ.trans</span> <span class=\"n\">AddEquiv.prodUnique</span> <span class=\"c1\">-- needs `Hu`</span>\n  <span class=\"n\">replace</span> <span class=\"n\">ht</span> <span class=\"o\">:=</span> <span class=\"n\">φ.IsTorsionFree</span> <span class=\"n\">ht</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">ht</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid.IsTorsionFree</span><span class=\"o\">,</span> <span class=\"n\">IsOfFinAddOrder</span><span class=\"o\">,</span> <span class=\"n\">Function.periodicPts</span><span class=\"o\">,</span> <span class=\"n\">Function.IsPeriodicPt</span><span class=\"o\">,</span>\n    <span class=\"n\">add_left_iterate</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">Prod.forall</span><span class=\"o\">,</span> <span class=\"n\">Prod.mk_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">push_neg</span>\n  <span class=\"n\">classical</span> <span class=\"c1\">-- to have `DecidableEq ι`</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ht</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.single</span> <span class=\"n\">i</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">H</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">^</span> <span class=\"n\">e</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">pow_pos</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩⟩⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">DFinsupp.single_apply</span><span class=\"o\">,</span> <span class=\"bp\">↓</span><span class=\"n\">reduceDite</span><span class=\"o\">,</span> <span class=\"n\">DirectSum.zero_apply</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">subsingleton_iff_zero_eq_one</span><span class=\"o\">,</span> <span class=\"n\">ZMod.subsingleton_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_one</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">pow_eq_one_iff</span> <span class=\"n\">hi</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">H</span>\n  <span class=\"bp\">·</span> <span class=\"c1\">-- in the line below, `simp` in place of `rw` gives</span>\n    <span class=\"c1\">-- failed to synthesize</span>\n    <span class=\"c1\">-- NoZeroSMulDivisors ℕ ((Fin n →₀ ℤ) × DirectSum ι fun i =&gt; ZMod (p i ^ e i))</span>\n    <span class=\"c1\">-- (deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached</span>\n    <span class=\"c1\">-- (use 'set_option synthInstance.maxHeartbeats &lt;num&gt;' to set the limit)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Function.IsFixedPt</span><span class=\"o\">,</span> <span class=\"n\">Prod.smul_mk</span><span class=\"o\">,</span> <span class=\"n\">smul_zero</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">Prod.mk_eq_zero</span><span class=\"o\">]</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">DFinsupp.single_smul</span><span class=\"o\">,</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">CharP.cast_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">DFinsupp.single_zero</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>For <code>AddEquiv.IsTorsionFree</code> and similar statements, it would be nice if one could argue \"<code>IsTorsionFree</code> is defined purely in terms of the additive monoid structure, so carries over via an <code>AddEquiv</code>\". Is there some kind of tactic that can do such things?</p>",
        "id": 422036397,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1708197687
    },
    {
        "content": "<p>No, there is no such tactic</p>",
        "id": 422045885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708207333
    },
    {
        "content": "<p>Usually the right approach is to introduce lemmas at every level</p>",
        "id": 422045900,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708207354
    },
    {
        "content": "<p>Here's a golfed version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">addOrderOf_dvd_addOrderOf_of_injective</span>\n    <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">addOrderOf</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"n\">addOrderOf</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">addOrderOf_dvd_of_nsmul_eq_zero</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">hf</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">map_nsmul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">addOrderOf_nsmul_eq_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">AddEquiv.IsTorsionFree</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AddMonoid.IsTorsionFree</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n  <span class=\"n\">e.surjective.forall.2</span> <span class=\"bp\">&lt;|</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">hA</span> <span class=\"n\">x</span> <span class=\"o\">((</span><span class=\"n\">map_ne_zero_iff</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">h'.mono</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">addOrderOf_dvd_addOrderOf_of_injective</span> <span class=\"n\">e</span> <span class=\"n\">e.injective</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 422045907,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708207363
    },
    {
        "content": "<p>There's a missing lemma about <code>IsOfFinAddOrder</code> there too</p>",
        "id": 422046098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708207556
    },
    {
        "content": "<p>One reason that you should expect to write these lemmas is that many properties require only injectivity or surjectivity, and not a full bijection</p>",
        "id": 422046344,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708207790
    },
    {
        "content": "<p>So even if the tactic you ask for did exist, it would often be preferable to avoid it</p>",
        "id": 422046400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708207807
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 422088170,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1708253402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Finitely.20generated.20.28additive.20commutative.29.20groups/near/421897209\">said</a>:</p>\n<blockquote>\n<p>I'm trying to prove that a finitely generated torsion-free additive abelian group is free via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddCommGroup.equiv_free_prod_directSum_zmod#doc\">docs#AddCommGroup.equiv_free_prod_directSum_zmod</a> (idea: show that the finite part in the decomposition is trivial), but I'm running into the problem that the function <code>e</code> in this statement (which gives the exponents of the prime powers) is not required to take only nonzero values (so that one needs to deal with a potential product of trivial groups). Is this just an oversight, or is there a reason for not requiring positive exponents? (The proof uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.equiv_free_prod_directSum#doc\">docs#Module.equiv_free_prod_directSum</a>, which has the same problem.)</p>\n</blockquote>\n<p>Why don't you want to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.free_iff_noZeroSMulDivisors#doc\">docs#Module.free_iff_noZeroSMulDivisors</a></p>",
        "id": 422088246,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1708253458
    }
]