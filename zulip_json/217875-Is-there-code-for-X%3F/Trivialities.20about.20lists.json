[
    {
        "content": "<p>Do we have them?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nmem_replicate_of_neq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">List.replicate</span> <span class=\"n\">n</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sublist_append_nmem_left</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">dnix</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">∉</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subl</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">d</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 421665556,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708007376
    },
    {
        "content": "<p>I could not find them (which does not mean much), but discovered <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.replicate_subset_singleton#doc\">docs#List.replicate_subset_singleton</a> which gives this proof for the first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nmem_replicate_of_neq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">List.replicate</span> <span class=\"n\">n</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Set.not_mem_subset</span> <span class=\"o\">(</span><span class=\"n\">List.replicate_subset_singleton</span> <span class=\"n\">n</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">List.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>where</p>\n<ul>\n<li><code>apply</code> cannot be changed to <code>refine</code>,</li>\n<li><code>erw</code> cannot be changed to <code>rw</code>.</li>\n</ul>\n<p>This makes me suspect that something weird is going on.</p>",
        "id": 421670005,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708008544
    },
    {
        "content": "<p><code>nmem_replicate_of_neq</code> is the contrapositive of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=eq_of_mem_replicate#doc\">docs#eq_of_mem_replicate</a></p>",
        "id": 421715850,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708021803
    },
    {
        "content": "<p>Oh there is also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.mem_replicate#doc\">docs#List.mem_replicate</a> for the most general statement.</p>",
        "id": 421724814,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708025069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Trivialities.20about.20lists/near/421670005\">said</a>:</p>\n<blockquote>\n<p>I could not find them (which does not mean much), but discovered <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.replicate_subset_singleton#doc\">docs#List.replicate_subset_singleton</a> which gives this proof for the first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nmem_replicate_of_neq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">List.replicate</span> <span class=\"n\">n</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Set.not_mem_subset</span> <span class=\"o\">(</span><span class=\"n\">List.replicate_subset_singleton</span> <span class=\"n\">n</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">List.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>\n<p>where</p>\n<ul>\n<li><code>apply</code> cannot be changed to <code>refine</code>,</li>\n<li><code>erw</code> cannot be changed to <code>rw</code>.</li>\n</ul>\n<p>This makes me suspect that something weird is going on.</p>\n</blockquote>\n<p>The proof abuses defeq: <code>List.replicate_subset_singleton n b</code> uses <code>\\subseteq</code> on lists, but you're using <code>Set.not_mem_subset</code> on it, which expects <code>\\subseteq</code> on sets. Everything is thus unfolded and the chaos thus ensues.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">List.not_mem_subset</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nmem_replicate_of_neq</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">List.replicate</span> <span class=\"n\">n</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">List.not_mem_subset</span> <span class=\"o\">(</span><span class=\"n\">List.replicate_subset_singleton</span> <span class=\"n\">n</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.mem_singleton</span><span class=\"o\">]</span>\n  <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 421725167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708025209
    },
    {
        "content": "<p>Kevin, thanks: I had completely overlooked the <code>Set</code> namespace!  Now everything is clear!</p>",
        "id": 421737572,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1708029948
    },
    {
        "content": "<p>Here is a proof of the second lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">List.sublist_append_nmem_left</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">dnix</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"bp\">∉</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subl</span> <span class=\"o\">:</span> <span class=\"n\">d</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">x</span> <span class=\"bp\">++</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">d</span> <span class=\"o\">::</span> <span class=\"n\">l</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">subl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">dnix</span> <span class=\"bp\">∘</span> <span class=\"n\">List.Mem.tail</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n    <span class=\"n\">cases</span> <span class=\"n\">subl</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">aesop</span>\n</code></pre></div>\n<p>Do we want it in Mathlib?</p>",
        "id": 421821139,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708075962
    },
    {
        "content": "<p>Surely that can be made an iff?</p>",
        "id": 421821780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708076196
    },
    {
        "content": "<p>Yes! Do you want to suggest a name for it?</p>",
        "id": 421822756,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708076535
    },
    {
        "content": "<p><code>List.cons_sublist_append_iff_right</code>?</p>",
        "id": 421823530,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708076809
    },
    {
        "content": "<p>Did you intentionally avoid <code>d ∉ x</code> in the lemma name?</p>",
        "id": 421823976,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708076951
    },
    {
        "content": "<p>I think it's pretty clear from context but could be added if disambiguation is needed</p>",
        "id": 421824075,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1708076976
    },
    {
        "content": "<p>All right, I'll use the name you suggested.</p>",
        "id": 421824200,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708077008
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10629\">#10629</a></p>",
        "id": 421826533,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708077846
    },
    {
        "content": "<p>Can you add a more general version, <code>(h : l₂.Disjoint l₄) (h' : l₂ ≠ []) : l₁ ++ l₂ &lt;+ l₃ ++ l₄ ↔ l₁ ++ l₂ &lt;+ l₃</code>?</p>",
        "id": 421829638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708078961
    },
    {
        "content": "<p>(and then the obvious symmetric version)</p>",
        "id": 421829677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708078978
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Disjoint#doc\">docs#List.Disjoint</a></p>",
        "id": 421830358,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708079217
    },
    {
        "content": "<p>I guess <code>¬l₂ &lt;+ l₄</code> and  <code>¬l₄ &lt;+ l₂</code> would be a tighter constraint</p>",
        "id": 421831557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708079623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Trivialities.20about.20lists/near/421829638\">said</a>:</p>\n<blockquote>\n<p>Can you add a more general version</p>\n</blockquote>\n<p>Maybe in addition to my lemma, not as its replacement. Even when I add both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lllllllllllll</span> <span class=\"o\">{</span><span class=\"n\">l₃</span> <span class=\"n\">l₄</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₂.Disjoint</span> <span class=\"n\">l₄</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">l₂</span> <span class=\"bp\">≠</span> <span class=\"o\">[])</span> <span class=\"o\">:</span>\n    <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">l₃</span> <span class=\"bp\">++</span> <span class=\"n\">l₄</span> <span class=\"bp\">↔</span> <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">l₃</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">llllllllllllll</span> <span class=\"o\">{</span><span class=\"n\">l₃</span> <span class=\"n\">l₄</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₁.Disjoint</span> <span class=\"n\">l₃</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">≠</span> <span class=\"o\">[])</span> <span class=\"o\">:</span>\n    <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">l₃</span> <span class=\"bp\">++</span> <span class=\"n\">l₄</span> <span class=\"bp\">↔</span> <span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">l₄</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p><code>exact?</code> still won't solve my original problem.</p>",
        "id": 421831626,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708079642
    },
    {
        "content": "<p>Indeed, I'm suggesting you add those lemmas to provide a one- or two- line proof of your version</p>",
        "id": 421831725,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708079668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Trivialities.20about.20lists/near/421831557\">said</a>:</p>\n<blockquote>\n<p>I guess <code>¬l₂ &lt;+ l₄</code> and  <code>¬l₄ &lt;+ l₂</code> would be a tighter constraint</p>\n</blockquote>\n<p>What about them?</p>",
        "id": 421832425,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1708079897
    },
    {
        "content": "<p>They should work instead of <code>l₂.Disjoint l₄</code>, right?</p>",
        "id": 421833327,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708080212
    },
    {
        "content": "<p>Aren't all those list lemmas better suited for Std than for Mathlib?</p>",
        "id": 421847554,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1708085816
    },
    {
        "content": "<p>It's probably more pleasant to prove them in mathlib first, then check if they still compile in Std once you're done</p>",
        "id": 421990488,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708157899
    }
]