[
    {
        "content": "<p>I'm looking for this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">LinearMap.pi_lift</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>where <code>(α → M)</code> has the natural Module structure as a pi-type. I would also like the corresponding thing for <code>AffineMap</code>. I suspect the answer may lie with <code>TensorProduct</code> but I'm not sure. Loogle turned up nothing:<br>\n<a href=\"https://loogle.lean-lang.org/?q=%22LinearMap%22%2C+%28%3Fa+%E2%86%92+%28LinearMap+%3Fr+%3Fm+_%29%29+-%3E+%28LinearMap+%3Fr+%28%3Fa+-%3E+%3Fm%29+_%29\">https://loogle.lean-lang.org/?q=%22LinearMap%22%2C+%28%3Fa+%E2%86%92+%28LinearMap+%3Fr+%3Fm+_%29%29+-%3E+%28LinearMap+%3Fr+%28%3Fa+-%3E+%3Fm%29+_%29</a></p>",
        "id": 418735514,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706568883
    },
    {
        "content": "<p>The affine one (which is the one I really need I guess) would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AffineMap.pi_lift</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddTorsor</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ᵃ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ᵃ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 418736655,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706569365
    },
    {
        "content": "<p>I don't think this exists (mathematically). Can you describe what the output should be in a simple example (e.g. α = Fin 2, M = R)?</p>",
        "id": 418748921,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706576332
    },
    {
        "content": "<p>In case you're thinking \"both sides are surely the same because function composition is associative\" or something -- that's <code>∘</code>. The pi type <code>→</code> is not in general associative, for the same reason that <code>^</code> isn't. The numbers 3^(1^2) and (3^1)^2 are different -- one is 3 and one is 3^2.</p>",
        "id": 418751338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706577930
    },
    {
        "content": "<p>But the size of <code>A → B</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>b</mi><mi>a</mi></msup></mrow><annotation encoding=\"application/x-tex\">b^a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">a</span></span></span></span></span></span></span></span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a,b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> are the sizes of <code>A</code> and <code>B</code>.</p>",
        "id": 418751452,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706577986
    },
    {
        "content": "<p>Right, I'm aware that -&gt; isn't associative, but I think this exists. For a=Fin 2 and M=R, the original form <code>fs</code> is a pair of linear maps R -&gt; R.</p>\n<p>In the image, (Fin 2-&gt;R) is the free rank-2 module over R. This already exists as an instance in mathlib. If I label the basis elements of that module as b0 and b1, I get a linear map defined by mapping b0 to ((fs 0) 1), and mapping b1 to ((fs 1) 1). Those extend to a full linear map in the natural way then</p>",
        "id": 418756457,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706581425
    },
    {
        "content": "<p>You will need to say either finitely supported functions on <code>α</code>, or add a hypothesis that <code>α</code> is finite.</p>\n<p>Then you can define your function on <code>f</code> as a sum over <code>i : α</code> of <code>fs i (f i)</code>.</p>",
        "id": 418757312,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706582152
    },
    {
        "content": "<p>Mm, so [Fintype a]?</p>",
        "id": 418758034,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706582722
    },
    {
        "content": "<p>I think <code>[Finite a]</code> is easier to prove with (but harder to compute with)</p>",
        "id": 418758207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706582874
    },
    {
        "content": "<p>Turns out I had myself mixed up and this wasn't even what I wanted <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> <br>\nI actually just wanted <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.pi#doc\">docs#LinearMap.pi</a></p>",
        "id": 418892417,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706637561
    },
    {
        "content": "<p>Which helped me quickly write the Affine one (which I think doesn't exist otherwise):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AffineMap.pi</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ᵃ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M₂</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ᵃ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.pi</span> <span class=\"o\">(</span><span class=\"n\">AffineMap.linear</span> <span class=\"bp\">∘</span> <span class=\"n\">fs</span><span class=\"o\">),</span>\n   <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"n\">funext</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">3</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 418892462,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706637584
    },
    {
        "content": "<p>It would be better style to write that using <code>where</code>, but otherwise that would be a good PR</p>",
        "id": 418916455,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706647263
    },
    {
        "content": "<p>Oh, and it should be defined for an arbitrary affine space, not just a module!</p>",
        "id": 418916503,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706647292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lifting.20a.20Pi-type.20linear.20map.20to.20a.20linear.20map/near/418735514\">said</a>:</p>\n<blockquote>\n<p>I'm looking for this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">LinearMap.pi_lift</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>With the <code>α → M</code> replaced by <code>Finsupp α M</code>, this is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.lsum#doc\">docs#Finsupp.lsum</a> (you also need R to be commutative).</p>",
        "id": 418917832,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706647849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lifting.20a.20Pi-type.20linear.20map.20to.20a.20linear.20map/near/418916455\">said</a>:</p>\n<blockquote>\n<p>It would be better style to write that using <code>where</code>, but otherwise that would be a good PR</p>\n</blockquote>\n<p>Done! <a href=\"https://github.com/leanprover-community/mathlib4/pull/10147\">mathlib4#10147</a></p>",
        "id": 419107303,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1706728286
    }
]