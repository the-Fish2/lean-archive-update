[
    {
        "content": "<p>Do we have the fact that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.rank#doc\">docs#Matrix.rank</a> (or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.rank#doc\">docs#LinearMap.rank</a>, I'm not too bothered) is the minimum number of summands in the decomposition of the matrix into pure tensors?</p>",
        "id": 418799710,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706607866
    },
    {
        "content": "<p>What's the lean spelling of \"pure tensor\" here?</p>",
        "id": 418887232,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706635659
    },
    {
        "content": "<p>By pure tensor, I mean <code>fun i j ↦ f i * g j : Matrix m n α</code></p>",
        "id": 418901441,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706641102
    },
    {
        "content": "<p>So <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.vecMulVec#doc\">docs#Matrix.vecMulVec</a> ?</p>",
        "id": 418914855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706646546
    },
    {
        "content": "<p>Didn't know it had a name, but yes</p>",
        "id": 418915064,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706646620
    },
    {
        "content": "<p>One inequality is trivial by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.rank_finset_sum_le#doc\">docs#LinearMap.rank_finset_sum_le</a> because the pure tensors have rank one or zero. For the other inequality, you get a decomposition into pure tensors once you put the matrix into <a href=\"https://en.wikipedia.org/wiki/Smith_normal_form#Definition\">Smith normal form</a>. However mathlib's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.smithNormalForm#doc\">docs#Submodule.smithNormalForm</a> etc. don't take a LinearMap as input, and I see no obvious way to make use of them. However, over a field, you can take the kernel of your linear map and find a complement of it, and the linear map will map the complement isomorphically onto the range, and you get a decomposition by choosing a basis of the complement, which is mapped to a basis of the range.</p>",
        "id": 418927979,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706652178
    },
    {
        "content": "<p>Ahah, I was worrying about the direction you claimed to be trivial and thought the direction you claimed to be harder was trivial.</p>",
        "id": 418929197,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706652735
    },
    {
        "content": "<p>By which I mean that I don't think you need the Smith normal form. If the matrix <code>M</code> has full rank, then <code>∑ i, vecMulVec (indicator {i}) (M i)</code> is a decomposition into pure tensors of the correct size. If the matrix doesn't have full rank, I'm pretty sure you can do something similar by picking a basis of <code>M.range</code> and pulling back along <code>M</code>.</p>",
        "id": 418929644,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706652959
    },
    {
        "content": "<p>Does that sound reasonable, Junyan?</p>",
        "id": 418930430,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706653307
    },
    {
        "content": "<blockquote>\n<p>If the matrix M has full rank, then ∑ i, vecMulVec (indicator {i}) (M i) is a decomposition into pure tensors of the correct size.</p>\n</blockquote>\n<p>That's a good point! But thinking in terms of linear maps, if you have a surjective linear map from a higher dimensional space to a lower dimensional space, I think you still need to choose a subspace of the first space that maps isomorphically to the second space, and a complementary subspace that maps to 0, in order to use something like <code>∑ i, vecMulVec (indicator {i}) (M i)</code>.</p>",
        "id": 418930517,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706653329
    },
    {
        "content": "<p>Yep, which is part of the information you get from the SNF, but the SNF gives you much more along the way. Is there a simpler result in this direction?</p>",
        "id": 418930718,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706653441
    },
    {
        "content": "<p>For the result in terms of LinearMap, I would define pure tensors using <code>Set.image2</code> of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.smulRight#doc\">docs#LinearMap.smulRight</a> (there are also dualTensorHom and LinearMap.smulRightₗ but they're more complicated). Then, I'd take a basis of the kernel and use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.extend#doc\">docs#Basis.extend</a>, then apply the linear map to both sides of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.sum_repr#doc\">docs#Basis.sum_repr</a> to obtain a decomposition into pure tensors, after removing the zero terms (basis elements that are in the kernel) and replacing Basis.repr by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.coord#doc\">docs#Basis.coord</a>. (Probably we should state a lemma that a finite basis of M induces a decomposition of a linear map out of M into pure tensors.)</p>",
        "id": 418934961,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706655359
    }
]