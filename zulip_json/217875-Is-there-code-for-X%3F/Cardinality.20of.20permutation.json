[
    {
        "content": "<p>I am trying to find the cardinality of a certain set, which is a basic problem in combinatorics.  I want to find the number of maps <code>Fin n  →  ℕ </code> that have a given multiplicity for each element of the image.  This is, of course, given by the multinomial coefficient <code>Nat.multinomial s f</code>, where s are the elements in the image, and f gives the multiplicity of these elements.  I am having difficulty, however, establishing this correspondence.  Here is a formalization of the problem which I believe is correct</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fin_map_multinom</span>\n  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Finsupp</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">Finsupp.sum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Finset.filter</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">Finset.univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">S.card</span> <span class=\"bp\">=</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the definition of multinomial coefficient, it says \"The multinomial coefficient. Gives the number of strings consisting of symbols from s, where c ∈ s appears with multiplicity f c.\"  However, the formal definition does not really appeal to that intuitive definition, and instead gives a formula.  If I could find the equivalence between the formula and that intuitive definition, it would solve the problem.  </p>\n<p>In my investigation, I have looked through the various definitions of multinomial coefficients and related constructs, such as the multiset definition, compositions, and partitions, trying to find a theorem that expresses the cardinality in terms of the multinomial coefficient.  Any such theorem would probably lead to a straightforward bijection that would close the goal.  It seems that using induction and <code>Finsupp.multinomial_update</code> is probably the best idea I've come up with so far, but I think there should in principle be a more direct route, even though I haven't found it.</p>\n<p>Thanks in advance for any help with this problem!</p>",
        "id": 410055037,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1703615691
    },
    {
        "content": "<p>I don't know if this is the shortest route, but one could show that the permutation group of <code>Fin n</code> acts transitively on <code>S</code> and the stabilizer is in bijection with the product of permutation groups and so has order <code>Finsupp.prod f (fun j =&gt; Nat.factorial j)</code>, and then appeal to the orbit stabilizer theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulAction.card_orbit_mul_card_stabilizer_eq_card_group#doc\">docs#MulAction.card_orbit_mul_card_stabilizer_eq_card_group</a></p>",
        "id": 410073370,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703629726
    },
    {
        "content": "<p>Thanks so much!  I like the approach, it is very elegant and I can see how the proof would work.  I've been working on implementing it, but I didn't manage to complete it due to a few technical difficulties.  I'll be sure to share if I do end up completing the proof that way! Thanks again.</p>",
        "id": 410103832,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1703653419
    },
    {
        "content": "<p>What you want is pretty close to the original proposed definition of <code>multinomial</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">multinomial_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">multinomial</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">nat.card</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">//</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat.card</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but we switched to the current <code>(∑ i, f i)! / ∏ i, (f i)!</code> midway because it's more convenient for the multinomial theorem.</p>\n<p>I think <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> probably has some code about the first definition as he worked on counting permutations of given cycle type.</p>",
        "id": 410105569,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703654907
    },
    {
        "content": "<p>Thanks! That is good to know.  I think it would probably be useful to have a lemma in Mathlib stating that that quantity is equal to the multinomial coefficient, even given the current definition.  What do you think?</p>",
        "id": 410172803,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1703692787
    },
    {
        "content": "<p>Certainly.</p>",
        "id": 410173387,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1703692975
    },
    {
        "content": "<p>However, I don't think I have code that proves this result. What I proved (it should be PRed soon) is a proof of the formula for the number of permutations of given cycle type, and a group theoretic description of the centralizer of a permutation that implies this formula.<br>\nWhile the result you wish has a purely algebraic proof, it makes sense to provide (= I would love to see) a group-theoretic proof.  Indeed, the numerator is the cardinality of the group <code>Equiv.Perm (Fin (∑ i, f i))</code>, which acts transitively on the indicated type, and the denominator is the cardinality of the stabilizer of a particular element.</p>",
        "id": 410175614,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1703694121
    },
    {
        "content": "<p>Great, thanks, this has been a helpful discussion!  In the meantime I think that I might do the proof by induction because it is a bit easier, but I'd like to see the group theoretic proof when it is completed!</p>",
        "id": 410186018,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1703700641
    },
    {
        "content": "<p>Here is half of the group theoretic proof, written in a way that does not explicitly refer to natural number labels.  It's missing three claims that should all be straightforward, but I unfortunately don't have further time to devote to it, so anyone is welcome to pick it up from here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MulAction</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">smul</span> <span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"n\">one_smul</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Finsupp.multinomial_spec</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finsupp.multinomial_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">convert</span> <span class=\"n\">Nat.multinomial_spec</span> <span class=\"n\">f.support</span> <span class=\"n\">_</span> <span class=\"n\">using</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">.</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Finset.prod_subset_one_on_sdiff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">.</span> <span class=\"n\">infer_instance</span>\n    <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum_subset_zero_on_sdiff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">.</span> <span class=\"n\">infer_instance</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fin_map_multinom</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f₀</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n  <span class=\"n\">Fintype.card</span> <span class=\"o\">{</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n  <span class=\"n\">set</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n  <span class=\"n\">change</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">claim1</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">MulAction.orbit</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">claim2</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">MulAction.stabilizer</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">claim3</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">MulAction.card_orbit_mul_card_stabilizer_eq_card_group</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">claim1</span><span class=\"o\">,</span> <span class=\"n\">claim2</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_perm</span><span class=\"o\">,</span> <span class=\"n\">claim3</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span><span class=\"n\">Finsupp.multinomial_spec</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_eq_mul_left_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"n\">this</span> <span class=\"bp\">|</span> <span class=\"n\">this</span>\n  <span class=\"bp\">.</span> <span class=\"n\">assumption</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finset.prod_eq_zero_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">this</span> <span class=\"o\">⟩</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">this</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.factorial_ne_zero</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 410240145,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703738078
    },
    {
        "content": "<p>Just want to share another relevant thread: <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/permutations.20preserving.20a.20function/near/391930331\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/permutations.20preserving.20a.20function/near/391930331</a><br>\n(which is basically <code>claim2</code>, I think)</p>",
        "id": 410241414,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703739041
    },
    {
        "content": "<p>The first instance is already in mathlib but stated using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DomMulAct#doc\">docs#DomMulAct</a></p>",
        "id": 410256260,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703749075
    },
    {
        "content": "<p>Here is the first claim :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">claim1</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">MulAction.orbit</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Set.ext</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hf</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n      <span class=\"k\">have</span> <span class=\"n\">bij_left</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.equivFinOfCardEq</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">bij_right</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.equivFinOfCardEq</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">bij_b</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.trans</span> <span class=\"o\">(</span><span class=\"n\">bij_left</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">bij_right</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.ofFiberEquiv_map</span> <span class=\"n\">bij_b</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MulAction.mem_orbit_iff</span><span class=\"o\">]</span>\n      <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">Equiv.ofFiberEquiv</span> <span class=\"n\">bij_b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n      <span class=\"n\">funext</span> <span class=\"n\">a</span>\n      <span class=\"k\">show</span> <span class=\"n\">f₀</span> <span class=\"o\">((</span><span class=\"n\">Equiv.ofFiberEquiv</span> <span class=\"n\">bij_b</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hf</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">MulAction.mem_orbit_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hf</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf</span><span class=\"o\">]</span>\n      <span class=\"n\">intro</span> <span class=\"n\">b</span>\n      <span class=\"n\">replace</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f₀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n      <span class=\"k\">have</span> <span class=\"n\">subtype_equiv</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">Equiv.subtypeEquivOfSubtype</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f₀</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span>\n      <span class=\"k\">have</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">congr</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">this</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">subtype_equiv</span>\n      <span class=\"n\">replace</span> <span class=\"n\">subtype_equiv</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card_congr</span> <span class=\"n\">subtype_equiv</span>\n      <span class=\"n\">exact</span> <span class=\"n\">subtype_equiv</span>\n</code></pre></div>",
        "id": 410312255,
        "sender_full_name": "Teddy Baker",
        "timestamp": 1703778892
    },
    {
        "content": "<p>And here is the third claim:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"k\">have</span> <span class=\"n\">claim3</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">change</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n    <span class=\"n\">convert</span> <span class=\"n\">Finset.card_eq_sum_card_fiberwise</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">_</span>\n    <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinset_card</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span>\n    <span class=\"n\">simp</span>\n</code></pre></div>\n<p>It occurs to me that it might be slightly more efficient to refactor the proof using <code>Multiset</code> and in particular take advantage of the <code>Multiset.map</code> API.  (This may also allow one to drop the <code>Fintype β</code> hypothesis, which is inessential.)  But I guess one should get a complete working proof first and then worry about refactoring later.</p>",
        "id": 410317797,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703781613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410256260\">said</a>:</p>\n<blockquote>\n<p>The first instance is already in mathlib but stated using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DomMulAct#doc\">docs#DomMulAct</a></p>\n</blockquote>\n<p>After following <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>'s link I see that the action is also stated explicitly in <code>MulAction</code> form as (a special case of) <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=arrowAction#doc\">docs#arrowAction</a> (maybe one should update the docs so that these two items mention each other?).</p>",
        "id": 410324817,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703786017
    },
    {
        "content": "<p>Curious... We should only have one of these (and probably it's <code>DomMulAct</code>). <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, do you know what happened there?</p>",
        "id": 410326891,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703787259
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DomMulAct#doc\">docs#DomMulAct</a> is basically <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MulOpposite#doc\">docs#MulOpposite</a> and it applies more generally for monoid actions, while <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=arrowAction#doc\">docs#arrowAction</a> uses the group inverse (which is an isomorphism between a group and its opposite). A docstring explaining the difference is certainly welcome! It's probably more convenient to use arrowAction in this case (and a proof using it was already there).</p>",
        "id": 410326940,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703787299
    },
    {
        "content": "<p>By the way, I managed to piece together all the different components into a full proof (though there was some dependent type weirdness in the proof of <code>claim2</code> that I don't really understand but I got it to work anyways - somehow <code>convert</code> can power through discrepancies in definitional equality for dependent types that <code>rw</code>, <code>apply</code>, or <code>change</code> cannot).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Nat</span> <span class=\"n\">MulAction</span> <span class=\"n\">Equiv</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MulAction</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">arrowAction</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">arrowAction.mem_stabilizer_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">g</span> <span class=\"bp\">∈</span> <span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">g.comp_symm_eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ_invFun</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Perm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">φ_invFun_eq</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Perm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">φ_invFun</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comp_φ_invFun</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Perm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">φ_invFun</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span><span class=\"bp\">.</span><span class=\"n\">prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">φ_invFun_equiv</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Perm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">Perm</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">φ_invFun</span> <span class=\"n\">g</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">φ_invFun</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n  <span class=\"n\">left_inv</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">φ_invFun_eq</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">comp_φ_invFun</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Subtype.val</span> <span class=\"o\">((</span><span class=\"n\">g</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">right_inv</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">φ_invFun_eq</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">comp_φ_invFun</span> <span class=\"n\">_</span> <span class=\"n\">a</span><span class=\"o\">)]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Subtype.val</span> <span class=\"o\">((</span><span class=\"n\">g</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"bp\">Φ</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">≃*</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Perm</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">Perm.subtypePerm</span> <span class=\"n\">g</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf_eq</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Function.comp_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"n\">arrowAction.mem_stabilizer_iff.mp</span> <span class=\"n\">g.prop</span><span class=\"o\">]</span>\n  <span class=\"n\">invFun</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">φ_invFun_equiv</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"n\">ext</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">comp_φ_invFun</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n  <span class=\"n\">left_inv</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">right_inv</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"n\">a</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">φ_invFun_eq</span>\n  <span class=\"n\">map_mul'</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Finsupp.multinomial_spec</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finsupp.multinomial_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">convert</span> <span class=\"n\">Nat.multinomial_spec</span> <span class=\"n\">f.support</span> <span class=\"n\">_</span> <span class=\"n\">using</span> <span class=\"mi\">2</span>\n  <span class=\"bp\">.</span> <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Finset.prod_subset_one_on_sdiff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"bp\">.</span> <span class=\"n\">infer_instance</span>\n    <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Finset.sum_subset_zero_on_sdiff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"bp\">.</span> <span class=\"n\">infer_instance</span>\n  <span class=\"bp\">.</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fin_map_multinom</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f₀</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n  <span class=\"n\">Fintype.card</span> <span class=\"o\">{</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n  <span class=\"n\">set</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">b</span> <span class=\"o\">}</span>\n  <span class=\"n\">change</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">claim1</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">MulAction.orbit</span> <span class=\"o\">(</span><span class=\"n\">Equiv.Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Set.ext</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hf</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n      <span class=\"k\">have</span> <span class=\"n\">bij_left</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.equivFinOfCardEq</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"n\">bij_right</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.equivFinOfCardEq</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n      <span class=\"k\">let</span> <span class=\"n\">bij_b</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Equiv.trans</span> <span class=\"o\">(</span><span class=\"n\">bij_left</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">bij_right</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">ofFiberEquiv_map</span> <span class=\"n\">bij_b</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_orbit_iff</span><span class=\"o\">]</span>\n      <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"n\">ofFiberEquiv</span> <span class=\"n\">bij_b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span>\n      <span class=\"n\">funext</span> <span class=\"n\">a</span>\n      <span class=\"k\">show</span> <span class=\"n\">f₀</span> <span class=\"o\">((</span><span class=\"n\">ofFiberEquiv</span> <span class=\"n\">bij_b</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span> <span class=\"n\">a</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">hf</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_orbit_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hf</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span> <span class=\"o\">⟩</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_setOf</span><span class=\"o\">]</span>\n      <span class=\"n\">intro</span> <span class=\"n\">b</span>\n      <span class=\"n\">replace</span> <span class=\"n\">hx</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f₀</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hx</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span>\n      <span class=\"k\">have</span> <span class=\"n\">subtype_equiv</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">subtypeEquivOfSubtype</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f₀</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span>\n      <span class=\"k\">have</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">congr</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">this</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">subtype_equiv</span>\n      <span class=\"n\">replace</span> <span class=\"n\">subtype_equiv</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.card_congr</span> <span class=\"n\">subtype_equiv</span>\n      <span class=\"n\">exact</span> <span class=\"n\">subtype_equiv</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">claim2</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">stabilizer</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span> <span class=\"n\">Fintype.ofEquiv_card</span> <span class=\"bp\">Φ.</span><span class=\"n\">toEquiv</span><span class=\"o\">]</span>\n    <span class=\"n\">set</span> <span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">Perm</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">((</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∏</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"bp\">.</span> <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"c1\">-- convert is needed here to deal with two slightly different Fintype instances</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Fintype.card_pi</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">claim3</span> <span class=\"o\">:</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">change</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">f₀</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n    <span class=\"n\">convert</span> <span class=\"n\">Finset.card_eq_sum_card_fiberwise</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">f₀</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">Finset.univ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">_</span>\n    <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">Set.toFinset_card</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span>\n    <span class=\"n\">simp</span>\n\n\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">card_orbit_mul_card_stabilizer_eq_card_group</span> <span class=\"o\">(</span><span class=\"n\">Perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">f₀</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">claim1</span><span class=\"o\">,</span> <span class=\"n\">claim2</span><span class=\"o\">,</span> <span class=\"n\">Fintype.card_perm</span><span class=\"o\">,</span> <span class=\"n\">claim3</span><span class=\"o\">,</span> <span class=\"bp\">&lt;-</span><span class=\"n\">Finsupp.multinomial_spec</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">∏</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">Finsupp.multinomial</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.equivFunOnFinite.symm</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_eq_mul_left_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"n\">apply</span> <span class=\"n\">or_iff_not_imp_right.mp</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">&lt;-</span><span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">Finset.prod_ne_zero_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span> <span class=\"n\">_</span>\n  <span class=\"n\">exact</span> <span class=\"n\">factorial_ne_zero</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 410328862,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703788569
    },
    {
        "content": "<p><code>convert</code> is needed in that case because there is what is called a \"diamond\" of fintype instances, that is, the theorems you wanted to use are of the form <code>@Fintype.card _ inst1 ... = _</code>, but you wanted to have <code>@Fintype.card _ inst2 ... = _</code>, where <code>inst1</code> and <code>inst2</code> are two different instances of <code>Fintype</code> for the type you wanted. So these are not \"exactly\" the same theorems, but Fintype is a subsingleton; <code>convert</code> is aware of this, and will use the fact that <code>inst1</code> and <code>inst2</code> are equal to prove the goal. (You can probably see this by using <code>show_term convert ...</code>). There's also a second issue there, when you say <code>have (b:β) : Fintype (P b) := by infer_instance</code>; <code>have</code> forgets the term that you provide, so <code>Fintype.card_pi</code> again runs into the same issue. You should either be able to delete this line, or at worst replace it with <code>let : Fintype (P b) := by infer_instance</code>.</p>",
        "id": 410337057,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703794130
    },
    {
        "content": "<p>Thanks!  You were right, after deleting the <code>infer_instance</code> line, <code>exact</code> works just fine, and I have updated the code block accordingly.  On the other hand, after inserting <code>show_term</code>, I see that the <code>convert this</code> line is hiding an enormous mess of motive manipulation that I am really glad I did not need to work out manually...</p>",
        "id": 410339512,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703795765
    },
    {
        "content": "<p>So are we putting this in mathlib? :)</p>",
        "id": 410343211,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1703798445
    },
    {
        "content": "<p>It could do with a little refactoring and golfing.  For instance if one refactors to work with <code>Multiset</code> instead of <code>Finsupp</code> then <code>claim3</code> collapses to basically <code>Multiset.card_map</code>.  And <code>claim1</code> becomes a statement that is perhaps of its own interest: if <code>f f₀: α → β</code> then one has <code>f = f₀ ∘ g</code> for some <code>g : Perm α</code> if and only if <code>Multiset.map f Finset.univ.val = Multiset.map f₀ Finset.univ.val</code>.</p>",
        "id": 410356493,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703805775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410326891\">said</a>:</p>\n<blockquote>\n<p>Curious... We should only have one of these (and probably it's <code>DomMulAct</code>). <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>, do you know what happened there?</p>\n</blockquote>\n<p>Perhaps we are missing a type synonym that exchanges right and left actions by using the inverse element of a group? This is going to be a mess with the new notation though</p>",
        "id": 410362592,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703809140
    },
    {
        "content": "<p>And even <code>DomMulAct</code> is a flawed design that faces diamonds, but it at least contains them so only its users experience them</p>",
        "id": 410362799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703809240
    },
    {
        "content": "<p>What are the diamonds for <code>DomMulAct</code>? It is rarely used at the moment, so it's not too late to fix it.</p>",
        "id": 410366607,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703811051
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/p0lNuq8D4idNRYPmBPWe8gex/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/p0lNuq8D4idNRYPmBPWe8gex/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/p0lNuq8D4idNRYPmBPWe8gex/image.png\"></a></div>",
        "id": 410407024,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703840089
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/3sW4i-dFiQ6ezvLpXC2viGY6/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/3sW4i-dFiQ6ezvLpXC2viGY6/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/3sW4i-dFiQ6ezvLpXC2viGY6/image.png\"></a></div>",
        "id": 410407192,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703840201
    },
    {
        "content": "<p>(this is from an extended version of \"scalar actions in Lean's mathlib\", which has turned into a thesis section. Rest assured I credit you for DomMulAct, and I have positive remarks about it too!)</p>",
        "id": 410407384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703840331
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 410441050,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703862202
    },
    {
        "content": "<p>Another solution would be to support non-instance actions and have notations like in your text for them.</p>",
        "id": 410441986,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703862789
    },
    {
        "content": "<p>I think lean 4 makes that pretty unviable, since SMul lemmas will refuse to apply to a non-instance action in the goal (finding instances by unification is no longer allowed)</p>",
        "id": 410442807,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703863325
    },
    {
        "content": "<p>Another way out would be <code>SMul tag R M</code> where <code>tag : Unit</code> is one of a handful of irreducible definitions such as <code>leftMul</code> or <code>codAction leftMul</code></p>",
        "id": 410443109,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703863515
    },
    {
        "content": "<p>Wow, it's rough being a left-handed Lean type in a universe made for right-handed types.  Is there at least some sort of <code>infer_instance?</code> diagnostic tool that can help detect these diamonds?  I just lost more than an hour to an (unrelated) silent diamond that was causing very weird heartbeat errors to pop up on extremely innocuous tactics (including <code>stop</code>!) until I finally caught it by chance when trying to narrow down a unification problem with <code>congr</code>.  Having a tool to test for such instance diamonds would be nice.</p>",
        "id": 410444517,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703864358
    },
    {
        "content": "<p>What was the diamond in question that you ran into?</p>",
        "id": 410444678,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703864464
    },
    {
        "content": "<p>Right now our diagnostic tool is \"post on Zulip\", though indeed an automated solution would be superior!</p>",
        "id": 410444718,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703864489
    },
    {
        "content": "<p>(Once you've guessed where the diamond is, it's easy enough to verify that it's problematic)</p>",
        "id": 410444806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703864530
    },
    {
        "content": "<p>By \"support non-instance actions\" I meant \"set up theory so that it takes <code>{_ : SMul M α}</code>, not <code>[SMul M α]</code>, like we do for σ-algebras in measure theory\". But this will have unwanted side effects too.</p>",
        "id": 410461426,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703872926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410444678\">said</a>:</p>\n<blockquote>\n<p>What was the diamond in question that you ran into?</p>\n</blockquote>\n<p>It was one of my own creation.  I had a commutative group <code>G</code> with discrete measurable structure on it, and a subgroup <code>N</code> of that group .  I needed the discrete measurable structure on the quotient group <code>G ⧸ N</code>, so I made an instance for it: <code>have _ : Measurable G ⧸ N = ⊤</code>.  However, I didn't realize that the quotient group already inherited a measurable structure from <code>G</code>, nevertheless the code was working okay despite the two instances except that random lines of code would time out using up a functionally infinite number of heartbeats (but if I commented out some other lines of code, then those random lines would compile, only for some other subsequent random line to fail).  Eventually I isolated the problem with <code>congr</code> reducing to showing that the two instances were equal, and deleting my own instance (and replacing it with a proof that the pre-existing measurable structure on <code>G ⧸ N</code> was discrete) fixed everything.  But it was a frustrating bug to hunt down, as (apart from the small example in the permutation code) I had not encountered this issue before, and nothing in the infoview or my diagnostic toolkit (except, ultimately, <code>congr</code> to try to understand why various defeq checks were sometimes (but not always!) taking near-infinite amounts of time) offered any clues (and the fact that errors only popped up after the code reached a certain length prevented me from isolating a MWE).  (In particular, some sort of linter that was able to detect potentially problematic multiple instances assigned to the same object would help, though I don't know whether it is possible to do this without creating a lot of either false positives or false negatives.)</p>",
        "id": 410463049,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703874033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410461426\">said</a>:</p>\n<blockquote>\n<p>By \"support non-instance actions\" I meant \"set up theory so that it takes <code>{_ : SMul M α}</code>, not <code>[SMul M α]</code>, like we do for σ-algebras in measure theory\". But this will have unwanted side effects too.</p>\n</blockquote>\n<p>Perhaps one could set up a small amount of support for a <code>SMulRight</code> structure, and then some tools to convert a <code>SMulRight</code> structure to a <code>SMul</code> structure and conversely, adding local instances manually as needed?  Not sure if this is enough of a roadblock to cut off unwanted diamonds, though.</p>",
        "id": 410463544,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703874448
    },
    {
        "content": "<p>Unfortunately <code>Right</code> doesn't contain nearly enough information to specify which of many right actions you might want. I have a few paragraphs on this too; I'll upload the relevant thesis section here as a PDF when I'm back at my laptop next week.</p>",
        "id": 410465897,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703876057
    },
    {
        "content": "<p>Oh I see.  I imagine a similar problem will eventually come up if one wants to manipulate the high rank tensors that show up in Riemannian geometry, where there are multiple useful ways to contract indices that can't be inferred just from the type of the inputs.</p>",
        "id": 410466526,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703876485
    },
    {
        "content": "<p>(I imagine Lean will barf heavily at trying to implement <a href=\"https://en.wikipedia.org/wiki/Penrose_graphical_notation\">Penrose graphical notation</a>, for instance.)</p>",
        "id": 410466677,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703876558
    },
    {
        "content": "<p>That notation would make a very cool formalization/widget project :)</p>",
        "id": 410467013,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1703876675
    },
    {
        "content": "<p>Since it is used here and I have to use it in another PR, I just made a PR out of <code>claim2</code> : <a href=\"https://github.com/leanprover-community/mathlib4/pull/9342\">#9342</a></p>",
        "id": 410484796,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1703889099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410407024\">said</a>:</p>\n<blockquote>\n<p>[Example of a diamond caused by <code>DomMulAct</code>]<br>\n<a href=\"/user_uploads/3121/p0lNuq8D4idNRYPmBPWe8gex/image.png\">image.png</a></p>\n</blockquote>\n<p>I don't understand the path on the right, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Pi.instSMul#doc\">docs#Pi.instSMul</a> : Why does<code>DomMulAct (G)</code> act on <code>G</code> ? Just because, as types, <code>DomMulAct (G) = G</code> ? <br>\n(On the other hand, a similar diamond would also appear using <code>f : G -&gt; G -&gt; DomMulAct(G)</code>.)</p>",
        "id": 410759751,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704144577
    },
    {
        "content": "<p>It acts on <code>G → G</code> using \"domain\" action.</p>",
        "id": 410759982,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704144678
    },
    {
        "content": "<p>But precisely, mathematically speaking, there is no action of <code>DomMulAct (G)</code> on <code>G</code> (the domain of <code>G -&gt; G</code>), hence my question.</p>",
        "id": 410760156,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704144759
    },
    {
        "content": "<p><code>Pi.instSmul</code> is being instantiated with <code>G -&gt; G</code> as the codomain, not <code>G</code></p>",
        "id": 410760225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704144798
    },
    {
        "content": "<p>Perhaps I need to show the arguments in the diagram too, but then I start to have space issues</p>",
        "id": 410760288,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704144836
    },
    {
        "content": "<p>Didn't you switch the two labels on the red path?</p>",
        "id": 410760599,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704144969
    },
    {
        "content": "<p>(I don't know, I'm lost…)</p>",
        "id": 410760664,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704145007
    },
    {
        "content": "<p>I think the labels are correct, but perhaps this presentation is non-optimal</p>",
        "id": 410760741,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704145053
    },
    {
        "content": "<p>The top arrow is saying that the <code>smul</code> that it originates from is unfolded to the expression it points to, using the instance specified</p>",
        "id": 410760844,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704145092
    },
    {
        "content": "<p>OK, I think I understand.<br>\nMathematically speaking, <code>DomMulAct(G)</code> acts on <code>G -&gt; H</code> by acting on the source, but if <code>DomMulAct(G)</code> acts on <code>H</code>, it also acts on <code>G -&gt; H</code> by acting on the target.<br>\nConsequently, <code>DomMulAct(G)</code> acts on <code>G -&gt; (G -&gt; G)</code> in two different ways : the first one is the action on the source, and the second one is the action  on the target, and these actions are distinct.</p>\n<p>A similar problem would consider <code>DomMulAct (G)</code> acting on <code>G → DomMulAct (G)</code> :  for <code>f : G → DomMulAct(G)</code> and <code>g : DomMulAct (G)</code>, one has <code>(g • f) (a) = f (g⁻¹ a) ≠ g • f(a) = f(a) g⁻¹</code>.</p>",
        "id": 410761634,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704145490
    },
    {
        "content": "<p>DomMulAct has no inverses, but otherwise that example is correct</p>",
        "id": 410761825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704145584
    },
    {
        "content": "<p>Apparently, I confused <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DomMulAct#doc\">docs#DomMulAct</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=arrowAction#doc\">docs#arrowAction</a>…</p>",
        "id": 410761937,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704145687
    },
    {
        "content": "<p>The correct line would thus be : <code>(g • f) (a) = f (a * g) ≠ g • f(a) = f(a) * g</code>.</p>",
        "id": 410762173,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704145951
    },
    {
        "content": "<p>Modulo the missing functions to transfer across the identification, yes</p>",
        "id": 410762304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704146094
    },
    {
        "content": "<p>One day or another, we shall need to teach Lean to cope with such ambiguities.</p>",
        "id": 410762354,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1704146154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410465897\">said</a>:</p>\n<blockquote>\n<p>I have a few paragraphs on this too; I'll upload the relevant thesis section here as a PDF when I'm back at my laptop next week.</p>\n</blockquote>\n<p><a href=\"/user_uploads/3121/G4Ns6ZxqrtT_ZPKe2hOZDBw1/efw-scalars-2024-01-04.pdf\">efw-scalars-2024-01-04.pdf</a></p>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Cardinality.20of.20permutation/near/410443109\">said</a>:</p>\n<blockquote>\n<p>Another way out would be <code>SMul tag R M</code> where <code>tag : Unit</code> is one of a handful of irreducible definitions such as <code>leftMul</code> or <code>codAction leftMul</code></p>\n</blockquote>\n<p>There is now a short outline of this approach too.</p>",
        "id": 411183622,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704372623
    }
]