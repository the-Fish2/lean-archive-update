[
    {
        "content": "<p>Is the following statement missing or wrong?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RepresentationTheory.Character</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.RootsOfUnity.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.RingTheory.SimpleModule</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Simple</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.CategoryTheory.Limits.Shapes.ZeroObjects</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">Representation</span><span class=\"w\"> </span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kd\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(sorry for the many imports lol)</p>",
        "id": 443618879,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717956090
    },
    {
        "content": "<p>Since you can embed k into A (via <code>algebraMap</code>) and the axioms should work out</p>",
        "id": 443619349,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717956410
    },
    {
        "content": "<p>The way mathlib's typeclass hierarchy is designed is such that this instance doesn't exist. The reasoning here is that we might have a preexisting typeclass instance <code>[Module k V]</code> not definitionally equal to the one you're thinking of here, and having multiple instances of typeclasses floating around is a massive headache. Instead, when we want to consider a <code>V</code> which is compatibly a <code>k</code>-module and an <code>A</code>-module we add both typeclass assumptions <code>[Module k V]</code> and <code>[Module A V]</code> <em>as well as</em> the assumption <code>[IsScalarTower k A V]</code>. This last typeclass basically says that the restriction of scalars of <code>V</code> as an <code>A</code>-module to a <code>k</code>-module gives the existing <code>k</code>-module structure. But since it's a proposition instead of a required definitional equality it behaves much better</p>",
        "id": 443620223,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717956833
    },
    {
        "content": "<p>Ahh okay, I will have a look at the IsScalarTower API, thanks!</p>",
        "id": 443620971,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1717957160
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/Defs.html#Module.compHom\">Module.compHom</a> exists but it can't be made an instance for obvious reasons (no way to infer S, even if the RingHom is replaced by Algebra).</p>",
        "id": 443624102,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1717958987
    },
    {
        "content": "<p><del>docs#Module.restrictScalars</del> never mind… that’s for ModuleCat and it indeed restricts scalars with what Junyan suggested</p>",
        "id": 443632167,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1717962848
    }
]