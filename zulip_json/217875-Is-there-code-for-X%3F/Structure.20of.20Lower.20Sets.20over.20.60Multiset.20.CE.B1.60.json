[
    {
        "content": "<p>Hello, I tried to search the following result in mathlib4 and didn't find it:</p>\n<blockquote>\n<p>Consider some <code>α : Type _</code> and <code>S : Set (Multiset α)</code>, and suppose that <code>S</code> is an infinite lower set. Then at least one of the following holds:</p>\n<ul>\n<li>there exists infinitely many <code>a : α</code> such that <code>{a} ∈ S</code>; or</li>\n<li>there exists <code>a : α</code> such that <code>Multiset.replicate n a ∈ S</code> for all <code>n : ℕ</code>.</li>\n</ul>\n</blockquote>\n<p>I'm wondering if there is at least a result similar to this one already in mathlib4 (or something generalizing this result). Thank you very much.</p>",
        "id": 410369250,
        "sender_full_name": "Gian Cordana Sanjaya",
        "timestamp": 1703812591
    },
    {
        "content": "<p>FYI Multisets are always finite in mathlib, so you may want a different type here</p>",
        "id": 410370957,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1703813565
    },
    {
        "content": "<p>Ah, I mistyped; I meant <code>S : Set (Multiset α)</code>, not <code>S : Multiset α</code>. I'll edit it.</p>",
        "id": 410371431,
        "sender_full_name": "Gian Cordana Sanjaya",
        "timestamp": 1703813780
    },
    {
        "content": "<p>We don't have that, but it should be an easy pigeonhole argument (assume both options don't hold, then your multisets can only use finitely many copies of finitely many <code>a</code>, so your set is finite)</p>",
        "id": 410401312,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703835722
    },
    {
        "content": "<p>I would first prove the version without the lower set condition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Multiset</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.Infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">m</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">Infinite</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m.count</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 410401659,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703836019
    },
    {
        "content": "<p>I decided to step away from this result for a while, but now I have a proof down below.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import Mathlib.Data.Set.Finite<br>\nimport Mathlib.Algebra.BigOperators.Order</p>\n<p>namespace Multiset</p>\n<p>open scoped Classical</p>\n<p>variable {S : Set (Multiset α)}</p>\n<p>lemma subset_powerset_of_finset_mem_of_count_bdd_fn<br>\n    {A : Finset α} (h : ∀ a, (a ∈ A ↔ ∃ M ∈ S, a ∈ M))<br>\n    {n : α → ℕ} (h0 : ∀ a, ∀ M ∈ S, M.count a ≤ n a) :<br>\n    S ⊆ (A.sum λ a ↦ Multiset.replicate (n a) a).powerset.toFinset := by<br>\n  intro M h1<br>\n  rw [Finset.mem_coe, Multiset.mem_toFinset,<br>\n    Multiset.mem_powerset, Multiset.le_iff_count]<br>\n  intro a; by_cases h2 : a ∈ A<br>\n  ---- Case 1: <code>a ∈ A</code><br>\n  · apply (h0 a M h1).trans<br>\n    rw [Multiset.count_sum', ← Multiset.count_replicate_self a (n a)]<br>\n    exact Finset.single_le_sum (λ _ _ ↦ Nat.zero_le _) h2<br>\n      (f := λ x ↦ (Multiset.replicate (n x) x).count a)<br>\n  ---- Case 2: <code>a ∉ A</code><br>\n  · exact (Nat.zero_le _).trans_eq' &lt;| Multiset.count_eq_zero.mpr &lt;|<br>\n<a href=\"http://not_and.mp\">not_and.mp</a> (<a href=\"http://not_exists.mp\">not_exists.mp</a> (mt (h a).mpr h2) M) h1</p>\n<p>lemma finite_of_finset_mem_of_count_bdd_fn<br>\n    {A : Finset α} (h : ∀ a, (a ∈ A ↔ ∃ M ∈ S, a ∈ M))<br>\n    {n : α → ℕ} (h0 : ∀ a, ∀ M ∈ S, M.count a ≤ n a) : S.Finite :=<br>\n  Set.Finite.subset (Finset.finite_toSet _)<br>\n    (subset_powerset_of_finset_mem_of_count_bdd_fn h h0)</p>\n<p>lemma finite_of_finite_mem_of_count_bdd<br>\n    (h : {a | ∃ M ∈ S, a ∈ M}.Finite) (h0 : ∀ a, ∃ n, ∀ M ∈ S, M.count a ≤ n) :<br>\n    S.Finite :=<br>\n  (Classical.axiomOfChoice h0).elim λ _ ↦<br>\n    finite_of_finset_mem_of_count_bdd_fn (λ _ ↦ h.mem_toFinset)</p>\n<p>lemma finite_mem_of_finite (h : S.Finite) : {a | ∃ M ∈ S, a ∈ M}.Finite :=<br>\n  (h.toFinset.sum id).toFinset.finite_toSet.subset λ a ↦ by<br>\n    rw [Finset.mem_coe, Multiset.mem_toFinset, Finset.mem_sum]<br>\n    simp_rw [h.mem_toFinset]; exact id</p>\n<p>lemma count_bdd_of_finite (h : S.Finite) (a : α) :<br>\n    ∃ n, ∀ M ∈ S, M.count a ≤ n :=<br>\n  ⟨Multiset.card (h.toFinset.sum id), λ M h0 ↦ (M.count_le_card a).trans &lt;| by<br>\n    rw [map_sum]; exact Finset.single_le_sum<br>\n      (λ K _ ↦ K.card.zero_le) (h.mem_toFinset.mpr h0)⟩</p>\n<p>lemma finite_iff_atoms :<br>\n    S.Finite ↔ {a | ∃ M ∈ S, a ∈ M}.Finite ∧ ∀ a, ∃ n, ∀ M ∈ S, M.count a ≤ n :=<br>\n  ⟨λ h ↦ ⟨finite_mem_of_finite h, count_bdd_of_finite h⟩,<br>\n  λ h ↦ finite_of_finite_mem_of_count_bdd h.1 h.2⟩</p>\n<p>lemma infinite_iff_atoms :<br>\n    S.Infinite ↔ {a | ∃ M ∈ S, a ∈ M}.Infinite ∨<br>\n      ∃ a, ∀ n, ∃ M ∈ S, n &lt; M.count a := by<br>\n  rw [Set.Infinite, finite_iff_atoms, not_and_or]<br>\n  simp only [not_forall, not_exists, not_imp, not_le]; rfl</p>\n</div></div>\n<p>It seems to me that the version without the lower set condition is already very nice in itself, so I'm not implementing the lower set version yet. Would the result be worth putting in some existing files/new file in Mathlib? If so, I might need help in choosing names for the lemmas.</p>\n<p>I needed this result to prove a result about divisor-closed, infinite subsets of <code>PNat</code>; it either contains a power of some fixed prime or contains infinitely many primes. Using <code>PrimeMultiset</code> should help with this.</p>",
        "id": 411583917,
        "sender_full_name": "Gian Cordana Sanjaya",
        "timestamp": 1704618104
    }
]