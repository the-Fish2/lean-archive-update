[
    {
        "content": "<p>I couldn't find this. Do we have it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.Coalgebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Bilinear</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">do_we_have_this</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">φ</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">ψ</span> <span class=\"n\">b</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_add</span><span class=\"o\">]</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">map_add'</span> <span class=\"n\">a₁</span> <span class=\"n\">a₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">]</span>\n  <span class=\"n\">map_smul'</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>The multiplication on <code>S</code> is used in the definition of the map, which made it different to the things I could find.</p>",
        "id": 418446382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706389572
    },
    {
        "content": "<p>We must have the multiplication map out of the tensor product of S with itself, so you can tensor phi and psi, compose with that, and curry</p>",
        "id": 418446773,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706390018
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">do_we_have_this</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">TensorProduct.map</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span>\n  <span class=\"k\">let</span> <span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">μ.comp</span> <span class=\"n\">a</span>\n  <span class=\"n\">TensorProduct.curry</span> <span class=\"n\">t</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">do_we_have_this</span> <span class=\"n\">S</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span> <span class=\"n\">b</span>  <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">ψ</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 418447044,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706390268
    },
    {
        "content": "<p>mostly all found with <code>exact?</code></p>",
        "id": 418447093,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706390289
    },
    {
        "content": "<p>Nice. I'd been using <code>exact?</code> to go from <code>do_we_have_this</code> to the following question (which I don't have the answer to, and probably it would be easier to figure it out with pencil and paper): is there a contravariant monoid functor on (commutative) R-algebras attached to a CoAlgebra? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"n\">suppress_compilation</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Coalgebra</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Coalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"c1\">--Maybe commSemiring needed?</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"k\">in</span>\n<span class=\"n\">abbrev</span> <span class=\"n\">do_we_have_this</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">TensorProduct.map</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span>\n  <span class=\"k\">let</span> <span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span>\n  <span class=\"k\">let</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">μ.comp</span> <span class=\"n\">a</span>\n  <span class=\"n\">TensorProduct.curry</span> <span class=\"n\">t</span>\n\n<span class=\"sd\">/-- The `1` for the possible monoid structure on `A →ₗ[R] S` comes from the counit</span>\n<span class=\"sd\">of the coalgebra structure on `A` (composed with the canonical `R`-linear map `R →ₗ[R] S`). -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Algebra.linearMap</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">counit</span>\n\n<span class=\"sd\">/-- The `*` for the possible monoid structure on `A →ₗ[R] S` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">TensorProduct.lift</span> <span class=\"o\">(</span><span class=\"n\">do_we_have_this</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">comul</span>\n\n<span class=\"c1\">-- Is this a monoid?</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">one_mul</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul</span> <span class=\"n\">one</span> <span class=\"n\">φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">one</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_assoc</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"n\">ρ</span> <span class=\"bp\">=</span> <span class=\"n\">mul</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">ψ</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>These <code>sorry</code>s could well not be provable. I'm not particularly convinced that there is; if A is a Bialgebra then you probably get a monoid structure on the R-<em>algebra</em> morphisms to S (as you can guess I'm thinking about group functors), and I was wondering if this was a submonoid of a possible monoid structure on the bigger space of R-linear maps.</p>",
        "id": 418448403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706391612
    },
    {
        "content": "<p>So an R algebra is “just” a monoid in the monoidal category of R-modules (with the usual tensor product). So yes, Hom(-,S) should take values in monoids</p>",
        "id": 418449436,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706392734
    },
    {
        "content": "<p>I'm a bit unclear about what you're claiming: which kind of homs do you mean by Hom(-,S)? Note that I'm doing coalgebras not algebras (and currently trying to understand them; I know nothing)</p>",
        "id": 418449594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706392912
    },
    {
        "content": "<p>Oh I see from Wikipedia that (at least over fields R) Hom_{R-mod}(R-coalgebra,R) is an algebra? Is that what it's saying?</p>",
        "id": 418449757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706393056
    },
    {
        "content": "<p>sorry, I don't know what I'm saying. I was getting my kids ready for ski lessons and was only half reading/thinking</p>",
        "id": 418450112,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706393489
    },
    {
        "content": "<p>what is definitely true is that a (co)algebra over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is the same thing as a (co)monoid in the monoidal category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules (in the sense of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Mon_#doc\">docs#Mon_</a> for instance)</p>",
        "id": 418450168,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706393531
    },
    {
        "content": "<p>I think this is <code>(LinearMap.mul R S).compl₁₂</code>? (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap#doc\">docs#LinearMap</a>.compl₁₂)</p>",
        "id": 418451320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706394774
    },
    {
        "content": "<p>Wait what is a comonoid object in a monoidal category?</p>",
        "id": 418452375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706395824
    },
    {
        "content": "<p>All I want is a connected reductive group over a field and they're all affine</p>",
        "id": 418452474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706395933
    },
    {
        "content": "<p>I was wondering whether I should just use Hopf algebras to model these.</p>",
        "id": 418452600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706396088
    },
    {
        "content": "<p>And then I went down a rabbit hole</p>",
        "id": 418452609,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706396103
    },
    {
        "content": "<p>What structure do you need on a category for it to admit coalgebras? Eg vector spaces over a fixed ground field (or commsemiring) seems to work. Is there such a thing as a cosemigroup?</p>",
        "id": 418454037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706397594
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> do you understand this twaddle?</p>",
        "id": 418454321,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706397846
    },
    {
        "content": "<p>So maybe there's the concept of a \"coalgebra object\" in any monoidal category, and probably modules over a semiring are a monoidal category?</p>",
        "id": 418455092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706398581
    },
    {
        "content": "<p>As are R-algebras and commutative R-algebras?</p>",
        "id": 418455130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706398673
    },
    {
        "content": "<p>aha maybe I've got it: is it something like: a coalgebra is a coalgebra object in the category of R-modules, a Hopf algebra is a coalgebra object in the category of (commutative?) R-algebras?</p>",
        "id": 418455299,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706398812
    },
    {
        "content": "<p>and a bialgebra is some weird in-between thing?</p>",
        "id": 418455346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706398873
    },
    {
        "content": "<p>Kevin, Hopf algebras are a bit more complicated, so let's get the bialgebra story straight first. :-)</p>\n<p>The usual way to describe a bialgebra is as something that is simultaneously an algebra and a coalgebra, and that the coalgebra structural morphisms are algebra maps and (in fact, equivalently) the algebra morphisms are coalgebra maps.</p>",
        "id": 418456124,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706399694
    },
    {
        "content": "<p>Another way to say that is that a bialgebra is a comonoid object in the category of monoid objects in the category of R-modules.</p>",
        "id": 418456146,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706399743
    },
    {
        "content": "<p>And inevitably that is equivalent to the monoid objects in the comonoid objects in R-mod.</p>",
        "id": 418456196,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706399770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Bilinear.20map.20coming.20from.20two.20linear.20maps/near/418452474\">said</a>:</p>\n<blockquote>\n<p>All I want is a connected reductive group over a field and they're all affine</p>\n</blockquote>\n<p>I think (affine) group schemes should be modeled as group objects in the category of (affine) schemes.</p>",
        "id": 418456691,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706400288
    },
    {
        "content": "<p>Do we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Group_#doc\">docs#Group_</a> ?</p>",
        "id": 418456703,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1706400301
    },
    {
        "content": "<p>For the relation between Hopf algebras and group objects the summary at <a href=\"https://ncatlab.org/nlab/show/Hopf+algebra#relation_to_hopf_groups\">https://ncatlab.org/nlab/show/Hopf+algebra#relation_to_hopf_groups</a> seems good.</p>",
        "id": 418457257,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1706400778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Bilinear.20map.20coming.20from.20two.20linear.20maps/near/418456691\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Bilinear.20map.20coming.20from.20two.20linear.20maps/near/418452474\">said</a>:</p>\n<blockquote>\n<p>All I want is a connected reductive group over a field and they're all affine</p>\n</blockquote>\n<p>I think (affine) group schemes should be modeled as group objects in the category of (affine) schemes.</p>\n</blockquote>\n<p>I want to implement them as commutative rings with extra structure because it's cheaper. I want to be able to do some trick like I did for elliptic curves, where I say \"let <code>K</code> be a field and let <code>𝒞ℛ𝒢</code> denote the type of connected reductive groups over <code>K</code> and the user can have their <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">G</mi><mi>m</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{G}_m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> but secretly it's just `<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo separator=\"true\">,</mo><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[X,X^{-1}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 418458727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706402159
    },
    {
        "content": "<p>Oh I'm a fool about bialgebras, I had got the definition wrong. Ignore most of my nonsense about monoid (co)objects above</p>",
        "id": 418458789,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706402189
    },
    {
        "content": "<p>Which side is <code>simp</code> normal form? (I see we use <code>comul.lTensor</code> in the definition of coalgebra.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">comul.lTensor</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">TensorProduct.map</span> <span class=\"n\">LinearMap.id</span> <span class=\"n\">comul</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 418462157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706405903
    },
    {
        "content": "<p>Do we have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"n\">suppress_compilation</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- dual of Coalgebra.coassoc</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Algebra.assoc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">((</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">((</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rTensor</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n  <span class=\"n\">simp</span>\n  <span class=\"c1\">-- `ring` doesn't work on mul_assoc.symm??</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"c1\">-- ??</span>\n</code></pre></div>",
        "id": 418467215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706412037
    },
    {
        "content": "<p>I'm finally getting the hang of it. I'm annoyed that I have to use pen and paper sometimes and can't use Lean as a scratchpad.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- attribute [pp_dot] LinearMap.comp</span>\n<span class=\"c1\">-- attribute [pp_dot] LinearMap.mul'</span>\n<span class=\"c1\">-- attribute [pp_dot] LinearMap.id</span>\n\n<span class=\"n\">suppress_compilation</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Coalgebra</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Coalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A proposed `*` for a possible semigroup structure on `A →ₗ[R] S` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">((</span><span class=\"n\">TensorProduct.map</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">comul</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mul</span><span class=\"o\">⟩</span>\n\n<span class=\"sd\">/-- A -(comul)-&gt; A ⊗ A -(φ ⊗ ψ)-&gt; S ⊗ S -(* on S)-&gt; S -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_def</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">φ</span> <span class=\"bp\">*</span> <span class=\"n\">ψ</span> <span class=\"bp\">=</span>\n<span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">((</span><span class=\"n\">TensorProduct.map</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">comul</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- dual of Coalgebra.coassoc</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Algebra.assoc</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">((</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct.assoc</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">S</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">((</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">rTensor</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n  <span class=\"n\">simp</span>\n  <span class=\"c1\">-- `ring` doesn't work on mul_assoc.symm??</span>\n  <span class=\"c1\">-- something weird going on?</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"c1\">-- ??</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">*</span> <span class=\"n\">ψ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">ρ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"bp\">*</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_def</span><span class=\"o\">]</span>\n  <span class=\"c1\">-- worked out proof on paper</span>\n  <span class=\"c1\">-- first commutative square</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">map_map_comp_assoc_eq</span> <span class=\"n\">φ</span> <span class=\"n\">ψ</span> <span class=\"n\">ρ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"c1\">-- contains two `TensorProduct.assoc`s</span>\n  <span class=\"c1\">-- now glue on another one</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">.</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.rTensor</span> <span class=\"n\">A</span> <span class=\"n\">comul</span> <span class=\"bp\">∘ₗ</span> <span class=\"n\">comul</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">))</span> <span class=\"n\">h</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- and another</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(((</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">((</span><span class=\"n\">LinearMap.mul'</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lTensor</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"bp\">∘ₗ</span> <span class=\"bp\">.</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- now need to remove both `TensorProduct.assoc`s from h using associativity</span>\n  <span class=\"c1\">-- and coassociativity axioms</span>\n  <span class=\"k\">have</span> <span class=\"n\">hSassoc</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.assoc</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">hAassoc</span> <span class=\"o\">:=</span> <span class=\"n\">coassoc</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- comping one way</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"n\">hSassoc</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hSassoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"c1\">-- comping the other way</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"n\">hAassoc</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hAassoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">LinearMap.comp_assoc</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>How am I supposed to be doing these calculations?</p>",
        "id": 418468821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706413904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Bilinear.20map.20coming.20from.20two.20linear.20maps/near/418462157\">said</a>:</p>\n<blockquote>\n<p>Which side is <code>simp</code> normal form? (I see we use <code>comul.lTensor</code> in the definition of coalgebra.)</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">comul.lTensor</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">A</span> <span class=\"o\">:</span>\n    <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">TensorProduct.map</span> <span class=\"n\">LinearMap.id</span> <span class=\"n\">comul</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>In category theory land, there is a big refactor going on to try and make lTensor simp-normal</p>",
        "id": 418474151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706419496
    },
    {
        "content": "<p>It might also be reasonable to make it reducible (outside of category theory) to make the question go away</p>",
        "id": 418474184,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1706419546
    }
]