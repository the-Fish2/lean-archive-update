[
    {
        "content": "<p>Am I right to say that we don't have the following lemma? It should hold more generally for PIDs or unique factorisation monoids depending on the definition of coprime you use.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Squarefree</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">coprime_of_mul_squarefree</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Squarefree</span> <span class=\"bp\">$</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.coprime</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">by_contra</span> <span class=\"n\">h_ncop</span>\n  <span class=\"n\">cases'</span> <span class=\"n\">Nat.Prime.not_coprime_iff_dvd.mp</span> <span class=\"n\">h_ncop</span> <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">hp</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Nat.squarefree_iff_prime_squarefree.mp</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">hp.1</span> <span class=\"bp\">$</span> <span class=\"n\">Nat.mul_dvd_mul</span> <span class=\"n\">hp.2.1</span> <span class=\"n\">hp.2.2</span>\n</code></pre></div>",
        "id": 371713659,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1688301016
    },
    {
        "content": "<p>We seem to have exactly one lemma relating <code>coprime</code> and <code>squarefree</code>: <a href=\"https://leanprover-community.github.io/mathlib_docs/data/nat/squarefree.html#nat.squarefree_mul\">nat.squarefree_mul</a></p>",
        "id": 371714540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1688301254
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/5669\">#5669</a></p>",
        "id": 371738870,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1688307322
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Why do you keep posting links to mathlib3 docs even if the thread is about mathlib4?</p>",
        "id": 371801303,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1688327215
    },
    {
        "content": "<p>Mathlib3: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.squarefree_mul\">docs3#nat.squarefree_mul</a>, Mathlib4: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.squarefree_mul#doc\">docs#Nat.squarefree_mul</a> (Note these are both linkifiers Yaël. No need to make your own links)</p>",
        "id": 371802430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1688327716
    },
    {
        "content": "<p>because that's the docs I have open and it's easy to figure out the mathlib4 declaration from there.</p>",
        "id": 371814574,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1688333535
    },
    {
        "content": "<p>It's easier for everyone else if you post a less confusing message</p>",
        "id": 371887799,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1688367236
    },
    {
        "content": "<p>Wow, a language model rewrote your proof: <a href=\"https://wolfia.com/query/01H4J8BPAGH5RQ0F2NEGZY1KSB\">https://wolfia.com/query/01H4J8BPAGH5RQ0F2NEGZY1KSB</a> (see <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Semantic.20Search.20for.20Mathematics/near/371908249\">here</a> for context)<br>\nIt seems to know Lean (3) pretty well and was able to informalize the proof (or maybe it already knew the proof); probably GPT(-4)?</p>",
        "id": 372468135,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1688535016
    },
    {
        "content": "<p>That link doesn't seem germane to this thread?</p>",
        "id": 372476516,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1688538178
    },
    {
        "content": "<p>Thanks, fixed</p>",
        "id": 372497426,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1688544146
    },
    {
        "content": "<p>Can it generalise it?</p>",
        "id": 372505411,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1688546002
    },
    {
        "content": "<p>I asked it to generalize (<a href=\"https://wolfia.com/query/c4e3fe2c-f05d-48f7-9323-a52114ff891d\">two</a> of the <a href=\"https://wolfia.com/query/b57edbf8-8c6f-4b44-896d-ca4ecc50ed07\">attempts</a>) but the results were disappointing. Anyway, here's a generalization by myself of the PR to arbitrary \"decomposition monoids\", which include all gcd monoids: <a href=\"https://gist.github.com/alreadydone/0ad7fb42db30711c4540ac92e37f6655\">https://gist.github.com/alreadydone/0ad7fb42db30711c4540ac92e37f6655</a> (probably golfable)</p>",
        "id": 373110730,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1688716080
    },
    {
        "content": "<p>With that definition of <code>RelPrime</code> the original lemma actually holds for arbitrary commutative monoids!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Squarefree</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">relPrime_of_squarefree_mul</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Squarefree</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">IsUnit</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">p</span> <span class=\"bp\">$</span> <span class=\"n\">mul_dvd_mul</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n</code></pre></div>",
        "id": 373181989,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1688730715
    },
    {
        "content": "<p>Ah sorry, I missed that you <a href=\"https://gist.github.com/alreadydone/0ad7fb42db30711c4540ac92e37f6655/53c0540ecd9eadb9dc3fc4d6cf4bd0e23235237a#file-decomposition_monoid-lean-L19\">proved it too</a></p>",
        "id": 373248141,
        "sender_full_name": "Arend Mellendijk",
        "timestamp": 1688743502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Coprime.20if.20product.20is.20squarefree/near/373110730\">said</a>:</p>\n<blockquote>\n<p>I asked it to generalize (<a href=\"https://wolfia.com/query/c4e3fe2c-f05d-48f7-9323-a52114ff891d\">two</a> of the <a href=\"https://wolfia.com/query/b57edbf8-8c6f-4b44-896d-ca4ecc50ed07\">attempts</a>) but the results were disappointing. Anyway, here's a generalization by myself of the PR to arbitrary \"decomposition monoids\", which include all gcd monoids: <a href=\"https://gist.github.com/alreadydone/0ad7fb42db30711c4540ac92e37f6655\">https://gist.github.com/alreadydone/0ad7fb42db30711c4540ac92e37f6655</a> (probably golfable)</p>\n</blockquote>\n<p>Did any of these lemmas make it to Mathlib?  I just needed essentially these exact results and proved them in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10170\">#10170</a> I'd like to know if I can weaken the hypotheses in this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.SquareFree.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.PrincipalIdealDomain</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsDomain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">IsPrincipalIdealRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">GCDMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"c1\">-- Too strong?</span>\n<span class=\"c1\">-- variable [UniqueFactorizationMonoid R] -- Sufficient?</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">squarefree_mul_iff</span> <span class=\"o\">:</span>\n    <span class=\"n\">Squarefree</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">IsCoprime</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">Squarefree</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">Squarefree</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- See #10170</span>\n</code></pre></div>",
        "id": 419334520,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706822051
    },
    {
        "content": "<p>I've just used up my final minute for the day so I'll have to run now.</p>",
        "id": 419334592,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706822096
    },
    {
        "content": "<p>Something like this is certainly true only under the <code>UniqueFactorizationMonoid R</code> assuption, but then <code>IsCoprime</code> doesn't work. I thought Something like <code>Disjoint x y</code> should work instead, with the preorder on <code>R</code> being divisibility (so 1 is a bottom element and 0 is a top element), but then we run into two problems: <code>Disjoint x y</code> seems to need a partial order (even though it shouldn't, you can just ask that every inf is a bottom element), and also it's going to be hard putting this preorder on an arbitrary UFM, because the naturals and integers already have a totally different order. So really the question about whether we can weaken the hypotheses, for me right now, is more the question of how to <em>state</em> the result for UFMs. In other words, I guess this will be true:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CancelCommMonoidWithZero</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">squarefree_mul_iff'</span> <span class=\"o\">:</span>\n    <span class=\"n\">Squarefree</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">Squarefree</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">Squarefree</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and <a href=\"https://github.com/leanprover-community/mathlib4/pull/10172\">#10172</a> (if it compiles!) will let us use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Disjoint#doc\">docs#Disjoint</a> on preorders. I don't however know how to solve the problem of putting the preorder I want on a unique factorization monoid without creating non-defeq diamonds for (at least) Nat, Int, Rat and Real.</p>",
        "id": 419341762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706825244
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Associated#doc\">docs#Associated</a> with the right pre-order</p>",
        "id": 419389019,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706853411
    },
    {
        "content": "<p>Sorry, it's the relation but we have the quotient too</p>",
        "id": 419389079,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706853476
    },
    {
        "content": "<p>Also, I think that we should add this kind of coprime as a definition with API. What would be a good name?</p>",
        "id": 419389702,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706853919
    },
    {
        "content": "<p><code>Coprime</code> :-/</p>",
        "id": 419393456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706856613
    },
    {
        "content": "<p>Having both <code>Coprime</code> and <code>IsCoprime</code> with different meaning is not good.</p>",
        "id": 419395796,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1706858237
    },
    {
        "content": "<p>We had a long discussion about the meaning of this term for commutative rings, with the key observation being that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> were obviously coprime in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\R[X,Y]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">]</span></span></span></span> but the ideal they generated was not the whole ring, so the literature says they're not coprime. However this time the discussion is about monoids so the ideal objection does not apply. Except for the fact that lots of UFMs are rings anyway :-/</p>",
        "id": 419403837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706859746
    },
    {
        "content": "<p>Thanks for all of this, it's very helpful. I think I'll probably rework <a href=\"https://github.com/leanprover-community/mathlib4/pull/10170\">#10170</a> so that it is a result about elements of unique factorization domains but using an inline \"correct\" definition of coprime in the context of UFDs rather than using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCoprime#doc\">docs#IsCoprime</a> (similar to what I see in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UniqueFactorizationMonoid.induction_on_coprime#doc\">docs#UniqueFactorizationMonoid.induction_on_coprime</a> for example).</p>\n<p>This  doesn't solve the question of how best to have both types of coprimeness in the library but does at least mean I can prove my result in the generality I desire.</p>",
        "id": 419416566,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706865577
    },
    {
        "content": "<p>I don't understand why we haven't simply already defined <code>FactorFree</code></p>",
        "id": 419416779,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1706865659
    },
    {
        "content": "<p>The answer may very well be the usual one: nobody's got round to it yet.</p>",
        "id": 419416873,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706865702
    },
    {
        "content": "<p>I've just tried to do a literature search on the books in my office: it seems to me that none of Matsumura commutative ring theory, Matsumura commutative algebra, and Eisenbud Commutative Algebra define coprime elements of a ring (although coprime <em>ideals</em> are defined to mean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>+</mo><mi>J</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">I+J=(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>). So perhaps we're at liberty to refactor <code>Coprime</code> to mean \"no common non-unit divisor\"?</p>",
        "id": 419422067,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706867599
    },
    {
        "content": "<p>Oh I've just got a dodgy pdf copy of Matsumura's commutative ring theory so I can search for words, and of the 8 times the word \"coprime\" is occurring in the text, 7 times it applies to ideals and the 8th time it's talking about elements of the field of fractions of a UFD and it says they can be written as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mi mathvariant=\"normal\">/</mi><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x/y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">x,y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span></span></span></span> coprime (no defintion supplied ;-) ), and this would not be true for our definition of coprime. So I'm leaning towards a redefinition of coprime; we lose the assertion that if a,b are coprime then the ideals generated by a,b are coprime, but I suspect that commutative algebraists would be happy to lose this.</p>",
        "id": 419422774,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1706867808
    },
    {
        "content": "<p>I suggest using the word \"comaximal\" for notions around <code>I + J = 1</code>.</p>",
        "id": 419504983,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706896003
    },
    {
        "content": "<blockquote>\n<p>Did any of these lemmas make it to Mathlib? I just needed essentially these exact results and proved them in <a href=\"https://github.com/leanprover-community/mathlib4/pull/10170\">#10170</a> I'd like to know if I can weaken the hypotheses in this:</p>\n</blockquote>\n<p>Sorry I didn't see this. I have not PR'd the gist. The implications are <br>\nIsPrincipalIdealRing -&gt; UniqueFactorizationMonoid -&gt; GCDMonoid -&gt; DecompositionMonoid.<br>\nSo I think <a href=\"https://gist.github.com/alreadydone/0ad7fb42db30711c4540ac92e37f6655\">my version</a> is the most general one.</p>",
        "id": 419550761,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706915848
    },
    {
        "content": "<p>Interesting! I just updated <a href=\"https://github.com/leanprover-community/mathlib4/pull/10170\">#10170</a>, upgrading it from PID to UFM. It was a surprising amount of effort.</p>",
        "id": 419551245,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706916101
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Unique_factorization_domain\">Wikipedia</a> has this nice list <br>\n<a href=\"/user_uploads/3121/tE0AIIQTxo9txNF1qaC5l-j2/image.png\">image.png</a><br>\nbut apparently DecompositionMonoid isn't that well known.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/tE0AIIQTxo9txNF1qaC5l-j2/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/tE0AIIQTxo9txNF1qaC5l-j2/image.png\"></a></div>",
        "id": 419551413,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706916178
    },
    {
        "content": "<p>I was just looking at this picture.</p>",
        "id": 419551440,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706916194
    },
    {
        "content": "<p>I'm out of time for today. I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/10170\">#10170</a> is still a reasonable proposal but if you have the appetite I encourage you to generalise it further.</p>",
        "id": 419551578,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706916262
    },
    {
        "content": "<p>(feel free to push commits etc.)</p>",
        "id": 419551595,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1706916271
    },
    {
        "content": "<p>Okay! I think even if you don't introduce DecompositionMonoid, proving it for GCDMonoid first would still be easier. We'd also like a UFD version because there isn't a canonical GCDMonoid instance on a UFD (GCD is data and involves choice).<br>\nBut since I already proved it for DecompositionMonoid, I'd just go ahead to add the typeclass to mathlib (it can go into the file where <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=semigroupDvd#doc\">docs#semigroupDvd</a> is defined). I think it only makes sense for CommMonoid or maybe CommSemigroup.<br>\nCoprimality could be add to that file as well; to avoid conflict should we call it IsRelPrime for now? I incline to use the definition <code>∀ c, c ∣ a → c ∣ b → IsUnit c</code> and it will be almost defeq to <code>Disjoint (Associates.mk a) (Associates.mk b)</code> except for a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isUnit_iff_dvd_one#doc\">docs#isUnit_iff_dvd_one</a>.</p>",
        "id": 419553060,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706917200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Do you agree with merging <a href=\"https://github.com/leanprover-community/mathlib4/pull/10170\">#10170</a>, so that <span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> can continue his Jordan-Chevalley-Dunford quest? And then we can golf it with your proof at a later stage?</p>",
        "id": 419583408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706943545
    },
    {
        "content": "<p>Sounds good!</p>",
        "id": 419584340,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1706944609
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Just looked at your gist. Very slick development! Please PR it <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 419586263,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1706946743
    }
]