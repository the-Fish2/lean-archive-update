[
    {
        "content": "<p>Do we have the decision procedure for real semialgebraic geometry?</p>\n<p>(Asking for one of these worked last time, figured I should try again.)</p>",
        "id": 410154873,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1703684441
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#nlinarith\">tactic#nlinarith</a> is not complete, but works in practice</p>",
        "id": 410154995,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703684516
    },
    {
        "content": "<p>(it certainly works more often than I have seen from <code>omega</code> haha, I do think I'm using it wrong though)</p>",
        "id": 410157261,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703685674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Decision.20procedure.20for.20.60.28.E2.84.9D.2C.2B.2C*.2C.E2.89.A4.29.60/near/410154995\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#nlinarith\">tactic#nlinarith</a> is not complete, but works in practice</p>\n</blockquote>\n<p>What exactly do you mean by \"works in practice\" ? It seems to be very, very weak; it does succeed in showing that <code>∀ (x y : ℝ), 0 ≤ x ^ 2 + y ^ 2</code>, but it gets stuck if you ask for <code>0 ≤ x ^ 4 + y ^ 2</code>, or <code>2 * x * y ≤ x ^ 2 + y ^ 2</code>.</p>",
        "id": 410421713,
        "sender_full_name": "David Loeffler",
        "timestamp": 1703848704
    },
    {
        "content": "<p>I remember that it solves some really complex-looking problem which comes up when defining the basic API for the integers defined as a quotient of Nat^2 and I've always loved it for that</p>",
        "id": 410424776,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703850997
    },
    {
        "content": "<p>A decision procedure would solve this right away I guess.<br>\n<a href=\"/user_uploads/3121/-zqMxEPBsqA1F_SXZNPywUIq/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/-zqMxEPBsqA1F_SXZNPywUIq/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/-zqMxEPBsqA1F_SXZNPywUIq/image.png\"></a></div>",
        "id": 410463568,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703874468
    },
    {
        "content": "<p>Here's example where <code>nlinarith</code> needs significant help.  Is there a way to avoid the sign splits?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">maxHeartbeats</span> <span class=\"mi\">10000000</span> <span class=\"k\">in</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nlinarith_wish</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cd</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">xac</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xad</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xbc</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xbd</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">au</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ub</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cv</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vd</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">u</span> <span class=\"bp\">*</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">--nlinarith  -- I wish this one worked, but it does not</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">cases</span> <span class=\"n\">nonpos_or_nonneg</span> <span class=\"n\">c</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">cases</span> <span class=\"n\">nonpos_or_nonneg</span> <span class=\"n\">d</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">cases</span> <span class=\"n\">nonpos_or_nonneg</span> <span class=\"n\">u</span>\n  <span class=\"n\">all_goals</span> <span class=\"n\">cases</span> <span class=\"n\">nonpos_or_nonneg</span> <span class=\"n\">v</span>\n  <span class=\"n\">repeat</span> <span class=\"n\">nlinarith</span>\n</code></pre></div>",
        "id": 410883297,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704218225
    },
    {
        "content": "<p>Possibly worth remembering that <code>linarith</code> is currently buggy (<a href=\"https://github.com/leanprover-community/mathlib4/pull/2717\">#2717</a>, <a href=\"https://github.com/leanprover-community/mathlib4/pull/8875\">#8875</a>), which almost certainly impacts <code>nlinarith</code> too. Of course, it's possible that your example is not in scope of what it's <em>supposed</em> to do either.</p>",
        "id": 410883716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704218409
    },
    {
        "content": "<p>I thought that <code>nlinarith</code> was little more than <code>linarith</code> + <code>positivity</code> + \"squares are nonnegative\"</p>",
        "id": 410884970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704218860
    },
    {
        "content": "<p>I think it also does \"Nat is nonnegative\"</p>",
        "id": 410885388,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704219046
    },
    {
        "content": "<p>My point is that it really might not be in scope, my memory was that it was a quick hack to get some basic extension of linarith that knew some basic nonlinear stuff. The known decision procedures for the whole thing have really crappy runtime, right?</p>",
        "id": 410885787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704219248
    },
    {
        "content": "<p><code>linarith</code> itself should handle nats are nonnegative if I understand correctly <a href=\"https://github.com/leanprover-community/mathlib4/pull/7439\">#7439</a></p>",
        "id": 410886995,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1704219875
    },
    {
        "content": "<p>Is there any other machinery that would solve my example in one go?</p>",
        "id": 410894354,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704223659
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> They have bad worst-case runtime, but I don’t know if that means they aren’t practical.</p>",
        "id": 410895819,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704224459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"514145\">@Geoffrey Irving</span> John Harrison has an implementation of a \"semidecision procedure\" (if that's the word) for linearly ordered rings/fields in HOL Light.  I've thought for a while that it would be nice to port it to Lean.</p>",
        "id": 410898065,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704225505
    },
    {
        "content": "<p>It looks to be quite a bit easier to implement than the full cylindrical algebraic decomposition algorithm.</p>",
        "id": 410898158,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704225563
    },
    {
        "content": "<p>Here's the article: <a href=\"https://www.cl.cam.ac.uk/~jrh13/papers/sos.html\">https://www.cl.cam.ac.uk/~jrh13/papers/sos.html</a></p>",
        "id": 410898182,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704225584
    },
    {
        "content": "<p>Oh, would this be <code>polyrith</code> vibes, i.e. cert can be generated by fast external program?</p>",
        "id": 410898345,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704225659
    },
    {
        "content": "<p>Also see page 6 and 7 of this article by Parrilo (to whom Harrison attributes the main idea):<br>\n<a href=\"https://www.mit.edu/~6.454/www_fall_2001/cmcaram/parrilo.pdf\">https://www.mit.edu/~6.454/www_fall_2001/cmcaram/parrilo.pdf</a></p>",
        "id": 410898876,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704225855
    },
    {
        "content": "<p>The basic idea: given a problem like</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>a b c : R\nh : a * x ^ 2 + b * x + c = 0\n⊢ b ^ 2 - 4 * a * c ≥ 0\n</code></pre></div>\n<p>come up with a proof by magic identity + Grobner basis verification:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">calc</span>\n  <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linear_combination</span> <span class=\"bp\">-</span><span class=\"mi\">4</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">h</span>\n  <span class=\"n\">_</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 410899250,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704225997
    },
    {
        "content": "<p>The process could still be slow, though.  Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> be the polynomial expression you want to prove to be nonnegative (subject to certain polynomial constraints in the same variables).  If I understand correctly, in general there will be no magic identity to turn <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> into a sum of squares.  But there will be a magic identity to turn <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mi>n</mi></msup><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">A^nE</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> into a sum of squares, for large enough <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">A=x^2+y^2+\\ldots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0085em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.123em;\"></span><span class=\"minner\">…</span></span></span></span> is the sum of the squares of all the variables occuring in the problem.  So you iterate, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo>…</mo></mrow><annotation encoding=\"application/x-tex\">n=0,1,2,3\\ldots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span></span></span></span></p>",
        "id": 410899765,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704226300
    },
    {
        "content": "<p>Fortunately that process would generate a certificate that could then be baked into the saved proof.</p>",
        "id": 410899920,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704226363
    },
    {
        "content": "<p>To clarify, why is this only a semidecision procedure?  If I'm reading Theorem 4 and the implementation right, if you run the SDP in high enough precision and iterate through enough powers, you'll eventually find the certificate.  Is that right?</p>",
        "id": 410900345,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704226630
    },
    {
        "content": "<p>I guess because if you present it with something false, it will never terminate.</p>",
        "id": 410900376,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704226659
    },
    {
        "content": "<p>Ah, sorry, of course. :)</p>",
        "id": 410900541,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704226754
    },
    {
        "content": "<p>Is it possible to map a certificate of SDP failure to an attempted counterexample, with some loss?  I'm curious if some of the proving work could be reused as counterexample work.</p>",
        "id": 410900989,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1704226983
    },
    {
        "content": "<p>I don't know of any way of doing that.  On the other hand, you can probably hook up (different) external software to find and check counterexamples directly.</p>",
        "id": 410904440,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704228934
    },
    {
        "content": "<p>That is, the numbers themselves form the certificate for an existentially-quantified problem, whereas you need some cleverness (such as Harrison's idea with the magic identity producing a sum-of-squares expression) to produce a certificate for a universally-quantified problem.</p>",
        "id": 410904643,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704229057
    },
    {
        "content": "<p>For example, Li-Passmore-Paulson (section 7 <a href=\"https://arxiv.org/abs/1506.08238\">here</a>) use <a href=\"https://reference.wolfram.com/language/ref/FindInstance.html\">Mathematica</a> for numerical witnesses.</p>",
        "id": 410905317,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1704229348
    }
]