[
    {
        "content": "<p>Does a decidable instance for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ReflTransGen#doc\">docs#ReflTransGen</a> exist?</p>\n<p>I see there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.instDecidableRelReachable#doc\">docs#SimpleGraph.instDecidableRelReachable</a> for not for ReflTransGen itself.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>: I'm defining a <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalence.20Relation.20associated.20to.20a.20subset\">quotient from a collection of subsets</a>, as part of defining graph contraction. For induction, I'd like to prove that contraction results in a smaller graph, i.e. <code>Fintype.card (Quotient (Setoid.fromSets S)) ≤ Fintype.card α</code>. But that uses <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.fintype#doc\">docs#Quotient.fintype</a> which in turn requires that the setoid is decidable. While I can use <code>Nat.card</code> instead, the rest of the graph theory library uses <code>Fintype</code>, so I'd like to match that.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Relation</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Setoid.fromSets</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">ReflTransGen</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">ReflTransGen.refl</span>\n    <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"n\">ReflTransGen.trans</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"n\">ReflTransGen.symmetric</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.card_quotient_fromSets_le</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Fintype.card</span> <span class=\"o\">(</span><span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">Setoid.fromSets</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"bp\">≤</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 425680230,
        "sender_full_name": "Chris Wong",
        "timestamp": 1709985008
    },
    {
        "content": "<p>It's not decidable in general, but it's decidable if the type is a Fintype and the relation has the property that the sets <code>{y | r x y}</code> are Fintypes for each x.</p>\n<p>You probably don't need an actual decidable instance though, even if you use Fintype.card, since you can use <code>classical</code></p>",
        "id": 425737131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1710038657
    },
    {
        "content": "<p>Yeah, I took a stab at this and got stuck. I think my problem was that ReflTransGen doesn't carry data, so I couldn't reason about the length of the path, which is how the Reachable proof works. I'll just stick with classical for now.</p>",
        "id": 425780200,
        "sender_full_name": "Chris Wong",
        "timestamp": 1710082946
    },
    {
        "content": "<p>BTW, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.card_quotient_lt#doc\">docs#Fintype.card_quotient_lt</a> is very useful!</p>",
        "id": 425780427,
        "sender_full_name": "Chris Wong",
        "timestamp": 1710083143
    }
]