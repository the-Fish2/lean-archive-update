[
    {
        "content": "<p>In the context of <a href=\"https://github.com/leanprover-community/mathlib4/pull/13348\">#13348</a> (which adds the statement that an equivalence of monoids preserves the orders of elements), I was idly wondering whether it might be possible to formalize the \"meta-theorem\" that (say) monoid isomorphisms preserve monoid properties. I.e., something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">MulEquiv</span><span class=\"bp\">.</span><span class=\"n\">preserves</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≃*</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">orderOf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">orderOf</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">preserves</span><span class=\"w\"> </span><span class=\"n\">orderOf</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>(One small problem seems to be that <code>f</code> cannot be universe polymorphic: replacing <code>Type u</code> by <code>Type*</code> gives something that does not typecheck.)</p>\n<p>Is there any chance something like this is actually provable in Lean? The informal argument is roughly that <code>f</code> has access only to the monoid structure of <code>M</code> and so anything <code>f</code> does can be transported to <code>M'</code> via <code>e</code>. But this sounds like it would require some sort of \"induction over the structure of <code>f</code>\",  which I have a feeling we cannot really do...</p>",
        "id": 441296310,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717008342
    },
    {
        "content": "<p>besides the universe problem, i think it might be the case that this formulation of <code>MulEquiv.preserves</code> doesn't work? because you could imagine a property <code>f : Type u -&gt; ... -&gt; Fin 2</code> where <code>@f x _ _ = if x = A then 1 else 0</code> for some specific type <code>A</code>. in other words, a property of type <code>{M:Type u} -&gt; [Monoid M] -&gt; M -&gt; a</code> can look at more things than just the monoid properties. Even when looking more general, i think this kind of lemma only scarcely holds, if it isn't never. i think that for this, you generally need some kind of univalent foundations.</p>",
        "id": 441300519,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717010040
    },
    {
        "content": "<p>I would think <code>x = A</code> doesn't type-check when <code>A</code> is some fixed type. Can you produce a concrete example of an <code>f</code> that would lead to a contradiction?</p>",
        "id": 441300858,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717010164
    },
    {
        "content": "<p>If you have two 1-element types <code>A</code> and <code>B</code> that <em>you know are different</em>, then you can use <code>if M = A then [map the element to true] else to false</code>.</p>",
        "id": 441301293,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717010366
    },
    {
        "content": "<p>Note that the \"you know are different\" is actually undecidable (and there are a few threads about this).</p>",
        "id": 441301337,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717010392
    },
    {
        "content": "<p>I was going to say something like this...</p>",
        "id": 441301409,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717010410
    },
    {
        "content": "<p>Anyway, I suspect that at best your lemma is undecidable.</p>",
        "id": 441301517,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717010464
    },
    {
        "content": "<p>well... you can always use classical for the decidability instance</p>",
        "id": 441301570,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717010489
    },
    {
        "content": "<p>What I had almost convinced myself of, when I had a similar thought about proving statements about a monoid and its opposite, is that you can probably write a metaprogram that writes the converted statement and attempts at converting the proof.  For every \"reasonable\" statement that you prove, this will work, but artificial things (that may not exist) will not work.</p>",
        "id": 441302055,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717010682
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">SemidirectProduct</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">CharP</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Ring</span><span class=\"bp\">.</span><span class=\"n\">Pi</span>\n\n<span class=\"c1\">-- variable (ι : Type*) (R : Type*) [Semiring R] (p:ℕ) [CharP R p] [Nonempty ι]</span>\n\n<span class=\"c1\">-- #synth AddMonoidWithOne (ι → R)</span>\n\n<span class=\"c1\">-- #check MulEquiv</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">stuff</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">propDecidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">stuff</span>\n</code></pre></div>\n<p>this seems to work...</p>",
        "id": 441302288,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717010783
    },
    {
        "content": "<p>feel free to replace <code>Unit</code> with <code>Nat</code> or anything else you might want</p>",
        "id": 441302401,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717010845
    },
    {
        "content": "<p>Yes, but you still cannot use it to prove <code>False</code> using my lemma, because you cannot prove that some type is not equal to <code>Unit</code>.</p>",
        "id": 441302405,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717010849
    },
    {
        "content": "<p>I think Damiano is right about the undecidability. Maybe we can actually prove <em>that</em>? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 441302522,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717010890
    },
    {
        "content": "<p>ahhh.... i kind of assumed that equality of types is just defeq? or does that contradict stuff?</p>",
        "id": 441303146,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717011159
    },
    {
        "content": "<p>surely not?</p>",
        "id": 441303170,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717011171
    },
    {
        "content": "<p>What about replacing <code>M = Unit</code> by a genuinely undecidable statement?  E.g. if Peano arithmetic is consistent, then 1 else 0.</p>",
        "id": 441303200,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717011184
    },
    {
        "content": "<p>You cannot prove <code>Unit \\ne Fin 1</code>, for example.</p>",
        "id": 441303235,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717011204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441302522\">said</a>:</p>\n<blockquote>\n<p>I think Damiano is right about the undecidability. Maybe we can actually prove <em>that</em>? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>The proof is: there's a model whre it's true and a model where it's false.</p>",
        "id": 441303383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717011265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441303200\">said</a>:</p>\n<blockquote>\n<p>What about replacing <code>M = Unit</code> by a genuinely undecidable statement?  E.g. if Peano arithmetic is consistent, then 1 else 0.</p>\n</blockquote>\n<p>If it doesn't depend on <code>M</code>, it will not make the lemma false. In this case <code>f</code> will be constant (and one can prove that without needing to know what the constant is).</p>",
        "id": 441303388,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717011269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441303383\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441302522\">said</a>:</p>\n<blockquote>\n<p>I think Damiano is right about the undecidability. Maybe we can actually prove <em>that</em>? <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>The proof is: there's a model whre it's true and a model where it's false.</p>\n</blockquote>\n<p>Can you do it in Lean?</p>",
        "id": 441303446,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717011291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441302055\">said</a>:</p>\n<blockquote>\n<p>What I had almost convinced myself of, when I had a similar thought about proving statements about a monoid and its opposite, is that you can probably write a metaprogram that writes the converted statement and attempts at converting the proof.  For every \"reasonable\" statement that you prove, this will work, but artificial things (that may not exist) will not work.</p>\n</blockquote>\n<p>This is the <code>transfer</code> tactic which nobody ever wrote because on the rare occasion that this comes up, people just knock up the easy mathlib proof rather than writing a new tactic. Note that in a homotopy type theory prover they don't need this tactic because they can just <code>rw</code> (isomorphisms and equality are \"the same thing\"; things can be equal in more than one way, in contrast to Lean, so <code>rw</code> is more powerful).</p>",
        "id": 441303803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717011439
    },
    {
        "content": "<p>Coming back to the original question: is there a way of formalising the notion of a function that is a \"monoid property\" of monoid elements? Then there would be hope to be able to prove such a lemma for these functions. (And then one would need another proof that <code>orderOf</code> actually <em>is</em> a suitable function...)</p>",
        "id": 441303820,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717011448
    },
    {
        "content": "<p>I think that you can't write a Lean predicate for \"monoid property\" but you can write a metaprogram which attempts to check this and which would work for the kinds of inputs which we want in practice (and hence you can write a <code>transfer</code> tactic, although the issue is that it would take far longer than just writing the code of the kind Eric wrote in the other thread).</p>",
        "id": 441303981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717011505
    },
    {
        "content": "<p>this statement that the function can be lifted is Precisely what you want.</p>",
        "id": 441304032,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717011535
    },
    {
        "content": "<p>or at least, my intuition tells me so, i could be wrong</p>",
        "id": 441304079,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1717011562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110193\">Cyril Cohen</span> spoke at LftCM 2024 about transfer without univalence. I don't think it was recorded, but here is the <a href=\"https://www.cirm-math.fr/RepOrga/2970/Abstracts/cohen.pdf\">abstract</a></p>",
        "id": 441304999,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1717011965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441303981\">said</a>:</p>\n<blockquote>\n<p>I think that you can't write a Lean predicate for \"monoid property\"</p>\n</blockquote>\n<p>One could perhaps produce an inductive type <code>MonoidProperty</code> (that captures the idea of an expression only involving the monoid structure and the given element, plus logic etc.) with a <code>FunLike</code> instance. This would allow to prove the lemma by induction on <code>MonoidProperty</code>.<br>\n Then one could construct a  term<code>orderOf' : MonoidProperty</code> and show that <code>⇑orderOf' = orderOf</code>.</p>",
        "id": 441305000,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1717011965
    },
    {
        "content": "<p>Here is the <a href=\"https://arxiv.org/abs/2310.14022\">associated paper</a></p>",
        "id": 441305100,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1717012031
    },
    {
        "content": "<p>I think this is more about transferring between different inductive types that are equivalent, but it may be applicable here too. (Perhaps not, I have not thought much about it since he spoke.)</p>",
        "id": 441305381,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1717012196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441302405\">said</a>:</p>\n<blockquote>\n<p>I think Damiano is right about the undecidability. Maybe we can actually prove <em>that</em>?</p>\n</blockquote>\n<p>Yes, it is undecidable. The only way to prove that two types aren't equal is by cardinality. But here your two types are the same because e : M ≃* M'` forces them to be the same size.</p>",
        "id": 441315037,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717015823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Equivalences.20preserve.20properties/near/441303803\">said</a>:</p>\n<blockquote>\n<p>This is the <code>transfer</code> tactic which nobody ever wrote</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> wrote it, but it hasn't yet made it to mathlib</p>",
        "id": 441315094,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1717015849
    },
    {
        "content": "<p>I wrote a partial prototype with Jake Levinson (and a different, not so good prototype separately back in Lean 3) back in 2023. It was not at all ready to go.</p>",
        "id": 441400837,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1717054733
    },
    {
        "content": "<p>I could find the branch if someone wanted to try playing with it further, but I won't be doing this.</p>",
        "id": 441400993,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1717054802
    },
    {
        "content": "<p>I think a Lean port of <code>trocq</code> (the Rocq tactic that Jireh mentioned that Cyril presented at CIRM) would be really nice.</p>",
        "id": 441403321,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1717055760
    },
    {
        "content": "<p>ping <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 441407385,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1717057396
    }
]