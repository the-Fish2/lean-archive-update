[
    {
        "content": "<p>I want to understand how to do a basic construction on lean4. <br>\nGiven a semigroup M, it is defined that an element m is regular if multiplication by m is injective on both sides. The set of regular elements forms a subsemigroup. But if the semigroup M is a monoid, then it is a submonoid (i.e. it contains 1). So if one defines Regulars M as this subsemigroup, how can I say to lean4 that if M is a monoid, then Regulars M is a submonoid? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Submonoid.Membership</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Regulars</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Semigroup</span> <span class=\"n\">M</span><span class=\"o\">]:</span> <span class=\"n\">Subsemigroup</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">IsRegular</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"n\">ra</span> <span class=\"n\">rb</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"n\">IsLeftRegular.mul</span> <span class=\"n\">ra.left</span> <span class=\"n\">rb.left</span><span class=\"o\">,</span><span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"n\">IsRightRegular.mul</span> <span class=\"n\">ra.right</span> <span class=\"n\">rb.right</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Regulars_one</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Monoid</span> <span class=\"n\">M</span><span class=\"o\">]:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">Regulars</span> <span class=\"n\">M</span><span class=\"o\">:=</span> <span class=\"n\">isRegular_one</span>\n</code></pre></div>",
        "id": 411405264,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704475684
    },
    {
        "content": "<p>The idiomatic way is probably to define a separate</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Submonoid.regulars</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n  <span class=\"n\">__</span> <span class=\"o\">:=</span> <span class=\"n\">SubSemigroup.regulars</span> <span class=\"n\">M</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"n\">isRegular_one</span>\n</code></pre></div>",
        "id": 411407782,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704476866
    },
    {
        "content": "<p>Thanks. By the way, do you think it is better to call them Regulars, Cancellables, or any other option...</p>",
        "id": 411408452,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704477176
    },
    {
        "content": "<p>It's already called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsRegular#doc\">docs#IsRegular</a> in mathlib</p>",
        "id": 411410251,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1704477850
    },
    {
        "content": "<p>I think <code>Regulars</code> is good enough as it mirrors the naming convention of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit#doc\">docs#IsUnit</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a>.</p>",
        "id": 411411240,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704478291
    },
    {
        "content": "<p>But  IsRegular is a property of the elements of a set with a multiplication, and here we are considering the set of all elements verifying this property (as a subsemigroup). That is why I suggest \"Regulars\", in the same way the subgroup of elements verifying IsUnit is called Units</p>",
        "id": 411411258,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704478300
    },
    {
        "content": "<p>Hmmm. The corresponding thing is actually called <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsUnit.submonoid#doc\">docs#IsUnit.submonoid</a> though.</p>",
        "id": 411411424,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1704478375
    },
    {
        "content": "<p>Part of the reason for this distinction is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a> carries extra data around (the inverse of each element).</p>",
        "id": 411412143,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1704478694
    },
    {
        "content": "<p>So <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Units#doc\">docs#Units</a> is actually <em>not</em> a subtype of the monoid from whence it came.</p>",
        "id": 411412333,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1704478789
    },
    {
        "content": "<p>Also, this is slightly different, but closely related: we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RegularNormedAlgebra#doc\">docs#RegularNormedAlgebra</a></p>",
        "id": 411414513,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1704479696
    },
    {
        "content": "<p>Then, what it is different is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nonZeroDivisors#doc\">docs#nonZeroDivisors</a> (although it is true there is no <code>IsnonZeroDivisor</code>).</p>",
        "id": 411419300,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704482037
    },
    {
        "content": "<p>So at the end probably the best option is <code>IsRegular.subsemigroup</code> and <code>IsRegular.submonoid</code> (and their Left and Right avatars also...). And may be the Add versions. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 411419676,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704482232
    },
    {
        "content": "<p>By the way, with all these I can show the following result that I think it will be interesting to have in Mathlib, that characterizes when the localization map is injective (for monoids).  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Submonoid.LocalizationMap.injective_iff</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>  <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommMonoid</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Submonoid.LocalizationMap</span> <span class=\"n\">M</span> <span class=\"n\">S</span><span class=\"o\">):</span>\n    <span class=\"o\">(</span> <span class=\"n\">M</span> <span class=\"bp\">≤</span> <span class=\"n\">IsLeftRegular.submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>  <span class=\"n\">Injective</span> <span class=\"o\">(</span><span class=\"n\">Submonoid.LocalizationMap.toMap</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 411420692,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704482729
    },
    {
        "content": "<p>Honestly I think you should just have one <code>Regulars</code> type and write more and more instances on it. Subobjects are only useful for the small amount of API they provide, like \"a submonoid is closed under finite products\".</p>",
        "id": 411436025,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704490485
    },
    {
        "content": "<p>See eg <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=UpperSet#doc\">docs#UpperSet</a> for this design</p>",
        "id": 411436068,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704490515
    },
    {
        "content": "<p>I don't really understand the design you propose. In my example,  how it will be?</p>",
        "id": 411486877,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704529241
    },
    {
        "content": "<p>Something like <code>Injective (Submonoid.LocalizationMap.toMap f ↔ ∀ ⦃x⦄, x ∈ M → IsLeftRegular x</code></p>",
        "id": 411487227,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704529585
    },
    {
        "content": "<p>That's clearly a simpler result. But we will need some <code>Regulars</code> as a <code>Submonoid</code> if in the future we would like to have something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FractionRing#doc\">docs#FractionRing</a> for <code>CommSemirings</code>, as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FractionSemiring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]:=</span>\n  <span class=\"n\">Localization</span> <span class=\"o\">(</span><span class=\"n\">Regulars</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 411503827,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704543506
    },
    {
        "content": "<p>I made the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/9531\">#9531</a> with the Injective_iff result for Monoids, as well as some result generalizing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsLocalization.isDomain_localization#doc\">docs#IsLocalization.isDomain_localization</a> to MonoidsWithZero. If somebody likes to review or criticize (it is my first real proof in Mathlib4).</p>",
        "id": 411629558,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704658839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315546\">Xavier Xarles</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Regular.20Elements/near/411503827\">said</a>:</p>\n<blockquote>\n<p>That's clearly a simpler result. But we will need some <code>Regulars</code> as a <code>Submonoid</code> if in the future we would like to have something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FractionRing#doc\">docs#FractionRing</a> for <code>CommSemirings</code>, as </p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">FractionSemiring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommSemiring</span> <span class=\"n\">R</span><span class=\"o\">]:=</span>\n  <span class=\"n\">Localization</span> <span class=\"o\">(</span><span class=\"n\">Regulars</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That's typically the use-cases for <code>Regulars</code> bundled as a submonoid. But as you see it's used inside a definition and should basically rarely (if ever) leak out.</p>",
        "id": 411629658,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1704658949
    },
    {
        "content": "<p>Anyway, I still don't understand how to define <code>Regulars</code> (in a <code>Semigroup</code>) giving a <code>Subsemigroup</code>, and then be able to have instances in <code>Monoid</code>, for example, as <code>Submonoid</code>.</p>",
        "id": 411630104,
        "sender_full_name": "Xavier Xarles",
        "timestamp": 1704659469
    },
    {
        "content": "<p><del>You can actually define it as a Subsemigroup but give it a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SubmonoidClass#doc\">docs#SubmonoidClass</a> instance when in a Monoid, and submonoid lemmas will apply to it. You will get a Monoid structure on the coerced type too, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SubmonoidClass.toMonoid#doc\">docs#SubmonoidClass.toMonoid</a>.</del> Nope, that doesn't work, unless every subsemigroup in a monoid contains 1, which is not the case ...</p>",
        "id": 411879102,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1704785328
    }
]