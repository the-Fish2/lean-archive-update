[
    {
        "content": "<p>In the FLT project we seem to need that an abelian group is flat as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-module iff it's torsionfree. I guess flat =&gt; tf is true for general <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, and I guess the other way will be true for PIDs or something, but I couldn't find either of these things and so I thought I'd try and get my hands dirty and learn about flatness in Lean. Here's what looks to me like a rather poor effort to prove the key fact that multiplication by a nonzerodivisor is injective for a flat module:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">nonZeroDivisors</span><span class=\"w\"> </span><span class=\"n\">TensorProduct</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Is this even stated correctly? Do we have (r • _) as an R-linear map from M to M?</span>\n\n<span class=\"sd\">/-- Multiplication by a nonzerodivisor is injective on a flat module. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">smul_injective_of_flat</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"bp\">⁰</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- closest I could find: the corresponding map `R ⊗[R] M →ₗ[R] R ⊗[R] M` is injective</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"bp\">.</span><span class=\"n\">rTensor_preserves_injective_linearMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">toSpanSingleton</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">injective_iff_map_eq_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">toSpanSingleton</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now muddle through</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">lid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap</span><span class=\"w\"> </span><span class=\"bp\">∘ₗ</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">rTensor</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">toSpanSingleton</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∘ₗ</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">lid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LinearEquiv</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Do we have any of this stuff already? Is the proof supposed to look so awful?</p>",
        "id": 441443166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717070820
    },
    {
        "content": "<p>Without looking deep into this, I think that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSMulRegular#doc\">docs#IsSMulRegular</a> may be a thing?</p>",
        "id": 441443520,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717070969
    },
    {
        "content": "<p>(I had introduced the \"regular-mul\" version to talk about regular sequences, so \"smul-regular\" should be some API for flatness.)</p>",
        "id": 441443694,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717071041
    },
    {
        "content": "<p>Nice! No mention of flatness in <code>Mathlib/Algebra/Regular/*</code> but at least it gives me a nicer way of stating it.</p>",
        "id": 441443900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717071122
    },
    {
        "content": "<p>No, even the IsRegular --&gt; regular sequences is probably underdeveloped, but I feel like this could be a \"principled starting point\".</p>",
        "id": 441444025,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717071187
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>The defining property is that an element `a ∈ R` is `M`-regular if the smultiplication map\n`M → M`, defined by `m ↦ a • m`, is injective.\n</code></pre></div>\n<p>\"smultiplication\" :-)</p>",
        "id": 441444125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717071230
    },
    {
        "content": "<p>And you could probably get for free results about products of smul-regular elements, trivialities about 0 and units...</p>",
        "id": 441444136,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1717071233
    },
    {
        "content": "<p>So the statement can be rewritten as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isSMulRegular_of_flat</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"bp\">⁰</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSMulRegular</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>",
        "id": 441444643,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1717071384
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110401\">@Brendan Seamas Murphy</span> recently did a lot on regular sequences. Maybe Brendan has something close?</p>",
        "id": 441444764,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717071425
    },
    {
        "content": "<p>One option is to use the equational criterion for flatness (<a href=\"https://github.com/leanprover-community/mathlib4/pull/12666\">#12666</a>).</p>",
        "id": 441478008,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1717081475
    },
    {
        "content": "<p>I'm not sure if that's actually easier than what you did though</p>",
        "id": 441478769,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1717081642
    },
    {
        "content": "<p>I don't think this has come up for me? I have a currently open (edit: but failing to build, oops) PR which includes the fact that tensoring with a flat module preserves regularity, which is close to this result</p>",
        "id": 441501002,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717086504
    },
    {
        "content": "<p>And lemmas that let you transport regularity across a linear equivalence</p>",
        "id": 441502000,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717086749
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lTensor</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSMulRegular</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsSMulRegular</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">lTensor_smul_action</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M'</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"bp\">.</span><span class=\"n\">lTensor_preserves_injective_linearMap</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and see Equiv.isSMulRegular_congr (already in mathlib)</p>",
        "id": 441502788,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717086965
    },
    {
        "content": "<p>What proof did you end up using?</p>",
        "id": 443172284,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717712970
    },
    {
        "content": "<p>If it hasn't been finished yet, here's a proof</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">nonZeroDivisors</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">IsSMulRegular</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isSMulRegular_of_flat</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"bp\">⁰</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Flat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsSMulRegular</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">((</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">rid</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSMulRegular_congr</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">lTensor</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">isSMulRegular_of_smul_eq_zero_imp_eq_zero</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul_comm</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 443180708,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717716727
    },
    {
        "content": "<p>The <code>open IsSMulRegular in</code> is due to some poor choices in namespacing by me in a recent PR that is fixed in <a href=\"https://github.com/leanprover-community/mathlib4/pull/13582\">#13582</a></p>\n<p>The anonymous function here is necessary because we don't have an existing lemma that says a non zero divisor, meaning a right non zero divisor, is a non smul zero divisor in a commutative ring. Why is <code>nonZeroDivisors</code> defined as right non zero divisors? I thought mathlib convention was to have things on the left by default</p>",
        "id": 443181796,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1717717517
    },
    {
        "content": "<p>TBH <code>nonZeroDivisors</code> should be the intersection of left and right.</p>",
        "id": 443182469,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1717717969
    }
]