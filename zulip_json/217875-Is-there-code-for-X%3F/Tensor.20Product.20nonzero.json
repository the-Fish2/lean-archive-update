[
    {
        "content": "<p>I am trying to prove the following lemma: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Algebra.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tmul_nonzero_of_nonzero</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)(</span><span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Does anyone know if this is done in Mathlib?</p>",
        "id": 423411306,
        "sender_full_name": "Elena Gutierrez",
        "timestamp": 1708958832
    },
    {
        "content": "<p>What's the math proof?</p>",
        "id": 423413103,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708959313
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.tensorProduct#doc\">docs#Basis.tensorProduct</a>, so morally we have something much stronger, and even if the literal result is not there it shouldn't be hard.</p>",
        "id": 423416881,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708960292
    },
    {
        "content": "<p>Sorry, this was nonsense.</p>",
        "id": 423417457,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708960455
    },
    {
        "content": "<p>This works, but it's probably not the best proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tmul_nonzero_of_nonzero</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.TensorProduct.basisAux</span> <span class=\"n\">ℝ</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Algebra.TensorProduct.basisAux_tmul</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Finsupp.mapRange</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b.repr</span> <span class=\"n\">x</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Finsupp.support_mapRange_of_injective</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b.repr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">algebraMap</span> <span class=\"n\">ℚ</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finsupp.support_eq_empty</span><span class=\"o\">,</span> <span class=\"n\">AddEquivClass.map_eq_zero_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx</span> <span class=\"n\">H</span>\n</code></pre></div>",
        "id": 423426796,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708962947
    },
    {
        "content": "<p>Ah, this is the proof I was thinking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tmul_nonzero_of_nonzero</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span>\n  <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.TensorProduct.basis</span> <span class=\"n\">ℝ</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hx</span>\n  <span class=\"n\">exact</span> <span class=\"n\">b.forall_coord_eq_zero_iff.1</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">B.forall_coord_eq_zero_iff.2</span> <span class=\"n\">h</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 423428237,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708963330
    },
    {
        "content": "<p>Essentially I introduce a <code>ℚ</code>-basis <code>b</code> of <code>V</code>, that gives an <code>ℝ</code>-basis <code>B</code> of <code>ℝ ⊗ V</code>. Now, <code>simp</code> is smart enough to understand that the coordinates of <code>1 ⊗ x</code> satisfy the obvious relation, so we can conclude.</p>",
        "id": 423428589,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708963445
    },
    {
        "content": "<p>Here is a general version.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tmul_nonzero_of_nonzero</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nontrivial</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NoZeroSMulDivisors</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.TensorProduct.basis</span> <span class=\"n\">S</span> <span class=\"n\">b</span>\n  <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"n\">hx</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">b.forall_coord_eq_zero_iff.1</span>  <span class=\"bp\">&lt;|</span>\n    <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"n\">NoZeroSMulDivisors.algebraMap_injective</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">B.forall_coord_eq_zero_iff.2</span> <span class=\"n\">h</span> <span class=\"n\">i</span>\n</code></pre></div>\n<p>I don't  think that mathematically it is possible to do better.</p>",
        "id": 423431167,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708964131
    },
    {
        "content": "<p>Or maybe mathlib wants:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">one_tmul_injective</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Nontrivial</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n    <span class=\"o\">[</span><span class=\"n\">NoZeroSMulDivisors</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module.Free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Function.Injective</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span>\n  <span class=\"k\">have</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n  <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.TensorProduct.basis</span> <span class=\"n\">S</span> <span class=\"n\">b</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">b.ext_elem_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">B.ext_elem_iff</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">NoZeroSMulDivisors.algebraMap_injective</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eq_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 423441708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708966681
    },
    {
        "content": "<p>Is negation needed to make this true?</p>",
        "id": 423441772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708966686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423441772\">said</a>:</p>\n<blockquote>\n<p>Is negation needed to make this true?</p>\n</blockquote>\n<p>I don't think so. Using semirings in <code>Algebra.TensorProduct.basis</code> seems fine without any modification.</p>",
        "id": 423443240,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708967054
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10988\">#10988</a></p>",
        "id": 423444490,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708967399
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NoZeroSMulDivisors.algebraMap_injective#doc\">docs#NoZeroSMulDivisors.algebraMap_injective</a> isn't generalized either</p>",
        "id": 423446410,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708967905
    },
    {
        "content": "<p>Probably we need a SMul version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsCancelMulZero#doc\">docs#IsCancelMulZero</a></p>",
        "id": 423446620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708967961
    },
    {
        "content": "<p>Yes, that one is probably false.</p>",
        "id": 423447500,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708968169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423428237\">ha dicho</a>:</p>\n<blockquote>\n<p>Ah, this is the proof I was thinking:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tmul_nonzero_of_nonzero</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℚ</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">Module.Free.chooseBasis</span> <span class=\"n\">ℚ</span> <span class=\"n\">V</span>\n  <span class=\"k\">let</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"n\">Algebra.TensorProduct.basis</span> <span class=\"n\">ℝ</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hx</span>\n  <span class=\"n\">exact</span> <span class=\"n\">b.forall_coord_eq_zero_iff.1</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">B.forall_coord_eq_zero_iff.2</span> <span class=\"n\">h</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thank you so much!!</p>",
        "id": 423459425,
        "sender_full_name": "Elena Gutierrez",
        "timestamp": 1708972292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423413103\">said</a>:</p>\n<blockquote>\n<p>What's the math proof?</p>\n</blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is flat over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>.</p>",
        "id": 423460262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708972582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423460262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423413103\">said</a>:</p>\n<blockquote>\n<p>What's the math proof?</p>\n</blockquote>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is flat over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>.</p>\n</blockquote>\n<p>You mean faithfully flat? Flatness is not enough (the vanishing of <code>1 ⊗ x</code> doesn't tell you anything at primes not in the image of the map between the Spec)</p>",
        "id": 423464776,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708974266
    },
    {
        "content": "<p>It preserves the injection from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> sending 1 to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\"application/x-tex\">v</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span></span></span></span> so flatness is enough, no?</p>",
        "id": 423480130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708980180
    },
    {
        "content": "<p>Ah, you mean that the module is flat, not <code>ℝ</code>.<br>\nI mean, <code>ℚ</code> is a flat <code>ℤ</code>-module, but taking <code>M = ℤ/2ℤ</code> you have <code>x ∈ M</code> different from <code>0</code> such that <code>1 ⊗ x = 0 ∈ M ⊗ ℚ</code>.</p>",
        "id": 423480386,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708980303
    },
    {
        "content": "<p>Right but there the map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> isn't injective, so yeah I need that too :-)</p>",
        "id": 423480689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708980436
    },
    {
        "content": "<p>The thing is the following: we have a <code>R</code>-algebra <code>S</code> and an <code>R</code>-module <code>M</code> with <code>0 ≠ x ∈ M</code>. When is <code>x ⊗ 1 ∈ M ⊗ S ≠ 0</code>? I see two situation:</p>\n<ul>\n<li><code>R → S</code> is faithfully flat (I have to check the details, but it seems ok)</li>\n<li><code>M</code> is flat as <code>R</code>-module and <code>R → S</code> is injective (tensor <code>R → S</code> with <code>M</code>).</li>\n</ul>",
        "id": 423480995,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708980571
    },
    {
        "content": "<p>Yes you're right -- I meant the second one. I guess both conditions are implied by R is a field and S is nonzero, which is what we have here</p>",
        "id": 423481181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708980646
    },
    {
        "content": "<p>The first point holds since faithfully flat morphisms are universally injective, so, tensoring <code>R → S</code> (that is injective) with <code>M</code> we get an injective map (regardless of flatness of <code>M</code>).</p>",
        "id": 423482105,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1708981037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423460262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Tensor.20Product.20nonzero/near/423413103\">said</a>:</p>\n<blockquote>\n<p>What's the math proof?</p>\n</blockquote>\n<p>$\\mathbb{R}$ is flat over $\\mathbb{Q}$.</p>\n</blockquote>\n<p>How do you prove this without knowing that vector spaces gave bases and essentially doing Riccardo's proof?</p>",
        "id": 423542910,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1709016800
    },
    {
        "content": "<p>I was answering Eric's question, which was asked before Ricardo's contribution :-) (but I agree!)</p>",
        "id": 423555784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1709023049
    }
]