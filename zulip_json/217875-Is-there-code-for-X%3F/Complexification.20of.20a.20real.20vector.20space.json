[
    {
        "content": "<p>I assume this (Exercise 1B Problem 7) from Axler's Linear Algebra is a one liner in Mathlib, but what one liner is it?</p>\n<blockquote>\n<p>Suppose 𝑉 is a real vector space.<br>\n• The complexification of 𝑉, denoted by 𝑉𝐂 , equals 𝑉 × 𝑉. An element of<br>\n𝑉𝐂 is an ordered pair( 𝑢,𝑣),where𝑢,𝑣 ∈ 𝑉, but we write this as 𝑢+𝑖𝑣.<br>\n• Addition on 𝑉𝐂 is defined by<br>\n(𝑢1 +𝑖𝑣1)+(𝑢2 +𝑖𝑣2) = (𝑢1 +𝑢2)+𝑖(𝑣1 +𝑣2) for all 𝑢1,𝑣1,𝑢2,𝑣2 ∈𝑉.<br>\n• Complex scalar multiplication on 𝑉𝐂 is defined by (𝑎+𝑏𝑖)(𝑢+𝑖𝑣) = (𝑎𝑢−𝑏𝑣)+𝑖(𝑎𝑣+𝑏𝑢)<br>\nfor all 𝑎, 𝑏 ∈ 𝐑 and all 𝑢, 𝑣 ∈ 𝑉.<br>\nProve that with the definitions of addition and scalar multiplication as above,<br>\n𝑉𝐂 is a complex vector space.</p>\n</blockquote>",
        "id": 407787357,
        "sender_full_name": "Arien Malec",
        "timestamp": 1702492204
    },
    {
        "content": "<p>This will be done with the tensor product in mathlib</p>",
        "id": 407790240,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702493312
    },
    {
        "content": "<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"n\">TensorProduct</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>?</p>",
        "id": 407795536,
        "sender_full_name": "Arien Malec",
        "timestamp": 1702495604
    },
    {
        "content": "<p>No, more like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Module</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 407801610,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702498036
    },
    {
        "content": "<p>You can then prove your first bullet point as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prodEquivComplexTensor</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">≃</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the second one as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">smul_def</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">c</span> <span class=\"bp\">•</span> <span class=\"n\">prodEquivComplexTensor</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">prodEquivComplexTensor</span> <span class=\"o\">(</span><span class=\"n\">c.re</span> <span class=\"bp\">•</span> <span class=\"n\">a.1</span> <span class=\"bp\">-</span> <span class=\"n\">c.im</span> <span class=\"bp\">•</span> <span class=\"n\">a.2</span><span class=\"o\">,</span> <span class=\"n\">c.re</span> <span class=\"bp\">•</span> <span class=\"n\">a.1</span> <span class=\"bp\">+</span> <span class=\"n\">c.im</span> <span class=\"bp\">•</span> <span class=\"n\">a.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 407802343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702498326
    },
    {
        "content": "<p>I've been beating my head against the first theorem without seeing any cracks in the armor -- any Mathlib theorems that simply or open  up the proof.</p>",
        "id": 408400639,
        "sender_full_name": "Arien Malec",
        "timestamp": 1702781887
    },
    {
        "content": "<p><code>TensorProduct.prodLeft</code> or <code>TensorProduct.prodRight</code> should help.</p>",
        "id": 408403246,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702784142
    },
    {
        "content": "<p>I'm having trouble getting the right types in place.... <code>prodLeft</code> wants to distribute a product over a tensor product.</p>",
        "id": 408407764,
        "sender_full_name": "Arien Malec",
        "timestamp": 1702788366
    },
    {
        "content": "<p>Can you show <code>ℂ ≃ₗ[R] (ℝ × ℝ)</code>? (It's hard to guess exactly how far you've got.)</p>",
        "id": 408409291,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702789381
    },
    {
        "content": "<p>huh... Nice idea...</p>",
        "id": 408409323,
        "sender_full_name": "Arien Malec",
        "timestamp": 1702789432
    },
    {
        "content": "<p>You can assume that I've been searching for relating things in Mathlib and trying to see if I can find a chain of structural decomposition to force fit.</p>",
        "id": 408409417,
        "sender_full_name": "Arien Malec",
        "timestamp": 1702789510
    },
    {
        "content": "<p>Then there's <code>TensorProduct.rid</code> and <code>TensorProduct.lid</code>.</p>",
        "id": 408409644,
        "sender_full_name": "Richard Copley",
        "timestamp": 1702789721
    },
    {
        "content": "<p>OK, coming back to this, I've done the brute force approach that Axler is looking for, by making a structure <code>Vc</code> with addition and multiplication as designated, and showing that it's a complex vector space.</p>\n<p>(btw, when I look at introductions to complexification, the order of the tensor product is opposite to the <code>(ℂ ⊗[ℝ] V)</code> but rather <code>(V ⊗[ℝ] ℂ)</code>?)</p>\n<p>The more mathy flavor of this is still beyond me. I think what <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  is asking me for as a definition is the full <code>Equiv</code> structure? And I <em>think</em> we do this by mapping <code>(fst,snd) = (1 ⊗[ℝ] fst) + (i ⊗[ℝ] snd)</code> or something like that? And <code>v ⊗[ℝ] ⟨re, im⟩</code> to <code>(re • v, im • v)</code> or ???</p>\n<p>I'm not even sure that's the right track, but if it is, I don't know the syntax to make it work?</p>",
        "id": 422038090,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708199399
    },
    {
        "content": "<p>(current code at <a href=\"https://github.com/arienmalec/axler\">https://github.com/arienmalec/axler</a>)</p>",
        "id": 422038178,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708199463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422038090\">said</a>:</p>\n<blockquote>\n<p>(btw, when I look at introductions to complexification, the order of the tensor product is opposite to the <code>(ℂ ⊗[ℝ] V)</code> but rather <code>(V ⊗[ℝ] ℂ)</code>?)</p>\n</blockquote>\n<p>in mathlib <code>V ⊗[ℝ] ℂ</code> is not a <code>ℂ</code>-module, but <code>ℂ ⊗[ℝ] V</code> is. We can't have both without instance diamonds, and we picked the one that uses left-actions</p>",
        "id": 422043731,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708205035
    },
    {
        "content": "<p>Hopefully you can work out how to define the forward mapping. The trick with the reverse mapping is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.lift#doc\">docs#TensorProduct.lift</a></p>",
        "id": 422043796,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708205086
    },
    {
        "content": "<p>I think I figured out the forward mapping, but I'm swimming in a sea of notation.  Like the difference between <code>⊗ₜ[ℝ]</code> and <code>⊗[ℝ]</code> where the first is \"The canonical function M → N → M ⊗ N.\"</p>",
        "id": 422046597,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708208008
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">toFun</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span>  <span class=\"o\">⟨</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span>  <span class=\"o\">(⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">fst</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">⟩</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">snd</span>\n</code></pre></div>",
        "id": 422046610,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708208025
    },
    {
        "content": "<p>Arien, are you familiar with tensor products mathematically, aside from Lean?</p>\n<p>The first one creates <em>elementary tensors</em>. The second one forms the tensor product of two modules, and this is spanned by elementary tensors.</p>",
        "id": 422046825,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708208228
    },
    {
        "content": "<p>The difference between <code>A ⊗[ℝ] B</code> and <code>a ⊗ₜ[ℝ] b</code> is like the difference between <code>α × β</code> and  <code>(a, b)</code></p>",
        "id": 422046827,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708208229
    },
    {
        "content": "<p>Note that for <code>⊗ₜ</code> you can almost always drop the <code>[R]</code> too</p>",
        "id": 422046864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708208272
    },
    {
        "content": "<p>(with the key distinction that <em>unlike</em> <code>Prod</code>, not every element can be written this way)</p>",
        "id": 422046876,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1708208282
    },
    {
        "content": "<p>(and also unlike Prod, there is usually more than one way to write the same element)</p>",
        "id": 422046935,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708208329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422046825\">said</a>:</p>\n<blockquote>\n<p>Arien, are you familiar with tensor products mathematically, aside from Lean?</p>\n<p>The first one creates <em>elementary tensors</em>. The second one forms the tensor product of two modules, and this is spanned by elementary tensors.</p>\n</blockquote>\n<p>Not at any level of detail, which is certainly part of the issue here. So elementary tensors are to tensor products as vectors are to vector spaces?</p>",
        "id": 422047199,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708208641
    },
    {
        "content": "<p>I think a mildly better analogy is \"as <em>basis</em> vectors are to vectors spaces\"; not every vector is a basis vector, just as not every tensor is elementary</p>",
        "id": 422047265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708208688
    },
    {
        "content": "<p>It may also help to know that a tensor product of vector spaces has as a basis the elementary tensors of the bases of the spaces; if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a basis for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a basis for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub><mo>⊗</mo><msub><mi>f</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">e_i \\otimes f_j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9805em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> (note: two indices!) is a basis for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>⊗</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\otimes F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.</p>",
        "id": 422047389,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708208823
    },
    {
        "content": "<p>Some syntax help, please --</p>\n<p>Following the hint, I got to: <code>invFun tp := TensorProduct.lift liftFun tp</code> where the type signature for <code>liftFun</code> is <code>ℂ →ₗ[ℝ] V →ₗ[ℝ] (V × V)</code>, and I think it wants to take a complex number and a vector, and produce a <code>Prod</code> in the form of the <code>smul</code> definition above. But from a syntax perspective, when I write:</p>\n<p><code>def liftFun: ℂ →ₗ[ℝ] V →ₗ[ℝ] (V × V) where</code> the type of <code>toFun</code> wants to be <code>ℂ → V →ₗ[ℝ] V × V</code> not <code>ℂ → V → V × V</code> -- how do I write <code>liftFun</code> to be what I'm looking for?</p>\n<p>(or, of course, if I'm completely off track....)</p>",
        "id": 422124006,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708285963
    },
    {
        "content": "<p>(not sure how to get the unicode for R-linear maps to show up correctly.)</p>",
        "id": 422124113,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708286056
    },
    {
        "content": "<p>You probably want <code>LinearMap.mk\\_2</code></p>",
        "id": 422124695,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708286577
    },
    {
        "content": "<p>I think it would be easier to help you if you made a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 422124706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708286595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422124113\">said</a>:</p>\n<blockquote>\n<p>(not sure how to get the unicode for R-linear maps to show up correctly.)</p>\n</blockquote>\n<p>I think you're referring to an Android bug; it looks fine on desktop</p>",
        "id": 422124717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708286616
    },
    {
        "content": "<p>Firefox bug apparently.</p>\n<p>I seem to be missing an import somewhere, but hopefully this is close enough:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Module</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">toFun</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span>  <span class=\"o\">⟨</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">fst</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">⟩:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>  <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">snd</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">liftFun</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prodEquivComplexTensor</span><span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">≃</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">toFun</span> <span class=\"n\">p</span>\n  <span class=\"n\">invFun</span> <span class=\"n\">tp</span> <span class=\"o\">:=</span> <span class=\"n\">TensorProduct.lift</span> <span class=\"n\">liftFun</span> <span class=\"n\">tp</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 422126033,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708287751
    },
    {
        "content": "<p>Note that the final result is not as strong as the one you want to prove, and in fact you will find the stronger result easier!</p>",
        "id": 422126377,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708287982
    },
    {
        "content": "<p>You should be showing <code>(V × V) ≃ₗ[ℂ] (ℂ ⊗[ℝ] V)</code></p>",
        "id": 422126408,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708288021
    },
    {
        "content": "<p>And you will almost certainly want to do so with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.ofLinear#doc\">docs#LinearEquiv.ofLinear</a></p>",
        "id": 422126441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708288040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422126408\">said</a>:</p>\n<blockquote>\n<p>You should be showing <code>(V × V) ≃ₗ[ℂ] (ℂ ⊗[ℝ] V)</code></p>\n</blockquote>\n<p>Surely there is no <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>-module structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V\\times V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is a real vector space? You mean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>-linear?</p>",
        "id": 422134578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708295109
    },
    {
        "content": "<p>Arien your code is full of errors for me (on master and in the lean 4 playground). Are you missing some import/open/whatever?</p>",
        "id": 422134836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708295349
    },
    {
        "content": "<p>It's missing something but I'm not sure what. Perhaps a variable statement<br>\nearlier on in the file I extracted this from.</p>",
        "id": 422135564,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708296104
    },
    {
        "content": "<p>I'll try to track down what's missing and repost.</p>",
        "id": 422135671,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708296196
    },
    {
        "content": "<p><code>import Mathlib.Data.Complex.Module</code></p>",
        "id": 422136642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708297144
    },
    {
        "content": "<p>But note that <code>import Mathlib</code> is fine for most \"I can't work this out\" mwes</p>",
        "id": 422136652,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708297159
    },
    {
        "content": "<p>Reducing imports is only important for \"i think there is a bug\" mwes</p>",
        "id": 422136664,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708297176
    },
    {
        "content": "<p>Fixed the MWE</p>",
        "id": 422138063,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708298584
    },
    {
        "content": "<p>It would be fun, for certain values of fun, to work out the material in <a href=\"https://kconrad.math.uconn.edu/blurbs/linmultialg/complexification.pdf\">https://kconrad.math.uconn.edu/blurbs/linmultialg/complexification.pdf</a> in Mathlib...</p>",
        "id": 422138325,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708298842
    },
    {
        "content": "<p>I spent quite a lot of work on complexifying clifford algebras a few months ago</p>",
        "id": 422139460,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708299994
    },
    {
        "content": "<p>Note that in mathlib, \"complexification\" is usually called <code>baseChange</code></p>",
        "id": 422139493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708300051
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> \"baseChange\"</p>",
        "id": 422139570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708300108
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/TensorProduct/Tower.html#Submodule.baseChange\">Submodule.baseChange</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/TensorProduct/Tower.html#Submodule.baseChange_bot\">Submodule.baseChange_bot</a>, and <a href=\"https://loogle.lean-lang.org/?q=%22baseChange%22\">171 more</a></p>",
        "id": 422139572,
        "sender_full_name": "loogle",
        "timestamp": 1708300110
    },
    {
        "content": "<p>Mathlib makes hard things possible, and really easy things elegant and things in the middle are sometimes....</p>",
        "id": 422144265,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708304622
    },
    {
        "content": "<p>I've gotten to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Module</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">toFun</span><span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span>  <span class=\"o\">⟨</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">fst</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">Complex.I</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">snd</span>\n  <span class=\"n\">map_add'</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.tmul_add</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">abel_nf</span>\n  <span class=\"n\">map_smul'</span> <span class=\"n\">r</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.tmul_smul</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">invFun</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">tp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_add'</span> <span class=\"n\">tp1</span> <span class=\"n\">tp1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_smul'</span> <span class=\"n\">r</span> <span class=\"n\">tp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but the definition of <code>invFun</code> eludes me. In particular, if I had a complex number and a vector, I could create a <code>Prod</code> but I'm not sure how to get these \"out\" of the product, if I'm thinking about that the right way.</p>\n<p>Also, when I do <code>theorem toFun_invFun_comp: LinearMap.comp toFun invFun = LinearMap.id := by sorry</code> I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">AddCommMonoid</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.21022</span> <span class=\"bp\">×</span> <span class=\"bp\">?</span><span class=\"n\">m.21022</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which I assume means I need an instance for <code>V × V </code></p>",
        "id": 422302662,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708374469
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">invFun</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">TensorProduct.lift</span> <span class=\"o\">{</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span>\n    <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"o\">}</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 422303719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708374909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422124695\">said</a>:</p>\n<blockquote>\n<p>You probably want <code>LinearMap.mk\\_2</code></p>\n</blockquote>\n<p>This would work too</p>",
        "id": 422306872,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708376679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422302662\">said</a>:</p>\n<blockquote>\n<p>Also, when I do <code>theorem toFun_invFun_comp: LinearMap.comp toFun invFun = LinearMap.id := by sorry</code> I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">AddCommMonoid</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.21022</span> <span class=\"bp\">×</span> <span class=\"bp\">?</span><span class=\"n\">m.21022</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which I assume means I need an instance for <code>V × V </code></p>\n</blockquote>\n<p>Lean is confused because you never told it you were talking about <code>V</code></p>",
        "id": 422306930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708376726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422306872\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422124695\">said</a>:</p>\n<blockquote>\n<p>You probably want <code>LinearMap.mk\\_2</code></p>\n</blockquote>\n<p>This would work too</p>\n</blockquote>\n<p>I'm sure but <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  put the Don't Panic sticker on his.... (I looked at the sig for <code>mk_2</code> but didn't grok it :-))</p>",
        "id": 422307115,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708376854
    },
    {
        "content": "<p>It takes a two-argument function, and four proofs</p>",
        "id": 422307210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708376899
    },
    {
        "content": "<p>You could use <code>by apply LinearMap.mk2</code> to have Lean grok it for you :)</p>",
        "id": 422307255,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708376941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422306930\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422302662\">said</a>:</p>\n<blockquote>\n<p>Also, when I do <code>theorem toFun_invFun_comp: LinearMap.comp toFun invFun = LinearMap.id := by sorry</code> I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">AddCommMonoid</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.21022</span> <span class=\"bp\">×</span> <span class=\"bp\">?</span><span class=\"n\">m.21022</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>...</p>\n</blockquote>\n<p>Lean is confused because you never told it you were talking about <code>V</code></p>\n</blockquote>\n<p>Ah, <code>theorem toFun_invFun_comp: LinearMap.comp (@toFun V _ _) invFun = LinearMap.id := by sorry</code> fixes it.</p>",
        "id": 422307494,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708377080
    },
    {
        "content": "<p>Using <code>(V)</code> instead of <code>{V}</code> above would be another solution</p>",
        "id": 422307621,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708377164
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>mk\\2</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">invFun</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.lift</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">LinearMap.mk₂</span>\n  <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>\n</div></div>",
        "id": 422308014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1708377460
    },
    {
        "content": "<p>It turns out that works better -- the proofs for the plain <code>lift</code> version have complicated structures in them -- I'm sure there's a way around this, but this, despite the hackery, works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">invFun</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.lift</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">LinearMap.mk₂</span>\n  <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_smul</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">smul_add</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_comm</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 422309433,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708378340
    },
    {
        "content": "<p>Here's where I've gotten:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Module.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Complex.Module</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.TensorProduct</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"n\">Module</span> <span class=\"n\">ℂ</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">toFun</span><span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">p</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span>  <span class=\"o\">⟨</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">snd</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">fst</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">Complex.I</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">snd</span>\n  <span class=\"n\">map_add'</span> <span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.tmul_add</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">abel_nf</span>\n  <span class=\"n\">map_smul'</span> <span class=\"n\">r</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.tmul_smul</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">invFun</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.lift</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">LinearMap.mk₂</span>\n  <span class=\"n\">ℝ</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"n\">v</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_smul</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">smul_add</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">dsimp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_comm</span><span class=\"o\">])</span>\n\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toFun_invFun_comp_eq_id</span><span class=\"o\">:</span> <span class=\"n\">LinearMap.comp</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">toFun</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">invFun</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toFun</span><span class=\"o\">,</span> <span class=\"n\">invFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">z</span> <span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.tmul_add</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.smul_tmul</span><span class=\"o\">]</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">invFun_toFun_comp_eq_id</span><span class=\"o\">:</span> <span class=\"n\">LinearMap.comp</span> <span class=\"n\">invFun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">toFun</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">invFun</span><span class=\"o\">,</span> <span class=\"n\">toFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prodRLinearComplexTensor</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ℂ</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">LinearEquiv.ofLinear</span> <span class=\"n\">toFun</span> <span class=\"n\">invFun</span> <span class=\"n\">toFun_invFun_comp_eq_id</span> <span class=\"n\">invFun_toFun_comp_eq_id</span>\n</code></pre></div>\n<p>A few issues here:</p>\n<ol>\n<li>If I make the <code>{V}</code> explicit I get a world of hurt with errors like: <code>typeclass instance problem is stuck, it is often due to metavariables RingHomCompTriple ?m.31917 (RingHom.id ℝ) (RingHom.id ℝ)</code> and friends</li>\n<li>In <code>toFun_invFun_comp_eq_id</code> I get to a really nice goal state, but I can't get <code>rw [←TensorProduct.add_tmul (z.re • 1) (z.im • Complex.I) v]</code> to accept that the pattern exists; I've tried using <code>@</code> and getting super explicit, but been unable to get a non barf state.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">V</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝¹</span><span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">ℝ</span> <span class=\"n\">V</span>\n<span class=\"n\">z</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span>\n<span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">V</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">Complex.I</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>\n<p>The proof state for <code>invFun_toFun_comp_eq_id</code> by contrast is a real mess that I don't have a clue how to fix...</p>\n</li>\n<li>\n<p>Most concerning, in <code>prodRLinearComplexTensor</code> I get the error:</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">compiler</span> <span class=\"n\">IR</span> <span class=\"n\">check</span> <span class=\"n\">failed</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">prodRLinearComplexTensor._rarg'</span><span class=\"o\">,</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">toFun'</span>\n</code></pre></div>",
        "id": 422329821,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708392620
    },
    {
        "content": "<p>BTW, when I clear this thicket, is it going to be easy to use the proofs to do simple things like prove:</p>\n<p><code>def Rn_complexified_equiv {n: ℕ}: (ℂ ⊗[ℝ] (Fin n → ℝ)) ≃ₗ[ℝ] (Fin n → ℂ) := sorry</code></p>\n<p>?</p>",
        "id": 422330034,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708392834
    },
    {
        "content": "<p>1 is because you need to add a bunch of <code>V</code>s everywhere</p>",
        "id": 422338748,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708399662
    },
    {
        "content": "<p>I would guess your problem in 2 is that the operators don't have the parenthesization you think they do, and you need to start with an associativity lemma</p>",
        "id": 422338880,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708399777
    },
    {
        "content": "<p>4 is asking you to add <code>noncomputable</code></p>",
        "id": 422338950,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708399815
    },
    {
        "content": "<p>Regarding R^n; you will most likely have to do all the work again from scratch, but you should find it much easier once you know the tricks</p>",
        "id": 422338978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708399858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422338880\">said</a>:</p>\n<blockquote>\n<p>I would guess your problem in 2 is that the operators don't have the parenthesization you think they do, and you need to start with an associativity lemma</p>\n</blockquote>\n<p>I see -- the issue is that <code>z.re • 1 ⊗ₜ[ℝ] v</code> is seen as <code>z.re • (1 ⊗ₜ[ℝ] v)</code>?</p>",
        "id": 422339697,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708400464
    },
    {
        "content": "<p>If you hover over the goal view, vscode will tell you</p>",
        "id": 422339919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708400623
    },
    {
        "content": "<p>I'm afraid while I can remember many lemmas names, I am unreliable at remembering operator precedence</p>",
        "id": 422339979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708400658
    },
    {
        "content": "<p>It's <code>rfl</code> as it happens.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">toFun_invFun_comp_eq_id</span><span class=\"o\">:</span> <span class=\"n\">LinearMap.comp</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">toFun</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">invFun</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toFun</span><span class=\"o\">,</span> <span class=\"n\">invFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">ext</span> <span class=\"n\">z</span> <span class=\"n\">v</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.tmul_add</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.smul_tmul</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">Complex.I</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">Complex.I</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">TensorProduct.add_tmul</span> <span class=\"o\">(</span><span class=\"n\">z.re</span> <span class=\"bp\">•</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z.im</span> <span class=\"bp\">•</span> <span class=\"n\">Complex.I</span><span class=\"o\">)</span> <span class=\"n\">v</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Complex.real_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">Complex.re_add_im</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 422340126,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708400775
    },
    {
        "content": "<p>I recommend using <code>by rw?</code> to find the actual lemma name</p>",
        "id": 422340338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708400977
    },
    {
        "content": "<p>Wow! <code>rw?</code> is a thing! <code>TensorProduct.smul_tmul'</code></p>",
        "id": 422340773,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708401312
    },
    {
        "content": "<p>Just to explain why I told you to build everything as linear maps: if you hadn't, and tried to prove the inverse as <code>f (g x) = x</code> instead of this <code>comp</code> version, your <code>ext z w</code> wouldn't have worked</p>",
        "id": 422340970,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708401464
    },
    {
        "content": "<p>You might find the proof even easier if you add <code>attribute [ext] TensorProduct.ext'</code> before your proof</p>",
        "id": 422341055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708401515
    },
    {
        "content": "<p>I'm down to <code>invFun_toFun_comp_eq_id</code> and I can't seem to make progress -- the first part of the goal state is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">TensorProduct.lift</span>\n        <span class=\"o\">(</span><span class=\"n\">LinearMap.mk₂</span> <span class=\"n\">ℝ</span> <span class=\"c1\">--- then lots of functions to structures</span>\n</code></pre></div>\n<p>and I haven't found the way around -- somehow this all normalized out in <code>toFun_inFun_comp_eq_id</code>.</p>",
        "id": 422447488,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708444401
    },
    {
        "content": "<p>Can you share the full goal state, or an updated mwe?</p>",
        "id": 422447735,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708444466
    },
    {
        "content": "<p>Uh, scratch that, somehow:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">invFun_toFun_comp_eq_id</span><span class=\"o\">:</span> <span class=\"n\">LinearMap.comp</span> <span class=\"n\">invFun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">toFun</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">LinearMap.ext</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">invFun</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">invFun_toFun_comp_eq_id</span><span class=\"o\">:</span> <span class=\"n\">LinearMap.comp</span> <span class=\"n\">invFun</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">toFun</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">toFun</span><span class=\"o\">,</span> <span class=\"n\">invFun</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">LinearMap.ext</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">p</span>\n</code></pre></div>\n<p>was <code>simp</code> resistant</p>",
        "id": 422447908,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708444516
    },
    {
        "content": "<p>Oh, that's not correct either -- I never tried the literally <code>simp</code>lest tactic</p>",
        "id": 422448107,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708444564
    },
    {
        "content": "<p>Now what do I do with my time? Oh, yeah, show the <code>R^n</code> <code>C^n</code> case.</p>",
        "id": 422448664,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708444712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"542196\">Arien Malec</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Complexification.20of.20a.20real.20vector.20space/near/422448664\">said</a>:</p>\n<blockquote>\n<p>Now what do I do with my time? Oh, yeah, show the <code>R^n</code> <code>C^n</code> case.</p>\n</blockquote>\n<p>This one should actually be easier, you should be able to compose isomorphisms already in mathlib</p>",
        "id": 422449063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708444808
    },
    {
        "content": "<p>Hmm. With your hints on <code>baseChange</code>, do I want something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsBaseChange.equiv#doc\">docs#IsBaseChange.equiv</a> ?</p>",
        "id": 422467334,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708450167
    },
    {
        "content": "<p>I think I'm wrong, the result I'm thinking of only exists for finitely supported functions, not general functions</p>",
        "id": 422470082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708451141
    },
    {
        "content": "<p>I'll go the hard way then.</p>",
        "id": 422470193,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708451173
    },
    {
        "content": "<p>What would need to be in Mathlib for this to be trivial?</p>",
        "id": 422470274,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708451205
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.directSumLeft#doc\">docs#TensorProduct.directSumLeft</a> for Pi types</p>",
        "id": 422470372,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708451242
    },
    {
        "content": "<p>(probably over a <code>Fintype</code> index)</p>",
        "id": 422470393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708451251
    },
    {
        "content": "<p>You'd combine that with the fact that <code>ℂ ⊗[ℝ] ℝ</code> and <code>ℂ</code> are isomorphic, which Mathlib knows</p>",
        "id": 422470550,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708451311
    },
    {
        "content": "<p>Oh, hey, we know <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Complex.equivRealProd#doc\">docs#Complex.equivRealProd</a> and now we know that <code>(V × V) ≃ₗ[ℝ] (ℂ ⊗[ℝ] V)</code></p>",
        "id": 422477487,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708453843
    },
    {
        "content": "<p>Can these be combined in useful ways?</p>",
        "id": 422477525,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708453858
    },
    {
        "content": "<p>Yes, you could have used that to get the isomorphism instead of your approach, I think</p>",
        "id": 422477693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708453917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> TensorProduct, Prod</p>",
        "id": 422477777,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708453937
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/TensorProduct.html#TensorProduct.SMul.aux\">TensorProduct.SMul.aux</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/TensorProduct.html#TensorProduct.SMul.aux_of\">TensorProduct.SMul.aux_of</a>, and <a href=\"https://loogle.lean-lang.org/?q=TensorProduct%2C%20Prod\">68 more</a></p>",
        "id": 422477783,
        "sender_full_name": "loogle",
        "timestamp": 1708453938
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.prodLeft#doc\">docs#TensorProduct.prodLeft</a> is what I was looking for</p>",
        "id": 422477911,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708453982
    },
    {
        "content": "<p>I played with that for a bit but didn't find the path through....</p>",
        "id": 422478055,
        "sender_full_name": "Arien Malec",
        "timestamp": 1708454031
    },
    {
        "content": "<p>You'll need <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.congr#doc\">docs#TensorProduct.congr</a> too</p>",
        "id": 422478157,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708454062
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.lid#doc\">docs#TensorProduct.lid</a></p>",
        "id": 422478199,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708454077
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.prod#doc\">docs#LinearEquiv.prod</a></p>",
        "id": 422478313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708454120
    }
]