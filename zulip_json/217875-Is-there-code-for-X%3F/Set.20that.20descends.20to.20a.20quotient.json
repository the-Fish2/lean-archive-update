[
    {
        "content": "<p>Say we have <code>α : Sort*</code>, <code>r : α → α → Prop</code> (known to be an equivalence relation), and <code>S : Set α</code>. What's the mathlib-idomatic way to say that <code>S</code> is a union of equivalence classes of <code>r</code>, i.e. that <code>S</code> is the preimage of some <code>Set (Quot r)</code>? I'm also happy to assume <code>α, r</code> are given as a setoid instead separately</p>",
        "id": 419751383,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707097966
    },
    {
        "content": "<p>One way we could write it is as <code>(r ⇒ Iff) (. ∈ S) (. ∈ S)</code> or <code>(r ⇒ (. → .)) (. ∈ S) (. ∈ S)</code>, but I've never used <code>⇒</code> or any of the Relator stuff and it's a bit of a mystery to me</p>",
        "id": 419751609,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707098153
    },
    {
        "content": "<p>Those spellings all look hard to understand or even parse. Can you just say that the set is the premiage of its image?</p>",
        "id": 419753548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707099549
    },
    {
        "content": "<p>That works, but it would be nice to get a definitional equality with <code>∀ x y, r x y → (x ∈ S ↔ y ∈ S)</code> or <code>∀ x y, r x y → x ∈ S → y ∈ S</code> since this type is directly \"about\" <code>α</code> and can applied to terms of type <code>α</code> to get something useful</p>\n<p>(I agree re: the <code>⇒</code> things)</p>",
        "id": 419753937,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707099875
    },
    {
        "content": "<p>Also, I think the word I was looking for to desrcibe these sets is \"saturated\". At least this is what was used for describing the quotient topology when I first learned topology</p>",
        "id": 419754268,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707100192
    },
    {
        "content": "<p>I would just use those. “For all x,y, r x y implies x in S implies y in S” sounds reasonable.</p>",
        "id": 419755651,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707101280
    },
    {
        "content": "<p>If you are willing to use <code>Setoid</code>s, <code>⟨r, h⟩ ≤ Setoid.ker S</code> works (where <code>h</code> is a proof of <code>Equivalence r</code>).</p>",
        "id": 419758338,
        "sender_full_name": "Terence Tao",
        "timestamp": 1707103442
    },
    {
        "content": "<p>I think that would give = instead of iff</p>",
        "id": 419758422,
        "sender_full_name": "Brendan Seamas Murphy",
        "timestamp": 1707103506
    },
    {
        "content": "<p><code>(r ⇒ (. ∈ S → . ∈ S))</code> should also work right?</p>\n<p>\"saturated\" is too ambiguous IMO, see <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Closure.20of.20Submonoid.20in.20CommMonoids/near/419087778\">here</a> for two different meanings in the context of monoids.</p>",
        "id": 419877552,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707149958
    }
]