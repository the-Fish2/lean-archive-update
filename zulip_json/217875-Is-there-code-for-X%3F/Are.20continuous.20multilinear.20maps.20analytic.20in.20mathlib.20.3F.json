[
    {
        "content": "<p>I was looking at the mathlib files on analytic functions, and at the beginning of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Analytic/Linear.html\">that one</a>, I saw the following text:</p>\n<p>\"In this file we prove that a ContinuousLinearMap defines an analytic function with the formal power series f x = f a + f (x - a). We also prove similar results for multilinear maps.\"</p>\n<p>However, I didn't find a proof that continuous multilinear maps are analytic in that file or its dependencies.</p>\n<p>So my question is: does mathlib contain the proof that continuous multilinear maps are analytic ? I ask because I wrote a proof when trying to simplify my proof that continuous multilinear maps are differentiable, and I'm wondering whether to PR it or whether it's useless.</p>",
        "id": 409255167,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703104013
    },
    {
        "content": "<p>Apparently there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousLinearMap.analyticAt_bilinear#doc\">docs#ContinuousLinearMap.analyticAt_bilinear</a> but not trilinear or higher up.</p>",
        "id": 409256849,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703104802
    },
    {
        "content": "<p>Okay ! By the way, we were talking about writing some lemmas for functions that have finite power series. I have a bit more time now, so I'll get to it until you've already started doing something.</p>",
        "id": 409257390,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703105061
    },
    {
        "content": "<p>Nope, haven't had time to look deeply into the new stuff on your PR yet ...</p>",
        "id": 409257473,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703105110
    },
    {
        "content": "<p>That can wait, no worries ! It's just stuff to prepare for the proof that multilinear maps are analytic. (By the way, I messed up pretty badly yesterday and the branch had to be reset to a previous commit. I hope we didn't delete anybody else's corrections while doing that, I'm really sorry if we did.)</p>\n<p>I was already talking about stuff that will be needed to deduce that they are also differentiable without a completeness assumption on the target space.</p>",
        "id": 409258102,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703105433
    },
    {
        "content": "<p>Okay, I did \"continuously polynomial\" functions (= functions that can be written as the sum of a finite formal multilinear series) and proved that are they are infinitely differentiable without a completeness hypothesis on the target space <code>F</code>. It's a first version so maybe I'll think about it a bit more before PRing it, but in any case it's <a href=\"https://github.com/leanprover-community/mathlib4/tree/Analytic\">there</a>.</p>",
        "id": 409470726,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703196151
    },
    {
        "content": "<p>Thanks! The diff looks quite nice as lemmas come in a natural flow and most proofs are of reasonable size, except for <code>changeOrigin_eval_of_finite</code> in Analytic/Basic, which is longer than the <a href=\"https://github.com/leanprover-community/mathlib4/blob/e7c657f3b4b6f175895c3c1143a5275d24ba418c/Mathlib/Analysis/Analytic/Basic.lean#L1301-L1346\">infinite counterpart</a> that assumes completeness. Maybe you combined multiple lemmas into the main proof, or is it really more difficult in this case? If we could unify both proofs that would be even nicer.</p>\n<p>Some initial comments:<br>\nYou could remove the commented out lemmas at the end of Analytic/Basic, since you already made copies of them, and this should reduce the diff.<br>\nYou could make <code>HasFiniteFPowerSeriesOnBall extends HasFPowerSeriesOnBall</code> and I think you will get <code>HasFiniteFPowerSeriesOnBall.toHasFPowerSeriesOnBall</code> automatically.<br>\nWhy are the double c in the lemma names <code>cCPolynomialAt/On_const</code>? Should they just be called <code>cPolynomialAt/On_const</code>?</p>",
        "id": 409480158,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703200580
    },
    {
        "content": "<p>Thanks for the suggestions ! The double c in some places were typos, and I've hunted them down and hopefully removed them all.<br>\nOops, I thought I had gotten all the commented out lemmas ! Removing them.<br>\nGood point about making <code>HasFiniteFPowerSeriesOnBall</code> extend <code>HasFPowerSeriesOnBall</code>.</p>\n<p>The proof for <code>changeOrigin_eval_of_finite</code> is easier than the proof of its infinite counterpart, it's only longer because I had to write some parts myself and I'm not as effective as the mathlib authors. There's at least one other proof that is extremely clunky. Most of the other proofs and lemmas flow well because they're a copy-paste of the \"analytic\" lemmas and proofs with minimal adaptations. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 409538502,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703231594
    },
    {
        "content": "<p>Ah, there's two commented out lemmas at the end of Basic that are still here because I wonder whether they're worth adapting.</p>",
        "id": 409538719,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703231715
    },
    {
        "content": "<p>I cleaned up a little. As for the proof of <code>changeOrigin_eval_of_finite</code>, one of the things that takes a long time to prove is summability of some series, where I use the fact that they have finite support but take forever to prove that the support is finite. Here is an example of one these long finiteness proofs, extracted as a MWE so everyone can admire the monster:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Card</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n    <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">set</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">//</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">|</span>\n      <span class=\"n\">p.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">p.2.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.finite_def</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nonempty.intro</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span>\n        <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"o\">⟨⟨</span><span class=\"n\">p.1.1</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range.mpr</span> <span class=\"n\">p.2.1</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">p.1.2.1</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range.mpr</span> <span class=\"n\">p.2.2</span><span class=\"o\">⟩,</span> <span class=\"n\">p.1.2.2</span><span class=\"o\">⟩)</span>\n  <span class=\"n\">set</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span>\n        <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n        <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">refine</span> <span class=\"o\">⟨⟨</span><span class=\"n\">p.1</span><span class=\"o\">,</span> <span class=\"n\">p.2.1</span><span class=\"o\">,</span> <span class=\"n\">p.2.2</span><span class=\"o\">⟩,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n                    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">]</span>\n                    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">Finset.mem_range.mp</span> <span class=\"n\">p.1.property</span><span class=\"o\">,</span> <span class=\"n\">Finset.mem_range.mp</span> <span class=\"n\">p.2.1.property</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">Sigma.eta</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_setOf</span><span class=\"o\">,</span> <span class=\"n\">mem_setOf_eq</span><span class=\"o\">,</span> <span class=\"n\">id_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">set</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Finset.range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">×</span>\n        <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"bp\">|</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n        <span class=\"o\">{</span><span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">g</span>\n         <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n         <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span>\n         <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">h2</span><span class=\"o\">}</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Fintype.ofEquiv</span> <span class=\"n\">_</span> <span class=\"n\">e.symm</span>\n</code></pre></div>\n<p>There has to be a better way to do this, but I don't know how.</p>",
        "id": 409570413,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703246228
    },
    {
        "content": "<p>This was the sort of question I'd ask <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> in 2018 and he'd make a mathlib PR and then solve it in one line using <code>decide</code> or <code>apply_instance</code> or some other incantation</p>",
        "id": 409583187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1703251764
    },
    {
        "content": "<p>If you asked me to prove this as mathematician, I would say that my set has a map into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>×</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}\\times\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7722em;vertical-align:-0.0833em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> with finite fibers and finite image, so it is finite. However, I have been searching for such a lemma in mathlib in vain. The closest I found is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Finite.html#Set.Finite.of_finite_image\">this</a>, but it assumes that the fibers are empty or singletons, not that they are finite.</p>",
        "id": 409583945,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703252148
    },
    {
        "content": "<p>I cannot believe that such a thing would not be there...</p>",
        "id": 409584104,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703252218
    },
    {
        "content": "<p>There's <a href=\"https://github.com/leanprover-community/mathlib4/pull/6449\">#6449</a> by <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span>. Not sure why it's abandoned. I can try reviving it now if I manage to get cache.</p>",
        "id": 409584158,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703252242
    },
    {
        "content": "<p>A pity that this is abandoned indeed. So if you don't revive it, that means I should learn to work with such incantantions as <code>Tendsto f cofinite cofinite</code>, hmm... Or maybe there is yet another way to do the finiteness proof. It actually comes up twice in the current proof of <code>changeOrigin_eval_of_finite</code>, because I later want to show that <code> {p : (l : ℕ) × {s : Finset (Fin (m + l)) // s.card = l} | p.1  &lt; n}</code> is also finite.</p>",
        "id": 409585684,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703253020
    },
    {
        "content": "<p>And I did that in the worst possible way, but copy-pasting the previous finiteness proof and modifying it where needed. <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 409585810,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703253101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Are.20continuous.20multilinear.20maps.20analytic.20in.20mathlib.20.3F/near/409584158\">said</a>:</p>\n<blockquote>\n<p>There's <a href=\"https://github.com/leanprover-community/mathlib4/pull/6449\">#6449</a> by <span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span>. Not sure why it's abandoned. I can try reviving it now if I manage to get cache.</p>\n</blockquote>\n<p>The answer is not so secret: you get away with playing with Lean full time in Cambridge, but Anatole is doing Orsay's <a href=\"https://www.imo.universite-paris-saclay.fr/fr/etudiants/masters/mathematiques-et-applications/m2/arithmetique-analyse-geometrie/\">M2 AAG</a>.</p>",
        "id": 409593298,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1703256265
    },
    {
        "content": "<p>So anyway, I wrote the \"if a map has finite fibers and a finite image, then its source is finite\" lemma, and it's super easy ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Set.Finite.of_finite_image_of_finite_fibers</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hfin1</span> <span class=\"o\">:</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hfin2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">Set.Finite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}))</span> <span class=\"o\">:</span>\n    <span class=\"n\">Set.Finite</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Set.Finite.subset</span> <span class=\"o\">(</span><span class=\"n\">Set.Finite.biUnion</span> <span class=\"n\">hfin1</span> <span class=\"n\">hfin2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"n\">Set.mem_biUnion</span>\n  <span class=\"o\">(</span><span class=\"n\">Set.mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_singleton_iff</span><span class=\"o\">]))</span>\n</code></pre></div>\n<p>Now let's see if applying it will be as easy.</p>",
        "id": 409629485,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703271640
    },
    {
        "content": "<p>Hi again everyone! Indeed I was quite busy for this whole semester so I didn't have time to work on this. I have some Lean time during the holiday but I want to focus on finishing up Ascoli's theorem since people are waiting for it. <br>\nRegarding <a href=\"https://github.com/leanprover-community/mathlib4/pull/6449\">#6449</a> specifically, the main reason I left it aside is I realized it would be much better to make it not depend on filters as I originally did. While that is satisfying, it's quite obviously the wrong way to order things, and anyway the filter approach didn't work well to do the relative version Yaël suggested. I think I have some unpushed commits on my computer too <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 409829189,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703437750
    },
    {
        "content": "<p>Yeah I think using filters for things like this and  <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsMinOn#doc\">docs#IsMinOn</a> is a bit overpowered and will result in people not using the API because it would involve needing to understand and importing filters.</p>",
        "id": 409834224,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703443311
    },
    {
        "content": "<p>This is too foundational to use fancy machinery, basically.</p>",
        "id": 409834274,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703443339
    },
    {
        "content": "<p>I'm happy to have a look into redoing things the basic way. One thing I was surprised is that your <code>HasFiniteFibersOn</code> was restricting to a set on the domain, not to a set on the codomain. Is there any reason for that?</p>",
        "id": 409834451,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703443623
    },
    {
        "content": "<p>I guess it's more general, since every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> in the codomain having a finite fiber under <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is the same as every element in the codomain having finite fiber with the restriction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>? I'm wondering whether we will actually use this extra generality, since it makes the main lemma I have in mind (proving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> is finite if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> is) harder to apply.</p>",
        "id": 409834999,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1703444356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Are.20continuous.20multilinear.20maps.20analytic.20in.20mathlib.20.3F/near/409834999\">said</a>:</p>\n<blockquote>\n<p>I guess it's more general, since every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> in the codomain having a finite fiber under <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is the same as every element in the codomain having finite fiber with the restriction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span>? </p>\n</blockquote>\n<p>Yes exactly</p>",
        "id": 409835015,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703444396
    },
    {
        "content": "<p>I have no opinion about usability there, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.preimage#doc\">docs#Finset.preimage</a> already uses something similar</p>",
        "id": 409835209,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703444512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Are.20continuous.20multilinear.20maps.20analytic.20in.20mathlib.20.3F/near/409480158\">said</a>:</p>\n<blockquote>\n<p>except for <code>changeOrigin_eval_of_finite</code> in Analytic/Basic, which is longer than the <a href=\"https://github.com/leanprover-community/mathlib4/blob/e7c657f3b4b6f175895c3c1143a5275d24ba418c/Mathlib/Analysis/Analytic/Basic.lean#L1301-L1346\">infinite counterpart</a> that assumes completeness. Maybe you combined multiple lemmas into the main proof, or is it really more difficult in this case? If we could unify both proofs that would be even nicer.</p>\n</blockquote>\n<p>With the help of several people, I reduced the size of that proof, and it is... still longer than in the infinite case. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> But at least it's something like 52 lines against 46, not like 2-3 times as long.</p>",
        "id": 409905370,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703505549
    },
    {
        "content": "<p>I made a PR (<a href=\"https://github.com/leanprover-community/mathlib4/pull/9269\">#9269</a>) for continuously polynomial functions.</p>",
        "id": 409928771,
        "sender_full_name": "Sophie Morel",
        "timestamp": 1703525834
    }
]