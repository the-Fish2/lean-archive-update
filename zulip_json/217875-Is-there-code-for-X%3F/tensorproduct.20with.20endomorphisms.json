[
    {
        "content": "<p>I would be interested in knowing if we have constructions that allow to golf this.<br>\nCertainly, the first two decls should be generalized to the case of linear maps between two modules, instead of just endomorphisms. But that's orthogonal to my question.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LinearMap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Module</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProductEndₗ'</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">End</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.lift</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">baseChangeHom</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"n\">M</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">forall_true_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">RingHom.id_apply</span><span class=\"o\">,</span> <span class=\"n\">forall_true_iff</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProductEndₗ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">End</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">TensorProductEndₗ'</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"k\">with</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">f</span>\n      <span class=\"k\">show</span> <span class=\"n\">TensorProductEndₗ'</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">TensorProductEndₗ'</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"n\">f</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">TensorProductEndₗ'</span>\n      <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"n\">using</span> <span class=\"n\">TensorProduct.induction_on</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_zero</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.map_zero</span><span class=\"o\">]</span>\n      <span class=\"bp\">|</span> <span class=\"n\">tmul</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">TensorProduct.smul_tmul'</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.lift.tmul</span><span class=\"o\">]</span>\n          <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_mk</span><span class=\"o\">,</span> <span class=\"n\">AddHom.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">smul_apply</span><span class=\"o\">,</span> <span class=\"n\">baseChangeHom_apply</span><span class=\"o\">]</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_assoc</span><span class=\"o\">]</span>\n      <span class=\"bp\">|</span> <span class=\"n\">add</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_add</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.map_add</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProductEnd</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">End</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Algebra.TensorProduct.algHomOfLinearMapTensorProduct</span>\n    <span class=\"o\">(</span><span class=\"n\">TensorProductEndₗ</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">TensorProductEndₗ</span><span class=\"o\">,</span> <span class=\"n\">TensorProductEndₗ'</span><span class=\"o\">,</span> <span class=\"n\">coe_mk</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.lift.tmul'</span><span class=\"o\">,</span>\n        <span class=\"n\">AddHom.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_comp</span><span class=\"o\">,</span> <span class=\"n\">baseChangeHom_apply</span><span class=\"o\">,</span> <span class=\"n\">smul_apply</span><span class=\"o\">,</span> <span class=\"n\">baseChange_comp</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">LinearMap.ext</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">smul_apply</span><span class=\"o\">,</span> <span class=\"n\">map_smul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">mul_smul</span><span class=\"o\">])</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">TensorProductEndₗ</span><span class=\"o\">,</span> <span class=\"n\">TensorProductEndₗ'</span><span class=\"o\">,</span> <span class=\"n\">coe_mk</span><span class=\"o\">,</span> <span class=\"n\">TensorProduct.lift.tmul'</span><span class=\"o\">,</span>\n        <span class=\"n\">AddHom.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">,</span> <span class=\"n\">baseChangeHom_apply</span><span class=\"o\">]</span>\n      <span class=\"n\">apply</span> <span class=\"n\">LinearMap.ext</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">baseChange_eq_ltensor</span><span class=\"o\">,</span> <span class=\"n\">lTensor_id</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.id_apply</span><span class=\"o\">])</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LinearMap</span>\n</code></pre></div>",
        "id": 423138440,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708753917
    },
    {
        "content": "<p>I think you can merge the first two by using <code>TensorProduct.AlgebraTensorModule.lift</code></p>",
        "id": 423150965,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708764517
    },
    {
        "content": "<p>I don't think you can go much shorter, because it is really about the definition of a base change functor in various categories. Basically , one applies the universal property of the tensor product, and sone hypotheses have to be checked — they could have been checked elsewhere.</p>",
        "id": 423159160,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1708771241
    },
    {
        "content": "<p>The key here is indeed <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TensorProduct.AlgebraTensorModule.lift#doc\">docs#TensorProduct.AlgebraTensorModule.lift</a> as <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> suggests:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LinearMap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Module</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProductEndₗ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">End</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">TensorProduct.AlgebraTensorModule.lift</span> <span class=\"bp\">&lt;|</span>\n  <span class=\"o\">{</span> <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">baseChangeHom</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"n\">M</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_smul</span><span class=\"o\">,</span> <span class=\"n\">forall_true_iff</span><span class=\"o\">]</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">RingHom.id_apply</span><span class=\"o\">,</span> <span class=\"n\">forall_true_iff</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 423160319,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1708772420
    },
    {
        "content": "<p>I would guess that linear map already exists too</p>",
        "id": 423161215,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708773000
    },
    {
        "content": "<p>(as the general form that SMul is a linear map)</p>",
        "id": 423161310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708773042
    },
    {
        "content": "<p>I searched for it, but didn't find it. <code>SMulOneHom</code> isn't the right thing...</p>",
        "id": 423164261,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708775805
    },
    {
        "content": "<p>(Likewise I couldn't find it.)</p>",
        "id": 423164638,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1708776211
    },
    {
        "content": "<p>But thanks for the pointer to <code>TensorProduct.AlgebraTensorModule.lift</code>!</p>",
        "id": 423164695,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708776256
    },
    {
        "content": "<p>It will be something like <code>Module.toLinearMap</code></p>",
        "id": 423167001,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708778666
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.toSpanSingleton#doc\">docs#LinearMap.toSpanSingleton</a> (see also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.ringLmapEquivSelf#doc\">docs#LinearMap.ringLmapEquivSelf</a>)</p>",
        "id": 423167598,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1708779270
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.lsmul#doc\">docs#Algebra.lsmul</a> should give the last result, along with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Algebra.TensorProduct.lift#doc\">docs#Algebra.TensorProduct.lift</a></p>",
        "id": 423169562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708781118
    },
    {
        "content": "<p>Which result?</p>",
        "id": 423169644,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708781168
    },
    {
        "content": "<p>Now that I'm at a computer, here's my spelling of all of them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">LinearMap</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Module</span>\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">TensorProduct</span>\n\n<span class=\"c1\">-- these should be in mathlib</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">baseChange_id</span> <span class=\"o\">:</span> <span class=\"n\">LinearMap.baseChange</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">baseChange</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- On endomorphisms, `LinearMap.baseChangeHom` is an `AlgHom`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"bp\">!</span><span class=\"kd\">]</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.Module.End.baseChangeHom</span> <span class=\"o\">:</span> <span class=\"n\">End</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">End</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">.</span><span class=\"n\">ofLinearMap</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.baseChangeHom</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">baseChange_id</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">baseChange_comp</span> <span class=\"n\">g</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- These are maybe more contrived</span>\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProductEndₗ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">):=</span>\n  <span class=\"n\">TensorProduct.AlgebraTensorModule.lift</span> <span class=\"bp\">&lt;|</span>\n    <span class=\"o\">(</span><span class=\"n\">Algebra.lsmul</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toLinearMap.flip</span> <span class=\"o\">(</span><span class=\"n\">baseChangeHom</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">TensorProductEnd</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">End</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Algebra.TensorProduct.lift</span> <span class=\"o\">(</span><span class=\"n\">Algebra.ofId</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Module.End.baseChangeHom</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">=&gt;</span> <span class=\"n\">Algebra.commute_algebraMap_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">LinearMap</span>\n</code></pre></div>",
        "id": 423187682,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708793480
    },
    {
        "content": "<p><del>Probably we should have <code>AlgHom.baseChange</code> that handles the <code>lift (.ofId _ _) ?_ sorry</code> pattern</del></p>",
        "id": 423187776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708793542
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/10928\">#10928</a> adds the first two results</p>",
        "id": 423188258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1708793986
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 423191840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1708797279
    }
]