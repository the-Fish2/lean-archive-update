[
    {
        "content": "<p>Do we have anything like the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Rel</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">Rel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"bp\">.</span><span class=\"n\">Rel</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">Rel</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>One can fill in the <code>sorry</code>'s by using the equivalent non-rel versions of these lemmas and taking subtypes. However, this is grossly inefficient when working with certain specific examples.</p>",
        "id": 445454254,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718742423
    },
    {
        "content": "<p>This came up today: <a href=\"https://github.com/leanprover-community/mathlib4/pull/12273#discussion_r1644797534\">https://github.com/leanprover-community/mathlib4/pull/12273#discussion_r1644797534</a></p>",
        "id": 445454993,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718742669
    },
    {
        "content": "<p>The result linked to there <code>SimpleGraph.Hom.instFintype</code> is doing this using the equivalence to a subtype. I believe this is not  the most efficient way of tackling this problem. (Efficient in terms of speed and memory usage of generating the list of elements, rather than length of code).</p>",
        "id": 445456766,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718743242
    },
    {
        "content": "<p>I agree, although I wonder what general solution you have to offer</p>",
        "id": 445456937,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718743299
    },
    {
        "content": "<p>For the case of <code>Fintype (T.Rel ≃r T.Rel)</code>,  at least, the problem reduces to finding permutations within equivalence classes, and then `stitching' them together.</p>",
        "id": 445457989,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718743596
    },
    {
        "content": "<p>Yes, so this is not a general solution, making it unsuitable for a general instance. I suspect you would be better off <em>not</em> relying on <code>Fintype</code> here</p>",
        "id": 445458197,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718743668
    },
    {
        "content": "<p>A  <code>T.Rel →r S.Rel </code> is determined by it's map on equivalence classes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">/</mi><mo>∼</mo><mo>→</mo><mi>T</mi><mi mathvariant=\"normal\">/</mi><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\"> F : S / \\sim \\to T/\\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span></span></span></span> and the maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>→</mo><mi>F</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e \\to F e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\">e</span></span></span></span> for each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>∈</mo><mi>S</mi><mi mathvariant=\"normal\">/</mi><mo>∼</mo></mrow><annotation encoding=\"application/x-tex\"> e \\in S / \\sim</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∼</span></span></span></span>. This can likely be turned into an equivalence of types between <code>T.Rel →r S.Rel </code> and the Pi type determined by the map on equivalence classes and those between individual corresponding equivalence classes. This Pi type is a Fintype uses of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/Pi.html#Pi.fintype\">Pi.fintype</a>.</p>",
        "id": 445458375,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718743727
    },
    {
        "content": "<p>Similar for <code>T.Rel ≃r S.Rel</code>.</p>\n<p>In what sense is this not a general solution?</p>",
        "id": 445458737,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718743836
    },
    {
        "content": "<p>It's not a general solution in the sense that it won't work to eg replace <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Hom.instFintype#doc\">docs#SimpleGraph.Hom.instFintype</a></p>",
        "id": 445460730,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718744508
    },
    {
        "content": "<p>In general, computation typeclasses like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a> walk a fine line between generality and optimisation. When reasoning about them, you want them general. When computing, you want them specific.</p>",
        "id": 445460901,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718744565
    },
    {
        "content": "<p>Here you have a specific use case in mind (partitions), which clashes with the general reasoning we want to do about relation homomorphisms. The solution I'm offering is to not shoehorn your optimisation into the general reasoning framework, but instead to write your own framework</p>",
        "id": 445461120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718744665
    },
    {
        "content": "<p>I understand why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Hom.instFintype#doc\">docs#SimpleGraph.Hom.instFintype</a> will not work with my solution. </p>\n<p>I'm not suggesting to put my solution into Mathlib. I'm simply asking if a optimised solution exists out there anywhere. Sorry for the miscommunication about this.</p>",
        "id": 445462610,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718745104
    },
    {
        "content": "<p>I think the issue is independent on whether you are planning on contributing your optimised solution: When mathlib acquires a general solution, it will interfere with your optimised one regardless of whether that's in mathlib or in your project</p>",
        "id": 445463163,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718745337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"653351\">Joseph Tooby-Smith</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Fintype.20of.20RelHom.20and.20RelIso/near/445462610\">said</a>:</p>\n<blockquote>\n<p>I'm simply asking if a optimised solution exists out there anywhere</p>\n</blockquote>\n<p>Not to my knowledge</p>",
        "id": 445463196,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1718745351
    },
    {
        "content": "<p>Is the issue you describe a general one about having two instances of the same thing on the same type? If so, I can surely get around this using priorities?  Just checking there is nothing more subtle going on which I'm missing.</p>",
        "id": 445468744,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1718747884
    },
    {
        "content": "<p>It's not as easy as you're suggesting because sometimes you use lemmas which have the \"bad\" instance baked in or for which typeclass inference finds the bad instance anyway (if X has low priority and Y has high priority there are still ways of asking typeclass inference to find an instance and it finds X before Y, perhaps because there was a decision taken much earlier to go down the X route for other reasons). But if you're aware of the issue and know how to test for it by hovering over terms and looking in them, then you should be fine.</p>",
        "id": 445517803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718779571
    }
]