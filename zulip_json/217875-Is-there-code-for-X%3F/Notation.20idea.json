[
    {
        "content": "<p>One point of friction from human mathematics to formalization is that we can't say things like: Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo separator=\"true\">,</mo><mi>V</mi><mo>⊂</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">U,V\\subset\\mathbb C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> and let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>U</mi><mo>→</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">f:U\\to V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo separator=\"true\">,</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">U,V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> aren't types. I wonder if there could be some notation to smooth this out? E.g.<br>\nThe text \"example (U V : Set \\C) (f : U \\longrightarrow V)\" would \"under the hood\" produce </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fUV</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In other words, you would write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but it would be interpreted as above. Might something like that make sense?... (Yes, it's a trivial point, but I'd think we'd want to remove as many friction points as possible, even the trivial ones?..)</p>",
        "id": 440372390,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1716487194
    },
    {
        "content": "<p>The second thing you write should already work. <code>U</code> and <code>V</code> will be interpreted as subtypes of C</p>",
        "id": 440376353,
        "sender_full_name": "Felix Weilacher",
        "timestamp": 1716488940
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> are types. Or rather, they can already automatically be coerced to types; it's already possible to write <code>f : U → V</code>. But it's more idiomatic to write <code>f : ℂ → ℂ</code> (at least in the complex analysis part of mathlib), because it means you don't have to include the hypothesis <code>fUV: ∀ u ∈ U, f u ∈ V</code> unless it's necessary.</p>",
        "id": 440376389,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1716488955
    },
    {
        "content": "<p>Note that <code>fUV</code> can already be spelled more compactly using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.MapsTo#doc\">docs#Set.MapsTo</a></p>",
        "id": 440376436,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1716488979
    },
    {
        "content": "<p>And indeed using <code>f : U → V</code> and relying on the coercion from Set to Type is very painful.</p>",
        "id": 440376588,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1716489027
    },
    {
        "content": "<p>One way to do the thing you describe is by making <code>U ⟶ V</code> a structure, which carries the data of a function <code>f : ℂ → ℂ</code> and a proof that <code>∀ u ∈ U, f u ∈ V</code>. This won't automatically expand the argument into two arguments like you want, but it would still be usable. However, I suspect that the burden of learning this new notation, and the difficulty in convincing everyone to use it rather than <code>(f : ℂ → ℂ) (fUV: ∀ u ∈ U, f u ∈ V)</code>, would outweigh the minimal gains in the number of characters you have to type.</p>",
        "id": 440377412,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1716489361
    },
    {
        "content": "<p>(Also, this might be unnecessarily pedantic, but I think that <code>U ⟶ V</code>, defined as above, does not behave the way you might expect in all cases. Let <code>A</code> be any nonempty type and let <code>B</code> be any empty type. Let <code>U : Set A</code> and <code>V : Set B</code> be empty. Then, there is a function <code>f : U → V</code>, but there is no function <code>f : A  → B</code> satisfying <code>∀ u ∈ U, f u ∈ V</code>).</p>",
        "id": 440377930,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1716489564
    },
    {
        "content": "<p>While we're here, there's a related notion of functions between filters (as filters are \"generalized sets\"). If you extract the definition morphisms from Pro(Set) and specialize it to filters, it looks like the following. You get both the idea of functions from one subset to another (<code>Res</code> below) as well as germs of functions at a point (<code>Germ</code> below).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">Topology</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">tendsto</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Tendsto</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"n\">F₂</span>\n\n<span class=\"kn\">infixr</span><span class=\"o\">:</span><span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"s2\">\" ⟶ \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Fun</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">F₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Fun</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/-- Functions on filters are equivalent if they are eventually equal on the domain. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Fun</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">F₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∀ᶠ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"sd\">/-- Germs are functions on the neighborhood filter. `Filter.Fun.eq` is the expected equivalence relation for germs. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Germ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">𝓝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Functions from `U` to `V`. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Res</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">𝓟</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">𝓟</span><span class=\"w\"> </span><span class=\"n\">V</span>\n</code></pre></div>",
        "id": 440382936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716491674
    },
    {
        "content": "<p>What happens if <code>\\beta</code> is empty (but alpha is not)  and <code>F_1</code> is <code>\\bot</code>?</p>",
        "id": 440383347,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1716491861
    },
    {
        "content": "<p>That's the pathological example that Mitchell mentioned in the comment right before mine.</p>",
        "id": 440383809,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716492028
    },
    {
        "content": "<p>Oh yeah I see it now.</p>",
        "id": 440383891,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1716492058
    },
    {
        "content": "<p>(I for one don't think it's too pathological...)</p>",
        "id": 440384280,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1716492218
    },
    {
        "content": "<p>Assuming your code doesn't handle that example, is there a version of Filter.Fun that does handle it in the case of general filters?</p>",
        "id": 440388016,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1716493773
    },
    {
        "content": "<p>The only issue is that when alpha is nonempty and beta is empty then there are no functions from alpha to beta, but there should be a \"function\" from the empty filter on alpha to any filter on beta.</p>",
        "id": 440388551,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1716493993
    },
    {
        "content": "<p>You could, for example, use a partial function from alpha to beta, and add some additional conditions to <code>Filter.fun</code>.</p>",
        "id": 440389056,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1716494205
    },
    {
        "content": "<p>Yeah, I think partial functions are right (and also can be better since lots of times you don't want to bother with defining a function outside its domain). This might be the correct definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"w\">  </span><span class=\"n\">tendsto</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"bp\">.</span><span class=\"n\">Tendsto</span><span class=\"w\"> </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">F₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">F₂</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 440389733,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716494473
    },
    {
        "content": "<p>However, this goes in a direction that's not helpful for Alex's <code>f : ℂ → ℂ</code>.</p>",
        "id": 440389820,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716494507
    },
    {
        "content": "<p>But why worry about empty types. All types are inhabited, right? (That's how it is in Isabelle.)</p>",
        "id": 440390160,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1716494643
    }
]