[
    {
        "content": "<p>I have <code>V</code> a finite dimensional vector space over some field <code>F</code>, a vector <code>v</code> and an endomorphism <code>f</code>. I want to show that I can find a basis of Span(<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msup><mi>f</mi><mrow><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow></msup><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{f^{[k]}(v) | k \\in \\mathbb{N}\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose mtight\">]</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mclose\">}</span></span></span></span>) given by looking at the first k vectors: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo separator=\"true\">,</mo><msup><mi>f</mi><mrow><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow></msup><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(v, f(v), ..., f^{[k]}(v))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.138em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">...</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">[</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose mtight\">]</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">))</span></span></span></span>. </p>\n<p>Are there any good tricks/results that exist to solve this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.LinearAlgebra.FiniteDimensional</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_basis_iterate</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">)))),</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 419890972,
        "sender_full_name": "Lucas Whitfield",
        "timestamp": 1707153711
    },
    {
        "content": "<p>I'm not aware of any shortcut and I'd just define <code>k</code> to be the smallest such that <code>f^[k] v</code> isn't in the span of <code>f^[i] v</code> with <code>i &lt; k</code>, and then inductively show <code>f^[i] v</code> with <code>i &lt; k</code> are linearly independent using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=linearIndependent_fin_snoc#doc\">docs#linearIndependent_fin_snoc</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le_induction#doc\">docs#Nat.le_induction</a>, and separately inductively show <code>f^[i] v</code> with <code>i &gt;= k</code> lie in their span (where <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.span_image#doc\">docs#Submodule.span_image</a> could be useful).</p>",
        "id": 419893742,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707154641
    },
    {
        "content": "<p>There’s also an abstract argument through <code>F[X]</code> modules right ? Do we have the necessary glue for this ?</p>",
        "id": 419899077,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707156428
    },
    {
        "content": "<p>I don't think we do, but it would probably be nice to have it because I bet it would make all these sorts of generalized eigenvector / Jordan canonical form / rational canonical form arguments smoother in the long run.</p>",
        "id": 419904793,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707158488
    },
    {
        "content": "<p>I thought we had the structure theorem for modules over PIDs?</p>",
        "id": 419907278,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707159363
    },
    {
        "content": "<p>And I would hope that mathlib knows about the basis of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K[X]/(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> in terms of monomials.</p>",
        "id": 419907479,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707159427
    },
    {
        "content": "<p>We have! It's in <code>Mathlib.LinearAlgebra.FreeModule.PID</code>.</p>",
        "id": 419909013,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707159987
    },
    {
        "content": "<p>It can probably be stated in several way and we may need some glue, but I think all the mathematics is there.</p>",
        "id": 419909064,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1707160008
    },
    {
        "content": "<p>Ah, and the glue would be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.AEval%27#doc\">docs#Module.AEval'</a> right?</p>",
        "id": 419910721,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707160665
    },
    {
        "content": "<p>It's maybe not exactly the result you are looking for, but often <code>LinearMap.eventually_codisjoint_ker_pow_range_pow</code> is quite useful.</p>",
        "id": 419911383,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1707160892
    },
    {
        "content": "<p>Ah, I had no idea about <code>Module.AEval'</code>!</p>",
        "id": 419923594,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1707165262
    },
    {
        "content": "<p>Following <span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span>'s idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.AdjoinRoot</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.RingTheory.MvPolynomial.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">Polynomial</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kn\">section</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toAEval'</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]]</span> <span class=\"n\">Module.AEval'</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">LinearMap.toSpanSingleton</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.IsPrincipal.generator</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.ker</span> <span class=\"o\">(</span><span class=\"n\">toAEval'</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">toAEval''</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Module.AEval'.of</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">∘ₗ</span> <span class=\"o\">(</span><span class=\"n\">toAEval'</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">gen_ne_zero</span> <span class=\"o\">:</span> <span class=\"n\">gen</span> <span class=\"n\">v</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span>\n  <span class=\"n\">Polynomial.not_finite</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">FiniteDimensional.of_injective</span> <span class=\"o\">(</span><span class=\"n\">toAEval''</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"n\">Ideal.span</span> <span class=\"o\">{</span><span class=\"bp\">·</span><span class=\"o\">})</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">gen</span><span class=\"o\">,</span> <span class=\"n\">Ideal.span_singleton_generator</span><span class=\"o\">,</span>\n      <span class=\"n\">Ideal.span_singleton_eq_bot.mpr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.ker_eq_bot</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toAEval''_monomial_one</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">toAEval''</span> <span class=\"n\">v</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.monomial</span> <span class=\"n\">n</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">toAEval''</span><span class=\"o\">,</span> <span class=\"n\">toAEval'</span><span class=\"o\">,</span> <span class=\"n\">LinearMap.coe_pow</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">range_toAEVal'</span> <span class=\"o\">:</span> <span class=\"n\">LinearMap.range</span> <span class=\"o\">(</span><span class=\"n\">toAEval''</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">LinearMap.range_eq_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.basisMonomials</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">span_eq</span><span class=\"o\">,</span> <span class=\"n\">Submodule.map_span</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Set.range_comp</span><span class=\"o\">]</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">Function.comp</span><span class=\"o\">,</span> <span class=\"n\">Polynomial.coe_basisMonomials</span><span class=\"o\">,</span> <span class=\"n\">toAEval''_monomial_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">genEquiv</span> <span class=\"o\">:</span> <span class=\"n\">AdjoinRoot</span> <span class=\"o\">(</span><span class=\"n\">gen</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Submodule.quotEquivOfEq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Submodule.IsPrincipal.span_singleton_generator</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrictScalars</span> <span class=\"n\">F</span>\n    <span class=\"bp\">≪≫ₗ</span> <span class=\"o\">(</span><span class=\"n\">toAEval''</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotKerEquivRange</span> <span class=\"bp\">≪≫ₗ</span> <span class=\"bp\">.</span><span class=\"n\">ofEq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">range_toAEVal'</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_basis_iterate</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span> <span class=\"n\">v</span><span class=\"o\">)),</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">AdjoinRoot.powerBasis</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">gen_ne_zero</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">basis.map</span> <span class=\"o\">(</span><span class=\"n\">genEquiv</span> <span class=\"n\">v</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"k\">fun</span> <span class=\"n\">i</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Basis.map_apply</span><span class=\"o\">,</span> <span class=\"n\">PowerBasis.coe_basis</span><span class=\"o\">]</span>\n    <span class=\"n\">change</span> <span class=\"n\">toAEval''</span> <span class=\"n\">v</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Polynomial.X</span> <span class=\"bp\">^</span> <span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">_</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Polynomial.monomial_one_right_eq_X_pow</span><span class=\"o\">,</span> <span class=\"n\">toAEval''_monomial_one</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 419933848,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707169587
    },
    {
        "content": "<p>Nice, I’ve learnt a dozen of \"algebra in Lean\" tricks by reading this <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 419934705,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707169956
    },
    {
        "content": "<p>What is <code>≪≫ₗ</code>??</p>",
        "id": 419934878,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1707170034
    },
    {
        "content": "<p>Is it annoying to define the generator in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.annihilator#doc\">docs#Submodule.annihilator</a> instead ? I think it would be more natural</p>",
        "id": 419934956,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707170056
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Basis.20for.20span.20of.20iterated.20linear.20map/near/419934878\">said</a>:</p>\n<blockquote>\n<p>What is <code>≪≫ₗ</code>??</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.trans#doc\">docs#LinearEquiv.trans</a></p>",
        "id": 419935073,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707170119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Basis.20for.20span.20of.20iterated.20linear.20map/near/419934956\">said</a>:</p>\n<blockquote>\n<p>Is it annoying to define the generator in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.annihilator#doc\">docs#Submodule.annihilator</a> instead ? I think it would be more natural</p>\n</blockquote>\n<p>You'd need to obtain a F[X]-module structure on <code>Submodule.span F (Set.range (f^[·] v))</code> (or rather its copy in <code>Module.AEval' f</code>) using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.AEval.mapSubmodule#doc\">docs#Module.AEval.mapSubmodule</a>, which may or may not be simpler ...</p>",
        "id": 419937696,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707171263
    },
    {
        "content": "<p>Could you move only <code>v</code> to <code>Module.AEval' f</code> and take the <code>F[X]</code>-span there ?</p>",
        "id": 419938536,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707171638
    },
    {
        "content": "<p>Not sure what you mean, but we could restrict <code>f : V →ₗ[F] V</code> (i.e. <code>f : Module.End F V</code>) to <code>f' : Module.End F (Submodule.span F (Set.range (f^[·] v)))</code> using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.domRestrict#doc\">docs#LinearMap.domRestrict</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearMap.codRestrict#doc\">docs#LinearMap.codRestrict</a>, and then we can just take <code>minpoly F f'</code>. But another concern is that iterated <code>f</code> is not defeq to iterated <code>f'</code>, and I don't know whether a relevant lemma exists ...</p>",
        "id": 419939484,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707172105
    },
    {
        "content": "<p>I mean define <code>gen</code> as a generator of the annihilator of <code>Submodule.span F[X] (AEval'.of f v)</code> (hope that makes sense, I’m on mobile…)</p>",
        "id": 419939875,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707172278
    },
    {
        "content": "<p>I think my definition of <code>gen</code> makes things easier because it's the generator of a kernel, so you can immediately apply the first isomorphism theorem and get an isomorphism between the quotient (defeq to AdjoinRoot) and the range (a submodule in <code>Module.AEval' f</code>). With your suggestion</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">Submodule.IsPrincipal.generator</span> <span class=\"o\">(</span><span class=\"n\">Submodule.span</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">Module.AEval'.of</span> <span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">annihilator</span>\n</code></pre></div>\n<p>although the annihilator is also defined as a kernel</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">Submodule.annihilator</span> <span class=\"n\">N</span> <span class=\"bp\">=</span> <span class=\"n\">LinearMap.ker</span> <span class=\"o\">(</span><span class=\"n\">LinearMap.lsmul</span> <span class=\"n\">R</span> <span class=\"bp\">↥</span><span class=\"n\">N</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the image is a submodule in <code>Module.End R N</code> where <code>N := span F[X] {Module.AEval'.of f v}</code>, and it's not straightforward to connect this to a submodule of <code>Module.AEval' f</code> and then to <code>V</code>. I hope I'm not missing something!</p>",
        "id": 419943575,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707173781
    },
    {
        "content": "<p>I haven’t thought about it carefully, I was genuinely asking wether it got harder and I was half-expecting the answer to be yes ! I’ll have to think more about it tomorrow</p>",
        "id": 419944137,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707174012
    },
    {
        "content": "<p>Last idea if you want to try it : what about doing everything in an <code>F[X]</code> module for the multiplication by <code>X</code> map, and then only going back to <code>f</code> at the end, which should be easy since the statement is about <code>F</code> vector spaces with an endomorphism ?</p>",
        "id": 419944445,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1707174192
    },
    {
        "content": "<p>If W is a f.d. F[X]-module and <code>w : W</code>, you should be able to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Set.range</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"bp\">·</span> <span class=\"bp\">•</span> <span class=\"n\">w</span><span class=\"o\">)),</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">i</span> <span class=\"bp\">•</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>or maybe</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Basis</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Submodule.span</span> <span class=\"n\">F</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"n\">w</span><span class=\"o\">),</span>\n</code></pre></div>\n<p>the same way.<br>\nThen you can apply this to <code>W := Module.AEval' f</code> and use the F-LinearEquiv (or abuse defeq) between <code>W</code> and <code>V</code> and get the result in terms of <code>f^[n]</code>. This definitely seems a reasonable refactoring to do.</p>",
        "id": 419946505,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1707175369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Basis.20for.20span.20of.20iterated.20linear.20map/near/419935073\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Basis.20for.20span.20of.20iterated.20linear.20map/near/419934878\">said</a>:</p>\n<blockquote>\n<p>What is <code>≪≫ₗ</code>??</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearEquiv.trans#doc\">docs#LinearEquiv.trans</a></p>\n</blockquote>\n<p>This is motivated by the notation for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Iso.trans#doc\">docs#CategoryTheory.Iso.trans</a></p>",
        "id": 419948760,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1707176746
    }
]