[
    {
        "content": "<p>I want to be able to write something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">succ_squared</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>with the result that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">succ_squared</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there any way to do this?</p>",
        "id": 433144444,
        "sender_full_name": "Jeremy Kahn",
        "timestamp": 1713109908
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">succ_squared</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">letI</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">succ_squared</span>\n</code></pre></div>\n<p><code>letI</code> makes sure that the term is inlined, i.e., there is no <code>let</code> in the final definition.</p>",
        "id": 433144757,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1713110172
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> ! I'm wondering now what happens if you use let (instead of letI). If the <code>let</code> is in the conclusion it can be accessed with intro and simp:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">):</span> <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> ⊢ let y := x + 1; y * y &gt; 0 -/</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> y : ℕ := x + 1</span>\n<span class=\"cm\">  ⊢ y * y &gt; 0 -/</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">y</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but when the <code>let</code> is in a hypothesis I don't know how to access it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">y</span><span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">;</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> hy : let y := x + 1; y * y = 0</span>\n<span class=\"cm\">  ⊢ False-/</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I tried <code>rcases</code> and <code>rintro</code>, but these do not appear to work.</p>",
        "id": 433149467,
        "sender_full_name": "Jeremy Kahn",
        "timestamp": 1713114252
    },
    {
        "content": "<p><code>extract_lets</code> and <code>unfold_let</code> in mathlib will do roughly what you want.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"o\">:</span> <span class=\"k\">let</span> <span class=\"n\">y</span><span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">;</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">):</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">extract_lets</span> <span class=\"n\">y</span> <span class=\"n\">at</span> <span class=\"n\">hy</span> <span class=\"c1\">-- or unfold_let at hy</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hy</span>\n</code></pre></div>",
        "id": 433151559,
        "sender_full_name": "Richard Osborn",
        "timestamp": 1713116152
    },
    {
        "content": "<p><code>dsimp only at hy</code> is the standard way to apply standard reductions, like substituting <code>let</code>s or applying <code>fun</code>s</p>",
        "id": 433155098,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713119526
    },
    {
        "content": "<p>But <code>extract_lets</code> is definitely for extracting a let out of an expression and creating a new local variable. It can be paired with <code>lift_lets</code> if the <code>let</code>s are deeper in the expression.</p>",
        "id": 433155135,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713119592
    },
    {
        "content": "<p><code>simp at hy</code> gets rid of the let too.</p>",
        "id": 433161057,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1713125069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432565\">Jeremy Kahn</span> has marked this topic as resolved.</p>",
        "id": 433169877,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713133053
    },
    {
        "content": "<p><code>extract_lets</code> seems like the best bet for extracting a let while preserving it.</p>",
        "id": 433170017,
        "sender_full_name": "Jeremy Kahn",
        "timestamp": 1713133166
    }
]