[
    {
        "content": "<p>I am trying to prove the following, which feels like it probably exists somewhere in std or mathlib already, but I just can't find it, and Loogle doesn't turn up anything either. Without notation, this is <code>Eq (Eq.rec x (Eq.rec h‚ÇÅ h‚ÇÇ)) (Eq.rec (Eq.rec x h‚ÇÅ) h‚ÇÇ)</code>.<br>\nThis is actually a xy problem, with the x problem being <code>h ‚ñ∏ h.symm ‚ñ∏ T = T</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_cast_trans</span> <span class=\"o\">{</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">h‚ÇÅ</span><span class=\"o\">)</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">x</span>\n  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 411362118,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704457815
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">eq_cast_trans</span> <span class=\"o\">{</span><span class=\"n\">h‚ÇÅ</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h‚ÇÇ</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">h‚ÇÅ</span><span class=\"o\">)</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h‚ÇÇ</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">h‚ÇÅ</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">x</span>\n  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h‚ÇÅ</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h‚ÇÇ</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>but are you asking for the proof, or are you asking why you don‚Äôt find something like this in the library?<br>\n(I don‚Äôt have an answer for the latter; I think I searched for it myself at some point in the past.)</p>",
        "id": 411362225,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1704457898
    },
    {
        "content": "<p>Oh wow that was quick! I was asking for the proof, but if you have tips for finding theorems like these I'm all ears. So far I'm just trying to guess the theorem name and if that doesn't turn anything up, I am hitting a wall haha.</p>",
        "id": 411362532,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704458053
    },
    {
        "content": "<p>Something to watch out for with <code>‚ñ∏</code> is that it's not just notation, it entails running an elaborator that tries rewriting using a few different approaches.</p>",
        "id": 411363792,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704458642
    },
    {
        "content": "<p>Yeah I noticed that sometimes it applies <code>Eq.symm</code> and so on.</p>",
        "id": 411363903,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704458679
    },
    {
        "content": "<p>Could you xy further? Why do you have a <code>h ‚ñ∏ h.symm ‚ñ∏ T</code> term? Could you be better served having a custom <code>cast</code> definition that rewrites a type's indices, for example?</p>",
        "id": 411363910,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704458681
    },
    {
        "content": "<p>I had another instance of the same problem as in <a href=\"#narrow/stream/270676-lean4/topic/rw.20term.20depended.20on.20by.20other.20argument/near/409268800\">this thread</a>, just a bit more complicated, and that somehow resulted in this situation. I can try to minimise today's problem if you want? Alternatively, it's one (large) self-contained Lean file.</p>",
        "id": 411364301,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704458868
    },
    {
        "content": "<p>It looks like I already <a href=\"#narrow/stream/270676-lean4/topic/rw.20term.20depended.20on.20by.20other.20argument/near/409270721\">made the cast suggestion</a></p>",
        "id": 411366580,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704459894
    },
    {
        "content": "<p>While making a <code>cast</code> means you don't get library lemmas and have to write your own, there aren't so many general lemmas about Eq.rec that you'd be missing out on.</p>",
        "id": 411366671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704459958
    },
    {
        "content": "<p>I hadn't even thought of making a custom cast for this. I might, it is a good suggestion. I will try to finish the proof with what I have thus far, and then try to extract a useful specialised cast.<br>\nHowever, the whole reason I need two casts in the first place is (as far as I understand it, i.e. not very well) because of a definition which doesn't reduce even though I think it should, and thus I have to use <code>def f | args =&gt; (proof of reduction rule) ‚ñ∏ (rhs of f)</code>. This cast then spreads and messes up the approach from the other thread. I could come back or open another thread once I have a better grasp of what's going on, because maybe I just got some basics very very wrong. There is also a failure to generate injective theorems for an inductive type that is at the heart of this, that might be related.</p>",
        "id": 411367493,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704460386
    },
    {
        "content": "<p>...meanwhile the agda code that I am porting to Lean just shrugs this off as completely trivial.</p>",
        "id": 411367648,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704460477
    },
    {
        "content": "<p>Is there a recursive definition here? Sometimes all you need to do is <code>cases</code> on enough arguments to \"unlock\" reduction, and do <code>rfl</code> on each case.</p>",
        "id": 411367848,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704460579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416280\">Max Nowak üêâ</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28h.E2.82.82.20.E2.96.B8.20h.E2.82.81.29.20.E2.96.B8.20x.20.3D.20h.E2.82.82.20.E2.96.B8.20.28h.E2.82.81.20.E2.96.B8.20x.29/near/411367493\">said</a>:</p>\n<blockquote>\n<p>There is also a failure to generate injective theorems for an inductive type that is at the heart of this, that might be related.</p>\n</blockquote>\n<p>That possible sounds like a big problem. Is that something you think is a Lean bug?</p>",
        "id": 411367997,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704460654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28h.E2.82.82.20.E2.96.B8.20h.E2.82.81.29.20.E2.96.B8.20x.20.3D.20h.E2.82.82.20.E2.96.B8.20.28h.E2.82.81.20.E2.96.B8.20x.29/near/411367997\">said</a>:</p>\n<blockquote>\n<p>That possible sounds like a big problem. Is that something you think is a Lean bug?</p>\n</blockquote>\n<p>Yeah I am pretty sure. This is the third time I encounter the same or similar bug with generating injective theorems. I should open an issue about it some day.</p>",
        "id": 411368249,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704460784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.28h.E2.82.82.20.E2.96.B8.20h.E2.82.81.29.20.E2.96.B8.20x.20.3D.20h.E2.82.82.20.E2.96.B8.20.28h.E2.82.81.20.E2.96.B8.20x.29/near/411367848\">said</a>:</p>\n<blockquote>\n<p>Is there a recursive definition here? Sometimes all you need to do is <code>cases</code> on enough arguments to \"unlock\" reduction, and do <code>rfl</code> on each case.</p>\n</blockquote>\n<p>Yes and no. I have the following, but if I get rid of the recursive branch, then the <code>h ‚ñ∏  VarD v</code> in the non-recursive case is still necessary, and removing the cast breaks. This is also not a theorem, but an actual function.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Tm‚ÇõD</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">var</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"bp\">‚ñ∏</span>  <span class=\"n\">Var‚ÇõD</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- this was the recursive branch</span>\n</code></pre></div>",
        "id": 411369220,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704461264
    },
    {
        "content": "<p>This is simplifying a lot. I think I'll try to get it working in this ugly way first.</p>",
        "id": 411369362,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704461325
    },
    {
        "content": "<p>You have helped greatly btw, I appreciate it a lot!</p>",
        "id": 411369385,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704461336
    },
    {
        "content": "<p>So far: Inductive type <code>Tm‚Çõ</code> fails to generate injective theorems. Recursive definition <code>Tm‚ÇõA</code> has (imo) broken reduction behaviour, need to use casts with equation theorems. <code>Tm‚ÇõD</code> completely fails to generate equation theorems; it uses <code>Tm‚ÇõA</code> in its type. My next step would be to prove the equation theorems for <code>Tm‚ÇõD</code>, but I feel like this is a spiral that will never end and cause problems in the future.</p>",
        "id": 411376497,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704464066
    },
    {
        "content": "<p>can you post your code? this seems like a major bug</p>",
        "id": 411377101,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704464363
    },
    {
        "content": "<p><a href=\"https://github.com/Kiiyya/lean-reflection/blob/6846a0670183ecc523ca6df698475bfdfb85be95/Reflection/Mutual.lean#L264-L269\">Here is the code</a>, it is a rather large but self-contained file. If you search for <code>!</code> you will find the relevant trouble points (four of them). I also left three relevant errors which should help navigate a little.<br>\nI copy-pasted the original Agda bits into comments for reference.</p>",
        "id": 411379746,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704465548
    },
    {
        "content": "<p>I can try to minimise it if this is too much.</p>",
        "id": 411380073,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704465685
    },
    {
        "content": "<p>Nevermind, I managed to make it generate equation theorems after all. It's still a bit of a paper cut that a definition typechecks just fine but then fails to derive equation theorems. And the other issues remain.</p>",
        "id": 411387152,
        "sender_full_name": "Max Nowak üêâ",
        "timestamp": 1704468397
    }
]