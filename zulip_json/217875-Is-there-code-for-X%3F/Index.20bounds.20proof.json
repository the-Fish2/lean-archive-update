[
    {
        "content": "<p>Is there  a better way to handle index bound proofs in this example?<br>\nIdeally, index bounds would be derived from the set membership.<br>\nHere, I'm forced to use a dependent type for the index, and then convert it to <code>Finset.attach</code> and back, which makes the proof more complicated.<br>\nI like how using <code>Fin</code> index automatically derives the boundary proof, but Fin ranges from 0, which is not the case here.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">xs.size</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i.1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Ico</span> <span class=\"n\">i</span> <span class=\"n\">xs.size</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i.1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span>\n <span class=\"o\">:=</span> <span class=\"k\">calc</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">xs.size</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i.1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span>\n    <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Ico</span> <span class=\"n\">i</span> <span class=\"n\">xs.size</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"n\">i.1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">aesop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_rw</span><span class=\"o\">[</span><span class=\"n\">univ_eq_attach</span><span class=\"o\">,</span> <span class=\"n\">sum_attach</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"gr\">sorry</span><span class=\"o\">)]</span>\n                                                     <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">Finset.sum_eq_sum_Ico_succ_bot</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"gr\">sorry</span><span class=\"o\">)]</span><span class=\"bp\">;</span>\n                                                     <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sum_attach</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"n\">i</span> <span class=\"n\">xs.size</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">[</span><span class=\"bp\">·</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"gr\">sorry</span><span class=\"o\">)]</span><span class=\"bp\">;</span>\n                                                     <span class=\"n\">assumption</span>\n</code></pre></div>",
        "id": 435447545,
        "sender_full_name": "Vlad",
        "timestamp": 1714070683
    },
    {
        "content": "<p>Perhaps you can make a set of <code>Fin xs.size</code>?</p>",
        "id": 435678591,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1714179394
    },
    {
        "content": "<p>Unfortunately, that only works for indices starting from 0.</p>",
        "id": 435683618,
        "sender_full_name": "Vlad",
        "timestamp": 1714184268
    },
    {
        "content": "<p>Here's another attempt at this (if I understood the suggestion right)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">((</span><span class=\"n\">Ico</span> <span class=\"mi\">0</span> <span class=\"n\">xs.size</span><span class=\"o\">):</span> <span class=\"n\">Finset</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"n\">xs.size</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This results in an error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">OfNat</span> <span class=\"o\">(</span><span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">Array.size</span> <span class=\"n\">xs</span><span class=\"o\">))</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Any Nat literal coercion (like in <code>∑i : Ico (i+1) xs.size</code>) will trigger this error.</p>",
        "id": 436125791,
        "sender_full_name": "Vlad",
        "timestamp": 1714419927
    },
    {
        "content": "<p>Isn't that just Finset.univ?</p>",
        "id": 436126395,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714420117
    },
    {
        "content": "<p>Not sure I understand. Could you show how to use <code>Finset.univ</code> in the first example?</p>",
        "id": 436127286,
        "sender_full_name": "Vlad",
        "timestamp": 1714420406
    },
    {
        "content": "<p>My goal is to remove <code>(by aesop)</code> and <code>sorry</code> in all instances, including <code>rw</code> applications. It would be great if Lean could derive those proofs automatically or at least make them as side goals instead of proving them \"in-line\".</p>",
        "id": 436127911,
        "sender_full_name": "Vlad",
        "timestamp": 1714420621
    },
    {
        "content": "<p>I was only looking at your latest message. Maybe this is a start for your first question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span> <span class=\"n\">Finset</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"o\">(</span><span class=\"n\">xs.size</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">xs.get</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">Ioi</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">xs.get</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"n\">j</span> <span class=\"k\">in</span> <span class=\"n\">Ici</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">xs.get</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 436128750,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714420909
    },
    {
        "content": "<p>(and then the proof is <code>add_sum_Ioi_eq_sum_Ici ..</code>)</p>",
        "id": 436129036,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1714421005
    },
    {
        "content": "<p>The docs say </p>\n<blockquote>\n<p>From the point of view of proofs <code>Array α</code> is just a wrapper around <code>List α</code>.</p>\n</blockquote>\n<p>Doesn't that suggest that this sort of work might better be carried out on the underlying list?</p>",
        "id": 436130468,
        "sender_full_name": "A.",
        "timestamp": 1714421517
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span>. While your example is equivalent to my problem, it's less applicable for my use case. I'm using Lean for program refinement, which requires a series of transformation of the original boolean expression.<br>\nIn this context, I need to handle expressions in their original form regardless of their structure. For instance, if the expression includes a quantifier with range <code>Ico 0 n</code>, and the transformation increments <code>n</code>, then I would like to preserve the original <code>Ico</code> construct at least in the initial transformation step. I hope this clarifies my situation.</p>\n<p>As a separate question for my own understanding, why does replacing <code>xs.get</code> with square brackets in your example require proof of index boundaries?</p>",
        "id": 436134683,
        "sender_full_name": "Vlad",
        "timestamp": 1714423044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111433\">@Alistair Tucker</span> Just tried replacing Array with List, no significant difference. Index bounds proofs still needed.</p>",
        "id": 436135256,
        "sender_full_name": "Vlad",
        "timestamp": 1714423248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111433\">Alistair Tucker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Index.20bounds.20proof/near/436130468\">said</a>:</p>\n<blockquote>\n<p>The docs say </p>\n<blockquote>\n<p>From the point of view of proofs <code>Array α</code> is just a wrapper around <code>List α</code>.</p>\n</blockquote>\n<p>Doesn't that suggest that this sort of work might better be carried out on the underlying list?</p>\n</blockquote>\n<p>The <code>Array</code> vs <code>List</code> difference is completely orthogonal to Vlad's issue</p>",
        "id": 436135607,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714423389
    },
    {
        "content": "<p>Obviously I meant to suggest that he might not face that particular issue if he were able to reformulate the problem. Am I wrong?</p>",
        "id": 436137179,
        "sender_full_name": "A.",
        "timestamp": 1714423978
    },
    {
        "content": "<p>I believe so, yes. The <code>List</code> API uses the same mechanisms to check indices are in-bound</p>",
        "id": 436137468,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1714424087
    },
    {
        "content": "<p>Working with lists it is not so natural to use indices at all.</p>",
        "id": 436137692,
        "sender_full_name": "A.",
        "timestamp": 1714424168
    },
    {
        "content": "<p>Thanks for the suggestion, Alistair. Now I understand better what you mean. Unfortunately, I do need to use indexed access for my problem.</p>",
        "id": 436138100,
        "sender_full_name": "Vlad",
        "timestamp": 1714424313
    }
]