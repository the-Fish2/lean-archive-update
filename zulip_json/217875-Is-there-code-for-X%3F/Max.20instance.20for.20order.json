[
    {
        "content": "<p>Do we have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">a</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Max</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 434562604,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713679073
    },
    {
        "content": "<p>What would the semantics be? What if I write <code>max x y</code> and <code>x</code> and <code>y</code> are incomparable? (e.g. <code>x y : Set Nat</code>, <code>x := {3}</code>, and <code>y := {5}</code>)</p>",
        "id": 434562911,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713679403
    },
    {
        "content": "<p>Well we have this function in the library</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">Preorder</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">DecidableRel</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `maximum l` returns a `WithBot α`, the largest element of `l` for nonempty lists, and `⊥` for</span>\n<span class=\"sd\">`[]`  -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">maximum</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">WithBot</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">argmax</span> <span class=\"n\">id</span> <span class=\"n\">l</span>\n</code></pre></div>\n<p>so I guess the same semantics as that, which I imagine is <code>if a &lt; b then b else a</code></p>",
        "id": 434562994,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713679521
    },
    {
        "content": "<p>Seems like if we can define a function called maximum, we should be able to define <code>Max</code></p>",
        "id": 434563049,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713679565
    },
    {
        "content": "<p>Hmm, if I am reading you right, are you saying that this <code>maximum</code> function returns a singleton on <code>[{3},{5}]</code>? That's pretty nonintuitive.</p>",
        "id": 434563296,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713679866
    },
    {
        "content": "<p>Yep, here it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">List.maximum</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">Multiset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[{</span><span class=\"mi\">3</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"mi\">5</span><span class=\"o\">}]</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">List.maximum</span> <span class=\"n\">List.argmax</span> <span class=\"n\">List.argAux</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 434563669,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713680344
    },
    {
        "content": "<p>Frankly I am not a fan of Maximum returning a type not the same as the type of the list, I would prefer it require <code>Bot</code> and <code>Max</code> typeclass arguments and return the same type.</p>",
        "id": 434563741,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713680420
    },
    {
        "content": "<p>From a programming point of view, I think it's reasonable to be expected to handle the empty case separately. e.g. a signed 32-bit integer technically has a bottom element in -2,147,483,648, but if I'm taking the minimum of a list of them I probably want to error if it's empty, not produce that bottom element. If we want to draw off of other languages, Rust's <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.max\"><code>Iterator::max</code></a> returns <code>Option</code> which is the moral equivalent of <code>WithBot</code> here.</p>",
        "id": 434564040,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713680768
    },
    {
        "content": "<p>And it does seem like these functions should mostly be considered from a programming point of view. I think you would always prefer a function with infimum/supremum semantics for mathematics.</p>",
        "id": 434564117,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713680855
    },
    {
        "content": "<p>Well I take your point, but it is <code>math</code>lib, and I think we are generally oriented toward the more mathy way of doing things.  If this were to be moved to Std or Core I would certainly agree it should return an option.</p>",
        "id": 434564343,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713681077
    },
    {
        "content": "<p>Related is that I found this through <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/BigOperators.html#Polynomial.degree_list_sum_le\">Polynomial.degree_list_sum_le</a> which looks like it would be cleaner if there was <code>degree</code> on both sides, which seems like it would be easier  if there was a maximum function that preserved the type.</p>",
        "id": 434564444,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713681202
    },
    {
        "content": "<p>I am not sure if there is a type common in programming where the above clear strangeness pops up. A bitmask type perhaps?</p>",
        "id": 434564553,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713681327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434563296\">said</a>:</p>\n<blockquote>\n<p>Hmm, if I am reading you right, are you saying that this <code>maximum</code> function returns a singleton on <code>[{3},{5}]</code>? That's pretty nonintuitive.</p>\n</blockquote>\n<p>The use case comes from <span class=\"user-mention\" data-user-id=\"398581\">@Mantas Baksys</span>. The point is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.maximum#doc\">docs#List.maximum</a> returns <em>a</em> maximum element for nonempty lists. So unless the list is a chain it doesn't return something that's greater than anything in the list.</p>",
        "id": 434565040,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713681846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434564444\">said</a>:</p>\n<blockquote>\n<p>Related is that I found this through <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/BigOperators.html#Polynomial.degree_list_sum_le\">Polynomial.degree_list_sum_le</a> which looks like it would be cleaner if there was <code>degree</code> on both sides, which seems like it would be easier  if there was a maximum function that preserved the type.</p>\n</blockquote>\n<p>Aren't you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Tropical#doc\">docs#Tropical</a> by any chance?</p>",
        "id": 434565072,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713681900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434564553\">said</a>:</p>\n<blockquote>\n<p>I am not sure if there is a type common in programming where the above clear strangeness pops up. A bitmask type perhaps?</p>\n</blockquote>\n<p>So the question here is whether there is a type in programming for which comparison is common that is not a linear order? Floating point types are a classic example because NaN is incomparable to every element, including itself. So e.g. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Float.nan</span> <span class=\"o\">:</span> <span class=\"n\">Float</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span> <span class=\"bp\">/</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Preorder</span> <span class=\"n\">Float</span> <span class=\"n\">where</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">List.maximum</span> <span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">Float.nan</span><span class=\"o\">]</span> <span class=\"c1\">-- ↑0.000000</span>\n<span class=\"k\">#eval</span> <span class=\"n\">List.maximum</span> <span class=\"o\">[</span><span class=\"n\">Float.nan</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">]</span> <span class=\"c1\">-- ↑NaN</span>\n</code></pre></div>",
        "id": 434565381,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713682251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434564444\">said</a>:</p>\n<blockquote>\n<p>Related is that I found this through <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/BigOperators.html#Polynomial.degree_list_sum_le\">Polynomial.degree_list_sum_le</a> which looks like it would be cleaner if there was <code>degree</code> on both sides, which seems like it would be easier  if there was a maximum function that preserved the type.</p>\n</blockquote>\n<p>I think this should be restated in terms of a <code>List.supremum</code> like so</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.supremum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderBot</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊔</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">⊥</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Polynomial.degree_list_sum_le'</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Polynomial</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">Polynomial.degree</span> <span class=\"o\">(</span><span class=\"n\">List.sum</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">List.supremum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">Polynomial.degree</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 434565715,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713682634
    },
    {
        "content": "<p>Hmm I see. If <code>List.maximum</code> was stated in terms of <code>Max</code> and <code>Bot</code>, then all we would need is an instance from <code>SemilatticeSup</code> to <code>Max</code> and it would just be a generalization of my <code>List.supremum</code></p>",
        "id": 434566351,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1713683389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434565072\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434564444\">said</a>:</p>\n<blockquote>\n<p>Related is that I found this through <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/BigOperators.html#Polynomial.degree_list_sum_le\">Polynomial.degree_list_sum_le</a> which looks like it would be cleaner if there was <code>degree</code> on both sides, which seems like it would be easier  if there was a maximum function that preserved the type.</p>\n</blockquote>\n<p>Aren't you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Tropical#doc\">docs#Tropical</a> by any chance?</p>\n</blockquote>\n<p>Yes I am finally trying to add the structure from <a href=\"#narrow/stream/116395-maths/topic/Tropically.20degree-bound.20polynomials/near/399808368\">this</a> thread and adding an equivalence to lists.</p>",
        "id": 434600192,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713715746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434565715\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Max.20instance.20for.20order/near/434564444\">said</a>:</p>\n<blockquote>\n<p>Related is that I found this through <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Polynomial/BigOperators.html#Polynomial.degree_list_sum_le\">Polynomial.degree_list_sum_le</a> which looks like it would be cleaner if there was <code>degree</code> on both sides, which seems like it would be easier  if there was a maximum function that preserved the type.</p>\n</blockquote>\n<p>I think this should be restated in terms of a <code>List.supremum</code> like so</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">List.supremum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">SemilatticeSup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">OrderBot</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">⊔</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">⊥</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Polynomial.degree_list_sum_le'</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Polynomial</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">Polynomial.degree</span> <span class=\"o\">(</span><span class=\"n\">List.sum</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">List.supremum</span> <span class=\"o\">(</span><span class=\"n\">List.map</span> <span class=\"n\">Polynomial.degree</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Supremum seems like a good name. Is there any precedent for this in <code>Finset</code>? - it would be best to keep the names consistent if possible.</p>",
        "id": 434601344,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1713716637
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sup#doc\">docs#Finset.sup</a></p>",
        "id": 434602360,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1713717500
    }
]