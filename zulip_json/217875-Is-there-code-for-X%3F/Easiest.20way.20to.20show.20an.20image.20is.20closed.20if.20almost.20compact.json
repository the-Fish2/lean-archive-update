[
    {
        "content": "<p>I have a function <code>f : ℂ → ℂ</code> analytic for <code>r ≤ abs z</code>, which converges to infinity at infinity (i.e., it has a pole, but I should only need topological properties here).  What's the easiest way to show that <code>f '' {z | r ≤ abs z}</code> is closed?  Fundamentally this is almost the image of a compact set, except that infinity is removed, but that's fine as <code>f</code> also approaches infinity.</p>\n<p>In other words, I want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">closed_image</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">Complex.abs</span> <span class=\"n\">z</span><span class=\"o\">})</span>\n    <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Filter.cocompact</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Filter.cocompact</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"bp\">|</span> <span class=\"n\">r</span> <span class=\"bp\">≤</span> <span class=\"n\">Complex.abs</span> <span class=\"n\">z</span><span class=\"o\">})</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I can do this with calculations, but it seems like there should be an easy abstract way to get this.</p>",
        "id": 423105426,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708727616
    },
    {
        "content": "<p>Better version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">closed_image'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Filter.cocompact</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Filter.cocompact</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 423105842,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708727867
    },
    {
        "content": "<p>EDIT: this is correct, but already proven in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isProperMap_iff_tendsto_cocompact#doc\">docs#isProperMap_iff_tendsto_cocompact</a>, so one should not use it directly.</p>\n<p><del>The way I would do it is:</del><br>\n<del>- <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is compactly generated (because locally compact), so you just need to check that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>∩</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">f(S)\\cap K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is closed for any compact <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span></del><br>\n<del>- <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo stretchy=\"false\">)</mo><mo>∩</mo><mi>K</mi><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>S</mi><mo>∩</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(S) \\cap K = f(S \\cap f^{-1}(K))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∩</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">))</span></span></span></span></del><br>\n<del>- <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is proper so the latter is compact as the image of a compact set</del></p>",
        "id": 423106392,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708728215
    },
    {
        "content": "<p>As I just mentioned <a href=\"#narrow/stream/116395-maths/topic/Is.20there.20a.20name.20for.20.22closure.20is.20the.20union.20of.20.60Specializes.60.22.3F/near/423047645\">here</a> we don't have compactly generated spaces, but really we have everything to state all of this for (weakly) locally compact spaces, even though it is really about compactly generated spaces.</p>",
        "id": 423106590,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708728329
    },
    {
        "content": "<p>I have PRs to review before going to bed so if you or someone else wants to have fun with this please do! The cocompact assumption should be replaced by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsProperMap#doc\">docs#IsProperMap</a> (this is equivalent in this setting, but it's the right concept in general), and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> by any <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WeaklyLocallyCompactSpace#doc\">docs#WeaklyLocallyCompactSpace</a></p>",
        "id": 423106738,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708728439
    },
    {
        "content": "<p>Wait, I am dumb (or tired, let's say tired)</p>",
        "id": 423107121,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708728689
    },
    {
        "content": "<p>I'm redoing the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=isProperMap_iff_tendsto_cocompact#doc\">docs#isProperMap_iff_tendsto_cocompact</a> <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 423107235,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708728740
    },
    {
        "content": "<p>So you should really use that and then <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsProperMap.isClosedMap#doc\">docs#IsProperMap.isClosedMap</a></p>",
        "id": 423107290,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708728775
    },
    {
        "content": "<p>Hmmm, except you only have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ContinuousOn#doc\">docs#ContinuousOn</a>...</p>",
        "id": 423107625,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708729001
    },
    {
        "content": "<p>This sounds like a good reason to define <code>IsProperMapOn</code>, but in the mean time I should we should be able to circumvent that.</p>",
        "id": 423108565,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708729586
    },
    {
        "content": "<p>Yes, I’m not continuous everywhere unfortunately (f has a natural boundary of dimension 2 at radius = 1).</p>",
        "id": 423109202,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708730059
    },
    {
        "content": "<p>I think the IsProperMap machinery would lift straightforwardly but tediously to IsProperMapOn, but we don’t have that written down.</p>",
        "id": 423109281,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708730129
    },
    {
        "content": "<p>I'm working on a quick fix, but indeed the proper fix is <code>IsProperMapOn</code>. That shouldn't be too hard but a bit annoying maybe.</p>",
        "id": 423109358,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708730165
    },
    {
        "content": "<p>I’ll take a look at that.</p>",
        "id": 423109410,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708730220
    },
    {
        "content": "<p>Here's my proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Set</span>\n\n<span class=\"c1\">-- closed inducing is enough, should be replace/be used in the proof of `Homeomorph.isClosedMap`?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ClosedEmbedding.isProperMap</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ClosedEmbedding</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsProperMap</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isProperMap_iff_isClosedMap_and_compact_fibers</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hf.continuous</span><span class=\"o\">,</span> <span class=\"n\">hf.isClosedMap</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">hf.isCompact_preimage</span> <span class=\"n\">isCompact_singleton</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- This direction of `isProperMap_iff_tendsto_cocompact` requires no assumptions</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">IsProperMap.tendsto_cocompact</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsProperMap</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">hasBasis_cocompact.tendsto_right_iff.mpr</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">hK</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">hf.isCompact_preimage</span> <span class=\"n\">hK</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">compl_mem_cocompact</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">IsProperMap.comap_cocompact_eq</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">IsProperMap</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">cocompact</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">cocompact</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">comap_cocompact_le</span> <span class=\"n\">hf.continuous</span><span class=\"o\">)</span> <span class=\"n\">hf.tendsto_cocompact.le_comap</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">closed_image'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">ContinuousOn</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">IsClosed</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Filter.cocompact</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Filter.cocompact</span> <span class=\"n\">ℂ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">continuousOn_iff_continuous_restrict</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">range_restrict</span><span class=\"o\">]</span>\n  <span class=\"k\">suffices</span> <span class=\"n\">IsProperMap</span> <span class=\"o\">(</span><span class=\"n\">s.restrict</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"k\">from</span> <span class=\"n\">this.isClosedMap.closed_range</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">isProperMap_iff_tendsto_cocompact</span><span class=\"o\">,</span> <span class=\"c1\">-- why is this slow???</span>\n      <span class=\"bp\">←</span> <span class=\"n\">hs.closedEmbedding_subtype_val.isProperMap.comap_cocompact_eq</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hi.comp</span> <span class=\"n\">tendsto_comap</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 423111426,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708731609
    },
    {
        "content": "<p>The three lemmas before can be useful (especially the first one) so this experiment is not completely useless, but really I can't envision any good way to make this fit into the API without developping <code>IsProperMapOn</code>. Fortunately, proofs using filters are often really easy to reduce to subsets, and most of the proof in this file are very filter-y</p>",
        "id": 423111571,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708731720
    },
    {
        "content": "<p>I supposed I need <code>IsClosedMap</code> as well.</p>\n<p>What's the right way to spell \"t is closed relative to s\"?  I typically do <code>s ∩ closure t ⊆ t</code>, but this unfortunately mentions <code>t</code> twice.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Set</span> <span class=\"n\">Filter</span> <span class=\"n\">Function</span> <span class=\"n\">Topology</span> <span class=\"n\">Filter</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- `f : α → β` is closed on `s : Set α` if it sends relatively closed sets to closed sets -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">IsClosedMapOn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">closure</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">IsClosed</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I suppose the alternative is just <code>IsClosedMap (s.restrict f)</code>.</p>",
        "id": 423166891,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708778533
    },
    {
        "content": "<p>Hmmmm, I should have anticipated this, this is starting to turn into a really big refactor which we may want to think about twice before doing… We have multiple ways to talk about being relatively closed subsets, I’d say the easiest one to deal with are \"preimage by <code>Subtype.val</code> is closed\" and \"cluster points in <code>s</code> of <code>principal t</code> are in <code>t</code>\"</p>",
        "id": 423169833,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708781300
    },
    {
        "content": "<p>I may skip it for now, and if it’s okay I’ll PR your lemmas above.</p>",
        "id": 423169878,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1708781352
    },
    {
        "content": "<p>Maybe the best for now is not to make any new definition for closed maps and use the restriction, maybe adding one or two lemmas about equivalent conditions for a restriction to be closed, and only focusing on proper maps</p>",
        "id": 423169918,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708781386
    },
    {
        "content": "<p>You can also use what I did above indeed. I’m just not sure how best to state <code>closure_image'</code> for the library</p>",
        "id": 423170032,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1708781456
    }
]