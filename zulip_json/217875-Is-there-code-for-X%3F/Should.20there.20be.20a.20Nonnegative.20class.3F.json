[
    {
        "content": "<p>Working with <code>NNReal</code> and various non-negativity side conditions are somewhat annoying, though with the advent of <code>positivity</code> and <code>gcongr</code> things are better.  I wonder if perhaps it's worth it to make a <code>Nonnegative</code> class (similar other classes such as <code>Finite</code> or <code>Nonempty</code>) so that one could take advantage of instance inference to automate much of the nonnegativity side condition work.  That is, to have some basic wrapper code such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">Nonnegative</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">nonneg</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nonnegative_of_nonneg</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"n\">x</span> <span class=\"n\">where</span>\n  <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nonneg</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Nonnegative</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Nonnegative.nonneg</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"mi\">0</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.le</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"mi\">1</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le_one</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"mi\">2</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">zero_le_two</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"n\">n</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.cast_nonneg</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">NNReal</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"n\">x</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">x.2</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">:</span><span class=\"n\">Nonnegative</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">:</span><span class=\"n\">Nonnegative</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">add_nonneg</span> <span class=\"n\">hx.nonneg</span> <span class=\"n\">hy.nonneg</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">:</span><span class=\"n\">Nonnegative</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">:</span><span class=\"n\">Nonnegative</span> <span class=\"n\">y</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">mul_nonneg</span> <span class=\"n\">hx.nonneg</span> <span class=\"n\">hy.nonneg</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">nonneg</span> <span class=\"o\">:=</span> <span class=\"n\">sq_nonneg</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">abs_of_nonneg'</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Nonnegative</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">abs_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">nonneg</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>etc., and then one obtains automatic nonnegativity statements such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nonnegative</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">infer_instance</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"n\">nonneg</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"bp\">|</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>and so forth, thus bypassing a lot of appeals to the <code>positivity</code> tactic.  Are there any downsides to introducing such a class?</p>\n<p>Incidentally, while playing around with this concept, I discovered that <code>Complex.abs_nonneg</code> does not seem to exist:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Complex.abs_nonneg</span> <span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">Complex.abs</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">positivity</span>\n</code></pre></div>\n<p>I don't know if this was by design or is a simple omission.</p>",
        "id": 409946962,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703546524
    },
    {
        "content": "<p>re: your last point, I'm wondering if perhaps the intention was for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AbsoluteValue.nonneg#doc\">docs#AbsoluteValue.nonneg</a> to be used (since <code>Complex.abs</code> returns an <code>AbsoluteValue</code>)</p>",
        "id": 409950416,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1703549780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Should.20there.20be.20a.20Nonnegative.20class.3F/near/409950416\">said</a>:</p>\n<blockquote>\n<p>re: your last point, I'm wondering if perhaps the intention was for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AbsoluteValue.nonneg#doc\">docs#AbsoluteValue.nonneg</a> to be used (since <code>Complex.abs</code> returns an <code>AbsoluteValue</code>)</p>\n</blockquote>\n<p>Indeed, <code>AbsoluteValue.nonneg _ z</code> is a term for the lemma.  (For some reason <code>exact?</code> timed out before finding it, though.)  Mathlib/Data/Complex/Abs.lean also contains a <code>Complex.abs_nonneg'</code> lemma that establishes exactly this, but it has been set to <code>private</code> for some reason.</p>",
        "id": 409950677,
        "sender_full_name": "Terence Tao",
        "timestamp": 1703549945
    },
    {
        "content": "<p>I think this is usually avoided, there's a note somewhere related to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fact#doc\">docs#Fact</a> that says something along the lines of \"the type-class system is not meant to be a general FOL solver\"; on the other hand I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a> has been  success since it was introduced in FLT-regular to deal with casts not being zeros. I think there's a difficult balance to be found.</p>",
        "id": 409950851,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703550056
    },
    {
        "content": "<p>We have <code>positivity</code> tactic instead of the <code>Nonnegative</code>/<code>Positive</code> typeclass.</p>",
        "id": 409955313,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703552479
    },
    {
        "content": "<p>And you can use, e.g., <code>simp (disch := positivity) [my_lemmas]</code></p>",
        "id": 409955639,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703552640
    },
    {
        "content": "<p>In general, we avoid typeclasses for this kind of things, for performance and flexibility reasons. That's why also we don't have a measurable typeclass, which could be used to discharge automatically measurability goals. More precisely, typeclasses will try all the possible ways to get to the desired goal given the registered instances (which in many situations can lead to very bad performance), and they will only use the registered instances (which means that in many situations it won't be able to solve the goal). This means more fancy stuff using facts in the context or some kind of universal arguments can not be discharged with typeclasses -- for instance, you can't have a typeclass that will notice that <code>x^n</code> is nonnegative for any concrete even number <code>n</code>.</p>\n<p>In this respect, lemmas with usual arguments but a default tactic discharger (like we did with <code>finiteness</code> in the PFR project) is often a better design.</p>",
        "id": 409985713,
        "sender_full_name": "Sébastien Gouëzel",
        "timestamp": 1703575260
    }
]