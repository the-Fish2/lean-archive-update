[
    {
        "content": "<p>I'm looking to see if something like <code>Metric.tendsto_nhds'</code> below exists in Mathlib already:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Metric</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PseudoMetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Metric.tendsto_nhds'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"n\">u</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">ε</span> <span class=\"k\">in</span> <span class=\"bp\">𝓝</span><span class=\"o\">[</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n</code></pre></div>\n<p>This is basically a restatement of usual <code>eps</code> convergence but in terms of <code>Eventually</code> instead, letting us use all the nice filter stuff such as <code>filter_upwards</code> to avoid the awkward <code>max 1 d^2/4 ...</code> stuff that happens in usual  epsilon proofs. I'd be really shocked if this didn't exist in some form, because I honestly thought this was part of the sales points of filters.</p>\n<p>I asked <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> last night, and he sent this proof that he suggested I post here for further advice:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>A proof that Bhavik sent</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\nopen Filter Metric Topology\n\nvariable {α β : Type*} [PseudoMetricSpace α] {x : α} {s : Set α}\n\ntheorem nhdsWithin_basis_closedBall {s : Set α} :\n    (𝓝[s] x).HasBasis (fun ε : ℝ =&gt; 0 &lt; ε) fun ε =&gt; closedBall x ε ∩ s :=\n  nhdsWithin_hasBasis nhds_basis_closedBall s\n\n-- Bhavik&#39;s original proof\ntheorem Metric.mem_nhds_iff_mem_nhdsWithin&#39; : s ∈ 𝓝 x ↔ {ε | ball x ε ⊆ s} ∈ 𝓝[&gt;] 0 := by\n  rw [nhdsWithin_basis_closedBall.mem_iff, Metric.nhds_basis_ball.mem_iff]\n  constructor\n  · rintro ⟨ε, hε, hs⟩\n    refine ⟨ε, hε, fun y hy =&gt; (ball_subset_ball ?_).trans hs⟩\n    simp only [Set.mem_inter_iff, mem_closedBall_zero_iff] at hy\n    exact le_of_abs_le hy.1\n  · rintro ⟨ε, hε, hs⟩\n    exact ⟨ε, hε, hs &lt;| by simp [hε, abs_of_pos]⟩\n\n-- Mine, golfed inspired on `eventually_closedBall_subset` which is just a little wrong for this application\ntheorem Metric.mem_nhds_iff_mem_nhdsWithin : s ∈ 𝓝 x ↔ {ε | ball x ε ⊆ s} ∈ 𝓝[&gt;] 0 := by\n  rw [Metric.nhds_basis_ball.mem_iff]\n  constructor\n  · rintro ⟨ε, εpos, hε⟩\n    have : Set.Ioc 0 ε ∈ 𝓝[&gt;] (0 : ℝ) := Ioc_mem_nhdsWithin_Ioi&#39; εpos\n    filter_upwards [this] with r hr using (ball_subset_ball hr.2).trans hε\n  · rw [nhdsWithin_basis_closedBall.mem_iff]\n    exact .imp (fun a ha ↦ ha.imp_right fun hs ↦ hs &lt;| by simp [ha.1, abs_of_pos])\n\ntheorem Metric.mem_nhds_iff_eventually : s ∈ 𝓝 x ↔ ∀ᶠ ε in 𝓝[&gt;] 0, ball x ε ⊆ s :=\n  Metric.mem_nhds_iff_mem_nhdsWithin\n\ntheorem eventually_nhds_iff_eventually {p : α → Prop} :\n    (∀ᶠ y in 𝓝 x, p y) ↔ ∀ᶠ ε in 𝓝[&gt;] 0, ∀ ⦃y⦄, dist y x &lt; ε → p y :=\n  Metric.mem_nhds_iff_eventually\n\ntheorem Metric.tendsto_nhds&#39; {f : Filter β} {u : β → α} {a : α} :\n    Tendsto u f (𝓝 a) ↔ ∀ᶠ ε in 𝓝[&gt;] 0, ∀ᶠ x in f, dist (u x) a &lt; ε := by\n  rw [tendsto_iff_eventually]\n  constructor\n  · intro h\n    rw [eventually_nhdsWithin_iff]\n    exact eventually_of_forall fun ε hε =&gt; h &lt;| ball_mem_nhds _ hε\n  · intro h p hp\n    rw [eventually_nhds_iff_eventually] at hp\n    obtain ⟨ε, hε, hε&#39;⟩ := (h.and hp).exists\n    filter_upwards [hε] with x hx\n    exact hε&#39; hx\n</code></pre></div>\n</div></div>",
        "id": 409803100,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703412276
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.MetricSpace.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span> <span class=\"n\">Metric</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">PseudoMetricSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Filter</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Metric.tendsto_nhds'</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Filter</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"n\">Tendsto</span> <span class=\"n\">u</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">ε</span> <span class=\"k\">in</span> <span class=\"bp\">𝓝</span><span class=\"o\">[</span><span class=\"bp\">&gt;</span><span class=\"o\">]</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">tendsto_nhds</span><span class=\"o\">]</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">eventually_mem_nhdsWithin.mono</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"n\">ε</span> <span class=\"n\">ε₀</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">h.and</span> <span class=\"o\">(</span><span class=\"n\">Ioo_mem_nhdsWithin_Ioi'</span> <span class=\"n\">ε₀</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">exists</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">ε'</span><span class=\"o\">,</span> <span class=\"n\">hε'</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">hε'ε</span><span class=\"o\">⟩</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hε'.mono</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"bp\">↦</span> <span class=\"n\">hx.trans</span> <span class=\"n\">hε'ε</span>\n</code></pre></div>",
        "id": 409821800,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703430673
    },
    {
        "content": "<p>Amazing! Do you think this should be standard? And replace all similar statements?</p>",
        "id": 409822289,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703431075
    },
    {
        "content": "<p>(I envisioned a world where even intro on an Eventually works like a blank FilterUpwards...)</p>",
        "id": 409822353,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703431106
    },
    {
        "content": "<p>I found myself wanting this kind of statements from time to time, and indeed sometimes I'm wondering wether we're missing something. I think the main reason we don't have a lot of these is that the right hand side does not correspond to any nice filter because of the two <code>∀ᶠ</code>. We do have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.curry#doc\">docs#Filter.curry</a> which seems very related, but I wouldn't say I understand what it means informally. There's also probably a connection to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FIlter.smallSets#doc\">docs#FIlter.smallSets</a></p>",
        "id": 409830700,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703439422
    },
    {
        "content": "<p>from a glance, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.curry#doc\">docs#Filter.curry</a> seems to be exactly right; however, I wouldn't understand the aversion to just a double <code>Eventually</code>; in Mathlib I've always preferred <code>\\forall a, \\forall b</code> instead of <code>\\forall (a, b)</code> for many reasons; this seems like exactly the same situation. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=hasFDerivAt_of_tendstoUniformlyOnFilter#doc\">docs#hasFDerivAt_of_tendstoUniformlyOnFilter</a> uses it quite a lot and it does seem sensible to do so in such circumstances, but to me (a new filter-cult inductee) it seems unnecessary to turn everything into a single filter</p>",
        "id": 409831687,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703440567
    },
    {
        "content": "<p>I didn't mean that it's a bad statement, rather that there's not a systematic way to prove it because of this. For example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Metric.tendsto_nhds#doc\">docs#Metric.tendsto_nhds</a> is essentially free from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=nhds_comap_dist#doc\">docs#nhds_comap_dist</a></p>",
        "id": 409832543,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703441388
    },
    {
        "content": "<p>I'm just sharing random thoughts here, but it seems to me that the potential way to make it more systematic would be to have a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.HasBasis#doc\">docs#Filter.HasBasis</a> where the basis stes are \"indexed by a filter\", if that makes any sense.</p>",
        "id": 409832747,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703441613
    },
    {
        "content": "<p>Ahh, that makes sense. Filter bases are currently out of my depth so I'll have a read and understand them sometime soon :)</p>",
        "id": 409834112,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703443139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/epsilon-delta.20and.20such.20like.20in.20filter.20form/near/409832747\">said</a>:</p>\n<blockquote>\n<p>I'm just sharing random thoughts here, but it seems to me that the potential way to make it more systematic would be to have a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Filter.HasBasis#doc\">docs#Filter.HasBasis</a> where the basis stes are \"indexed by a filter\", if that makes any sense.</p>\n</blockquote>\n<p>This is an interesting idea. Could you please open a github issue for that?</p>",
        "id": 409835494,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703444653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/epsilon-delta.20and.20such.20like.20in.20filter.20form/near/409834112\">said</a>:</p>\n<blockquote>\n<p>Ahh, that makes sense. Filter bases are currently out of my depth so I'll have a read and understand them sometime soon :)</p>\n</blockquote>\n<p>When you read code about filter bases, keep 3 examples in mind: open balls form a basis of nhds of a point, same for closed balls, and intervals <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>a</mi><mo separator=\"true\">,</mo><mo>+</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[a, +\\infty)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">+</span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> form a basis of <code>Filter.atTop</code>.</p>",
        "id": 409835568,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1703444732
    },
    {
        "content": "<blockquote>\n<p>restatement of usual eps convergence but in terms of Eventually instead, letting us use all the nice filter stuff such as filter_upwards to avoid the awkward max 1 d^2/4 ... stuff that happens in usual epsilon proofs</p>\n</blockquote>\n<p>Some <a href=\"#narrow/stream/287929-mathlib4/topic/Shrinking.20epsilon.20in.20analysis.20proofs/near/407860475\">recent discussions</a> (and indeed the solution is to use <code>𝓝[&gt;] 0</code>)</p>",
        "id": 409835866,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1703445057
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/9258\">#9258</a>, feel free to edit</p>",
        "id": 409835875,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1703445070
    }
]