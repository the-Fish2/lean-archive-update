[
    {
        "content": "<p>What's the easiest way to spell \"something that is either a <code>Sort u</code>, or at least has a <code>CoeSort</code> instance?\"</p>\n<p>More specifically, I want to be able to accept functions of the type <code>α → α → Sort*</code> , but I also need to be able to write <code>EquivLike _ a b</code> for <code>(a b : α)</code>, so <code>α</code> needs to be coercible to a Sort. I don't want to actually restrict to <code>Sort* → Sort _ → Sort*</code>, though, because then not only my own function but the function passed can't make use of any properties of α beyond those of <code>Sort*</code>. I considered just using a direct sum, but to be honest that sounds like it's likely to be quite inconvenient both for me and any users of the tactic I'm writing, as we'd end up constantly having to do case splits. If that's what I have to do then that's what I have to do, but I thought I'd at least check first.</p>\n<p>I'd <em>like</em> to just require a <code>CoeSort</code> instance, but unfortunately, it seems that <code>Sort</code>s themselves are not coercible to Sort (or at least <code>#synth CoeSort (Type u) (Type u)</code> finds nothing.)</p>",
        "id": 434898742,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713845086
    },
    {
        "content": "<p>... I guess I can just write an inductive typeclass and make an instance for <code>Sort</code> and an instance that turns <code>CoeSort</code> into my typeclass, but then I basically run into right into Chesterton's Fence: why doesn't <code>CoeSort</code> already have instances for <code>Sort</code>s? It seems like whatever the answer to that is, it will probably apply to my custom typeclass as well.</p>",
        "id": 434900260,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713846038
    },
    {
        "content": "<p>This sounds like an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem; can you describe in a little more detail what you're actually trying to do?</p>",
        "id": 434916990,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713856046
    },
    {
        "content": "<p>Essentially, I want to be able to write something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">def</span> <span class=\"n\">TFAEType</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eqv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">EquivLike</span> <span class=\"o\">(</span><span class=\"n\">EqvGen'</span> <span class=\"n\">eqv</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>(where <code>EqvGen'</code> is <code>EqvGen</code> but for <code>(α → α → Sort*)</code>). Basically, I want<code>TFAEType</code> to be defined in such a way that the actual underlying isomorphisms are defined and can be composed, so that I can automatically generate the correct isos as part of a related tactic later. But unless I resort to importing <code>BundledHoms</code> or something (which I believe ends up adding a dependency onto a large chunk of the category theory libraries), that means that <code>x</code> and <code>y</code> need to be coercible to <code>Sort</code>.</p>",
        "id": 434918613,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713856561
    },
    {
        "content": "<p>My current approach is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">aesop</span> <span class=\"n\">safe</span> <span class=\"n\">unfold</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">TFAEType</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eqv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">EquivLike</span> <span class=\"o\">(</span><span class=\"n\">EqvGen'</span> <span class=\"n\">eqv</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">on</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">eqv</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>which... might work for me? But it depends on how well Lean can e.g. infer that <code>β</code> is just identity if <code>α</code> is already a <code>Sort u</code>; I haven't had the chance to really test the user-friendliness of this def yet</p>",
        "id": 434918827,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713856635
    },
    {
        "content": "<p>Can you make that a mwe by including <code>EqvGen'</code>?</p>",
        "id": 434957848,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713869994
    },
    {
        "content": "<p>Not really, because <code>EqvGen'</code> itself is something I'm working on that only sort of \"works.\" (In particular Lean is insisting that it be either always-Prop or never-Prop and this is putting a big hole in my use case.) </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.FunLike.Equiv</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.Common</span>\n\n  <span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n\n  <span class=\"sd\">/--`EqvGen' r` is the equivalence relation generated by the relation `r`.</span>\n\n<span class=\"sd\">  This is basically just `EqvGen`, but generalized to `Sort u`.-/</span>\n  <span class=\"kd\">inductive</span> <span class=\"n\">EqvGen'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n   <span class=\"bp\">|</span> <span class=\"n\">rel</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n   <span class=\"bp\">|</span> <span class=\"n\">refl</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n   <span class=\"bp\">|</span> <span class=\"n\">symm</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n   <span class=\"bp\">|</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n\n<span class=\"c1\">-- @[aesop safe unfold]</span>\n<span class=\"kd\">def</span> <span class=\"n\">TFAEType</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">eqv</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">EquivLike</span> <span class=\"o\">(</span><span class=\"n\">EqvGen'</span> <span class=\"n\">eqv</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">on</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">EqvGen'</span> <span class=\"n\">eqv</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>This compiles, at least...</p>",
        "id": 435077313,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713911344
    },
    {
        "content": "<p>Bleck. Part of the issue, of course, is figuring out what <code>EqvGen'</code> should even <em>be</em>. The above is just copypasta from <code>EqvGen</code>; it sort of works (in that it compiles and kind of represents the thing I want), but since it doesn't actually specify a function for <code>refl, symm, trans</code>, it's not really suited for purpose I don't think</p>",
        "id": 435094702,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713924646
    }
]