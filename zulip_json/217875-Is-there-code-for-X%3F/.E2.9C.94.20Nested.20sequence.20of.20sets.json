[
    {
        "content": "<p>In measure theory, it is very common to create a nested sequence of sets from a sequence of sets that preserves certain properties: for a sequence K1, K2, ...., this is often done by taking L1 = K1, L2 = K1 u K2, etc. I've put what I want in the form of two lemma's, but I'm mainly looking for two things: where can I find such results, and how do I encode <code>(∀ n m : ℕ, n ≤ m → L n ⊆ L m)</code> in a more condensed way?  I looked at Directed, but wasn't sure if that was the way to go here. I know how to prove the results (by taking the construction I just mentioned and deriving the necessary properties), but I'm looking for these types of results in Mathlib. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Regular</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">scoped</span> <span class=\"n\">ENNReal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">MeasureTheory</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">mα</span> <span class=\"o\">:</span> <span class=\"n\">MeasurableSpace</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">Measure</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_nested_sequence</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">L</span> <span class=\"n\">n</span> <span class=\"bp\">⊆</span> <span class=\"n\">L</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_nested_sequence_compact</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hK</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">L</span> <span class=\"n\">n</span> <span class=\"bp\">⊆</span> <span class=\"n\">L</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">IsCompact</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 434976272,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713876288
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=partialSups#doc\">docs#partialSups</a> . The property <code>n ≤ m → L n ⊆ L m</code> is simply <code>Monotone L</code>.</p>",
        "id": 434982001,
        "sender_full_name": "Rémy Degenne",
        "timestamp": 1713878010
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Accumulate#doc\">docs#Set.Accumulate</a> is similar and can also be useful. You can also take a look at existing declarations, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.SigmaFinite#doc\">docs#MeasureTheory.SigmaFinite</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.spanningSets#doc\">docs#MeasureTheory.spanningSets</a>.</p>",
        "id": 435004712,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1713884355
    },
    {
        "content": "<p>Thanks! partialSups seems fine for my purposes, but I’ll check out the others as well!</p>",
        "id": 435007672,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713885185
    },
    {
        "content": "<p>Set.Accumulate seems to work very nicely with compactness, thank you!</p>",
        "id": 435012378,
        "sender_full_name": "Josha Dekker",
        "timestamp": 1713886528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"673728\">Josha Dekker</span> has marked this topic as resolved.</p>",
        "id": 435018488,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713888436
    }
]