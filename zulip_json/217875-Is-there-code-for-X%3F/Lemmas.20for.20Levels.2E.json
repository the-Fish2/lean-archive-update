[
    {
        "content": "<p>It would be nice if I could provide a proper proof that e.g. <code>isLevelDefEq (Level.max u v) (Level.max v u)</code>. (Specifically, I want to prove that if <code>Level.dec u matches .some u'</code>, then <code>Level.dec u |&gt;.succ = u</code>, so I can subst in that proof when working with Qq typed expressions). Unfortunately, I don't see any relevant existing lemmas, and all the relevant definitions are opaque and/or external so it's hard to prove them myself by induction on <code>Level</code>. Is there an existing workaround?</p>",
        "id": 433103169,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713070205
    },
    {
        "content": "<p>How would you expect the proof to be stated?</p>",
        "id": 433130154,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1713096972
    },
    {
        "content": "<p>Well, that is sort of part of the question; I'm aware of the <code>BEq</code> instance for <code>Level</code>s and of <code>QL=</code> and of <code>Level.geq</code> and <code>Level.normLt</code>, but I wouldn't feel comfortable assertitng that that's all there is for <code>Level</code>s. Consider it a dependent goal  :p<br>\nMarginally more seriously, I did in fact try and write a couple of proofs...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"kd\">lemma</span> <span class=\"n\">Level.max_symm</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Level.max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">Level.max</span> <span class=\"n\">v</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">u</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">induction</span> <span class=\"n\">v</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n        <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">v</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"c1\">-- ??</span>\n\n  <span class=\"c1\">-- If I had `Level.max_symm`, I could make a decent attempt at writing something like...</span>\n  <span class=\"kd\">lemma</span> <span class=\"n\">Level.succ_get_dec</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">u.dec.isSome</span> <span class=\"bp\">=</span> <span class=\"n\">true</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">u.dec.get</span> <span class=\"n\">h</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">u</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Level.dec</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">u</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">wlog</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">Level.geq</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n        <span class=\"n\">next</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">specialize</span> <span class=\"n\">this</span> <span class=\"n\">v</span> <span class=\"n\">u</span> <span class=\"n\">h</span> <span class=\"c1\">-- fails because `Level.max u v` is not obviously convertible to a `Level.max v u`</span>\n</code></pre></div>",
        "id": 433130278,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097173
    },
    {
        "content": "<p>but I see no way of proving the subgoal that <code>Level.max 0 (.succ v) = Level.succ (Level.max 0 v)</code>, either</p>",
        "id": 433130393,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097322
    },
    {
        "content": "<p>(For whatever definition of <code>=</code> you care to use here; so far all the options I've seen either don't unfold or unfold to opaques.)</p>",
        "id": 433130451,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097359
    },
    {
        "content": "<p>At best, maybe I could try and prove that the mapping from <code>Nat</code>s is surjective, and then just work with <code>Level.ofNat</code>...?</p>",
        "id": 433130472,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097390
    },
    {
        "content": "<p>But that feels like it'd pretty much run into the same problem of \"everything to do with <code>Level</code>s is opaque meta code\".</p>",
        "id": 433130495,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097412
    },
    {
        "content": "<p>I don't even see a way of proving that a <code>u : Level</code> is valid iff there's a matching <code>Sort u</code>, so.</p>",
        "id": 433130557,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097451
    },
    {
        "content": "<p>... Hm. Actually, now that I look at that code again, I can get a good bit closer by working with <code>Level.geq</code>; I can probably prove that, _if_ <code>Level.geq</code> defines by antisymmetry a valid equivalence relation, _then_ all the expected things about <code>Level</code>s are true up to that equivalence</p>",
        "id": 433130776,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097722
    },
    {
        "content": "<p>But I still don't see a good way of turning that equivalence into something I can <code>subst</code> or <code>rw</code> or the like.</p>",
        "id": 433130790,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713097745
    },
    {
        "content": "<p><code>max_symm</code> is false</p>",
        "id": 433141614,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713107538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lemmas.20for.20Levels/near/433141614\">said</a>:</p>\n<blockquote>\n<p><code>max_symm</code> is false</p>\n</blockquote>\n<p>what?!</p>",
        "id": 433163992,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1713127854
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Level.max#doc\">docs#Level.max</a> is a constructor, isn't it? So it's axiomatically unique</p>",
        "id": 433166638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1713130252
    },
    {
        "content": "<p>Indeed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Level</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">Level</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">u.succ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">u.succ</span><span class=\"o\">)</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 433168042,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713131580
    },
    {
        "content": "<p>Once you have this, proving <code>Level.succ_get_dec</code> will be a breeze.</p>",
        "id": 433168222,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1713131737
    },
    {
        "content": "<p>but I mean within the context of actual universes, we do have that <code>max u v</code> = <code>max v u</code>? so what's going on here?</p>",
        "id": 433201454,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1713158162
    },
    {
        "content": "<p>Something like, <code>Sort</code> is actually the quotient of <code>Level</code> by <code>Level.geq a b &amp;&amp; Level.geq b a</code>? Except you can't actually write that in Lean because you'd be quantifying over <code>Sort</code>s and the resulting thing would live in <code>Sort Ï‰</code> or something.</p>",
        "id": 433202691,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1713159004
    },
    {
        "content": "<p>for typechecking purposes, levels which are geq in both directions are equal, at least in theory. In practice level comparison is done by normalization, which is known to be incomplete in some cases</p>",
        "id": 433205846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713160841
    },
    {
        "content": "<p>It's not that weird that <code>Level</code> contains equivalent things in it that are not <code>=</code> (which is basically what we would call \"syntactically equal\"). <code>Level</code> has a defeq relation on it just like <code>Expr</code>, it's just significantly simpler. Obviously we don't expect <code>Expr.const `foo [] = mkNumLit 1</code> to be true (assuming <code>def foo := 1</code>), but <code>isDefEq (.const `foo []) (mkNumLit 1)</code> is true</p>",
        "id": 433206447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713161054
    },
    {
        "content": "<p>The (assuming) part of the above sentence should give you a hint as to why we can't just make it true: the defeq relation depends on the environment, but <code>=</code> obviously cannot depend on anything but the structure of the <code>Expr</code> itself</p>",
        "id": 433206751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713161175
    },
    {
        "content": "<p>9 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lemmas.20for.20Levels\">#Is there code for X? &gt; Lemmas for Levels</a> by <span class=\"user-mention silent\" data-user-id=\"710432\">Ivan Gonzalez</span>.</p>",
        "id": 433466029,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713255131
    },
    {
        "content": "<p>10 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Lemmas.20for.20Levels\">#Is there code for X? &gt; Lemmas for Levels</a> by <span class=\"user-mention silent\" data-user-id=\"710432\">Ivan Gonzalez</span>.</p>",
        "id": 433467101,
        "sender_full_name": "Notification Bot",
        "timestamp": 1713255534
    }
]