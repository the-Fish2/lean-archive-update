[
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.join#doc\">docs#Array.join</a> looks the same as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.flatten#doc\">docs#Array.flatten</a> to me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">`O(|join L|)`. `join L` concatenates all the arrays in `L` into one array.</span>\n<span class=\"sd\">* `join #[#[a], #[], #[b, c], #[d, e, f]] = #[a, b, c, d, e, f]`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">join</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldl</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">++</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Joins array of array into a single array.</span>\n\n<span class=\"sd\">`flatten #[#[a₁, a₂, ⋯], #[b₁, b₂, ⋯], ⋯]` = `#[a₁, a₂, ⋯, b₁, b₂, ⋯]`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">def</span> <span class=\"n\">flatten</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"n\">as.foldl</span> <span class=\"o\">(</span><span class=\"n\">init</span> <span class=\"o\">:=</span> <span class=\"n\">empty</span><span class=\"o\">)</span> <span class=\"k\">fun</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>Which name should be kept?</p>",
        "id": 429909649,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711559585
    },
    {
        "content": "<p>(mentioned previously <a href=\"#narrow/stream/270676-lean4/topic/List.2Econcat.20and.20List.2Eappend/near/405948710\">here</a>)</p>",
        "id": 429909745,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711559624
    },
    {
        "content": "<p><code>join</code> is perhaps the more common name for this monadic operation, though it appears Scala might call it <code>flatten</code>.</p>\n<p>My vote would be for <code>join</code>.</p>\n<p>If we wanted Lean to be friendly in a Ruby sense, I know there is an aliasing mechanism where we could make <code>Array.flatten</code> be an alias for <code>Array.join</code> — so it would elaborate <em>as</em> <code>Array.join</code> — but I'm not sure that's exposed in any command (the Lean 3 <code>export</code> command would let you rename identifiers, but Lean 4's doesn't). I also seem to remember there being some inconsistencies with how aliases are handled, but having more aliases could help exercise this feature.</p>",
        "id": 429913159,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711560796
    },
    {
        "content": "<p>Join matches <code>List.join</code> too, which is nice; though to make things more confusing, <code>.flatten</code> was upstreamed to core</p>",
        "id": 429913354,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711560859
    },
    {
        "content": "<p>I think <code>Array.join</code> should be the exclusive one kept and upstreamed to core.  I don't see any reason that can't be done prior to the next release.</p>",
        "id": 429919806,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1711563111
    },
    {
        "content": "<p>We could make <code>Array.flatten</code> a deprecated abbreviation for <code>Array.join</code>.</p>",
        "id": 429920009,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1711563187
    },
    {
        "content": "<p>I think <code>join</code> is a bit of a monad-brained name, it is not as natural from procedural programming languages. From the name alone I think someone would guess that it is the <code>++</code> operation</p>",
        "id": 429949901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711573778
    },
    {
        "content": "<p>(I have also thought the same about <code>List.bind</code>, which would probably be called something more like <code>flatMap</code> in a javascriptish language)</p>",
        "id": 429950405,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711574008
    },
    {
        "content": "<p>(When I first came to Lean it took me a while to stop writing <code>flatMap</code>, which was one of the most common tokens in the Scala code I used to write...)</p>",
        "id": 429951404,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711574397
    },
    {
        "content": "<p>(Aside: is <code>flatMap</code> in Scala <code>join</code> or <code>bind</code>?)</p>",
        "id": 429956095,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1711576605
    },
    {
        "content": "<p><code>flatMap</code> is the monad operation, so I guess <code>bind</code></p>",
        "id": 429956938,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1711577000
    },
    {
        "content": "<p><code>bind</code></p>",
        "id": 429956942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711577000
    },
    {
        "content": "<p>I don't see any issue with having both so long as one is an alias pointing to the other. That way a quick hover will reveal they are synonyms.</p>\n<p>Of course, it's debatable which should be the root. My preference is for the generic name (<code>join</code>) to be an alias for the specialized name (<code>flatten</code>).</p>",
        "id": 429957028,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1711577043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-std4/topic/Array.2Ejoin.20vs.20Array.2Eflatten/near/429956095\">said</a>:</p>\n<blockquote>\n<p>(Aside: is <code>flatMap</code> in Scala <code>join</code> or <code>bind</code>?)</p>\n</blockquote>\n<p>Scala's <code>join</code> is <code>flatten</code>, which nicely emphasizes their relationship. <code>flatMap</code> is <code>map</code> followed by <code>flatten</code>.</p>",
        "id": 429981891,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1711592981
    },
    {
        "content": "<p>For what it's worth, I think the monad word \"join\" comes from generalizing the example of List.join to all monads.</p>",
        "id": 429982924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711593537
    },
    {
        "content": "<p>I'm not sure what's it's most often called the the math literature, but it's the \"multiplication\" law of the monad, denoted by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>μ</mi></mrow><annotation encoding=\"application/x-tex\">\\mu</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">μ</span></span></span></span>. Just mentioning this to say that neither \"join\" nor \"flatten\" is the general word, at least as the math is concerned.</p>",
        "id": 429983322,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711593830
    },
    {
        "content": "<p>I always assumed it was the other way around. It would be great to track down the history of the naming of <code>Monad.join</code> and <code>List.join</code> in haskell</p>",
        "id": 429989162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711597429
    },
    {
        "content": "<p>Doesn't Haskell use <code>concat</code> for <code>List.join</code>?</p>",
        "id": 429990059,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711598053
    },
    {
        "content": "<p>According to <a href=\"https://en.wikipedia.org/wiki/Monad_(functional_programming)#History\">https://en.wikipedia.org/wiki/Monad_(functional_programming)#History</a> , the first use of monads in FP is by Moggi (1989 / 1991), but he is using the standard mathematical notations only (i.e. greek letters) and does not name the operations AFAICT; and the next reference is to monads in Haskell when they were <a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf\">overhauling their IO system in 1993</a> and that paper uses <code>bindIO</code> for the first time but not <code>join</code></p>",
        "id": 429990382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711598335
    },
    {
        "content": "<p>there is no explanation of why the name \"bind\" is chosen, it may predate the paper</p>",
        "id": 429990406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711598359
    },
    {
        "content": "<p>there is also no mention of \"Monad\" as a typeclass, I think this may also predate typeclasses</p>",
        "id": 429990578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711598440
    },
    {
        "content": "<p>lol @ <a href=\"https://wiki.haskell.org/Monad_tutorials_timeline\">https://wiki.haskell.org/Monad_tutorials_timeline</a></p>",
        "id": 429990887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711598578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/348111-std4/topic/Array.2Ejoin.20vs.20Array.2Eflatten/near/429990059\">said</a>:</p>\n<blockquote>\n<p>Doesn't Haskell use <code>concat</code> for <code>List.join</code>?</p>\n</blockquote>\n<p>Indeed Haskell's list type has <a href=\"https://hackage.haskell.org/package/base-4.19.1.0/docs/GHC-List.html#v:concat\"><code>concat</code></a> and <a href=\"https://hackage.haskell.org/package/base-4.19.1.0/docs/GHC-List.html#v:concatMap\"><code>concatMap</code></a>, although of course you can also use <code>bind</code> and <code>join</code> coming from the Monad implementation. In Haskell I think the names tend to be different on specialized types because they don't have dot-notation for disambiguation (you can also use qualified imports but this is usually not used for things in <code>Base</code>)</p>",
        "id": 429991739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711599173
    },
    {
        "content": "<p>Some people might incorrectly expect <code>[[[1]]].flatten = [1]</code></p>",
        "id": 430045493,
        "sender_full_name": "James Sully",
        "timestamp": 1711625166
    },
    {
        "content": "<p>That view is probably quickly dispelled when they realize that <code>#[#[1, 2], 3]</code> is a type error.</p>",
        "id": 430048780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1711626299
    }
]