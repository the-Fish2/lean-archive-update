[
    {
        "content": "<p>In std, I see a bunch of a functions like that : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Returns the index of the first element satisfying `p`, or the length of the list otherwise. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">findIdx</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span>\n\n<span class=\"sd\">/-- Returns the index of the first element equal to `a`, or the length of the list otherwise. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">indexOf</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"sd\">/-- Removes the `n`th element of `l`, or the original list if `n` is out of bounds. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">removeNth</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>At first sight, I kind of dislike the \"or\" part , which looks like it's reinventing NULL. Is there a good reason for having them?<br>\nWouldn't it be better to just have a panic version (!)  along with the Option version (?), and maybe a regular version that takes a proof that the function will be successful, thereby mirroring <code>Array.get</code> conventions?</p>",
        "id": 425775964,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710079412
    },
    {
        "content": "<p>Potentially; another apt comparison, though, is <code>Nat.div</code>, for which we return a dummy value in the undefined case (<code>Nat.div i 0 = 0</code>). I think there's reasons for doing either in Lean, but I'm not sure I have intuition for when to use one over the other.</p>",
        "id": 425975177,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1710178305
    },
    {
        "content": "<p>I personally take the route of avoiding the <code>nth</code> and <code>idx</code> based APIs to List, cuz I find them very hard to write code with and prove theorems about</p>",
        "id": 425975958,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1710178566
    },
    {
        "content": "<p>Another way of describing <code>findIdx</code> is that it returns the least index <code>n</code> such that, for every <code>k &lt; n</code>, <code>p l[k]</code> is false</p>",
        "id": 426037257,
        "sender_full_name": "Chris Wong",
        "timestamp": 1710206645
    },
    {
        "content": "<p>Binary search algorithms work the same way. It means that you can use the same function for finding an element and inserting a new one.</p>",
        "id": 426037347,
        "sender_full_name": "Chris Wong",
        "timestamp": 1710206715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407274\">James Gallicchio</span> <a href=\"#narrow/stream/348111-std4/topic/findIdx.20and.20indexOf/near/425975177\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I have intuition for when to use one over the other.</p>\n</blockquote>\n<p>I think the rule of thumb is to restrict theorems, not definitions. Because if you put the hypothesis on the definition, then you need to re-prove it every time you mention the definition, even if the hypothesis is irrelevant to the result.</p>",
        "id": 426038266,
        "sender_full_name": "Chris Wong",
        "timestamp": 1710207403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"294142\">Chris Wong</span> <a href=\"#narrow/stream/348111-std4/topic/findIdx.20and.20indexOf/near/426038266\">said</a>:</p>\n<blockquote>\n<p>I think the rule of thumb is to restrict theorems, not definitions. Because if you put the hypothesis on the definition, then you need to re-prove it every time you mention the definition, even if the hypothesis is irrelevant to the result.</p>\n</blockquote>\n<p>Does this really make a difference? I still need to prove the same hypothesis in order to use the theorem. Or if I instead unfold the definition, I need to prove the hypothesis in order to exclude the corresponding branch of the function.</p>",
        "id": 426115350,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710247018
    },
    {
        "content": "<p>Yes it makes a difference, because in a proof like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mn>6</mn></msqrt><mo>=</mo><msqrt><mn>2</mn></msqrt><msqrt><mn>3</mn></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{6}=\\sqrt{2}\\sqrt{3}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">6</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1328em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9072em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">3</span></span></span><span style=\"top:-2.8672em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1328em;\"><span></span></span></span></span></span></span></span></span> you have to prove three obvious things if you demand nonnegativity in the definition, but you need less if you just want to apply the theorem. These extra things soon start adding up. </p>\n<p>Or think about it this way: you're defining a function but you're <em>ignoring</em> one of the inputs. Where is the logic in that?</p>",
        "id": 426200219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710272613
    },
    {
        "content": "<p>Thanks Kevin that's a nice example.<br>\nMy original concern is that programmers who write software code, will mindlessly pick <code>findIdx</code>, and forget that the returned index might not be valid.<br>\nFor proving this is not an issue because if you forget things, your proof just won't type check and that's it. <br>\nPerhaps these functions should be named with a more explicit ending.</p>",
        "id": 426221319,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710281606
    },
    {
        "content": "<p>(at a computer now): yeah <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.sqrt_mul#doc\">docs#Real.sqrt_mul</a> only asks that one of the inputs is non-negative (because the junk value 0 is returned for square roots of negative numbers)</p>",
        "id": 426228356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710285411
    },
    {
        "content": "<p>To me the proof looks exactly the same in both cases.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Real.sqrt</span> <span class=\"mi\">6</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Real.sqrt</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">Real.sqrt</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Real</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n  <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.ofNat_nonneg</span><span class=\"o\">,</span> <span class=\"n\">zero_le</span><span class=\"o\">,</span> <span class=\"n\">Real.sqrt_mul</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">sqrt'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Real.sqrt</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">sqrt'_mul</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sqrt'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">ha</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"n\">x</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"n\">y</span> <span class=\"n\">hc</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sqrt'</span><span class=\"o\">,</span> <span class=\"n\">Real.sqrt_mul</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sqrt'</span> <span class=\"mi\">6</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Real</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n  <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.ofNat_nonneg</span><span class=\"o\">,</span> <span class=\"n\">sqrt'_mul</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 426230974,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710287056
    },
    {
        "content": "<p>Sure, but you've put a default discharger on the input which has been chosen to work on the example I gave (and which had to run three times instead of once on this example)</p>",
        "id": 426232941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710288326
    },
    {
        "content": "<p>Can you give me an example for which this discharger doesn't work, but also doesn't require additional proofs for <code>Real.sqrt</code>?</p>\n<p>When I look the code of <code>Real.sqrt</code> and the functions it invokes, I find <code>⟨max r 0, le_max_right _ _⟩</code>, so here Lean has figure out that <code>0 ≤ 6</code>, otherwise it can't know anything about the result. I can avoid this check for <code>sqrt'</code> by using <code>NNReal.sqrt</code> directly. So in both cases there are three checks comparing 6, 3, and 2 with 0, either by the <code>linarith</code> or when calling <code>max</code>.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">sqrt'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Real</span> <span class=\"o\">:=</span> <span class=\"n\">NNReal.sqrt</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">sqrt'_mul</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sqrt'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">ha</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"n\">x</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"n\">y</span> <span class=\"n\">hc</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sqrt'</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">NNReal.coe_mul</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">NNReal.sqrt_mul</span><span class=\"o\">,</span> <span class=\"n\">NNReal.coe_inj</span><span class=\"o\">]</span>\n  <span class=\"n\">congr</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">sqrt'</span> <span class=\"mi\">6</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">sqrt'</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">6</span> <span class=\"o\">:</span> <span class=\"n\">Real</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span>\n  <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.ofNat_nonneg</span><span class=\"o\">,</span> <span class=\"n\">sqrt'_mul</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>While the differences look minute to me, they are still there and I can understand if you prefer using <code>max</code> for theorem proving. And for the non-computable <code>Real.sqrt</code> that's the end of it.</p>\n<p>But if we would be talking about a computable function like <code>Nat.div</code>, there is also runtime to consider. With a <code>Nat.div'</code> the non-zero check could be discharged entirely at compile time. While <code>Nat.div</code> <a href=\"https://github.com/leanprover/lean4/blob/e61d082a9555464bca6de954f8fbc2a1b1a1bf89/src/include/lean/lean.h#L1221\">checks for 0 every time it's called</a>.</p>",
        "id": 426319297,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710330865
    },
    {
        "content": "<p>If a def should not have assumptions, should a def ever have a <code>Fin</code> parameter ?</p>",
        "id": 426350501,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710339559
    },
    {
        "content": "<p>I'm not sure where \"a def should not have assumptions\" comes from. A def should not have any unnecessary assumptions for the definition.</p>",
        "id": 426428000,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1710364599
    },
    {
        "content": "<p>I think Kevin was arguing in favor of that tendency towards absence of assumptions in many mathlib defs, and returning junk values on meaningless inputs (in traditional math).<br>\nContinuing along this path, I was wondering why we should ever use Fin in a def, when we can replace a Fin with a Nat, and return a junk value if it's out of bounds.<br>\nBut it's true that many mathlib defs clearly have typeclass assumptions.</p>",
        "id": 426439866,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710370330
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"654733\">@Markus Schmaus</span> the point I'm trying to make is that <code>Real.sqrt_mul</code> only asks for a proof that <code>0 &lt;= x</code> whereas putting non-negativity as an assumption into the def of <code>Real.sqrt</code> means that you get asked to prove a non-negativity condition three times when invoking <code>Real.sqrt_mul</code>. Thus putting the assumptions only in the theorems makes the user's life easier. That is all I'm saying. I don't see the relevance of any of your questions to this point right now, but if you can explain why they're relevant to the point I'm making then I will certainly try to answer them.</p>",
        "id": 426448187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1710376364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"697190\">@Julien Michel</span> Suppose you want to prove something about finite types, eg involving their cardinality. Then Fin is quite useful</p>",
        "id": 426465475,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1710388372
    }
]