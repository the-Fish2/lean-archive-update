[
    {
        "content": "<p>Hello, I've been playing with Lean 4 for a while and would be interested in contributing to std. </p>\n<p>I have a couple questions about List and Arrays: </p>\n<p>Given that Array is just a wrapper on a List with a specific efficient implementation,</p>\n<p>1) Why shouldn't List and Array have the same list of public defs in std / Core (with possibly different implementations, but equivalent behaviors) ?</p>\n<p>2) Couldn't we just delete all Array theorems, keeping only equivalence proofs between Array and List defs, and focus on building a theory only about List's ?<br>\nAlternatively, if we want all Array theorems, couldn't we flag each List theorem with an attribute that automatically generates the corresponding Array theorem, provided that the required List and Array defs have proven equivalent behaviors?</p>\n<p>Here is an example I made up to elaborate on my second point :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- a List def</span>\n<span class=\"kd\">def</span> <span class=\"n\">List.get'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span>  <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span> <span class=\"s2\">\"bad index\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">,</span>  <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">get'</span> <span class=\"n\">as</span> <span class=\"n\">i</span>\n\n<span class=\"c1\">-- its Array version with a different implementation</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.get'</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨[]⟩,</span>  <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span> <span class=\"s2\">\"bad index\"</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>  <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">⟩,</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">get'</span> <span class=\"o\">⟨</span><span class=\"n\">as</span><span class=\"o\">⟩</span> <span class=\"n\">i</span>\n\n<span class=\"c1\">-- proof that they are equivalent</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Array.get_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a.get'</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">a.1.get'</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩</span> <span class=\"n\">i</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">as</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span>\n\n<span class=\"c1\">-- another List def</span>\n<span class=\"kd\">def</span> <span class=\"n\">List.set'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span>      <span class=\"n\">_</span><span class=\"o\">,</span>     <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">,</span>     <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">as</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">set'</span> <span class=\"n\">as</span> <span class=\"n\">n</span> <span class=\"n\">x</span>\n\n<span class=\"c1\">-- its Array version with a different implementation</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.set'</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨[]⟩,</span>      <span class=\"n\">_</span><span class=\"o\">,</span>     <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨[]⟩</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">⟩,</span> <span class=\"mi\">0</span><span class=\"o\">,</span>     <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">⟩,</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">set'</span> <span class=\"o\">⟨</span><span class=\"n\">as</span><span class=\"o\">⟩</span> <span class=\"n\">n</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- proof that they are equivalent</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Array.set_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a.set'</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">a.1.set'</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩</span> <span class=\"n\">i</span> <span class=\"n\">x</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">as</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"bp\">$</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">data</span> <span class=\"bp\">.</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span>\n\n<span class=\"c1\">-- another List def</span>\n<span class=\"kd\">def</span> <span class=\"n\">List.length'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span>       <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">as</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">length'</span> <span class=\"n\">as</span>  <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- its Array version with a different implementation</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.length'</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨[]⟩</span>       <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"o\">::</span> <span class=\"n\">as</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">length'</span> <span class=\"o\">⟨</span><span class=\"n\">as</span><span class=\"o\">⟩</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\">-- proof that they are equivalent</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Array.length_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a.length'</span> <span class=\"bp\">=</span> <span class=\"n\">a.1.length'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">x</span> <span class=\"n\">as</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">length'</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n\n<span class=\"c1\">-- a List theorem about the 3 definitions</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">List.set_get</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length'</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">l.set'</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get'</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">h</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">contradiction</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">y</span> <span class=\"n\">as</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">i</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_of_succ_lt_succ</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n\n<span class=\"c1\">-- the corresponding Array theorem, which could be auto generated from its List counterpart</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Array.set_get</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a.length'</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a.set'</span> <span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get'</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">revert</span> <span class=\"n\">l</span><span class=\"bp\">;</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">List.set_get</span> <span class=\"c1\">-- proof is trivial with the right simp lemmas</span>\n</code></pre></div>\n<p>Thanks for your clarifications or thoughts.</p>",
        "id": 425564092,
        "sender_full_name": "Julien Michel",
        "timestamp": 1709919803
    },
    {
        "content": "<p>Hi Julien,</p>\n<p>I agree that <code>List</code> and <code>Array</code> should have consistent interfaces and normal forms.  There are a lot of places in Lean where there are multiple operators or types and the lemma/simp normal forms should be more consistent.  In addition to being consistent across types, I'd like to ensure that normal forms for operations defined in Lean itself are consistent across Lean, Std and Mathlib.  </p>\n<p>The idea of synthesizing lemmas is also done in the <code>to_additive</code> Mathlib attribute.</p>\n<p>The approach I am currently working on is to build testing infrastructure to validate normal forms are consistent in different environments.  <a href=\"https://github.com/leanprover-community/Lean4/pull/3508\">Lean4#3508</a> includes the first protype in <code>tests/playground</code> for testing <code>Bool</code> normal forms, but as I get time to polish and document the generator, I will try to find a more permanent home for it.</p>\n<p>I am currently working on <code>Nat</code> and <code>Int</code>, but would like to tackle <code>List</code> and <code>Array</code> at some point.  Test cases and lemmas that find places to improve normal forms for <code>Array</code> and <code>List</code> would be welcome, but I'm not sure that the <code>to_additive</code> approach is the right fit.  There may be exceptions and I've personally found that tactic difficult to debug when things don't work.</p>\n<p>There's also a newish <code>#check_simp</code> command in Lean now that let's one easily test normal forms.</p>",
        "id": 425599066,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1709928313
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/348111-std4/topic/collection.20typeclasses\">this thread</a> for some discussion about making abstractions for collections. <a href=\"https://github.com/JamesGallicchio/LeanColls\"><code>LeanColls</code></a> is starting to actually become useful for me personally, so maybe it will be useful for you as well.</p>",
        "id": 425601700,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1709929510
    },
    {
        "content": "<p>RE: arrays specifically, I think a lot of the difficulty comes from the fact that often we want to treat an array NOT as a list, but as a function <code>Fin (size A) -&gt; ElemType</code>.</p>\n<p>IMO this should be resolved by separating these two views into an array, so that they can have different simp normal forms and work with different automation. This is one of the things LeanColls does (arrays are <a href=\"https://gallicch.io/LeanColls/docs/LeanColls/Classes/Seq.html\"><code>Seq</code></a>, or list-like, but you can <a href=\"https://gallicch.io/LeanColls/docs/LeanColls/Data/Transformer/FixSize.html#LeanColls.Seq.fixSize\"><code>Seq.fixSize</code></a> them to get an indexed collection that has some cleaner lemmas around <code>get</code> and <code>set</code> in particular)</p>",
        "id": 425602103,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1709929694
    }
]