[
    {
        "content": "<p>hey all, I'm working on getting assoclist into the leancolls abstraction circus, but I'm realizing that it is actually a rather annoying dictionary because of the whole deduplication thing.</p>\n<p>in particular, one of the things we do in leancolls is connect membership (here<code>AssocList.find?</code>) with fold (here <code>AssocList.foldl</code>). But for <code>AssocList</code> they are always going to disagree if we don't require deduplication.</p>\n<p>so, how do you use assoclist, and what does \"correctness\" mean to you for assoclist?</p>",
        "id": 434614105,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1713728580
    },
    {
        "content": "<p>I guess another question is whether you find it surprising (even if not too hard to see) that <code>AssocList.fold</code> \"disagrees\" with <code>AssocList.find?</code>, in the sense that it will fold over key-value pairs that are not in the dictionary according to <code>find?</code></p>",
        "id": 434614217,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1713728679
    },
    {
        "content": "<p>Have you seen <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AList#doc\">docs#AList</a> ?</p>",
        "id": 434616759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713731027
    },
    {
        "content": "<p><code>AssocList</code> is not suitable as a dictionary on its own, you want to pair it with a NodupKeys assumption to be usable</p>",
        "id": 434616841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713731093
    },
    {
        "content": "<p><code>AssocList</code> is just a funny looking <code>List</code></p>",
        "id": 434616868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713731122
    },
    {
        "content": "<p>is anyone proving code with <code>AssocList</code>?</p>\n<p>(or using <code>AList</code> for programming purposes? I thought the issue with <code>AList</code> was the performance hit from the extra indirection)</p>",
        "id": 434624312,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1713738856
    },
    {
        "content": "<p>I have a branch of Std (<a href=\"https://github.com/leanprover/std4/pull/556\">std4#556</a>) in which I added a <code>keysOrdered</code> predicate to <code>AssocList</code>, that</p>\n<ul>\n<li>asserted that according to some order the keys were strictly ordered</li>\n<li>gave some variants of operations which assumed / ensured this condition</li>\n<li>and some theorems about these operations.</li>\n</ul>\n<p>However my target application dropped off the priority list, so the PR is incomplete. If it's useful I can revive it or hand it off.</p>",
        "id": 434878636,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713834271
    },
    {
        "content": "<p>ooooh, okay, I may snatch this into leancolls if that is alright with you...</p>",
        "id": 434880742,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1713835563
    },
    {
        "content": "<p>Yes please!</p>",
        "id": 434880769,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713835592
    },
    {
        "content": "<p>(I could probably also maintain an assoclist variant that just scans the full list and maintains a nodupkeys invariant rather than an order invariant, so that the keys don't need to be ordered. but if there's no use case for unordered keys, I see no reason to maintain both...)</p>",
        "id": 434881027,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1713835745
    },
    {
        "content": "<p>I was initially working on this because the current implementation of <code>omega</code>just uses <code>List Int</code> to represent coefficients of linear forms (i.e. a dense representation), and wanted to replace it (because someday someone will run <code>omega</code> with thousands of variables, and the current implementation will fall over). We decided to do a more thorough replacement of <code>omega</code>, so if something usable appears in the meantime everyone will be happy. :-)</p>",
        "id": 434881034,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713835751
    },
    {
        "content": "<p>I'd be inclined to go straight to ordered.</p>",
        "id": 434881063,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1713835768
    },
    {
        "content": "<p>Ordered keys is more useful when based on <code>Array</code> rather than <code>List</code>. This is because <code>Array.get</code> is O(1) so binary search makes <code>AssocArray.get</code> O(log n). Since <code>List.get</code> is <code>O(n)</code>, <code>AssocList.get</code> is <code>O(n)</code> regardless of order.</p>",
        "id": 434974580,
        "sender_full_name": "Fran√ßois G. Dorais",
        "timestamp": 1713875750
    },
    {
        "content": "<p>actually, I just realized the hashmap buckets are assoclist with nodup keys, right? maybe it's worth maintaining then. hm.</p>",
        "id": 434990957,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1713880468
    },
    {
        "content": "<p>Note that the nodup key proof is stored separately from the assoc list itself, and after <a href=\"https://github.com/leanprover/std4/pull/748\">std4#748</a> (or some variant) lands this seems unlikely to change</p>",
        "id": 435007649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713885180
    }
]