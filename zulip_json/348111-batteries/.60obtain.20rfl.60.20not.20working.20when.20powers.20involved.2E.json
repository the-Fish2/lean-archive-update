[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.RCases</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- tactic 'subst' failed, 'b' occurs at c ^ 2</span>\n</code></pre></div>\n<p>This seems to be because some metavariables aren't resolved; with <code>pp.explicit</code> on we have that it's trying to substitute <code>x‚úù: @Eq Nat b (@HPow.hPow Nat ?m.29 Nat ?m.31 c 2)</code>. This also seems to do with powers specifically - other algebraic operations don't seem to struggle from this. This can also be fixed by writing (2 : Nat) on the power.</p>",
        "id": 410341744,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1703797297
    },
    {
        "content": "<p>For most binary operations, you may assume by default that both arguments have the same type.</p>",
        "id": 410750084,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704139088
    },
    {
        "content": "<p>(so, I'm not sure why do we have <code>HAdd</code>)</p>",
        "id": 410750095,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704139100
    },
    {
        "content": "<p>However, if you assume this for <code>^</code> (as it used to be), then Lean will treat <code>(a : Real) ^ (n : Nat)</code> as <code>(a : Real) ^ (Nat.cast n : Real)</code>.</p>",
        "id": 410750138,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704139153
    },
    {
        "content": "<p>But this works even if you have a full term in the right, as far as I remember. Let me test in a little</p>",
        "id": 410750239,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704139219
    },
    {
        "content": "<p>I would guess that <code>obtain</code> is failing to instantiate some metavariables?</p>",
        "id": 410751183,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704139918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> I'm not following what you're saying about <code>^</code> -- are you saying it tries to be homogeneous? That is not true for at least a month now.</p>",
        "id": 410753208,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704141325
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> It looks like obtain isn't synthesizing default instances, if I were to guess here (on my phone)</p>",
        "id": 410753430,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704141444
    },
    {
        "content": "<p>I'm sorry for not being clear. It was true, no longer true. Trying to be homogeneous would help with this example but caused issues in many other places.</p>",
        "id": 410758218,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704143793
    },
    {
        "content": "<p>Fixed in <a href=\"https://github.com/leanprover/std4/commit/baaa2918\"><code>baaa2918</code></a></p>",
        "id": 410760875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145114
    },
    {
        "content": "<p>I'm not sure that's sufficient of a fix -- it seems lots of the <code>Term.elab*</code> functions need to be wrapped in <code>Term.withSynthesize</code></p>",
        "id": 410761363,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704145364
    },
    {
        "content": "<p>If you change the test to <code>obtain h : b = c ^ 2 := sorry</code> you can see that <code>h</code> has a type with unsynthesized metavariables. The <code>rfl</code> was just forcing the issue.</p>",
        "id": 410761441,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704145405
    },
    {
        "content": "<p>Note that this is to some extent on purpose, forcing these metavariables too early can prevent deferring terms with <code>?_</code></p>",
        "id": 410761498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145439
    },
    {
        "content": "<p>but TBH this whole interface seems a bit scuffed for that use case</p>",
        "id": 410761580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145463
    },
    {
        "content": "<p>Could <code>subst</code> learn to eliminate dependencies from metavariables?</p>",
        "id": 410761682,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704145514
    },
    {
        "content": "<p>Aren't those <code>?_</code> metavariables synthetic opaque though, so they won't be solved for by the default instance system?</p>",
        "id": 410761726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704145543
    },
    {
        "content": "<p>it could, but keep in mind this is <code>TermElabM</code> state though, not <code>MetaM</code> state, substCore doesn't know about it</p>",
        "id": 410761793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145565
    },
    {
        "content": "<p>in fact <code>subst'</code> is also in <code>MetaM</code> so actually that's not an option</p>",
        "id": 410761840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145604
    },
    {
        "content": "<p>Anyway, maybe at least you can throw in another <code>Term.synthesizeSyntheticMVarsNoPostponing</code> before the tactic returns? That solves a bug where tactics after the current tactic cause pending synthetic metavariables to be solved for. I think between tactics there ought to never be any pending synthetic metavariables.</p>",
        "id": 410761843,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704145606
    },
    {
        "content": "<p>Is that actually the case in practice?</p>",
        "id": 410761876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145658
    },
    {
        "content": "<p>It should be. I've fixed tactics occasionally that fail to keep this invariant(?).</p>",
        "id": 410761941,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704145691
    },
    {
        "content": "<p>The '(?)' is just because I've never seen it written down, but it makes tactics really hard to debug if you don't realize a previous tactic forgot to finish synthesizing everything.</p>",
        "id": 410761949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704145706
    },
    {
        "content": "<p>added in <a href=\"https://github.com/leanprover/std4/pull/493\">std#493</a>, do you have any idea what tests can be used for it?</p>",
        "id": 410762183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145963
    },
    {
        "content": "<p>is there anything that will fail without it?</p>",
        "id": 410762191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704145978
    },
    {
        "content": "<p>In</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Before the <code>have</code> there are still metavariables in <code>h</code>, and after <code>have</code> there aren't.</p>",
        "id": 410762286,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704146058
    },
    {
        "content": "<p>If you do <code>subst h</code> before the <code>have</code> you get a failure, and after you don't.</p>",
        "id": 410762302,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704146093
    },
    {
        "content": "<p>You can replace <code>have</code> with <code>refine ?_</code>. They both synthesize</p>",
        "id": 410762342,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704146134
    },
    {
        "content": "<p>I think the <code>subst</code> tactic should also call <code>synthesizePendingMVars</code></p>",
        "id": 410762528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704146295
    },
    {
        "content": "<p>but that's sufficient for the current issue I think</p>",
        "id": 410762590,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704146399
    },
    {
        "content": "<p>I'm not sure that's <code>subst</code>s responsibility -- it's only elaborating its argument as far as seeing it's got an fvar, and then it's purely MetaM code.</p>",
        "id": 410762764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704146496
    },
    {
        "content": "<p>it seems similar to the known issues with pattern matching Exprs</p>",
        "id": 410762858,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704146535
    },
    {
        "content": "<p>usually it's the downstream code that is responsible for forcing things until whatever condition is met</p>",
        "id": 410762890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704146562
    },
    {
        "content": "<p>One way in which it is not like that is that <code>synthesizePendingMVars</code> takes and receives no arguments, it's just some kind of \"fix the state\" button which IMO is a very difficult interface to use correctly</p>",
        "id": 410762986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704146632
    },
    {
        "content": "<p>like, what was the invariant before and after such that it needs to be fixed?</p>",
        "id": 410763049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704146653
    },
    {
        "content": "<p>It be good to get clarification on this -- my thought is that the TacticM monad might be stacked on the TermElabM monad (which is convenient for elaboration!), but some of the TermElabM state isn't meant to cross over from one tactic to another.</p>\n<p>The pending synthetic mvars seem to be one of these kinds of state. Only the current tactic should be responsible for how the terms it elaborates actually elaborate (with the exception of <code>?_</code>'s), and using <code>synthesizePendingMVars</code> is a way to get a bit of progress in elaboration.</p>\n<p>I like <code>Term.withSynthesize</code> better to help scope this part of the elaborator state. I wouldn't mind seeing it used more...</p>",
        "id": 410763252,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704146850
    },
    {
        "content": "<p>but it means that any tactic which just calls <code>elabTerm</code> is wrong, right?</p>",
        "id": 410763669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704147285
    },
    {
        "content": "<p>This seems so subtle that it might be better to have a flag in the state which <code>withSynthesize</code> sets and <code>elabTerm</code> fails if it is not set, to ensure that you never call <code>elabTerm</code> outside the context of a <code>withSynthesize</code></p>",
        "id": 410763760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704147380
    },
    {
        "content": "<p>(even better if we could do it at compile time but that would involve way too much type refactoring)</p>",
        "id": 410763802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704147436
    },
    {
        "content": "<p>Alternatively, maybe the tactic framework could just wrap every tactic in <code>withSynthesize</code>?</p>",
        "id": 410763896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704147531
    },
    {
        "content": "<p>That sounds like it would be confusing for people writing simple tactics that chain the <code>TacticM</code>s from other tactics</p>",
        "id": 410763933,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704147575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/.60obtain.20rfl.60.20not.20working.20when.20powers.20involved.2E/near/410763669\">said</a>:</p>\n<blockquote>\n<p>but it means that any tactic which just calls <code>elabTerm</code> is wrong, right?</p>\n</blockquote>\n<p>I think this is a reason for the confusingly named <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.elabTerm#doc\">docs#Lean.Elab.Tactic.elabTerm</a>, since it synthesizes. I don't think this is always what you want though, so having the tactic framework wrap everything in <code>withSynthesize</code> seems appealing.</p>",
        "id": 410764127,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704147759
    },
    {
        "content": "<p>oh yeah... I never use that function <span aria-label=\"crazy\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"crazy\">:crazy:</span></p>",
        "id": 410764231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704147845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Do you have something that's confusing that could happen in mind? I feel like it's pretty confusing right now needing to be aware that the synthetic metavariables state is anything you need to worry about...</p>",
        "id": 410764236,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704147850
    },
    {
        "content": "<p>Mainly the confusion would be that <code>by foo; bar; baz</code> would work, yet <code>do fooCore; barCore; bazCore</code> would still hit the same errors we see today</p>",
        "id": 410764259,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704147886
    },
    {
        "content": "<p>So we'd be hiding the sharp edge from regular users, but it would be there to bite them as soon as they transition to meta-users and start writing metaprograms that skip the tactic parser</p>",
        "id": 410764276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704147917
    },
    {
        "content": "<p>I'm a little bit okay with that because when you are writing a tactic using the \"low level register\" you are expected to handle this aspect of elaboration</p>",
        "id": 410764354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704147981
    },
    {
        "content": "<p>That's fair <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>. Then maybe Mario's idea would be nice, where you need something like <code>withSynthesize</code> to enter into the term elaborator part of TacticM</p>",
        "id": 410764372,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704148010
    },
    {
        "content": "<p>Yes, that sounds like a much better solution to me in the long run</p>",
        "id": 410764406,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704148040
    },
    {
        "content": "<p>TBH that sounds like another monad</p>",
        "id": 410764408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148048
    },
    {
        "content": "<p>Yeah, or something like an indexed family of monads where <code>TacticM False x</code> doesn't allow running TermElabM but <code>TacticM True x</code> does</p>",
        "id": 410764436,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704148082
    },
    {
        "content": "<p>Presumably you want the non-term version to not even carry around the term elaborator state? Or is only part of the TermElabM state problematic?</p>",
        "id": 410764513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1704148128
    },
    {
        "content": "<p>well you can still let it run TacticElabM, you would just call <code>withSynthesize</code> automatically</p>",
        "id": 410764535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148143
    },
    {
        "content": "<p>It's a good question what other parts of the state we should be considering</p>",
        "id": 410764606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148182
    },
    {
        "content": "<p>There's also the option of a runtime error if you haven't wrapped a TacticM version of <code>withSynthesize</code>, just to make it explicit. (I don't like runtime errors, but it's an option.)</p>",
        "id": 410764687,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704148205
    },
    {
        "content": "<p>as a metaprogramming user I have never really had a strong grasp on how much state is lost when you go from TacticElabM to MetaM and back</p>",
        "id": 410764714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148223
    },
    {
        "content": "<p>The advantage of the runtime error is that it doesn't require changing the interface and breaking a significant fraction of all tactic metaprogramming code in the wild</p>",
        "id": 410764800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148297
    },
    {
        "content": "<p>it doesn't even have to be an error, it can be a \"linter warning\"</p>",
        "id": 410764872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148345
    },
    {
        "content": "<p>like a deprecation warning</p>",
        "id": 410764880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148355
    },
    {
        "content": "<p>Here's the TermElabM state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">  State of the `TermElabM` monad.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">State</span> <span class=\"n\">where</span>\n  <span class=\"n\">levelNames</span>        <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Name</span>       <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"n\">syntheticMVars</span>    <span class=\"o\">:</span> <span class=\"n\">MVarIdMap</span> <span class=\"n\">SyntheticMVarDecl</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">pendingMVars</span>      <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">MVarId</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">mvarErrorInfos</span>    <span class=\"o\">:</span> <span class=\"n\">MVarIdMap</span> <span class=\"n\">MVarErrorInfo</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n  <span class=\"n\">letRecsToLift</span>     <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">LetRecToLift</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n</code></pre></div>\n<p>(some comments would be nice...)</p>\n<ul>\n<li><code>levelNames</code>: The levels for the current declaration I guess. Why is this not meta state? Why is it even state instead of context info?</li>\n<li><code>syntheticMVars</code>, <code>pendingMVars</code>: the state that is managed by <code>synthesizeSyntheticMVars</code></li>\n<li><code>mvarErrorInfos</code>: I don't really understand why this is in the TermElabM state, this contains origin information for each metavariable so that we can highlight them at the end of the proof if things are still dangling</li>\n<li><code>letRecsToLift</code>: collects <code>let rec</code> declarations inside subterms that need to be lifted to the top level. This one does seem like something that needs to be in <code>TacticM</code> as well as <code>TermElabM</code>, because it only arises when elaborating definitions, not just using the metavariable context, and we don't want to lose track of these and recreate the state every time between tactics</li>\n</ul>",
        "id": 410765433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704148848
    },
    {
        "content": "<p>Maybe it's a hack, but <code>Type*</code> uses the fact that <code>levelNames</code> is part of the state. (Maybe autoimplicits for universe level variables uses that it's state and not context info?)</p>",
        "id": 410765560,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704148984
    },
    {
        "content": "<p>can you backtrack an autoimplicit?</p>",
        "id": 410765660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704149068
    },
    {
        "content": "<p>(Indeed, <code>levelNames</code> being state is used by level autoimplicits, via the rare <code>LevelElabM</code> monad.)</p>",
        "id": 410765931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704149354
    },
    {
        "content": "<p>It being part of state seems to be in practice a staged thing. It's state when elaborating binders, but not when elaborating the body. (Incidentally, this is a bug in <code>Type*</code> that you can use it in the body.)</p>",
        "id": 410766176,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1704149582
    },
    {
        "content": "<p>and apparently tactics disable autoimplicits, i.e. <code>example (h : by exact A) : True := trivial</code> doesn't work</p>",
        "id": 410766264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704149657
    },
    {
        "content": "<p>I think something in a similar vein, btw:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.RCases</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.zero_ne_one</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"c1\">--exact a</span>\n</code></pre></div>\n<p>No errors, no new goals generated, until you uncomment the <code>exact</code>. Why is <code>obtain</code> not implemented as <code>have : ... := ..., rcases this with patt</code>?</p>",
        "id": 411378064,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1704464790
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/std4/issues/116\">https://github.com/leanprover/std4/issues/116</a></p>",
        "id": 411378383,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1704464949
    }
]