[
    {
        "content": "<p>What is going to be the border between Std and Mathlib? I understand that lemmas about <code>List, </code>Nat<code>, </code>Int<code>, and </code>Rat` that don't need extra dependencies can go to Std. What about</p>\n<ul>\n<li>Order hierarchy, specifically<ul>\n<li><code>Preorder</code>, <code>PartialOrder</code>, <code>LinearOrder</code>?</li>\n<li><code>OrderBot</code>, <code>OrderTop</code>?</li>\n<li><code>Lattice</code>, <code>SemilatticeSup</code>, <code>SemilatticeInf</code>?</li>\n</ul>\n</li>\n<li><code>Function.Injective</code>, <code>Function.Surjective</code>, <code>Function.Bijective</code>, <code>Function.Involutive</code>?</li>\n<li><code>Equiv</code>, <code>Function.Embedding</code>? (if yes, then please wait till we decide about <a href=\"https://github.com/leanprover-community/mathlib4/pull/2202\">#2202</a>)</li>\n<li>algebraic hierarchy? (I guess, \"no\", at least for now)</li>\n</ul>",
        "id": 412190076,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704908160
    },
    {
        "content": "<p>My not-very-well thought out gut response to these:</p>\n<ul>\n<li><code>Preorder</code>, <code>PartialOrder</code>, <code>LinearOrder</code>: yes, likely with changes though so it is not yet clear whether it would be suitable for mathlib</li>\n<li><code>OrderBot</code>, <code>OrderTop</code>, <code>Lattice</code>, <code>SemilatticeSup</code>, <code>SemilatticeInf</code>: probably not unless some additional reasons for having them show up, esp. due to use in data structures</li>\n<li><code>Function.Injective</code>, <code>Function.Surjective</code>, <code>Function.Bijective</code>, <code>Function.Involutive</code>: These are basic vocabulary definitions, I don't see any reason not to have them</li>\n<li><code>Equiv</code>: I would say 'yes' but it comes with pretty huge implications in terms of lemmas about it, it may require some finess</li>\n<li><code>Function.Embedding</code>: probably also yes, although the name is not great</li>\n<li>algebraic hierarchy: I think we might need a separate repo just for this. The churn rate is too high to make it suitable for std</li>\n</ul>",
        "id": 412207154,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704915370
    },
    {
        "content": "<p>I'd like to have folds and sums over data structures so a <code>Monoid</code> in terms of append/empty and <code>SumMonoid</code> would be useful concepts to have.  Commutative versions could also be useful for folds over unordered data structures.</p>\n<p>I'm not sure they should match Mathlib's though.  I'd want to better understand the utility of <code>npow/nsmul</code> and would want to get consensus since stability is really important.</p>",
        "id": 412220118,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704921064
    },
    {
        "content": "<p>With regards to the other classes, I'd like to see algorithms/data structure needs drive their introducing.  e.g., graph algorithms for orders, abstract interpretation tactics for lattice operations.</p>",
        "id": 412220632,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704921296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412220118\">said</a>:</p>\n<blockquote>\n<p>I'd like to have folds and sums over data structures so a <code>Monoid</code> in terms of append/empty and <code>SumMonoid</code> would be useful concepts to have.  Commutative versions could also be useful for folds over unordered data structures.</p>\n<p>I'm not sure they should match Mathlib's though.  I'd want to better understand the utility of <code>npow/nsmul</code> and would want to get consensus since stability is really important.</p>\n</blockquote>\n<p>I think we need ad-hoc monoid classes that are not attached to specific operations and notations.</p>",
        "id": 412223057,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1704922467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110994\">Joe Hendrix</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412220118\">said</a>:</p>\n<blockquote>\n<p>I'd want to better understand the utility of <code>npow/nsmul</code> and would want to get consensus since stability is really important.</p>\n</blockquote>\n<p>Did you read Chapter 7 of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> about that?</p>",
        "id": 412223273,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704922568
    },
    {
        "content": "<blockquote>\n<p>Did you read Chapter 7 of <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> about that?</p>\n</blockquote>\n<p>I have not, but read through it now.  Thanks.</p>",
        "id": 412224640,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704923249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119741\">François G. Dorais</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412223057\">said</a>:</p>\n<blockquote>\n<p>I think we need ad-hoc monoid classes that are not attached to specific operations and notations.</p>\n</blockquote>\n<p>As in include the operations in the signature?  That seems reasonable for fold.  We could just restrict its use in Std to types where the parameters for that instance are clear (e.g, List/Array/etc).</p>",
        "id": 412226201,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704923912
    },
    {
        "content": "<p>It would be nice to have generic lemmas about unspecified operations and <code>simp</code> being able to apply it to specific operations (e.g., tagged with an attribute) like <code>*</code>/<code>+</code>/<code>∪</code>. Probably, this will need yet another change to <code>simp</code> core because these lemmas won't have head symbols anymore.</p>",
        "id": 412226661,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704924106
    },
    {
        "content": "<p>Could you share an example?</p>",
        "id": 412226830,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704924178
    },
    {
        "content": "<p>E.g., <code>1 * a = a</code>, where <code>1</code> is a neutral element for <code>*</code>.</p>",
        "id": 412226955,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704924231
    },
    {
        "content": "<p>Or <code>a + (-a) = 0</code>, where <code>-</code> is the negation for <code>+</code>.</p>",
        "id": 412227053,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704924257
    },
    {
        "content": "<p>OTOH, <code>to_additive</code> etc work for now.</p>",
        "id": 412227129,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704924293
    },
    {
        "content": "<p>There is some work on a more precise discrimination tree in <a href=\"https://github.com/leanprover/std4/pull/394\">std4#394</a>, but I don't think that addresses this use case though.  I think this would need to key on the type class constraint and require changes to the <code>Key</code> type.  I'd like to do additional work on simp (e.g., rewriting modulo) later in the year, but other things currently take priority.</p>",
        "id": 412231003,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704926039
    },
    {
        "content": "<p>I don't think that this has high priority. For now, we use tactic like <code>to_additive</code> to generate versions of lemmas for different operations.</p>",
        "id": 412231169,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704926105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412207154\">said</a>:</p>\n<blockquote>\n<ul>\n<li>algebraic hierarchy: I think we might need a separate repo just for this. The churn rate is too high to make it suitable for std</li>\n</ul>\n</blockquote>\n<p>Yes, a separate repo is a better idea. I, for <a href=\"https://github.com/fgdorais/GMLAlgebra\">example</a> and probably others, are experimenting with algebraic hierarchies based on different ideas from Mathlib's. It would be a huge setback if these experiments weren't able to use Std to implement complex decision algorithms, for example.</p>",
        "id": 412232789,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1704926954
    },
    {
        "content": "<p>Out of interest, what do you not like about mathlib's way of setting it all up? I guess mathlib itself can be regarded as evidence that it works...</p>",
        "id": 412241548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704931785
    },
    {
        "content": "<p>I think there are a few things:</p>\n<ol>\n<li>Standard should be performant.  I'd at least want a repeated squaring approach (e.g, <a href=\"https://github.com/leanprover-community/mathlib/pull/8885\">mathlib#8885</a>).</li>\n<li>There's complexity in how to deal with the diamond issue and desire for extensions (e.g., a <code>PosNat</code> version for <code>Semigroup</code>.</li>\n</ol>\n<p>I'm leaning towards introducing a version where the operations are unbundled for use with folding over structures.  That wouldn't conflict with the Mathlib and an analogue for <code>SMul</code> doesn't make sense there so the diamond issue is avoided.</p>",
        "id": 412244616,
        "sender_full_name": "Joe Hendrix",
        "timestamp": 1704933141
    },
    {
        "content": "<p>Before splitting the algebraic hierarchy into a separate repo, I would like to see evidence for projects that want to depend on the algebraic hierarchy but do not want to depend on mathlib</p>",
        "id": 412271968,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704949832
    },
    {
        "content": "<p>I think there is a fairly large number of projects that want to depend on \"mathlib lite\", i.e. tactics like <code>linarith</code>, some finite sets, maybe enough for doing basic combinatorics but not other things like topology and analysis (except insofar as those things are dependencies of the other things). I estimate somewhere in the range of 400 files being relevant here assuming a good job is done of import pruning</p>",
        "id": 412273422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704951020
    },
    {
        "content": "<p>The trouble is that mathlib has really not grown in a direction such that one can cleanly cleave that off without pulling closer to 1500 files (which is still better than the 4000 files you get today)</p>",
        "id": 412273591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704951163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412207154\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>Function.Injective</code>, <code>Function.Surjective</code>, <code>Function.Bijective</code>, <code>Function.Involutive</code>: These are basic vocabulary definitions, I don't see any reason not to have them</li>\n</ul>\n</blockquote>\n<p>I'm going to PR these to std. I have 2 questions:</p>\n<ul>\n<li>what would be a good file for (a) definitions; (b) theorems?</li>\n<li>what name should I put in the \"Author:\" field? The first 3 definitions are not mine.</li>\n</ul>",
        "id": 412274017,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704951522
    },
    {
        "content": "<p>This should be migrating a file from mathlib (ish), you should copy the author info from there</p>",
        "id": 412274428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704951895
    },
    {
        "content": "<p>I think we can move <code>Std.Logic</code> to <code>Std.Logic.Basic</code> and add this as <code>Std.Logic.Function</code></p>",
        "id": 412274503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704951953
    },
    {
        "content": "<p>Should it be <code>Std.Logic.Function.Defs</code> and <code>Std.Logic.Function.Lemmas</code> or just 1 file?</p>",
        "id": 412274565,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704951978
    },
    {
        "content": "<p>for now, just <code>Std.Logic.Function</code>, these are pretty abstract definitions</p>",
        "id": 412274602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952010
    },
    {
        "content": "<p>I'll make a PR. If there will be too many lemmas, then we can always move them to a new file.</p>",
        "id": 412274648,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704952056
    },
    {
        "content": "<p>in std there is a split between <code>Basic</code> and <code>Lemmas</code> roughly equivalent to <code>Defs</code> / <code>Basic</code> in mathlib, but <code>Basic</code> files are normally for executable functions</p>",
        "id": 412274650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952059
    },
    {
        "content": "<p>I think we can make an exception for <code>Std.Logic</code> which will be all lemmas and noncomputable defs more or less</p>",
        "id": 412274661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952082
    },
    {
        "content": "<p>back in the day there wasn't too much in the way of theorems directly about those four definitions but I'm sure it's grown since then...</p>",
        "id": 412274744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952145
    },
    {
        "content": "<p>I'm wondering if we can or should forgo the other auxiliary definitions like <code>LeftInverse</code> and <code>HasLeftInverse</code></p>",
        "id": 412274832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952215
    },
    {
        "content": "<p>I've never really felt that they pulled their weight, you can just inline them into the few statements using them</p>",
        "id": 412274859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952254
    },
    {
        "content": "<p>Do we need <code>HasLeftInverse</code>? In classical logic, it's just <code>Injective</code>.</p>",
        "id": 412274878,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704952267
    },
    {
        "content": "<p>std is, let's say, constructive-aware</p>",
        "id": 412274970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952325
    },
    {
        "content": "<p>but like I said I don't think we really need the definition regardless</p>",
        "id": 412274993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952344
    },
    {
        "content": "<p>There are 2 ways to write <code>LeftInverse</code>: <code>f ∘ g = id</code> and <code>∀ x, f (g x) = x</code>.</p>",
        "id": 412275041,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704952377
    },
    {
        "content": "<p>in lemma statements I would opt for the second one</p>",
        "id": 412275069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952395
    },
    {
        "content": "<p>which IIRC is also how <code>LeftInverse</code> is defined</p>",
        "id": 412275084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412274970\">said</a>:</p>\n<blockquote>\n<p>std is, let's say, constructive-aware</p>\n</blockquote>\n<p>Do you care about computable definitions, or constructive proofs as well?</p>",
        "id": 412275086,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704952413
    },
    {
        "content": "<p>both, although I'm not pushing very hard for constructive proofs ATM</p>",
        "id": 412275114,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952439
    },
    {
        "content": "<p>Actually the situation with computable definitions is more complex, because std wants computable definitions to actually be efficient</p>",
        "id": 412275190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952468
    },
    {
        "content": "<p>BTW, do you plan to write some automation for enforcing constructive proofs on a specific set of theorems?</p>",
        "id": 412275215,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704952482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> It's not that I don't like Mathlib's way, I'm just exploring other ways.</p>",
        "id": 412275236,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1704952492
    },
    {
        "content": "<p>I have some automation for that, but I never committed it</p>",
        "id": 412275264,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952505
    },
    {
        "content": "<p>If you care about some thoerems in Mathlib not using classical reasoning, then probably you should commit this automation.</p>",
        "id": 412275395,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704952564
    },
    {
        "content": "<p>(it was a bit depressing to trace everything back to <code>split</code> and then be dashed against the rocks of <a href=\"https://github.com/leanprover/lean4/pull/2414\">lean4#2414</a>)</p>",
        "id": 412275400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704952570
    },
    {
        "content": "<p>Note: I don't care about constructivist reasoning but I'm ready to tolerate it in some parts of Mathlib if this will improve chances of you and a few other people who care about it not leaving the project.</p>",
        "id": 412277188,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704953705
    },
    {
        "content": "<p>What should I do about <code>attribute [eqns _]</code>? Delete them and leave it for Mathlib?</p>",
        "id": 412277690,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704954052
    },
    {
        "content": "<p>yes, looks like you can set that from other files just fine so it should be okay to do so</p>",
        "id": 412277941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704954230
    },
    {
        "content": "<p>what declaration is using that?</p>",
        "id": 412278002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704954247
    },
    {
        "content": "<p><code>flip</code> and <code>comp</code></p>",
        "id": 412278055,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704954281
    },
    {
        "content": "<p>those aren't even defined in std, so it should be fine</p>",
        "id": 412278092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704954309
    },
    {
        "content": "<p>We can look into upstreaming <code>eqns</code> too, it looks fairly reasonable</p>",
        "id": 412278145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704954356
    },
    {
        "content": "<p>I want to keep this PR small.</p>",
        "id": 412278998,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704954929
    },
    {
        "content": "<p>We can upstream more later.</p>",
        "id": 412279005,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704954936
    },
    {
        "content": "<p>Btw, here is <code>ForbiddenAxioms</code>, which I think was mostly written by Mario at some point.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Tactic.Lint</span>\n<span class=\"kn\">import</span> <span class=\"n\">LeanCond.PrintNum</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">forbiddenAxioms</span> <span class=\"o\">(</span><span class=\"n\">bad</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">let</span> <span class=\"n\">decls</span> <span class=\"bp\">←</span> <span class=\"n\">liftCoreM</span> <span class=\"n\">Std.Tactic.Lint.getDeclsInCurrModule</span>\n  <span class=\"n\">decls.forM</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span>\n    <span class=\"k\">let</span> <span class=\"n\">axs</span> <span class=\"o\">:=</span> <span class=\"o\">((((</span><span class=\"n\">CollectAxioms.collect</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"n\">env</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{})</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kd\">axioms</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n    <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">bad.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">axs</span>\n    <span class=\"k\">if</span> <span class=\"n\">l.isEmpty</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"k\">else</span> <span class=\"n\">logError</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{n}' depends on: {l}\"</span>\n\n<span class=\"kn\">open</span> <span class=\"kn\">private</span> <span class=\"n\">printAxiomsOf</span> <span class=\"k\">from</span> <span class=\"n\">Lean.Elab.Print</span>\n<span class=\"n\">elab</span> <span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"s2\">\"#forbiddenAxioms \"</span> <span class=\"n\">ids</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withRef</span> <span class=\"n\">tk</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"bp\">←</span> <span class=\"n\">ids.mapM</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span>\n  <span class=\"n\">withRef</span> <span class=\"n\">tk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">forbiddenAxioms</span> <span class=\"n\">ns.toList</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">explainForbiddenAxioms</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bad</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CommandElabM</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">env</span> <span class=\"bp\">←</span> <span class=\"n\">getEnv</span>\n  <span class=\"k\">match</span> <span class=\"n\">env.find</span><span class=\"bp\">?</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"unknown constant '{n}'\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">ci</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"k\">match</span> <span class=\"n\">ci.value</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"constant '{n}' has no value\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">deps</span> <span class=\"o\">:=</span> <span class=\"n\">e.getUsedConstants</span>\n  <span class=\"n\">deps.forM</span> <span class=\"k\">fun</span> <span class=\"n\">d</span> <span class=\"bp\">↦</span>\n    <span class=\"k\">let</span> <span class=\"n\">axs</span> <span class=\"o\">:=</span> <span class=\"o\">((((</span><span class=\"n\">CollectAxioms.collect</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"n\">env</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span> <span class=\"o\">{})</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kd\">axioms</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n    <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">bad.filter</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">axs</span>\n    <span class=\"k\">if</span> <span class=\"n\">l.isEmpty</span> <span class=\"k\">then</span> <span class=\"n\">pure</span> <span class=\"o\">()</span>\n    <span class=\"k\">else</span> <span class=\"n\">logError</span> <span class=\"n\">m</span><span class=\"bp\">!</span><span class=\"s2\">\"'{d}' depends on: {l}\"</span>\n\n<span class=\"kn\">open</span> <span class=\"kn\">private</span> <span class=\"n\">printAxiomsOf</span> <span class=\"k\">from</span> <span class=\"n\">Lean.Elab.Print</span>\n<span class=\"n\">elab</span> <span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"s2\">\"#explainForbiddenAxioms \"</span> <span class=\"n\">ids</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"bp\">*</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withRef</span> <span class=\"n\">tk</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">ns</span> <span class=\"bp\">←</span> <span class=\"n\">ids.mapM</span> <span class=\"n\">resolveGlobalConstNoOverloadWithInfo</span>\n  <span class=\"k\">match</span> <span class=\"n\">ns.toList</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"no constant given\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">::</span><span class=\"n\">ns</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">withRef</span> <span class=\"n\">tk</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">explainForbiddenAxioms</span> <span class=\"n\">n</span> <span class=\"n\">ns</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Lean</span>\n</code></pre></div>",
        "id": 412282298,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704957159
    },
    {
        "content": "<p>I don't know if Std would want something like this.</p>\n<p>Usage: put <code>#forbiddenAxioms Classical.choice</code> at the bottom of a file, and it will ensure that all the decls in that file are constructive.</p>",
        "id": 412282346,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704957211
    },
    {
        "content": "<p>IMHO, it should be per-declaration.</p>",
        "id": 412282379,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1704957237
    },
    {
        "content": "<p>Makes sense</p>",
        "id": 412282473,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704957281
    },
    {
        "content": "<p><code>#explainForbiddenAxioms</code> will tell you which decls in the proof of theorem <code>X</code> are causing it to be non-constructive</p>",
        "id": 412282551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1704957342
    },
    {
        "content": "<p>oh yeah, that's my uncommitted tactic alright</p>",
        "id": 412283472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704957906
    },
    {
        "content": "<p>the reason it scans everything in the file is because I was using it to check all definitions for reasonable use of classical axioms. For a permanent attribute it would of course be per-declaration</p>",
        "id": 412283664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704958011
    },
    {
        "content": "<p>when you have a file like <code>Std.Data.Nat.Lemmas</code> with a bazillion little lemmas you don't want to have to write each declaration out separately</p>",
        "id": 412283751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704958062
    },
    {
        "content": "<p>(my previous workflow was to grep for <code>theorem</code> and then multi-edit my way to a long list of <code>#print axioms</code> lines, but you still have to then delete the ones which turn up empty (which isn't immediately obvious because <code>#print axioms</code> always produces output) and you still have to figure out which constant reference is \"to blame\" in each case)</p>",
        "id": 412284032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1704958219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412271968\">said</a>:</p>\n<blockquote>\n<p>Before splitting the algebraic hierarchy into a separate repo, I would like to see evidence for projects that want to depend on the algebraic hierarchy but do not want to depend on mathlib</p>\n</blockquote>\n<p>I definitely see a use case for having real numbers + tactics: 1st year undergrad teaching.</p>",
        "id": 412384376,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704992271
    },
    {
        "content": "<p>To be clear: the fact that the hard-drive requirement of my 1st year undergrad course got multiplied by 10 in the Lean 4 upgrade is a serious issue.</p>",
        "id": 412384596,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1704992317
    },
    {
        "content": "<p>I am about to find out this week whether this is an issue for my students; this time last year I was still teaching in Lean 3.</p>",
        "id": 412391254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1704994592
    },
    {
        "content": "<p>I think that instead of having separate repos we should have a tool that deletes all files not <code>import</code>ed by a given list of files. Then you put the remaining files in a separate repo and use it for your course.</p>",
        "id": 412470901,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705031262
    },
    {
        "content": "<p>Or <code>lake</code> should download <code>olean</code>s on the fly so that the students won't have to download unneeded files.</p>",
        "id": 412470974,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705031303
    },
    {
        "content": "<p>I will keep hoping that we can get <code>lake</code> to do this automatically</p>",
        "id": 412470978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031310
    },
    {
        "content": "<p>Note that you can already <code>lake exe cache get Mathlib.Data.Real.Basic</code> if you want</p>",
        "id": 412471044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031350
    },
    {
        "content": "<p>but lake will clone the whole repo, so you always get all the sources regardless</p>",
        "id": 412471080,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/348111-std4/topic/scope.20of.20std/near/412207154\">said</a>:</p>\n<blockquote>\n<p>My not-very-well thought out gut response to these:</p>\n<ul>\n<li><code>Preorder</code>, <code>PartialOrder</code>, <code>LinearOrder</code>: yes, likely with changes though so it is not yet clear whether it would be suitable for mathlib</li>\n</ul>\n</blockquote>\n<p>What changes would you expect in <code>Preorder</code>/<code>PartialOrder</code>?</p>",
        "id": 412471082,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705031395
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/1777\">lean4#1777</a></p>",
        "id": 412471172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031428
    },
    {
        "content": "<p>that is mainly about <code>LinearOrder</code> though</p>",
        "id": 412471196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031461
    },
    {
        "content": "<p>for the simpler classes the main thing is that we may want a lawless and/or decidable version of the class</p>",
        "id": 412471309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031538
    },
    {
        "content": "<p>Lawless: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LE#doc\">docs#LE</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT#doc\">docs#LT</a></p>",
        "id": 412471330,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705031568
    },
    {
        "content": "<p>in most programming languages <code>PartialOrd</code> or equivalent implies the existence of a function which decides LE/LT</p>",
        "id": 412471375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031599
    },
    {
        "content": "<p>Decidable: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DecidableRel#doc\">docs#DecidableRel</a></p>",
        "id": 412471390,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705031614
    },
    {
        "content": "<p>that's four classes though just for decidable le/lt</p>",
        "id": 412471402,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031629
    },
    {
        "content": "<p>and we definitely want to avoid the current situation where some stuff asks for le and other stuff uses lt</p>",
        "id": 412471480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031664
    },
    {
        "content": "<p>I will think whether we can make it useful both for Mathlib and programming.</p>",
        "id": 412471495,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1705031688
    },
    {
        "content": "<p>having one canonical ordering class (or a hierarchy of them) is important for this</p>",
        "id": 412471497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031693
    },
    {
        "content": "<p>(programming applications also have a use for the lawful ordering class, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.TransCmp#doc\">docs#Std.TransCmp</a> which is used in RBMap)</p>",
        "id": 412471846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1705031927
    },
    {
        "content": "<p>I would love to see <code>left</code> and <code>right</code> in Std4.</p>",
        "id": 412597898,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1705083814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span>, they have been for a while. <code>import Std.Tactic.LeftRight</code>.</p>",
        "id": 412655029,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1705110967
    }
]