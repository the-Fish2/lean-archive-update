[
    {
        "content": "<p>Currently, <code>HashMap</code> has a very weak notion of equality, so that even empty hashmaps with different capacities are unequal. Will <code>HashMap</code> eventually be defined as a quotient? One complication I can imagine is choosing the precise equivalence relation for the quotient:</p>\n<ul>\n<li>If two HashMaps are equal whenever they can't be distinguished through <code>HashMap.find?</code>, then <code>HashMap.toList</code>, which exposes the internal order, is not easily definable.<ul>\n<li>Even if we switched to an <a href=\"https://github.com/indexmap-rs/indexmap\"><code>IndexMap</code></a> implementation which has mostly predictable internal order, O(1) removal would still cause internal order to be exposed.</li>\n<li>Alternatively, I suppose we could do something similar to <code>Multiset</code> and have a <code>toList</code> which returns something quotiented by <code>List.Perm</code>. If this is done in an ergonomic way, it could be a nice improvement over most languages where relying on internal HashMap order is a correctness and forward-compatibility issue, but not caught by the type system.</li>\n</ul>\n</li>\n<li>If two HashMaps are equal whenever they can't be distinguished by <code>toList</code>, that might be surprising, because it doesn't reflect the usual meaning of <code>map1 == map2</code> in languages like Rust.</li>\n</ul>\n<p>One possible benefit of using a quotient type is that we could soundly store a random seed in the hashmap to mitigate HashDOS attacks without having to move <code>HashMap.empty</code> into the <code>IO</code> monad.</p>",
        "id": 421750864,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708035635
    },
    {
        "content": "<p>Do you have a reason for wanting to discuss hashmap equality? I sorta suspect that is a bit of a code smell.</p>\n<p>For any map type from <code>K</code> to <code>V</code> we can give an equivalence on the model <code>K -&gt; Option V</code> (<code>find?</code>), maybe call it <code>find?_equiv</code> even. It is decidable for hashmaps, even.</p>",
        "id": 421762138,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708041369
    },
    {
        "content": "<p>In implementing the simp lemma <code>find?_empty : (∅ : HashMap α β).find? k = none</code>, I realized that this lemma has misleading generality, because it doesn't actually characterize all empty hashmaps (i.e. those with <code>size = 0</code>), but only empty hashmaps with the default initial capacity.</p>",
        "id": 421762368,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708041497
    },
    {
        "content": "<p>Sure, but that's not an issue with equality, just with how the simp lemma was written, no?</p>",
        "id": 421762516,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708041590
    },
    {
        "content": "<p>(in particular you can make this simp lemma work for any initial capacity by explicitly providing that argument)</p>",
        "id": 421762973,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708041760
    },
    {
        "content": "<p>I admit that I don't personally have a use case (besides the random seeding idea) for talking about equality of hashmaps. But in most other parts of Lean I've seen (mathlib), we make sure to have a nice notion of equality on our types. I suppose you're saying for computational use cases, this is not important. Does that mean for <code>HashMap</code> we might end up with <code>BEq</code> reflecting the nice notion of equality and <code>Eq</code> reflecting the weak one?</p>",
        "id": 421763234,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708041889
    },
    {
        "content": "<p>Another example: Wouldn't it be nice if one could write a simp lemma <code>insert_insert : (m.insert k v).insert k v' = m.insert k v'</code>?</p>",
        "id": 421763437,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708042009
    },
    {
        "content": "<p>Actually I supposed that equality is true intensionally in any reasonable HashMap implementation... But <code>insert_remove_eq_remove</code> wouldn't be (because the insertion could have triggered growing)</p>",
        "id": 421763907,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708042254
    },
    {
        "content": "<p>That lemma is just a very strong claim in general. I think in LeanColls my goal has been to express those lemmas in terms of the models being equivalent, never using equality directly on the collection, because it vastly simplifies the implementor's job.</p>\n<p>I think there is a way to then quotient by the equivalence in a way that is generic over the collection type, where then those lemmas become equalities, but again I'm unsure of the benefit</p>",
        "id": 421764125,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708042393
    },
    {
        "content": "<p>Looking forward to checking out LeanColls in more detail then! Does LeanColls make it easy to verify algorithms in terms of models of the data structures they use rather than their implementations? It seems like we're probably missing relevant tooling (like <code>grw</code>) for working with anything but equalities.</p>",
        "id": 421764667,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1708042748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"500038\">Timo Carlin-Burns</span> <a href=\"#narrow/stream/348111-std4/topic/Extensional.20equivalence.20for.20.60HashMap.60/near/421764667\">said</a>:</p>\n<blockquote>\n<p>Does LeanColls make it easy to verify algorithms in terms of models of the data structures they use rather than their implementations?</p>\n</blockquote>\n<p>oh not at all, it's a shell of a library, the only thing it accomplishes is some abstraction over the existing data structures in std...</p>",
        "id": 421808598,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708070905
    },
    {
        "content": "<p>a lot of algorithms that operate over data structures do have some equivalence relation they want to quotient the data by. I just am not sure that equivalence relation is <em>always</em> the same for a given data structure, which is what gives me pause here.</p>\n<p>like maybe some algorithm does want to expose the internal order of the hashmaps, in which case having a version that is not quotiented is essential. or maybe you want to treat a red-black map as an ordered (partial,finite) map rather than a regular (partial,finite) map.</p>",
        "id": 421809059,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708071123
    },
    {
        "content": "<p>grw is going to be very useful precisely because quotients can be awkward to verify with...</p>",
        "id": 421809952,
        "sender_full_name": "James Gallicchio",
        "timestamp": 1708071541
    }
]