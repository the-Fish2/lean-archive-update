[
    {
        "content": "<p>I wanted to fill a proof_wanted for <code>erase_data</code> in std (equivalence between <code>Array.erase</code> and <code>List.erase</code>) but I feel that some code in the Init library needs to be cleaned up.<br>\nTo do things cleanly, I wanted to prove lemmas about the functions buried in it. <br>\nI proved that <code>findIdx?</code>, and <code>indexOf?</code> are equivalent for Array and List, after making some modifications for convenience.</p>\n<p>1) One issue is that in <code>Array.findIdx?</code>'s code uses index tricks to avoid wf recursion (old code maybe ?), but I find that it's less readable. For my proof, I simplified it to use termination_by (which I believe shouldn't affect performance).</p>\n<p>2) Another issue is that <code>Array.indexOf?</code> returns a Fin whereas <code>List.indexOf?</code>, and findIdx?'s return Nat's, and the order of parameters is not the same.<br>\nI want to simplify <code>Array.indexOf?</code> to use <code>Array.findIdx?</code> but their signature is different. Should they all return Fin ?</p>\n<p>3) Are contributions to the Init library welcome at this time ?<br>\nRegarding std, is there a list of tasks that need to be done and where help would be appreciated currently ?</p>\n<p>Thanks for your thoughts</p>",
        "id": 425760166,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710064254
    },
    {
        "content": "<p>These functions are widely used in core so you want to do rigorous performance testing.</p>",
        "id": 425765119,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1710069288
    },
    {
        "content": "<p>What I'd like to do first is something like that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List</span>\n<span class=\"c1\">-- I would suggest simplifying Array.findIdx? with below code</span>\n<span class=\"kd\">@[</span><span class=\"n\">inline</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Array.findIdx</span><span class=\"bp\">?'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"c1\">-- wouldn't it be better to return Option (Fin as.size) ?</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">as.size</span> <span class=\"k\">then</span>\n      <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"n\">as</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"n\">j</span> <span class=\"k\">else</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">none</span>\n    <span class=\"n\">termination_by</span> <span class=\"n\">as.size</span> <span class=\"bp\">-</span> <span class=\"n\">j</span>\n  <span class=\"n\">loop</span> <span class=\"mi\">0</span>\n\n<span class=\"c1\">-- so that it's more convenient to write this theorem</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Array.findIdx</span><span class=\"bp\">?</span><span class=\"n\">_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">as.findIdx</span><span class=\"bp\">?'</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">as.1.findIdx</span><span class=\"bp\">?</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">findIdx</span><span class=\"bp\">?'.</span><span class=\"n\">loop</span> <span class=\"n\">as</span> <span class=\"n\">p</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as.1.drop</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">findIdx</span><span class=\"bp\">?</span> <span class=\"n\">p</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">as</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">findIdx</span><span class=\"bp\">?'.</span><span class=\"n\">loop</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">size</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_pos</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">l.drop_eq_get_cons</span> <span class=\"n\">h1</span><span class=\"o\">]</span>\n      <span class=\"k\">show</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">ite</span> <span class=\"bp\">..</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n      <span class=\"bp\">.</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">if_pos</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">if_pos</span> <span class=\"n\">h2</span><span class=\"o\">]</span>\n      <span class=\"bp\">.</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">if_neg</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">loop</span>\n    <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">dif_neg</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">List.drop_eq_nil_of_le</span> <span class=\"o\">(</span><span class=\"n\">Nat.le_of_not_lt</span> <span class=\"n\">h1</span><span class=\"o\">)]</span>\n      <span class=\"n\">cases</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">termination_by</span> <span class=\"n\">as.size</span> <span class=\"bp\">-</span> <span class=\"n\">j</span>\n  <span class=\"n\">loop</span> <span class=\"n\">as</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>(Let me know if you can improve this proof). Note that one can then prove easily that indexOf? match for Array and List. Later, if nobody does it, I'll try to finish the proof that erase functions match. But I think there is still some cleaning up to do.</p>\n<p>4) Do you have any suggestions on how to do performance testing rigorously? Are there performance tests automatically done during the Core building pipeline? I will have a look</p>",
        "id": 425773340,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710077181
    },
    {
        "content": "<p>A lot of the code in Lean core is old. The modern way to approach this kind of dilemmas is to have two defs: one which is inefficient but easy to use in proofs, another which is efficient but hard to use in proofs, and a <code>@[csimp]</code> lemma proving that they compute the same function.</p>",
        "id": 425811274,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1710109793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"697190\">Julien Michel</span> <a href=\"#narrow/stream/348111-std4/topic/findIdx.3F.20and.20indexOf.3F/near/425760166\">said</a>:</p>\n<blockquote>\n<p>2) Another issue is that <code>Array.indexOf?</code> returns a Fin whereas <code>List.indexOf?</code>, and findIdx?'s return Nat's, and the order of parameters is not the same.<br>\nI want to simplify <code>Array.indexOf?</code> to use <code>Array.findIdx?</code> but their signature is different. Should they all return Fin ?</p>\n</blockquote>\n<p>The <code>size</code> of Array is cached and can be accessed in O(1), the <code>length</code> of a list is not. So making <code>List.indexOf?</code> return a <code>Fin</code> would require additional computation. On the other hand if I want to use <code>Array.indexOf?</code> in <code>Array.get</code>, I need a <code>Fin</code>.</p>",
        "id": 426117156,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710247660
    },
    {
        "content": "<p>I disagree that there would be an additional computation to return a Fin instead of a Nat, if you just prove what you need.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.List.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">List.lt_length_of_mem_findIdx</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">l.findIdx</span><span class=\"bp\">?</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">l.length</span> <span class=\"bp\">+</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">s</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">intro</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">trivial</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">intro</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ite</span> <span class=\"bp\">..</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Nat.add_assoc</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_comm</span> <span class=\"mi\">1</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"bp\">.</span> <span class=\"n\">simp_all_arith</span>\n    <span class=\"bp\">.</span> <span class=\"n\">simp_all</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.findIdxFin</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"bp\">$</span> <span class=\"n\">Fin</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span> <span class=\"c1\">-- this length won't be called at runtime</span>\n  <span class=\"o\">(</span><span class=\"n\">l.findIdx</span><span class=\"bp\">?</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pmap</span> <span class=\"n\">Fin.mk</span> <span class=\"o\">(</span><span class=\"n\">l.lt_length_of_mem_findIdx</span><span class=\"bp\">?</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 426884590,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710589279
    },
    {
        "content": "<p>You are right, sorry I was wrong.</p>",
        "id": 426891161,
        "sender_full_name": "Markus Schmaus",
        "timestamp": 1710595733
    },
    {
        "content": "<p>I actually dislike the idea of returning Fin or any data coupled with properties. I prefer returning pure data like Nat and separately prove things about it.</p>",
        "id": 426891738,
        "sender_full_name": "Julien Michel",
        "timestamp": 1710596215
    },
    {
        "content": "<p>I don't think the line between \"data\" and \"data coupled with properties\" is as clear as you make it out to be. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs#Fin</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin2#doc\">docs#Fin2</a> both represent numbers less than n, but the latter doesn't carry any explicit proof fields.</p>",
        "id": 427087140,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710673459
    },
    {
        "content": "<p>And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat#doc\">docs#Rat</a> contains proofs fields, but is presumably something you consider as \"pure data\"</p>",
        "id": 427087461,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1710673551
    },
    {
        "content": "<p>the usual place I would draw the line between \"data\" and \"data with properties\" is whether the function explicitly uses <code>Subtype</code> in inputs or outputs, or has proof arguments. Once you have defined a custom type with the properties as embedded fields, it's been rebranded as \"data\"</p>",
        "id": 427088681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710673868
    },
    {
        "content": "<p>There is another useful place to draw the line though, which is whether the type is a dependent function, as type dependencies can make rewriting more difficult. That litmus test would differentiate between the cases of <code>Fin n</code> vs <code>Rat</code></p>",
        "id": 427089499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1710674077
    }
]