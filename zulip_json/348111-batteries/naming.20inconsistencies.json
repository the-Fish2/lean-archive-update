[
    {
        "content": "<p>Is there a good reason why <code>Array.size</code> is not named <code>Array.length</code>, while for example, <code>Array.get</code> (O(1)) is named like <code>List.get</code> (O(n)) ?<br>\nSame question applies to many other pairs like <code>Array.push</code> and <code>List.concat</code>,  <code>Array.pop</code> and <code>List.dropLast</code>, ...</p>",
        "id": 429064614,
        "sender_full_name": "Julien Michel",
        "timestamp": 1711185201
    },
    {
        "content": "<p>(Note, most of these definitions are not in std, and I had no hand in the naming)</p>",
        "id": 429164159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711263737
    },
    {
        "content": "<p>Once upon a time <code>List.get</code> was also not named the same, it was <code>List.nth</code></p>",
        "id": 429164217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711263776
    },
    {
        "content": "<p>I think the fact that they have different asymptotic behaviors is actually relevant to the naming (at least descriptively). More specifically, <code>push</code> is what you do to a dynamic array to add an element at the end, but to add an element to the end of a linked list you <code>concat</code> a new node at the end</p>",
        "id": 429164364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711263885
    },
    {
        "content": "<p>which is to say, these names come from the picture of the concrete data structure moreso than from the abstract specification of both of these types as sequences</p>",
        "id": 429164394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711263947
    },
    {
        "content": "<p>Having a more awkward name is an old trick for nudging people in the direction of \"better\" operations (for various notions of better), which to me seems to be part of what is going on in <code>Array.pop</code> vs <code>List.dropLast</code></p>",
        "id": 429164528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711264072
    },
    {
        "content": "<p>I initially thought that, as reasoning is only done on the Lean code, the name should be consistent with only the Lean code, so that for example <code>Array</code> and <code>List</code> lemmas have exactly the same names.<br>\nI think you are saying that a def's name should be consistent with the underlying implementation be it C++ or Lean.<br>\nA possible issue I see, is that an implementation might be changed later with a csimp attribute (or extern / implemented_by)</p>\n<p>Comparing <code>List</code> and <code>Array</code>, I see functions that are named the same when they have different implementations (<code>get</code>, <code>set</code>, <code>append</code>, <code>map</code>, ...)<br>\nI also see functions that are named differently suggesting a different external implementation, but that have essentially the same Lean code (<code>size</code> vs <code>length</code>, <code>push</code> vs <code>concat</code>, <code>pop</code> vs <code>dropLast</code>, ...)<br>\nThis lack of consistency feels a bit disconcerting. Is the naming now set in stone or will there be changes in the future?</p>",
        "id": 429219851,
        "sender_full_name": "Julien Michel",
        "timestamp": 1711294101
    },
    {
        "content": "<p>It seems pretty unlikely to me that we will change such names.</p>",
        "id": 429236378,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711306290
    },
    {
        "content": "<p>Really? What do you mean by \"such names\"? I've noticed a lot of questionable and inconsistent naming in core/std and I always assumed that when Lean was ready to take on more stability promises, we would do a big survey and switch to a consistent set of names that we are happy to stabilize like the big pre-1.0 sweep Rust did</p>",
        "id": 429236919,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711306730
    },
    {
        "content": "<p>Personally, I have trouble caring about names as much as others do, and don't see anything to complain about in any of the examples mentioned so far in this thread. :-)</p>\n<p>More generally in the FRO renaming things is often considered as rearranging deck chairs, and a time sink because of the inevitable bike shedding.</p>\n<p>That said, if there are particular acute naming problems I'm game to start an internal discussion about what a renaming process would look like. </p>\n<p>But \"fix the gaping API holes, using the existing names\", seems like a much higher priority. :-)</p>",
        "id": 429237999,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711307439
    },
    {
        "content": "<p>I'm on the fence about whether the inconsistencies for <code>List</code> vs <code>Array</code> is a problem or not. On one hand, I'm frequently annoyed when I switch between <code>List</code> and <code>Array</code> and then need to go through and swap <code>length</code> for <code>size</code>, etc., but on the other it's also often useful that they have different names because it forces thinking about the changes to performance. It's not clear that the language should be forcing this discipline however.</p>",
        "id": 429239315,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1711308613
    },
    {
        "content": "<p>To give an example, I recently made a PR touching <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.feraseIdx#doc\">docs#Array.feraseIdx</a>. I can't imagine that this is a permanent name, and I considered doing what I thought would be an improvement as a drive <br>\n-by change (mirroring <code>get</code> and <code>getD</code> with <code>feraseIdx</code> -&gt; <code>eraseIdx</code> and <code>eraseIdx</code> -&gt; <code>eraseIdxD</code>), but I decided that it wasn't worth it because <code>eraseIdx</code> would probably not be the final name anyway. (I figured we would probably copy Rust's <code>remove</code> in a naming sweep)</p>",
        "id": 429244072,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1711312022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  I think if you want to attract more users and external contributors, it's becoming more and more important that the standard library and core look good and consistent. So far, as an outsider, I've been thinking \"names feel weird and unaligned, I don't really wanna touch anything right now because everything will probably change soon\". If other outsiders think as I do, I think you might miss opportunities to grow. If everything looked very consistent and appealing, don't you think you'd have more people willing to join in and fill the holes faster ?</p>\n<p>BTW What API holes are you trying to fill in priority ? Is there documentation / discussions somewhere?</p>",
        "id": 429264781,
        "sender_full_name": "Julien Michel",
        "timestamp": 1711326756
    },
    {
        "content": "<p>I appreciate what you're saying, but please make some allowance for \"consistent and appealling\" often being in the eye of the beholder, and for the desire to avoid bikeshedding. :-)</p>\n<p>Re: plans for the API. One starting point is <a href=\"https://github.com/leanprover/std4/pull/561/files\">https://github.com/leanprover/std4/pull/561/files</a>. It's lacking detail still, of course.</p>\n<p>We started, but only barely, to give indications of desired API gaps using <code>proof_wanted</code> in Std. Unfortunately there appear to only be two in <code>main</code> at present, and <a href=\"https://github.com/leanprover/std4/pull/690\">std4#690</a> is working on resolving one.</p>\n<p><code>HashMap.insert_find?</code> is still open, though!</p>\n<p>More generally, for <code>BitVec</code> / <code>HashMap</code> (and to a lesser extend the other data structures) we are still missing lots of lemmas about \"observations about operations\" (I guess <code>insert_find?</code> is a typical example).  (There's also the \"simplifying pairs of operations into single operations, or commuting them\" class of lemmas as well.)</p>\n<p>My experience is that you try to use any of these data structures are there are no shortage of painful gaps. </p>\n<p><code>BitVec</code> in particular, it would be great if every operation (of which there are many) had good lemmas for <code>getLsb</code>, <code>getMsb</code>, <code>toNat</code>, and, where relevant <code>toFin</code>, <code>msb</code>. We also need some \"casesOn\" type lemmas for pulling of high or low bits, and chopping into pieces that can be appended. There are <em>many</em> missing pairwise operations lemmas in <code>BitVec</code>.</p>",
        "id": 429269413,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711330578
    },
    {
        "content": "<p>Having a more detailed roadmap, and many more <code>proof_wanted</code> statements, is definitely on the agenda, and I'm happy to have the reminder that there is appetite for helping fulfill these!</p>",
        "id": 429269451,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1711330637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/348111-std4/topic/naming.20inconsistencies/near/429269413\">said</a>:</p>\n<blockquote>\n<p><code>HashMap.insert_find?</code> is still open, though!</p>\n</blockquote>\n<p>I recently (re)started working on this, trying to get <span class=\"user-mention\" data-user-id=\"128280\">@Wojciech Nawrocki</span> 's PR <a href=\"https://github.com/leanprover/std4/pull/279\">std4#279</a> over the line and close the API gap of basic theorems for HashMap (which are needed for at least lean4lean and a recent ITP formalization we worked on together, plus some incarnations of LeanSAT)</p>",
        "id": 429273384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1711333289
    }
]