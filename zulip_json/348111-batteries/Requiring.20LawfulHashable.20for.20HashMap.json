[
    {
        "content": "<p>Hi,</p>\n<p>currently in Batteries the HashMaps only require BEq and Hashable. I think it would be useful to also require LawfulHashable for the type. Otherwise there can be elements that are equal according to BEq, but are in  different buckets. The currently stated proof goal in HashMap.Lemmas does not work if the Hash is not lawful. Nonetheless, I think that this is a desired specification to have and is what I would expect. </p>\n<p>LawfulHashable is used in the specification of the well-formedness of the HashMap, but the hashMap below appears to be still well-formed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">proof_wanted</span><span class=\"w\"> </span><span class=\"n\">insert_find?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">a'</span>\n</code></pre></div>\n<p>See counterexample:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Batteries</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">testType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">firstElement</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testType</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">secondElement</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testType</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hashtestType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">firstElement</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">secondElement</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">hash</span><span class=\"o\">:=</span><span class=\"n\">hashtestType</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">compTestType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">beq</span><span class=\"o\">:=</span><span class=\"n\">compTestType</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">firstElement</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)])</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">secondElement</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">firstElement</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">firstElement</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">secondElement</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">ofList</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">firstElement</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)])</span><span class=\"bp\">.</span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"n\">testType</span><span class=\"bp\">.</span><span class=\"n\">firstElement</span>\n</code></pre></div>",
        "id": 447221046,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1719408996
    },
    {
        "content": "<p>You're right that the given lemma is not provable if the hash is not lawful. It's good that the <code>HashMap</code> type itself does not require <code>LawfulHashable</code>, so that you can use the hashmap if you're in a situation where you're just programming and don't care about proofs. The <a href=\"https://github.com/TwoFX/HashMap/blob/b2f5f5f5db881664e107fa3720ea67b039b84722/Hashmap/HashMap/Lemmas.lean#L153\">corresponding lemma</a> in the hashmap implementation that will soon be part of Lean core requires that the hash is lawful and also that the <code>BEq</code> instance is an equivalence relation.</p>",
        "id": 447223341,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719409691
    },
    {
        "content": "<p>From this point of view it makes sense. I didn't think of the purely programming side.</p>\n<p>Is there a roadmap or channel for your project ? I have worked a bit on proving lemmas about the current hash map implementation, but I didn't manage to prove all of the requirements I need yet.</p>",
        "id": 447235720,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1719413437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> <code>EquivBEq</code> has been wanted for a while... I almost submitted it to Batteries last week but other priorities got in the way. Anyway, please consider incremental submissions to lean core if possible!</p>",
        "id": 447349849,
        "sender_full_name": "François G. Dorais",
        "timestamp": 1719441860
    },
    {
        "content": "<p>It should land in core soon and will likely be part of the 4.10 release. (Update: nope, missed the 4.10 rc, 4.11 it is)</p>",
        "id": 447392511,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1719468076
    }
]